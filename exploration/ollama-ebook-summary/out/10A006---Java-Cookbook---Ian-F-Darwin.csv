filename,title,text,len
01-Cover.pdf,01-Cover,Ian F. Darwin   \nFourth \n Edition\nJava  \n Cookbook\nProblems and Solutions  \nfor Java Developers\nIan F. Darwin\nJava Cookbook\nProblems and Solutions for Java DevelopersFOURTH EDITION,189
02-Copyright.pdf,02-Copyright,"978-1-492-07258-4\n[LSI]Java Cookbook\nby Ian F. Darwin\nCopyright © 2020 RejmiNet Group, Inc. All rights reserved.\nPrinted in the United States of America.\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\nO’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are\nalso available for most titles ( http://oreilly.com ). For more information, contact our corporate/institutional\nsales department: 800-998-9938 or corporate@oreilly.com .\nAcquisition Editor:  Zan McQuade\nDevelopment Editor:  Corbin Collins\nProduction Editor:  Beth Kelly\nCopyeditor:  Amanda Kersey\nProofreader:  Charles RoumeliotisIndexer:  Potomac Indexing, LLC\nInterior Designer:  David Futato\nCover Designer:  Karen Montgomery\nIllustrator:  Rebecca Demarest\nJune 2001:  First Edition\nJune 2004:  Second Edition\nJuly 2014:  Third Edition\nMarch 2020:  Fourth Edition\nRevision History for the Fourth Edition\n2020-03-17: First Release\nSee http://oreilly.com/catalog/errata.csp?isbn=9781492072584  for release details.\nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. Java Cookbook , the cover image, and\nrelated trade dress are trademarks of O’Reilly Media, Inc.\nThe views expressed in this work are those of the author, and do not represent the publisher’s views.\nWhile the publisher and the author have used good faith efforts to ensure that the information and\ninstructions contained in this work are accurate, the publisher and the author disclaim all responsibility\nfor errors or omissions, including without limitation responsibility for damages resulting from the use of\nor reliance on this work. Use of the information and instructions contained in this work is at your own\nrisk. If any code samples or other technology this work contains or describes is subject to open source\nlicenses or the intellectual property rights of others, it is your responsibility to ensure that your use\nthereof complies with such licenses and/or rights.\nIn Memoriam\nAndrej Cerar Darwin 1989-2014\nSon, friend, fellow writer, and craftsman.",2129
03-Table of Contents.pdf,03-Table of Contents,"Table of Contents\nPreface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  xiii\n1.Getting Started: Compiling and Running Java. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1\n1.0 Introduction                                                                                                                 1\n1.1 Compiling and Running Java: Standard JDK                                                          2\n1.2 Compiling and Running Java: GraalVM for Better Performance                        3\n1.3 Compiling, Running, and Testing with an IDE                                                       5\n1.4 Exploring Java with JShell                                                                                        11\n1.5 Using CLASSPATH Effectively                                                                                13\n1.6 Downloading and Using the Code Examples                                                        15\n1.7 Automating Dependencies, Compilation, Testing, and Deployment with\nApache Maven                                                                                                              23\n1.8 Automating Dependencies, Compilation, Testing, and Deployment with\nGradle                                                                                                                             27\n1.9 Dealing with Deprecation Warnings                                                                      29\n1.10 Maintaining Code Correctness with Unit Testing: JUnit                                   31\n1.11 Maintaining Y our Code with Continuous Integration                                       34\n1.12 Getting Readable Stack Traces                                                                               38\n1.13 Finding More Java Source Code                                                                            39\n1.14 Finding Runnable Java Libraries                                                                           40\n2.Interacting with the Environment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  43\n2.0 Introduction                                                                                                               43\n2.1 Getting Environment Variables                                                                               43\n2.2 Getting Information from System Properties                                                       44\n2.3 Dealing with Code That Depends on the Java Version or the Operating\nSystem                                                                                                                            46\nv\n2.4 Using Extensions or Other Packaged APIs                                                            51\n2.5 Using the Java Modules System                                                                               52\n3.Strings and Things. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  57\n3.0 Introduction                                                                                                               57\n3.1 Taking Strings Apart with Substrings or Tokenizing                                            60\n3.2 Putting Strings Together with StringBuilder                                                         65\n3.3 Processing a String One Character at a Time                                                        67\n3.4 Aligning, Indenting, and Unindenting Strings                                                      69\n3.5 Converting Between Unicode Characters and Strings                                         73\n3.6 Reversing a String by Word or by Character                                                         75\n3.7 Expanding and Compressing Tabs                                                                          76\n3.8 Controlling Case                                                                                                        81\n3.9 Entering Nonprintable Characters                                                                          82\n3.10 Trimming Blanks from the End of a String                                                         83\n3.11 Creating a Message with I18N Resources                                                            85\n3.12 Using a Particular Locale                                                                                        88\n3.13 Creating a Resource Bundle                                                                                   89\n3.14 Program: A Simple Text Formatter                                                                       90\n3.15 Program: Soundex Name Comparisons                                                               92\n4.Pattern Matching with Regular Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  97\n4.0 Introduction                                                                                                               97\n4.1 Regular Expression Syntax                                                                                       99\n4.2 Using Regexes in Java: Test for a Pattern                                                              106\n4.3 Finding the Matching Text                                                                                     109\n4.4 Replacing the Matched Text                                                                                   112\n4.5 Printing All Occurrences of a Pattern                                                                  115\n4.6 Printing Lines Containing a Pattern                                                                     118\n4.7 Controlling Case in Regular Expressions                                                             119\n4.8 Matching Accented, or Composite, Characters                                                  120\n4.9 Matching Newlines in Text                                                                                     121\n4.10 Program: Apache Logfile Parsing                                                                        123\n4.11 Program: Full Grep                                                                                               125\n5.Numbers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  131\n5.0 Introduction                                                                                                             131\n5.1 Checking Whether a String Is a Valid Number                                                   134\n5.2 Converting Numbers to Objects and Vice Versa                                                135\n5.3 Taking a Fraction of an Integer Without Using Floating Point                        136\n5.4 Working with Floating-Point Numbers                                                               137\nvi | Table of Contents\n5.5 Formatting Numbers                                                                                               142\n5.6 Converting Among Binary, Octal, Decimal, and Hexadecimal                        146\n5.7 Operating on a Series of Integers                                                                          147\n5.8 Formatting with Correct Plurals                                                                           149\n5.9 Generating Random Numbers                                                                              151\n5.10 Multiplying Matrices                                                                                             153\n5.11 Using Complex Numbers                                                                                     155\n5.12 Handling Very Large Numbers                                                                           158\n5.13 Program: TempConverter                                                                                    160\n5.14 Program: Number Palindromes                                                                          162\n6.Dates and Times. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  167\n6.0 Introduction                                                                                                             167\n6.1 Finding Today’s Date                                                                                               170\n6.2 Formatting Dates and Times                                                                                  172\n6.3 Converting Among Dates/Times, YMDHMS, and Epoch Seconds                 174\n6.4 Parsing Strings into Dates                                                                                      175\n6.5 Difference Between Two Dates                                                                              176\n6.6 Adding to or Subtracting from a Date                                                                  177\n6.7 Handling Recurring Events                                                                                    178\n6.8 Computing Dates Involving Time Zones                                                             181\n6.9 Interfacing with Legacy Date and Calendar Classes                                           182\n7.Structuring Data with Java. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  185\n7.0 Introduction                                                                                                             185\n7.1 Using Arrays for Data Structuring                                                                        186\n7.2 Resizing an Array                                                                                                    188\n7.3 The Collections Framework                                                                                   189\n7.4 Like an Array, but More Dynamic                                                                        190\n7.5 Using Generic Types in Y our Own Class                                                             194\n7.6 How Shall I Iterate Thee? Let Me Enumerate the Ways                                     197\n7.7 Eschewing Duplicates with a Set                                                                           201\n7.8 Structuring Data in a Linked List                                                                          202\n7.9 Mapping with Hashtable and HashMap                                                               207\n7.10 Storing Strings in Properties and Preferences                                                   209\n7.11 Sorting a Collection                                                                                               213\n7.12 Avoiding the Urge to Sort                                                                                     218\n7.13 Finding an Object in a Collection                                                                       220\n7.14 Converting a Collection to an Array                                                                  222\n7.15 Making Y our Data Iterable                                                                                   223\n7.16 Using a Stack of Objects                                                                                       226\nTable of Contents | vii\n7.17 Multidimensional Structures                                                                               229\n7.18 Simplifying Data Objects with Lombok or Record                                          231\n7.19 Program: Timing Comparisons                                                                           233\n8.Object-Oriented Techniques. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  237\n8.0 Introduction                                                                                                             237\n8.1 Object Methods: Formatting Objects with toString(), Comparing with\nEquals                                                                                                                           240\n8.2 Using Inner Classes                                                                                                 247\n8.3 Providing Callbacks via Interfaces                                                                        249\n8.4 Polymorphism/Abstract Methods                                                                         253\n8.5 Using Typesafe Enumerations                                                                               255\n8.6 Avoiding NPEs with Optional                                                                               259\n8.7 Enforcing the Singleton Pattern                                                                            261\n8.8 Roll Y our Own Exceptions                                                                                     263\n8.9 Using Dependency Injection                                                                                  265\n8.10 Program: Plotter                                                                                                    268\n9.Functional Programming Techniques: Functional Interfaces, Streams,\nand Parallel Collections. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  273\n9.0 Introduction                                                                                                             273\n9.1 Using Lambdas/Closures Instead of Inner Classes                                             276\n9.2 Using Lambda Predefined Interfaces Instead of Y our Own                              280\n9.3 Simplifying Processing with Streams                                                                   283\n9.4 Simplifying Streams with Collectors                                                                    284\n9.5 Improving Throughput with Parallel Streams and Collections                        287\n9.6 Using Existing Code as Functional with Method References                           289\n9.7 Java Mixins: Mixing in Methods                                                                           293\n10. Input and Output: Reading, Writing, and Directory Tricks. . . . . . . . . . . . . . . . . . . . . . .  297\n10.0 Introduction                                                                                                           297\n10.1 About InputStreams/OutputStreams and Readers/Writers                            299\n10.2 Reading a Text File                                                                                                301\n10.3 Reading from the Standard Input or from the Console/Controlling\nTerminal                                                                                                                      304\n10.4 Printing with Formatter and printf                                                                     308\n10.5 Scanning Input with StreamTokenizer                                                               312\n10.6 Scanning Input with the Scanner Class                                                              316\n10.7 Scanning Input with Grammatical Structure                                                    319\n10.8 Copying a File                                                                                                        324\n10.9 Reassigning the Standard Streams                                                                      325\nviii | Table of Contents\n10.10 Duplicating a Stream as It Is Written; Reassigning Standard Streams        326\n10.11 Reading/Writing a Different Character Set                                                     329\n10.12 Those Pesky End-of-Line Characters                                                               330\n10.13 Beware Platform-Dependent File Code                                                           330\n10.14 Reading/Writing Binary Data                                                                            331\n10.15 Reading and Writing JAR or ZIP Archives                                                      332\n10.16 Finding Files in a Filesystem-Neutral Way with getResource() and\ngetResourceAsStream()                                                                                             336\n10.17 Getting File Information: Files and Path                                                         338\n10.18 Creating a New File or Directory                                                                      345\n10.19 Changing a File’s Name or Other Attributes                                                   346\n10.20 Deleting a File                                                                                                      349\n10.21 Creating a Transient/Temporary File                                                               351\n10.22 Listing a Directory                                                                                              353\n10.23 Getting the Directory Roots                                                                              354\n10.24 Using the FileWatcher Service to Get Notified About File Changes            356\n10.25 Program: Save User Data to Disk                                                                      358\n10.26 Program: Find—Walking a File Tree                                                                361\n11. Data Science and R. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  367\n11.1 Machine Learning with Java                                                                                368\n11.2 Using Data In Apache Spark                                                                                369\n11.3 Using R Interactively                                                                                             372\n11.4 Comparing/Choosing an R Implementation                                                    374\n11.5 Using R from Within a Java App: Renjin                                                           375\n11.6 Using Java from Within an R Session                                                                 377\n11.7 Using FastR, the GraalVM Implementation of R                                              378\n11.8 Using R in a Web App                                                                                           380\n12. Network Clients. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  383\n12.0 Introduction                                                                                                           383\n12.1 HTTP/REST Web Client                                                                                      385\n12.2 Contacting a Socket Server                                                                                  388\n12.3 Finding and Reporting Network Addresses                                                      389\n12.4 Handling Network Errors                                                                                    391\n12.5 Reading and Writing Textual Data                                                                      392\n12.6 Reading and Writing Binary or Serialized Data                                                394\n12.7 UDP Datagrams                                                                                                     397\n12.8 URI, URL, or URN?                                                                                              400\n12.9 Program: TFTP UDP Client                                                                                401\n12.10 Program: Sockets-Based Chat Client                                                                406\nTable of Contents | ix\n12.11 Program: Simple HTTP Link Checker                                                             410\n13. Server-Side Java. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  413\n13.0 Introduction                                                                                                           413\n13.1 Opening a Server Socket for Business                                                                414\n13.2 Finding Network Interfaces                                                                                 417\n13.3 Returning a Response (String or Binary)                                                           418\n13.4 Returning Object Information Across a Network Connection                      422\n13.5 Handling Multiple Clients                                                                                    423\n13.6 Serving the HTTP Protocol                                                                                 428\n13.7 Securing a Web Server with SSL and JSSE                                                         430\n13.8 Creating a REST Service with JAX-RS                                                               433\n13.9 Network Logging                                                                                                   436\n13.10 Setting Up SLF4J                                                                                                  437\n13.11 Network Logging with Log4j                                                                             439\n13.12 Network Logging with java.util.logging                                                           444\n14. Processing JSON Data. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  449\n14.0 Introduction                                                                                                           449\n14.1 Generating JSON Directly                                                                                    451\n14.2 Parsing and Writing JSON with Jackson                                                            452\n14.3 Parsing and Writing JSON with org.json                                                           453\n14.4 Parsing and Writing JSON with JSON-B                                                           455\n14.5 Finding JSON Elements with JSON Pointer                                                      457\n15. Packages and Packaging. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  461\n15.0 Introduction                                                                                                           461\n15.1 Creating a Package                                                                                                462\n15.2 Documenting Classes with Javadoc                                                                    464\n15.3 Beyond Javadoc: Annotations/Metadata                                                            468\n15.4 Preparing a Class as a JavaBean                                                                           469\n15.5 Archiving with JAR                                                                                               473\n15.6 Running a Program from a JAR                                                                          474\n15.7 Packaging Web Tier Components into a W AR File                                          476\n15.8 Creating a Smaller Distribution with jlink                                                        478\n15.9 Using JPMS to Create a Module                                                                          479\n16. Threaded Java. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  483\n16.0 Introduction                                                                                                           483\n16.1 Running Code in a Different Thread                                                                  485\n16.2 Displaying a Moving Image with Animation                                                    489\nx | Table of Contents\n16.3 Stopping a Thread                                                                                                 494\n16.4 Rendezvous and Timeouts                                                                                   497\n16.5 Synchronizing Threads with the synchronized Keyword                               498\n16.6 Simplifying Synchronization with Locks                                                           504\n16.7 Simplifying Producer/Consumer with the Queue Interface                           508\n16.8 Optimizing Parallel Processing with Fork/Join                                                511\n16.9 Scheduling Tasks: Future Times, Background Saving in an Editor                514\n17. Reflection,  or “A Class Named Class”. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  519\n17.0 Introduction                                                                                                           519\n17.1 Getting a Class Descriptor                                                                                   520\n17.2 Finding and Using Methods and Fields                                                             521\n17.3 Accessing Private Methods and Fields via Reflection                                      525\n17.4 Loading and Instantiating a Class Dynamically                                               526\n17.5 Constructing a Class from Scratch with a ClassLoader                                   529\n17.6 Constructing a Class from Scratch with JavaCompiler                                    530\n17.7 Performance Timing                                                                                             533\n17.8 Printing Class Information                                                                                  537\n17.9 Listing Classes in a Package                                                                                 539\n17.10 Using and Defining Annotations                                                                      542\n17.11 Finding Plug-In-Like Classes via Annotations                                               547\n17.12 Program: CrossRef                                                                                              549\n18. Using Java with Other Languages. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  555\n18.0 Introduction                                                                                                           555\n18.1 Running an External Program from Java                                                           556\n18.2 Running a Program and Capturing Its Output                                                 560\n18.3 Calling Other Languages via javax.script                                                           564\n18.4 Mixing Languages with GraalVM                                                                       566\n18.5 Marrying Java and Perl                                                                                         567\n18.6 Calling Other Languages via Native Code                                                         571\n18.7 Calling Java from Native Code                                                                            576\nAfterword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  dlxxix\nA. Java Then and Now. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  581\nIndex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  591\nTable of Contents | xi",28412
04-Who This Book Is For.pdf,04-Who This Book Is For,"1For the quirks, see the Java Puzzlers  books  by Joshua Bloch and Neal Gafter (Addison-Wesley).Preface\nLike any of the most-used programming languages, Java has its share of detractors,\nadvocates, issues, quirks,1 and a learning curve. The Java Cookbook  aims to help the\nJava developer get up to speed on some of the most important parts of Java develop‐\nment. I focus on the standard APIs and some third-party APIs, but I don’t hesitate to\ncover language issues as well.\nThis is the fourth edition of this book, and it has been shaped by many people and by\nthe myriad changes that Java has undergone over its first two decades of popularity.\nReaders interested in Java’s history can refer to Appendix A .\nJava 11 is the current long-term supported version, but Java 12 and 13 are out. Java 14\nis in early access and scheduled for final release the very same day as this book’s\nfourth edition. The new cadence of releases every six months may be great for the\nJava SE development team at Oracle and for click-driven, Java-related news sites, but\nit “may cause some extra work” for Java book authors, since books typically have a\nlonger revision cycle than Java now does! Java 9, which came out after the previous\nedition of this book, was a breaking release, the first release in a very long time to\nbreak backwards compatibility, primarily the Java module system. Everything in the\nbook is assumed to work on any JVM that is still being used to develop code. Nobody\nshould be using Java 7 (or anything before it!) for anything, and nobody should be\ndoing new development in Java 8. If you are, it’s time to move on!\nThe goal of this revision is to keep the book up to date with all this change. While\ncutting out a lot of older material, I’ve added information on new features such as\nModules and the interactive JShell, and I’ve updated a lot of other information along\nthe way.\nxiii",1911
05-Whats in This Book.pdf,05-Whats in This Book,,0
06-Organization of This Book.pdf,06-Organization of This Book,"Who This Book Is For\nI’m going to assume that you know the basics of Java. I won’t tell you how to println\na string, nor how to write a class that extends another and/or implements an\ninterface.  I presume you’ve taken a Java course such as Learning Tree’s Introduction\nor that you’ve studied an introductory book such as  Head First Java , Learning Java , or\nJava in a Nutshell  (O’Reilly). However, Chapter 1  covers some techniques that you\nmight not know very well and that are necessary to understand some of the later\nmaterial. Feel free to skip around! Both the printed version of the book and the elec‐\ntronic copy are heavily cross-referenced.\nWhat’s in This Book?\nJava has seemed better suited to “development in the large, ” or enterprise application\ndevelopment, than to the one-line, one-off script in Perl, Awk, or Python. That’s\nbecause it is a compiled, object-oriented language. However, this suitability has\nchanged somewhat with the appearance of JShell (see Recipe 1.4 ). I illustrate many\ntechniques with shorter Java class examples and even code fragments; some of the\nsimpler ones will be shown using JShell. All of the code examples (other than some\none- or two-liners) are in one of my public GitHub repositories, so you can rest\nassured that every fragment of code you see here has been compiled, and most have\nbeen run recently.\nSome of the longer examples in this book are tools that I originally wrote to automate\nsome mundane task or another. For example, a tool called MkIndex  (in the javasrc\nrepository) reads the top-level directory of the place where I keep my Java example\nsource code, and it builds a browser-friendly index.html  file for that directory.\nAnother example is XmlForm , which was used to convert parts of the manuscript from\nXML into the form needed by another publishing software. XmlForm  also handled—\nby use of another program, GetMark —full and partial code insertions from the javasrc\ndirectory into the book manuscript. XmlForm  is included in the Github repository I\nmentioned, as is a later version of GetMark , though neither of these was used in build‐\ning the fourth edition. These days, O’Reilly’s Atlas publishing software uses  Asciidoc‐\ntor, which provides the mechanism we use for inserting files and parts of files into the\nbook.\nOrganization of This Book\nLet’s go over the organization of this book. Each chapter consists of a handful of rec‐\nipes, short sections that describe a problem and its solution, along with a code exam‐\nple. The code in each recipe is intended to be largely self-contained; feel free to\nborrow  bits and pieces of any of it for use in your own projects. The code is dis‐\ntributed with a Berkeley-style copyright, just to discourage wholesale reproduction.\nxiv | Preface\nI start off Chapter 1, Getting Started: Compiling and Running Java , by describing some\nmethods of compiling your program on different platforms, running them in differ‐\nent environments (browser, command line, windowed desktop), and debugging.\nChapter 2, Interacting with the Environment , moves from compiling and running your\nprogram to getting it to adapt to the surrounding countryside—the other programs\nthat live in your computer.\nThe next few chapters deal with basic APIs. Chapter 3, Strings and Things , concen‐\ntrates on one of the most basic but powerful data types in Java, showing you how to\nassemble, dissect, compare, and rearrange what you might otherwise think of as ordi‐\nnary text. This chapter also covers the topic of internationalization/localization so\nthat your programs can work as well in Akbar, Afghanistan, Algiers, Amsterdam, and\nAngleterre as they do in Alberta, Arkansas, and Alabama.\nChapter 4, Pattern Matching with Regular Expressions , teaches you how to use the\npowerful regular expressions technology from Unix in many string-matching and\npattern-matching problem domains. Regex processing has been standard in Java for\nyears, but if you don’t know how to use it, you may be reinventing the flat tire.\nChapter 5, Numbers , deals both with built-in numeric types such as int and double ,\nas well as the corresponding API classes ( Integer , Double , etc.) and the conversion\nand testing facilities they offer. There is also brief mention of the “big number”\nclasses. Because Java programmers often need to deal in dates and times, both locally\nand internationally, Chapter 6, Dates and Times , covers this important topic.\nThe next few chapters cover data processing. As in most languages, arrays in Java are\nlinear, indexed collections of similar objects, as discussed in Chapter 7, Structuring\nData with Java . This chapter goes on to deal with the many Collections classes: pow‐\nerful ways of storing quantities of objects in the java.util  package, including use of\nJava Generics.\nDespite some syntactic resemblance to procedural languages such as C, Java is at\nheart an Object-Oriented Programming (OOP) language, with some important Func‐\ntional Programming (FP) constructs skilfully blended in. Chapter 8, Object-Oriented\nTechniques , discusses some of the key notions of OOP as it applies to Java, including\nthe commonly overridden methods of java.lang.Object  and the important issue of\ndesign patterns. Java is not, and never will be, a pure FP language. However, it is pos‐\nsible to use some aspects of FP , increasingly so with Java 8 and its support of lambda\nexpressions (a.k.a. closures). This is discussed in Chapter 9, Functional Programming\nTechniques: Functional Interfaces, Streams, and Parallel Collections .\nThe next chapter deals with aspects of traditional input and output. Chapter 10, Input\nand Output: Reading, Writing, and Directory Tricks , details the rules for reading and\nwriting files (don’t skip this if you think files are boring; you’ll need some of this\ninformation in later chapters). The chapter also shows you everything else about\nPreface | xv\nfiles— such as finding their size and last-modified time—and about reading and mod‐\nifying directories, creating temporary files, and renaming files on disk.\nBig data and data science have become a thing, and Java is right in there. Apache\nHadoop, Apache Spark, and much more of the big data infrastructure is written in,\nand extensible with, Java, as described in Chapter 11, Data Science and R . The R pro‐\ngramming language is popular with data scientists, statsticians, and other scientists.\nThere are at least two reimplementations of R coded in Java, and Java can also be\ninterfaced directly with the standard R implementation in both directions, so this\nchapter covers R as well.\nBecause Java was originally promulgated as the programming language for the inter‐\nnet, it’s only fair to spend some time on networking in Java. Chapter 12, Network Cli‐\nents, covers the basics of network programming from the client side, focusing on\nsockets. Today so many applications need to access a web service, primarily RESTful\nweb services, that this seemed to be necessary. I’ll then move to the server side in\nChapter 13, Server-Side Java , wherein you’ll learn some server-side programming\ntechniques.\nOne simple text-based representation for data interchange is JSON, the JavaScript\nobject notation. Chapter 14, Processing JSON Data , describes the format and some of\nthe many APIs that have emerged to deal with it.\nChapter 15, Packages and Packaging , shows how to create packages of classes that\nwork together. This chapter also talks about deploying (a.k.a. distributing and instal‐\nling) your software.\nChapter 16, Threaded  Java , tells you how to write classes that appear to do more than\none thing at a time and let you take advantage of powerful multiprocessor hardware.\nChapter 17, Reflection,  or “ A Class Named Class” , lets you in on such secrets as how to\nwrite API cross-reference documents mechanically and how web servers are able to\nload any old Servlet—never having seen that particular class before—and run it.\nSometimes you already have code written and working in another language that can\ndo part of your work for you, or you want to use Java as part of a larger package.\nChapter 18, Using Java with Other Languages , shows you how to run an external pro‐\ngram (compiled or script) and also interact directly with native code in C/C++ or\nother languages.\nThere isn’t room in a book this size for everything I’ d like to tell you about Java. The\nAfterword  presents some closing thoughts and a link to my online summary of Java\nAPIs that every Java developer should know about.\nFinally, Appendix A, Java Then  and Now , gives the storied history of Java in a release-\nby-release timeline, so whatever version of Java you learned, you can jump in here\nand get up to date quickly.\nxvi | Preface",8819
07-Java Books.pdf,07-Java Books,"So many topics, and so few pages! Many topics do not recieve 100% coverage; I’ve\ntried to include the most important or most useful parts of each API. To go beyond,\ncheck the official javadoc  pages for each package; many of these pages have some\nbrief tutorial information on how the package is to be used.\nBesides the parts of Java covered in this book, two other platform editions, Java ME\nand Java EE, have been standardized. Java Micro Edition (Java ME) is concerned with\nsmall devices such as handhelds, cell phones, and fax machines. At the other end of\nthe size scale—large server machines—there’s Eclipse Jakarta EE , replacing the former\nJava EE, which in the last century was known as J2EE. Jakarta EE is concerned with\nbuilding large, scalable, distributed applications. APIs that are part of Jakarta EE\ninclude Servlets, JavaServer Pages, JavaServer Faces, JavaMail, Enterprise JavaBeans\n(EJBs), Container and Dependency Injection (CDI), and Transactions. Jakarta EE\npackages normally begin with “javax” because they are not core packages. This book\nmentions but a few of these; there is also a Java EE 8 Cookbook  by Elder Moraes\n(O’Reilly) that covers some of the Jakarta EE APIs, as well as an older  Java Servlet &\nJSP Cookbook  by Bruce Perry (O’Reilly).\nThis book doesn’t cover Java Micro Edition, Java ME. At all. But speaking of cell\nphones and mobile devices, you probably know that Android uses Java as its lan‐\nguage. What should be comforting to Java developers is that Android also uses most\nof the core Java API, except for Swing and AWT, for which it provides Android-\nspecific replacements. The Java developer who wants to learn Android may consider\nlooking at my Android Cookbook  (O’Reilly), or the book’s website .\nJava Books\nA lot of useful information is packed into this book. However, due to the breadth of\ntopics, it is not possible to give book-length treatment to any one topic. Because of\nthis, the book contains references to many websites and other books. In pointing out\nthese references, I’m hoping to serve my target audience: the person who wants to\nlearn more about Java.\nO’Reilly publishes, in my opinion, the best selection of Java books on the market. As\nthe API continues to expand, so does the coverage. Check out the complete list of\nO’Reilly’s collection of Java books ; you can buy them at most bookstores, both physi‐\ncal and virtual. Y ou can also read them online through the O’Reilly Online Learning\nPlatform , a paid subscription service. And, of course, most are now available in ebook\nformat; O’Reilly ebooks are DRM free, so you don’t have to worry about their\ncopy-protection  scheme locking you into a particular device or system, as you do\nwith certain other publishers.\nThough many books are mentioned at appropriate spots in the book, a few deserve\nspecial mention here.\nPreface | xvii\nFirst and foremost, David Flanagan and Benjamin Evan’s Java in a Nutshell  (O’Reilly)\noffers a brief overview of the language and API and a detailed reference to the most\nessential packages. This is handy to keep beside your computer.  Head First Java  by\nBert Bates and Kathy Sierra offers a much more whimsical introduction to the lan‐\nguage and is recommended for the less experienced developer.\nJava 8 Lambdas  (Warburton, O’Reilly) covers the Lambda syntax introduced in Java 8\nin support of functional programming and more concise code in general.\nJava 9 Modularity: Patterns and Practices for Developing Maintainable Applications  by\nSander Mak and Paul Bakker (O’Reilly) covers the important changes made in the\nlanguage in Java 9 for the Java module system.\nJava Virtual Machine  by Jon Meyer and Troy Downing (O’Reilly) will intrigue the\nperson who wants to know more about what’s under the hood. This book is out of\nprint but can be found used and in libraries.\nA definitive (and monumental) description of programming the Swing GUI is Java\nSwing  by Robert Eckstein et al. (O’Reilly).\nJava Network Programming  and Java I/O , both by Elliotte Harold (O’Reilly), are also\nuseful references.\nFor Java Database work, Database Programming with JDBC & Java  by George Reese\n(O’Reilly) and Pro JPA 2: Mastering the Java Persistence API  by Mike Keith and Mer‐\nrick Schincariol (Apress) are recommended. Or my forthcoming overview of Java\nDatabase .\nAlthough the book you’re now reading doesn’t have much coverage of the Java EE, I’ d\nlike to mention two books on that topic:\n•Arun Gupta covers the Enterprise Edition in Java EE 7 Essentials  (O’Reilly).\n•Adam Bien’s Real World Java EE Patterns: Rethinking Best Practices  offers useful\ninsights in designing and implementing an Enterprise application.\nY ou can find more at the O’Reilly website .\nFinally, although it’s not a book, Oracle has a great deal of Java information  on the\nweb. This web page used to feature a large diagram showing all the components of\nJava in a “conceptual diagram. ” An early version of this is shown in Figure P-1 ; each\ncolored box is a clickable link to details on that particular technology.\nxviii | Preface",5123
08-Conventions Used in This Book.pdf,08-Conventions Used in This Book,"2With possible exceptions for algorithm decisions that are less relevant today given the massive changes in\ncomputing power now available.\nFigure P-1. Java conceptual diagram from Oracle documentation\nFor better or for worse, newer versions of Java have replaced this with a text page; for\nJava 13 the page is at https://docs.oracle.com/en/java/javase/13 .\nGeneral Programming Books\nDonald E. Knuth’s The Art of Computer Programming  (Addison-Wesley) has been a\nsource of inspiration to generations of computing students since its first publication\nin 1968. Volume 1 covers Fundamental Algorithms , Volume 2 is Seminumerical Algo‐\nrithms , Volume 3 is Sorting and Searching , and Volume 4A is Combinatorial Algo‐\nrithms, Part 1 . The remaining volumes in the projected series are not completed.\nAlthough his examples are far from Java (he invented the hypothetical assembly lan‐\nguage MIX for his examples), many of his discussions of algorithms—of how com‐\nputers ought to be used to solve real problems—are as relevant today as they were\nyears ago.2\nPreface | xix\nThough its code examples are quite dated now, the book The Elements of Program‐\nming Style  by Brian Kernighan and P . J. Plauger (McGraw-Hill) set the style (literally)\nfor a generation of programmers with examples from various structured\nprogramming  languages. Kernighan and Plauger also wrote a pair of books, Software\nTools  (Addison-Wesley) and Software  Tools in Pascal  (Addison-Wesley), which\ndemonstrated so much good advice on programming that I used to advise all pro‐\ngrammers to read them. However, these three books are dated now; many times I\nwanted to write a follow-on book in a more modern language. Instead I now defer to\nThe Practice of Programming , Kernighan’s follow-on—cowritten with Rob Pike\n(Addison-Wesley)—to the Software  Tools  series. This book continues the Bell Labs\ntradition of excellence in software textbooks. In previous editions of this book, I had\neven adapted one bit of code from their book, their CSV parser. Finally, Kernighan\nrecently published UNIX: A History and a Memoir , his take on the story of Unix.\nSee also The Pragmatic Programmer  by Andrew Hunt and David Thomas (Addison-\nWesley).\nDesign Books\nPeter Coad’s Java Design  (PTR-PH/Y ourdon Press) discusses the issues of object-\noriented analysis and design specifically for Java. Coad is somewhat critical of Java’s\nimplementation of the observable-observer paradigm and offers his own replacement\nfor it.\nOne of the most famous books on object-oriented design in recent years is  Design\nPatterns  by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides\n(Addison-Wesley). These authors are often collectively called the “Gang of Four, ”\nresulting in their book sometimes being referred to as the GoF book. One of my col‐\nleagues called it “the best book on object-oriented design ever, ” and I agree; at the\nvery least, it’s among the best.\nRefactoring  by Martin Fowler (Addison-Wesley) covers a lot of “coding cleanups” that\ncan be applied to code to improve readability and maintainability. Just as the GoF\nbook introduced new terminology that helps developers and others communicate\nabout how code is to be designed, Fowler’s book provided a vocabulary for discussing\nhow it is to be improved. But this book may be less useful than others; many of the\nrefactorings now appear in the Refactoring Menu of the Eclipse IDE (see Recipe 1.3 ).\nTwo important streams of methodology theories are currently in circulation. The first\nis collectively known as Agile methods, and its best-known members are Scrum  and\nExtreme Programming (XP). XP (the methodology, not that really old flavor of\nMicrosoft’s OS) is presented in a series of small, short, readable texts led by its\ndesigner, Kent Beck. The first book in the XP series is Extreme Programming\nExplained  (Addison-Wesley). A good overview of all the Agile methods is Jim High‐\nsmith’s Agile Software  Development Ecosystems  (Addison-Wesley).\nxx | Preface",4043
09-Programming Conventions.pdf,09-Programming Conventions,,0
10-OReilly Online Learning.pdf,10-OReilly Online Learning,"Another group of important books on methodology, covering the more traditional\nobject-oriented design, is the UML series led by “the Three Amigos” (Booch,\nJacobson, and Rumbaugh). Their major works are the UML User Guide , UML Process ,\nand others. A smaller and more approachable book in the same series is Martin Fowl‐\ner’s UML Distilled .\nConventions Used in This Book\nThis book uses the following conventions.\nProgramming Conventions\nI use the following terminology in this book. A program means any unit of code that\ncan be run: from a five-line main program, to a servlet or web tier component, an\nEJB, or a full-blown GUI application. Applets were Java programs for use in a web\nbrowser; these were popular for a while but barely exist today. A servlet is a Java com‐\nponent built using Jakarta EE APIs for use in a web server, normally via HTTP . EJBs\nare business-tier components built using Jakarta APIs. An application is any other\ntype of program. A desktop application (a.k.a. client) interacts with the user. A server\nprogram deals with a client indirectly, usually via a network connection (usually\nHTTP/HTTPS these days).\nThe examples shown are in two varieties. Those that begin with zero or more import\nstatements, a javadoc comment, and a public class  statement are complete exam‐\nples. Those that begin with a declaration or executable statement, of course, are\nexcerpts. However, the full versions of these excerpts have been compiled and run,\nand the online source includes the full versions.\nRecipes are numbered by chapter and number, so, for example, Recipe 8.1  refers to\nthe first recipe in Chapter 8 .\nTypesetting Conventions\nThe following typographic conventions are used in this book:\nItalic\nUsed for commands, filenames, and example URLs. It is also used for emphasis\nand to define new terms when they first appear in the text.\nConstant width\nUsed in code examples to show partial or complete Java source code program\nlistings. It is also used for class names, method names, variable names, and other\nfragments of Java code.\nPreface | xxi\nConstant width bold\nUsed for user input, such as commands that you type on the command line.\nConstant width italic\nShows text that should be replaced with user-supplied values or by values deter‐\nmined by context.\nThis element signifies a tip or suggestion.\nThis element signifies a general note.\nThis icon indicates a warning or caution.\nCode Examples\nThe code samples for this book are on the author’s GitHub. Most are in the repository\njavasrc , but a few are pulled in from one other repository, darwinsys-api . Details on\ndownloading these are in Recipe 1.6 .\nMany programs are accompanied by an example showing them in action, run from\nthe command line. These will usually show a prompt ending in either $ for Unix or >\nfor Windows, depending on which computer I was using the day I wrote that exam‐\nple. If there is text before this prompt character, it can be ignored. It may be a path‐\nname or a hostname, again, depending on the system.\nThese examples will usually also show the full package name of the class because Java\nrequires this when starting a program from the command line. And because that will\nremind you which subdirectory of the source repository to find the source code in, I\nwon’t be pointing it out explicitly very often.\nWe appreciate, but generally do not require, attribution. An attribution usually\nincludes the title, author, publisher, and ISBN. For example: “ Java Cookbook  by Ian F.\nDarwin (O’Reilly). Copyright 2020 RejmiNet Group, Inc., 978-1-492-07258-4. ”\nxxii | Preface",3639
11-At OReilly.pdf,11-At OReilly,"If you feel your use of code examples falls outside fair use or the permission given\nabove, feel free to contact us at permissions@oreilly.com .\nO’Reilly Online Learning\nFor more than 40 years, O’Reilly Media  has provided technol‐\nogy and business training, knowledge, and insight to help\ncompanies succeed.\nOur unique network of experts and innovators share their knowledge and expertise\nthrough books, articles, conferences, and our online learning platform. O’Reilly’s\nonline learning platform gives you on-demand access to live training courses, in-\ndepth learning paths, interactive coding environments, and a vast collection of text\nand video from O’Reilly and 200+ other publishers. For more information, please\nvisit http://oreilly.com .\nComments and Questions\nAs mentioned earlier, I’ve tested all the code on at least one of the reference plat‐\nforms, and most on several. Still, there may be platform dependencies, or even bugs,\nin my code or in some important Java implementation. Please report any errors you\nfind, as well as your suggestions for future editions, by writing to:\nO’Reilly Media, Inc.\n1005 Gravenstein Highway North\nSebastopol, CA 95472\n800-998-9938 (in the United States or Canada)\n707-829-0515 (international or local)\n707-829-0104 (fax)\nThere is a web page for this book where we list errata, examples, and any additional\ninformation. It can be accessed at http://shop.oreilly.com/product/0636920304371.do .\nEmail bookquestions@oreilly.com  to comment or ask technical questions about this\nbook.\nFor more information about our books, courses, conferences, and news, see our web‐\nsite at http://www.oreilly.com .\nFind us on Facebook: http://facebook.com/oreilly\nFollow us on Twitter: http://twitter.com/oreillymedia\nWatch us on Y ouTube: http://www.youtube.com/oreillymedia\nPreface | xxiii\nThe O’Reilly site lists errata. Y ou’ll also find the source code for all the Java code\nexamples to download; please  don’t waste your time typing them again! For specific\ninstructions, see Recipe 1.6 .\nAcknowledgments\nI wrote in the Afterword to the first edition that “writing this book has been a hum‐\nbling experience. ” I should add that maintaining it has been humbling, too. While\nmany have been lavish with their praise—one very kind reviewer called it “arguably\nthe best book ever written on the Java programming language”—I have been humbled\nby the number of errors and omissions in earlier editions. I have endeavored to cor‐\nrect these.\nMy life has been touched many times by the flow of the fates bringing me into contact\nwith the right person to show me the right thing at the right time. Steve Munro , with\nwhom I’ve long since lost touch, introduced me to computers when we were in the\nsame class in high school—in particular an IBM 360/30 at the Toronto Board of Edu‐\ncation that was bigger than a living room, had 32 or 64 K (not M or G!) of memory,\nand had perhaps the power of a PC/XT. The late Herb Kugel took me under his wing\nat the University of Toronto while I was learning about the larger IBM mainframes\nthat came later. Terry Wood and Dennis Smith at the University of Toronto intro‐\nduced me to mini- and micro-computers before there was an IBM PC. On evenings\nand weekends, the Toronto Business Club of Toastmasters International  and Al Lam‐\nbert’s Canada SCUBA School allowed me to develop my public speaking and teaching\nabilities. Several people at the University of Toronto, but especially Geoffrey Collyer ,\ntaught me the features and benefits of the Unix operating system at a time when I was\nready to learn it.\nThanks to the many Learning Tree  instructors and students who showed me ways of\nimproving my presentations. I still teach for “The Tree” and recommend their courses\nfor the busy developer who wants to zero in on one topic in detail over four days.\nCloser to this project, Tim O’Reilly believed in my “little Lint book” when it was just a\nsample chapter from a proposed longer work, enabling my early entry into the rare‐\nfied circle of O’Reilly authors. Y ears later, Mike Loukides encouraged me to keep try‐\ning to find a Java book idea that both he and I could work with. And he stuck by me\nwhen I kept falling behind the deadlines. Mike also read the entire manuscript and\nmade many sensible comments, some of which brought flights of fancy down to\nearth. Jessamyn Read turned many faxed and emailed scratchings of dubious legibil‐\nity into the quality illustrations you see in this book. And many, many other talented\npeople at O’Reilly helped put this book into the form in which you now see it.\nThe code examples are now dynamically included (so updates get done faster) rather\nthan pasted in. My son (and functional programming developer) Benjamin Darwin\nxxiv | Preface",4818
12-Readers.pdf,12-Readers,"helped meet the deadline by converting almost the entire code base to O’Reilly’s new‐\nest “include” mechanism and by resolving a couple of other non-Java presentation\nissues. He also helped make Chapter 9  clearer and more functional.\nAt O’Reilly\nFor this fourth edition of the book, Suzanne McQuade was the editorial overseer, and\nCorbin Collins the principal editor. Corbin was especially meticulous in checking the\nmanuscript. Meghan Blanchette, Sarah Schneider, Adam Witwer, Melanie Y arbrough,\nand the many production people listed on the Copyright page all played a part in get‐\nting the third edition ready for you to read. Thanks to Mike Loukides, Deb Cameron,\nand Marlowe Shaeffer for editorial and production work on the second edition.\nTechnical Reviewers\nFor the fourth edition I was blessed to have two very thorough technical reviewers,\nSander Mak and Daniel Hinojosa. Many issues that I hadn’t considered during the\nmain revision were called out by these two, leading to extensive rewrites and changes\nin the last few weeks before the O’Reilly production team took over. Thanks so much\nto both of you!\nMy reviewer for the third edition, Alex Stangl, read the third edition manuscript and\nwent far above the call of duty, making innumerable helpful suggestions, even finding\ntypos that had been present in previous editions! Helpful suggestions on particular\nsections were made by Benjamin Darwin, Mark Finkov, and Igor Savin. For anyone\nI’ve forgotten to mention, I thank you all!\nBil Lewis and Mike Slinn made helpful comments on multiple drafts of the first edi‐\ntion. Ron Hitchens and Marc Loy carefully read the entire final draft of the first edi‐\ntion. I am grateful to Mike Loukides for his encouragement and support throughout\nthe process. Editor Sue Miller helped shepherd the manuscript through the somewhat\nenergetic final phases of production. Sarah Slocombe read the XML chapter in its\nentirety and made many lucid suggestions; unfortunately, time did not permit me to\ninclude all of them in the first edition.\nJonathan Knudsen, Andy Oram, and David Flanagan commented on book’s outline\nwhen it was little more than a list of chapters and recipes, and they were able to see\nthe kind of book it could become and suggest ways to make it better.\nEach of these people made this book better in many ways, particularly by suggesting\nadditional recipes or revising existing ones. Thanks to one and all! The faults that\nremain are my own.\nPreface | xxv",2506
13-Book Production Software.pdf,13-Book Production Software,"3Earlier editions are or have been available in English, German, French, Polish, Russian, Korean, Traditional\nChinese, and Simplified Chinese. My thanks to all the translators for their efforts in making the book available\nto a wider audience.Readers\nMy sincere thanks to all the readers who found errata and suggested improvements.\nEvery new edition is better for the efforts of folks like you who take the time and\ntrouble to report that which needs reporting!\nSpecial mention must be made of one of the book’s German translators,3 Gisbert\nSelke, who read the first edition cover to cover during its translation and clarified my\nEnglish. Gisbert did it all over again for the second edition and provided many code\nrefactorings, which have made this a far better book than it would be otherwise.\nGoing beyond the call of duty, Gisbert even contributed one recipe ( Recipe 18.5 ) and\nrevised some of the other recipes in the same chapter. Thank you, Gisbert!\nThe second edition also benefited from comments by Jim Burgess, who read large\nparts of the book. Comments on individual chapters were received from Jonathan\nFuerth, the late Kim Fowler, Marc Loy, and Mike McCloskey. My wife, Betty, and my\nthen-teenaged children each proofread several chapters as well.\nThe following people contributed significant bug reports or suggested improvements:\nRex Bosma, Rod Buchanan, John Chamberlain, Keith Goldman, Gilles-Philippe Gre‐\ngoire, B. S. Hughes, Jeff Johnston, Rob Konigsberg, Tom Murtagh, Jonathan O’Con‐\nnor, Mark Petrovic, Steve Reisman, Bruce X. Smith, and Patrick Wohlwend.\nEtc.\nMy dear wife, Betty Cerar, still knows more about the caffeinated beverage that I\ndrink while programming than the programming language I use, but her passion for\nclear expression and correct grammar has benefited so much of my writing during\nour life together.\nNo book on Java would be complete without a note of thanks to James Gosling for\ninventing Java (he also invented the first Unix Emacs, the sc spreadsheet, and the\nNeWS window system). Thanks also to his employer Sun Microsystems (before they\nwere taken over by Oracle) for releasing not only the Java language but an incredible\narray of Java tools and API libraries freely available over the internet.\nWilli Powell of Apple Canada provided macOS access for the first edition, back in the\nearly days of macOS.\nTo each and every one of you, my sincere thanks.\nxxvi | Preface\nBook Production Software\nI used a variety of tools and operating systems in preparing, compiling, and testing\nthis book. The developers of OpenBSD , “the proactively secure Unix-like system, ”\ndeserve thanks for making a stable and secure Unix clone that is also closer to tradi‐\ntional Unix than other freeware systems. I used the vi editor ( vi on OpenBSD and vim\non Windows) while inputting the original manuscript in XML, and I used Adobe\nFrameMaker (a wonderful GUI-based documentation tool that Adobe bought and\nsubsequently destroyed) to format the documents. I do not know if I can ever forgive\nAdobe for destroying what was arguably the world’s best documentation system and\nfor making the internet such a dangerous place by keeping the bug-infested Flash\nalive long past its best-before century. I do know I will never use a documentation\nsystem from Adobe for anything.\nBecause of this, the crowd-sourced Android Cookbook  that I edited was not prepared\nwith FrameMaker, but instead XML DocBook (generated from wiki markup on a\nJava-powered website that I wrote for the purpose) and a number of custom tools\nprovided by O’Reilly’s tools group.\nThe third and fourth editions of this Java Cookbook  were formatted in Asciidoctor\nand brought to life on the publishing toolchain of O’Reilly’s Atlas .\nPreface | xxvii",3795
14-Chapter 1. Getting Started Compiling and Running Java.pdf,14-Chapter 1. Getting Started Compiling and Running Java,,0
15-1.1 Compiling and Running Java Standard JDK.pdf,15-1.1 Compiling and Running Java Standard JDK,"CHAPTER 1\nGetting Started: Compiling and\nRunning Java\n1.0 Introduction\nThis chapter covers some entry-level tasks that you need to know how to do before\nyou can go on. It is said you must crawl before you can walk, and walk before you can\nride a bicycle. Before you can try out anything in this book, you need to be able to\ncompile and run your Java code, so I start there, showing several ways to do that: the\nJDK way, the Integrated Development Environment (IDE) way, and the build tools\n(Ant, Maven, etc.) way. Another issue people run into is setting CLASSPATH  correctly,\nso that’s dealt with next. Deprecation warnings follow after that, because you’re likely\nto encounter them in maintaining old Java code. The chapter ends with some general\ninformation about conditional compilation, unit testing, assertions, and debugging.\nIf you don’t already have Java installed, you’ll need to download it. Be aware that\nthere are several different downloads. The JRE (Java Runtime Environment) was, up\nuntil Java 8, a smaller download for end users. Since there is far less desktop Java than\nthere once was, the JRE was eliminated in favor of  jlink  to make a custom download\n(see Recipe 15.8 ). The JDK or Java SDK download is the full development environ‐\nment, which you’ll want if you’re going to be developing Java software.\nStandard downloads for the current release of Java are available at Oracle’s website .\nY ou can sometimes find prerelease builds of the next major Java version on http://\njdk.java.net . The entire JDK is maintained as an open source project, and the\nOpenJDK source tree is used (with changes and additions) to build the commercial\nand supported Oracle JDKs.\n1",1711
16-Problem.pdf,16-Problem,,0
17-1.2 Compiling and Running Java GraalVM for Better Performance.pdf,17-1.2 Compiling and Running Java GraalVM for Better Performance,"If you’re already happy with your IDE, you may wish to skip some or all of this mate‐\nrial. It’s here to ensure that everybody can compile and debug their programs before\nwe move on.\n1.1 Compiling and Running Java: Standard JDK\nProblem\nY ou need to compile and run your Java program.\nSolution\nThis is one of the few areas where your computer’s operating system impinges on\nJava’s portability, so let’s get these issues out of the way first.\nJDK\nUsing the command-line Java Development Kit (JDK) may be the best way to keep up\nwith the very latest improvements in Java. Assuming you have the standard JDK\ninstalled in the standard location and/or have set its location in your PATH , you should\nbe able to run the command-line JDK tools. Use the commands  javac  to compile and\njava to run your program (and, on Windows only, javaw  to run a program without a\nconsole window), like this:\nC:\javasrc> javac HelloWorld.java\nC:\javasrc> java HelloWorld\nHello, World\nC:\javasrc>\nIf the program refers to other classes for which the source is available (in the same\ndirectory) and a compiled .class  file is not, javac  will automatically compile it for you.\nEffective with Java 11, for simple programs that don’t need any such co-compilation,\nyou can combine the two operations by simply passing the Java source file to the java\ncommand:\n $ java HelloWorld.java\n Hello, Java\n $\n \nAs you can see from the compiler’s (lack of) output, both javac  and java compilation\nworks on the Unix “no news is good news” philosophy: if a program was able to do\nwhat you asked it to, it shouldn’t bother nattering at you to say that it did so.\nThere is an optional setting called CLASSPATH , discussed in Recipe 1.5 , that controls\nwhere Java looks for classes. CLASSPATH , if set, is used by both javac  and java. In older\n2 | Chapter 1: Getting Started: Compiling and Running Java",1896
18-Problem.pdf,18-Problem,,0
19-1.3 Compiling Running and Testing with an IDE.pdf,19-1.3 Compiling Running and Testing with an IDE,"versions of Java, you had to set your CLASSPATH  to include “. ” even to run a simple\nprogram from the current directory; this is no longer true on current Java\nimplementations.\nSun/Oracle’s javac  compiler is the official reference implementation. There were sev‐\neral alternative open source command-line compilers, including Jikes  and Kaffe , but\nthey are, for the most part, no longer actively maintained.\nThere have also been some Java runtime clones, including Apache Harmony , Japhar ,\nthe IBM Jikes Runtime (from the same site as Jikes), and even JNode , a complete,\nstandalone operating system written in Java; but since the Sun/Oracle JVM has been\nopen sourced (GPL), most of these projects have stopped being maintained. Har‐\nmony was retired by Apache in November 2011.\nmacOS\nThe JDK is pure command line. At the other end of the spectrum in terms of\nkeyboard-versus-visual, we have the Apple Macintosh. Books have been written\nabout how great the Mac user interface is, and I won’t step into that debate. macOS\n(Release 10.x of the OS) is built upon a BSD Unix (and “Mach”) base. As such, it has a\nregular command line (the Terminal application, hidden away under /Applications/\nUtilities ), as well as both the traditional Unix command-line tools and the graphical\nMac tools. If you’re using macOS, you can use the command-line JDK tools or any of\nthe modern build tools. Compiled classes can be packaged into clickable applications\nusing the Jar Packager discussed in Recipe 15.6 . Mac fans can use one of the many full\nIDE tools discussed in Recipe 1.3 . Apple provides XCode as its IDE, but out of the\nbox it isn’t very Java-friendly.\n1.2 Compiling and Running Java: GraalVM for Better\nPerformance\nProblem\nY ou’ve heard that Graal is a JVM from Oracle that’s faster than the standard JDK, and\nyou want to try it out. Graal promises to offer better performance, and it offers the\nability to mix and match programming languages and pre-compile your Java code\ninto executable form for a given platform.\nSolution\nDownload and install GraalVM.\n1.2 Compiling and Running Java: GraalVM for Better Performance | 3\nDiscussion\nGraalVM bills itself as “a universal virtual machine for running applications written\nin JavaScript, Python, Ruby, R, JVM-based languages like Java, Scala, Clojure, Kotlin,\nand LLVM-based languages such as C and C++. ”\nNote that Graal is undergoing rapid change. While this recipe reflects the latest infor‐\nmation at press time (late 2019), there may be newer versions and changed function‐\nality by the time you are ready to install.\nAs we go to press, GraalVM is based on OpenJDK 11, which means you can use\nModules and other Java 9, 10, and 11 features, but it doesn’t have support for Java 12,\n13 or 14 features. Y ou can build your own Graal on later releases, since the complete\nsource is on GitHub .\nSee the GraalVM website  for more information on GraalVM. See also this presenta‐\ntion by Chris Thalinger, who has worked on JVMs for a decade and a half.\nStart at the downloads page . Y ou will have to choose between the Community Edition\nand the Enterprise Edition. To avoid any licensing issues, this recipe starts with the\nCommunity Edition. Y ou can download a tarball for Linux, macOS, and Windows.\nThere is no formal installer at this point. To install it, open a terminal window and try\nthe following (the directory chosen is for macOS):\n$ cd /Library/Java/JavaVirtualMachines\n$ tar xzvf ~/Downloads/graalvm-ce-NNN-VVV.tar.gz # replace with actual version\n$ cd\n$ /usr/libexec/java_home -V # macOS only\n11.0.2, x86_64:    ""OpenJDK 11.0.2""\n    /Library/Java/JavaVirtualMachines/jdk-11.0.2.jdk/Contents/Home\n1.8.0_221, x86_64:    ""GraalVM CE 19.2.0.1""\n    /Library/Java/JavaVirtualMachines/graalvm-ce-19.2.0.1/Contents/Home\n$\nOn other systems, do the install in a sensible place. On most versions of Linux, after\ninstalling a JDK, you can use the standard Linux alternatives  command  to make this\nyour default. On MacOS, the java_home  command output confirms that you have\ninstalled GraalVM, but it’s not your default JVM yet. To do that, you have to set your\nPATH :\nexport JAVA_HOME=<where you installed GraalVM>/Contents/Home\nexport PATH=$JAVA_HOME/bin:$PATH\nBe very sure to include the  :$PATH  at the end of the line—no space—or all your stan‐\ndard command-line tools will appear to disappear (if you made this mistake, just log\nout and log back in to restore your path). I suggest you don’t update your login scripts\nuntil you are sure the settings you have are correct.\nNow you should be running the Graal version of Java. This is what you should see:\n4 | Chapter 1: Getting Started: Compiling and Running Java",4738
20-Problem.pdf,20-Problem,,0
21-Solution.pdf,21-Solution,,0
22-Discussion.pdf,22-Discussion,"$ java -version\nopenjdk version ""1.8.0_222""\nOpenJDK Runtime Environment (build\n  1.8.0_222-20190711112007.graal.jdk8u-src-tar-gz-b08)\nOpenJDK 64-Bit GraalVM CE 19.2.0.1 (build 25.222-b08-jvmci-19.2-b02, mixed mode)\nY our output may differ, but as long as it says “GraalVM” you should be good.\nGraal includes a number of useful tools, including native-image , which can in some\ncases translate a class file into a binary executable for the platform it’s running on,\noptimizing startup speed and also reducing the download size needed to run a single\napplication. The native-image  tool must be downloaded separately using gu install\nnative-image .\nWe’ll explore running some of the other non-Java languages in Recipe 18.4 .\n1.3 Compiling, Running, and Testing with an IDE\nProblem\nIt is cumbersome to use several tools for the various development tasks.\nSolution\nUse an Integrated Development Environment (IDE), which combines editing, testing,\ncompiling, running, debugging, and package management.\nDiscussion\nMany programmers find that using a handful of separate tools—a text editor, a com‐\npiler, and a runner program, not to mention a debugger—is too many. An IDE inte‐\ngrates  all of these into a single toolset with a graphical user interface. Many IDEs are\navailable, and the better ones are fully integrated tools with their own compilers and\nvirtual machines. Class browsers and other features of IDEs round out the ease-of-\nuse feature sets of these tools. Today most developers use an IDE because of the pro‐\nductivity gains. Although I started as a command-line junkie, I do find that IDE fea‐\ntures like the following make me more productive:\nCode completion:: Ian’s Rule  here is that I never type more than three characters of\nany name that is known to the IDE; let the computer do the typing! Incremental\ncompiling features:: Note and report compilation errors as you type, instead of wait‐\ning until you are finished typing. Refactoring:: The ability to make far-reaching yet\nbehavior-preserving changes to a code base without having to manually edit dozens\nof individual files.\n1.3 Compiling, Running, and Testing with an IDE | 5\nBeyond that, I don’t plan to debate the merits of IDE versus the command-line pro‐\ncess; I use both modes at different times and on different projects. I’m just going to\nshow a few examples of using a couple of the Java-based IDEs.\nThe three most popular Java IDEs, which run on all mainstream computing plat‐\nforms and quite a few niche ones, are Eclipse , NetBeans , and IntelliJ IDEA . Eclipse is\nthe most widely used, but the others each have a special place in the hearts and minds\nof some developers. If you develop for Android, the ADT has traditionally been\ndeveloped for Eclipse, but it has now transitioned to IntelliJ as the basis for Android\nStudio, which is the standard IDE for Android, and for Google’s other mobile plat‐\nform, Flutter . All three IDEs are plug-in based and offer a wide selection of optional\nand third-party plug-ins to enhance the IDE, such as supporting other programming\nlanguages, frameworks, and file types. While the following paragraph shows creating\nand running a program with Eclipse, the IntelliJ IDEA and NetBeans IDEs all offer\nsimilar capabilities.\nOne of the most popular cross-platform, open source IDEs for Java is Eclipse, origi‐\nnally from IBM and now shepherded by the Eclipse Foundation , the home of many\nsoftware projects including Jakarta , the follow-on to the Java Enterprise Edition. The\nEclipse Platform is also used as the basis of other tools such as SpringSource Tool\nSuite (STS) and IBM’s Rational Application Developer (RAD). All IDEs do basically\nthe same thing for you when getting started. The example in Figure 1-1  shows start‐\ning a new project.\n6 | Chapter 1: Getting Started: Compiling and Running Java\nFigure 1-1. Starting a new project with the Eclipse New Java Class Wizard\nThe Eclipse New Java Class Wizard shown in Figure 1-2  shows creating a new class.\n1.3 Compiling, Running, and Testing with an IDE | 7\nFigure 1-2. Creating a new class with the Eclipse New Java Class Wizard\nEclipse, like all modern IDEs, features a number of refactoring capabilities, shown in\nFigure 1-3 .\n8 | Chapter 1: Getting Started: Compiling and Running Java\nFigure 1-3. Refactoring in Eclipse\nAnd, of course, all the IDEs allow you to run and/or debug your application.\nFigure 1-4  shows running an application; for variety and neutrality, this is shown\nusing IntelliJ IDEA.\nmacOS includes Apple’s Developer Tools. The main IDE is Xcode. Unfortunately, cur‐\nrent versions of Xcode do not really support Java development, so I can’t recommend\nit for our purposes; it is primarily for those building nonportable (iOS-only or OS X–\nonly) applications in the Swift or Objective-C programming languages. So even if you\nare on OS X, to do Java development you should use one of the three Java IDEs.\nMicrosoft VSCode (formerly part of Visual Studio) has been getting some attention\nin Java circles lately, but it’s not a Java-specific IDE. Give it a try if you like.\nHow do you choose an IDE? Perhaps it will be dictated by your organization or\nchosen by majority vote of your fellow developers. Given that all three major IDEs\n(Eclipse, NetBeans, and IntelliJ) can be downloaded free and are 100% open source,\nwhy not try them all and see which one best fits the kind of development you do?\nRegardless of what platform you use to develop Java, if you have a Java runtime, you\nshould have plenty of IDEs from which to choose.\n1.3 Compiling, Running, and Testing with an IDE | 9",5655
23-1.4 Exploring Java with JShell.pdf,23-1.4 Exploring Java with JShell,"Figure 1-4. IntelliJ program output\nSee Also\nEach IDE’s website maintains an up-to-date list of resources, including books. See\nTable 1-1  for the website for each.\nTable 1-1. The three major Java IDEs and their websites\nProduct name Project URL Note\nEclipse https://eclipse.org/ Basis of STS, RAD\nIntelliJ Idea https://jetbrains.com/idea/ Basis of Android Studio\nNetbeans https://netbeans.apache.org Run anywhere JavaSE does\nThese major IDEs are extensible; see their documentation for a list of the many, many\nplug-ins available. Most of them allow you to find and install plug-ins from within\nthe IDE. For Eclipse, use the Eclipse Marketplace, near the bottom of the Help menu.\nAs a last resort, if you need/want to write a plug-in that extends the functionality of\nyour IDE, you can do that too, and in Java.\n10 | Chapter 1: Getting Started: Compiling and Running Java",886
24-Problem.pdf,24-Problem,,0
25-Solution.pdf,25-Solution,,0
26-Discussion.pdf,26-Discussion,"For Eclipse, I have some useful information at https://darwinsys.com/java . The site\nincludes a list of shortcuts to aid developer productivity.\n1.4 Exploring Java with JShell\nProblem\nY ou want to try out Java expressions and APIs quickly, without having to create a file\nwith public class X { public static void main(String[] args) { … }  every\ntime.\nSolution\nUse JShell, Java’s REPL (Read-Evaluate-Print-Loop) interpreter.\nDiscussion\nStarting with Java 11, JShell  is included as a standard part of Java. It allows you to\nenter Java statements and have them evaluated without the bother of creating a class\nand a main program. Y ou can use it for quick calculations, to try out an API to see\nhow it works, or for almost any purpose; if you find an expression you like, you can\ncopy it into a regular Java source file and make it permanent. JShell can also be used\nas a scripting language over Java, but the overhead of starting the JVM means that it\nwon’t be as fast as awk, Perl, or Python for quick scripting.\nREPL programs are very convenient, and they are hardly a new idea (LISP languages\nfrom the 1950s included them). Y ou can think of Command-Line Interpreters (CLIs)\nsuch as the Bash or Ksh shells on UNIX/Linux, or Command.com and PowerShell on\nMicrosoft Windows, as REPLs for the system as a whole. Many interpreted languages\nlike Ruby and Python can also be used as REPLs. Java finally has its own REPL, JShell .\nHere’s an example of using it:\n$ jshell\n|  Welcome to JShell -- Version 11.0.2\n|  For an introduction type: /help intro\njshell> ""Hello""\n$1 ==> ""Hello""\njshell> System.out.println(""Hello"");\nHello\njshell> System.out.println($1)\nHello\njshell> ""Hello"" + sqrt(57)\n|  Error:\n1.4 Exploring Java with JShell | 11\n|  cannot find symbol\n|    symbol:   method sqrt(int)\n|  ""Hello"" + sqrt(57)\n|            ^--^\njshell> ""Hello"" + Math.sqrt(57)\n$2 ==> ""Hello7.54983443527075""\njshell> String.format(""Hello %6.3f"", Math.sqrt(57)\n   ...> )\n$3 ==> ""Hello  7.550""\njshell> String x = Math.sqrt(22/7) + "" "" + Math.PI +\n   ...> "" and the end.""\nx ==> ""1.7320508075688772 3.141592653589793 and the end.""\njshell>\nY ou can see some obvious features and benefits here:\n•The value of an expression is printed without needing to call Sys\ntem.out.println  every time, but you can call it if you like.\n•Values that are not assigned to a variable get assigned synthetic identifiers, like\n$1, that can be used in subsequent statements.\n•The semicolon at the end of a statment is optional (unless you type more than\none statement on a line).\n•If you make a mistake, you get a helpful message immediately.\n•Y ou can get completion with a single tab, as in shell filename completion.\n•Y ou can get the relevant portion of the Javadoc documentation on known classes\nor methods with just a double tab.\n•If you omit a close quote, parenthesis, or other punctuation, JShell will just wait\nfor you, giving a continuation prompt ( …).\n•If you do make a mistake, you can use “shell history” (i.e., up arrow) to recall the\nstatement so you can repair it.\nJShell is also useful in prototyping Java code. For example, I wanted one of those\nhealth-themed timers that reminds you to get up and move around a bit every half\nhour:\n$ jshell\n|  Welcome to JShell -- Version 11.0.2\n|  For an introduction type: /help intro\njshell> while (true) { sleep (30*60); JOptionPane.showMessageDialog(null,\n  ""Move it""); }\n|  Error:\n12 | Chapter 1: Getting Started: Compiling and Running Java",3527
27-1.5 Using CLASSPATH Effectively.pdf,27-1.5 Using CLASSPATH Effectively,,0
28-Problem.pdf,28-Problem,,0
29-Solution.pdf,29-Solution,,0
30-Discussion.pdf,30-Discussion,"|  cannot find symbol\n|    symbol:   method sleep(int)\n|  while (true) { sleep (30*60); JOptionPane.showMessageDialog(null, ""Move \nit"");}\n|                 ^---^\n|  Error:\n|  cannot find symbol\n|    symbol:   variable JOptionPane\n|  while (true) { sleep (30*60); JOptionPane.showMessageDialog(null, ""Move \nit"");}\n|                                ^---------^\njshell> import javax.swing.*;\njshell> while (true) { Thread.sleep (30*60); JOptionPane.showMessageDialog(null,\n""Move it""); }\njshell> while (true) { Thread.sleep (30*60 * 1000);\n  JOptionPane.showMessageDialog(null, ""Move it""); }\njshell> ^D\nI then put the final working version into a Java file called MoveTimer.java , put a class\nstatement and a main()  method around the main line, told the IDE to reformat the\nwhole thing, and saved it into my darwinsys-api  repository.\nSo go ahead and experiment with JShell. Read the built-in introductory tutorial for\nmore details! When you get something you like, either use /save , or copy and paste it\ninto a Java program and save it.\nRead more about JShell at the OpenJDK JShell Tutorial .\n1.5 Using CLASSPATH Effectively\nProblem\nY ou need to keep your class files in a common directory, or you’re wrestling with\nCLASSPATH .\nSolution\nSet CLASSPATH  to the list of directories and/or JAR files that contain the classes you\nwant.\nDiscussion\nCLASSPATH  is a list of class files in any of a number of directories, JAR files, or ZIP\nfiles. Just like the PATH  your system uses for finding programs, the CLASSPATH  is used\n1.5 Using CLASSPATH Effectively  | 13\nby the Java runtime to find classes. Even when you type something as simple as java\nHelloWorld , the Java interpreter looks in each of the places named in your CLASSPATH\nuntil it finds a match. Let’s work through an example.\nThe CLASSPATH  can be set as an environment variable the same way you set other\nenvironment variables, such as your PATH  environment variable. However, it’s usually\npreferable to specify the CLASSPATH  for a given command on the command line:\nC:\> java -classpath c:\ian\classes MyProg\nSuppose your CLASSPATH  were set to C:\classes;.  on Windows or ~/classes:.  on Unix or\nMac. Suppose you had just compiled a source file named HelloWorld.java  (with no\npackage statement) into HelloWorld.class  in the default directory (which is your cur‐\nrent directory) and tried to run it. On Unix, if you run one of the kernel tracing tools\n(trace , strace , truss , or ktrace ), you would probably see the Java program open  or\nstat  or access  the following files:\n•Some file(s) in the JDK directory\n•Then ~ /classes/HelloWorld.class , which it probably wouldn’t find\n•Finally, ./HelloWorld.class , which it would find, open, and read into memory\nThe vague “some file(s) in the JDK directory” is release dependent. Y ou should not\nmess with the JDK files, but if you’re curious, you can find them in the System Prop‐\nerties (see Recipe 2.2 ). There used to be a variable named sun.boot.class.path , but\nthat is not found anymore. Let’s look for any property with boot  in its name:\njshell> System.getProperties ().forEach((k,v) -> {\n ... if (((String)k).contains (""boot"")) System.out.println(k + ""->"" +v);})\nsun.boot.library.path->/usr/local/jdk-11/lib\nThe reason I and others suggest not setting CLASSPATH  as an environment variable is\nthat we don’t like surprises. It’s easy to add a JAR to your CLASSPATH  and then forget\nthat you’ve done so; a program might then work for you but not for your colleagues,\ndue to their being unaware of your hidden dependency. And if you add a new version\nto CLASSPATH  without removing the old version, you may run into conflicts.\nNote also that providing the -classpath  argument causes the CLASSPATH  environ‐\nment variable to be ignored.\nIf you still want to set CLASSPATH  as an environment variable, you can. Suppose you\nhad also installed the JAR file containing the supporting classes for programs from\nthis book, darwinsys-api.jar  (the actual filename if you download it may have a\nversion  number as part of the filename). Y ou might then set your CLASSPATH  to C:\n\classes;C:\classes\darwinsys-api.jar;.  on Windows or ~/classes:~/classes/darwinsys-\napi.jar:.  on Unix.\n14 | Chapter 1: Getting Started: Compiling and Running Java",4323
31-1.6 Downloading and Using the Code Examples.pdf,31-1.6 Downloading and Using the Code Examples,,0
32-Problem.pdf,32-Problem,,0
33-Discussion.pdf,33-Discussion,"Notice that you do need to list the full name of the JAR file explicitly. Unlike a single\nclass file, placing a JAR file into a directory listed in your CLASSPATH  does not make it\navailable.\nCertain specialized programs (such as a web server running a Servlet  container)\nmight not use either bootpath or CLASSPATH  exactly as shown; these application\nservers typically provide their own ClassLoader  (see Recipe 17.5  for information on\nclass loaders). EE Web containers, for example, set your web app CLASSPATH  to\ninclude the directory WEB-INF/classes  and all the JAR files found under WEB-INF/\nlib.\nHow can you easily generate class files into a directory in your CLASSPATH ? The javac\ncommand has a -d dir option, which specifies where the compiler output should go.\nFor example, using -d to put the HelloWorld  class file into my $HOME/classes  direc‐\ntory, I just type the following (note that from here on I will be using the package\nname in addition to the class name, like a good kid):\njavac -d $HOME/classes HelloWorld.java\njava -cp $HOME/classes starting.HelloWorld\nHello, world!\nAs long as this directory remains in my CLASSPATH , I can access the class file regard‐\nless of my current directory. That’s one of the key benefits of using CLASSPATH .\nWhile these examples show explicit use of java  with -classpath , it is generally more\nconvenient (and reproducible) to use a build tool such as Maven ( Recipe 1.7 ) or Gra‐\ndle, which automatically provide the CLASSPATH  for both compilation and execution.\nNote that Java 9 and later also have a module path (environment variable MODULEPATH ,\ncommand-line argument --module-path entry[:,…] ) with the same syntax as the\nclass path. The module path contains code that has been modularized; the Java Mod‐\nule System is discussed in Recipe 2.5  and Recipe 15.9 .\n1.6 Downloading and Using the Code Examples\nProblem\nY ou want to try out my example code and/or use my utility classes.\nSolution\nDownload the latest archive of the book source files, unpack it, and run Maven (see\nRecipe 1.7 ) to compile the files.\n1.6 Downloading and Using the Code Examples | 15\nDiscussion\nThe source code used as examples in this book is included in a couple of source code\nrepositories that have been in continuous development since 1995. These are listed in\nTable 1-2 .\nTable 1-2. The main source repositories\nRepository\nnameGitHub URL Package description Approx. size\njavasrc http://github.com/IanDarwin/javasrc Java code examples/demos 1,400 classes\ndarwinsys-api http://github.com/Iandarwin/darwinsys-api A published API 200 classes\nY ou can download these repositories from the GitHub URLs shown in Table 1-2 . Git‐\nHub allows you to download a ZIP file of the entire repository’s current state, as well\nas view individual files on the web interface. Downloading with  git clone  instead of as\nan archive is preferred because you can then update at any time with a simple  git pull\ncommand. And with the amount of updating this code base has undergone for the\ncurrent release of Java, you are sure to find changes after the book is published.\nIf you are not familiar with Git, see “CVS, Subversion, Git, Oh My!” on page 20 .\njavasrc\nThis is the largest repo and consists primarily of code written to show a particular\nfeature or API. The files are organized into subdirectories by topic, many of which\ncorrespond more or less to book chapters—for example, a directory for strings  exam‐\nples ( Chapter 3 ), regex  for regular expressions ( Chapter 4 ), numbers  (Chapter 5 ), and\nso on. The archive also contains the index by name and index by chapter files from\nthe download site, so you can easily find the files you need.\nThe javasrc  library is further broken down into a dozen Maven modules (shown in\nTable 1-3 ) so that you don’t need all the dependencies for everything on your CLASS\nPATH  all the time.\n16 | Chapter 1: Getting Started: Compiling and Running Java\nTable 1-3. JavaSrc Maven modules\nDirectory/module name Description\npom.xml Maven parent pom\nRdemo-web R demo using a web framework\ndesktop AWT and Swing stuff  (no longer covered in the Java Cookbook )\nee Enterprise stuff  (no longer covered in the Java Cookbook )\ngraal GraalVM demos\njlink JLink demos\njson JSON processing\nmain Contains the majority of the files,  i.e., those not required to be in one of the other\nmodules due to CLASSPATH  or other issues\nrestdemo REST service demo\nspark Apache Spark demo\ntesting Code for testing\nunsafe Demo of Unsafe  class\nxml XML stuff  (no longer covered in the Java Cookbook )\ndarwinsys-api\nI have built up a collection of useful stuff partly by moving some reusable classes\nfrom javasrc  into my own API, which I use in my own Java projects. I use example\ncode from it in this book, and I import classes from it into many of the other exam‐\nples. So, if you’re going to be downloading and compiling the examples individually ,\nyou should first download the file darwinsys-api-1. x.jar (for the latest value of x) and\ninclude it in your CLASSPATH . Note that if you are going to build the javasrc  code with\nEclipse or Maven, you can skip this download because the top-level Maven script\nstarts off by including the JAR file for this API.\nA compiled JAR file of darwinsys-api  is available in Maven Central ; find it by search‐\ning for darwinsys . This is the current Maven artifact:\n<dependency>\n   <groupId>com.darwinsys</groupId>\n   <artifactId>darwinsys-api</artifactId>\n   <version>1.1.3</version>\n</dependency>\nThis API consists of about two dozen com.darwinsys  packages, listed in Table 1-4 .\nThe structure vaguely parallels the standard Java API; this is intentional. These pack‐\nages now include around 200 classes and interfaces. Most of them have javadoc docu‐\nmentation that can be viewed with the source download.\n1.6 Downloading and Using the Code Examples | 17\nTable 1-4. The com.darwinsys packages\nPackage name Package description\ncom.darwinsys.csv Classes for comma-separated values files\ncom.darwinsys.database Classes for dealing with databases in a general way\ncom.darwinsys.diff Comparison utilities\ncom.darwinsys.genericui Generic GUI stuff\ncom.darwinsys.geo Classes relating to country codes, provinces/states, and so on\ncom.darwinsys.graphics Graphics\ncom.darwinsys.html Classes (only one so far) for dealing with HTML\ncom.darwinsys.io Classes for input and output operations, using Java’s underlying I/O classes\ncom.darwinsys.jsptags Java EE JSP tags\ncom.darwinsys.lang Classes for dealing with standard features of Java\ncom.darwinsys.locks Pessimistic locking API\ncom.darwinsys.mail Classes for dealing with email, mainly a convenience class for sending mail\ncom.darwinsys.model Sample data models\ncom.darwinsys.net Networking\ncom.darwinsys.preso Presentations\ncom.darwinsys.reflection Reflection\ncom.darwinsys.regex Regular expression stuff:  an REDemo program, a Grep variant\ncom.darwinsys.security Security\ncom.darwinsys.servlet Servlet API helpers\ncom.darwinsys.sql Classes for dealing with SQL databases\ncom.darwinsys.swingui Classes for helping construct and use Swing GUIs\ncom.darwinsys.swingui.layout A few interesting LayoutManager implementations\ncom.darwinsys.testdata Test data generators\ncom.darwinsys.testing Testing tools\ncom.darwinsys.unix Unix helpers\ncom.darwinsys.util A few miscellaneous utility classes\ncom.darwinsys.xml XML utilities\nMany of these classes are used as examples in this book; just look for files whose first\nline begins with the following:\npackage com.darwinsys;\nY ou’ll also find that many of the other examples have imports from the com.darwin\nsys packages.\n18 | Chapter 1: Getting Started: Compiling and Running Java\nGeneral notes\nY our best bet is to use git clone  to download a copy of both the Git projects and then\ndo a git pull  every few months to get updates. Alternatively, you can download from\nthis book’s catalog page  a single intersection subset of both libraries that is made up\nalmost exclusively of files actually used in the book. This archive is made from the\nsources that are dynamically included into the book at formatting time, so it should\nreflect exactly the examples you see in the book. But it will not include as many exam‐\nples as the three individual archives, nor is it guaranteed that everything will compile\nbecause of missing dependencies, nor will it get updated often. But if all you want is\nto copy pieces into a project you’re working on, this may be the one to get. Y ou can\nfind links to all of these files from my own website for this book ; just follow the\nDownloads link.\nThe two separate repositories contain multiple self-contained projects with support\nfor building both with Eclipse ( Recipe 1.3 ) and with Maven ( Recipe 1.7 ). Note that\nMaven will automatically fetch a vast array of prerequisite libraries when first invoked\non a given project, so be sure you’re online on a high-speed internet link. Maven will\nthus ensure that all prerequisites are installed before building. If you choose to build\npieces individually, look in the file pom.xml  for the list of dependencies. Unfortu‐\nnately, I will not be able to help you if you are using tooling other than Eclipse or\nMaven with the control files included in the download.\nIf you have a version of Java older than Java 12, a few files will not compile. Y ou can\nmake up exclusion elements for the files that are known not to compile.\nAll my code in the two projects is released under the least-restrictive credit-only\nlicense, the two-clause BSD license. If you find it useful, incorporate it into your own\nsoftware. There is no need to write to ask me for permission; just use it, with credit. If\nyou get rich off it, send me some money.\nMost of the command-line examples refer to source files, assuming\nyou are in src/main/java , and runnable classes, assuming you are in\n(or have added to your CLASSPATH ) the build directory (e.g., usually\ntarget/classes ). This will not be mentioned with each example, as\ndoing so would waste a lot of paper.\nCaveat lector\nThe repos have been in development since 1995. This means that you will find some\ncode that is not up to date or that no longer reflects best practices. This is not surpris‐\ning: any body of code will grow old if any part of it is not actively maintained. (Thus,\nat this point, I invoke Culture Club’s song “Do Y ou Really Want to Hurt Me”: “Give\nme time to realize my crime. ”) Where advice in the book disagrees with some code\nyou found in the repo, keep this in mind. One of the practices of Extreme Program‐\n1.6 Downloading and Using the Code Examples | 19\nming is Continuous Refactoring, the ability to improve any part of the code base at\nany time. Don’t be surprised if the code in the online source directory differs from\nwhat appears in the book; it is a rare month that I don’t make some improvement to\nthe code, and the results are committed and pushed quite often. So if there are differ‐\nences between what’s printed in the book and what you get from GitHub, be glad, not\nsad, for you’ll have received the benefit of hindsight. Also, people can contribute\neasily on GitHub via pull requests; that’s what makes it interesting. If you find a bug\nor an improvement, do send me a pull request! The consolidated archive on the page\nfor this book  will not be updated as frequently.\nCVS, Subversion, Git, Oh My!\nMany distributed version control systems or source code management systems are\navailable. These are the ones that have been widely used in open source over the\nyears:\n•Concurrent Versions System (CVS)\n•Apache Subversion\n•Git\n•As well as others that are used in particular niches (e.g., Bazaar, Mercurial)\nAlthough each has its advantages and disadvantages, the use of Git in the Linux build\nprocess (and projects based on Linux, such as the Android mobile environment), as\nwell as the availability of sites like github.com  and gitorious.org , give Git a massive\nmomentum over the others. I don’t have statistics, but I suspect the number of\nprojects in Git repositories probably exceeds the others combined. Several well-\nknown organizations using Git are listed on the Git home page.\nFor this reason, I have moved my public projects to GitHub; see http://github.com/\nIanDarwin . To download the projects and be able to get updates applied automati‐\ncally, use Git to download them. Options include the following:\n•The command-line Git client . If you are on any modern Unix or Linux system,\nGit is either included or available in your ports or packaging or developer tools,\nbut it can also be downloaded for MS Windows, Mac, Linux, and Solaris from the\nhome page under Downloads.\n•All modern IDEs have Git support built in (though IntelliJ doesn’t include Git\nitself; it relies on the command-line Git client, possibly because the main Java\nimplementation jgit  is owned by Eclipse).\n•Numerous standalone GUI clients .\n20 | Chapter 1: Getting Started: Compiling and Running Java\n•Even Continuous Integration servers such as Jenkins/Hudson (see Recipe 1.11 )\nhave plug-ins available for updating a project with Git (and other popular SCMs)\nbefore building them.\nY ou will want to have one or more of these Git clients at your disposal to download\nmy code examples. Y ou could instead download the code examples as ZIP archive\nfiles, but then you won’t get updates! Y ou can also view or download individual files\nfrom the GitHub page via a web browser.\nMake Versus Java Build Tools\nMake  is the original build tool from the 1970s, used in Unix and C/C++ development.\nMake and the Java-based tools each have advantages; I’ll try to compare them without\ntoo much bias.\nThe Java build tools work the same on all platforms, as much as possible. Make is\nrather platform-dependent; there is GNU Make, BSD Make, Xcode Make, Visual Stu‐\ndio Make, and several others, each with slightly different syntax.\nThat said, there are many Java build tools to choose from, including these:\n•Apache Ant\n•Apache Maven\n•Gradle\n•Apache Buildr\nMakefiles and Gradle build files are the shortest. Make just lets you list the commands\nyou want run and their dependencies. Buildr and Gradle each have their own lan‐\nguage (based on Ruby and Groovy, respectively). Maven uses XML, which is generally\nmore verbose but with a lot of sensible defaults and a standard, default workflow. Ant\nalso uses XML but makes you specify each task you want performed.\nMake runs faster for single tasks; most implementations are written in C. However,\nthe Java tools can run many Java tasks in a single JVM, such as the built-in Java com‐\npiler or .jar/.war/.tar/.zip  files—to the extent that it may be more efficient to run sev‐\neral Java compilations in one JVM process than to run the same compilations using\nMake. In other words, once the JVM that is running Ant/Maven/Gradle itself is up\nand running, it doesn’t take long at all to run the Java compiler and run the compiled\nclass. This is Java as it was meant to be!\nJava build tool files can do more for you. These tools automatically find all the *.java\nfiles in and under src/main/java . With make , you have to spell such things out.\nThe Java tools have special knowledge of CLASSPATH , making it easy to set a CLASS\nPATH  in various ways for compile time. Maven offers a scope of tests for classes and\n1.6 Downloading and Using the Code Examples | 21\nother files that will be on your CLASSPATH  only when running tests, for example. Y ou\nmay have to duplicate this in other ways—shell scripts or batch files—for using Make\nor for manually running or testing your application.\nMaven and Gradle also handle dependency management. Y ou simply list the API and\nversion that you want, and the tool finds it, downloads it over the internet, saves it in\na cache folder for future use, and adds it to your CLASSPATH  at the right time—all\nwithout writing any rules.\nGradle goes further yet and allows scripting logic in its configuration file. (Strictly\nspeaking, Ant and Maven do as well, but Gradle’s is much easier to use.)\nMake is simpler to extend but harder to do so portably. Y ou can write a one-line Make\nrule for getting a CVS archive from a remote site, but you may run into incompatibili‐\nties between GNU Make, BSD Make, Microsoft Make, and so on. There is a built-in\nAnt task for getting an archive from CVS using Ant; it was written as a Java source file\ninstead of just a series of command-line commands.\nMake has been around much longer. There are probably millions (literally) more\nmakefiles than Ant files. Non-Java developers have typically not heard of Ant; they\nalmost all use Make. Most non-Java open source projects use Make, except for pro‐\ngramming languages that provide their own build tool (e.g., Ruby provides Rake and\nThor, and Haskell provides Cabal).\nThe advantages of the Java tools make more sense on larger projects. Primarily, Make\nhas been used on the really large non-Java projects. For example, Make is used for tel‐\nephone switch source code, which consists of hundreds of thousands of source files\ntotaling tens or hundreds of millions of lines of source code. By contrast, Tomcat is\nabout 500,000 lines of code, and the JBoss Java EE server WildFly is about 800,000\nlines. Use of the Java tools is growing steadily, particularly now that most of the\nwidely used Java IDEs (IntelliJ, Eclipse, NetBeans, etc.) have interfaces to Ant, Maven,\nand/or Gradle. Effectively all Java open source projects use Maven; some still use Ant,\nor the newest kid on that block, Gradle.\nMake is included with most Unix and Unix-like systems and shipped with many Win‐\ndows IDEs. Ant and Maven and gradle are not included with any operating system\ndistribution that I know of, but they can be installed as packages on almost all sys‐\ntems, and both are available direct from Apache. Gradle installs from  http://\ngradle.org , and Buildr from the Apache website .\nTo sum up, although Make and the Java tools are good, new Java projects should use\none of the newer Java-based tools such as Maven or Gradle.\n22 | Chapter 1: Getting Started: Compiling and Running Java",18293
34-1.7 Automating Dependencies Compilation Testing and Deployment with Apache Maven.pdf,34-1.7 Automating Dependencies Compilation Testing and Deployment with Apache Maven,,0
35-Problem.pdf,35-Problem,,0
36-Solution.pdf,36-Solution,,0
37-Discussion.pdf,37-Discussion,"1.7 Automating Dependencies, Compilation, Testing, and\nDeployment with Apache Maven\nProblem\nY ou want a tool that does it all automatically: downloads your dependencies, com‐\npiles your code, compiles and runs your tests, packages the app, and installs or\ndeploys it.\nSolution\nUse Apache Maven.\nDiscussion\nMaven is a Java-centric build tool that includes a sophisticated, distributed depend‐\nency management system that also gives it rules for building application packages\nsuch as JAR, W AR, and EAR files and deploying them to an array of different targets.\nWhereas older build tools focus on the how, Maven files focus on the what , specifying\nwhat you want done.\nMaven is controlled by a file called pom.xml  (for Project Object Model). A sample\npom.xml  might look like this:\n<project  xmlns=""http://maven.apache.org/POM/4.0.0""\n  xmlns:xsi= ""http://www.w3.org/2001/XMLSchema-instance""\n  xsi:schemaLocation= ""http://maven.apache.org/POM/4.0.0\n                      http://maven.apache.org/xsd/maven-4.0.0.xsd"" >\n  <modelVersion> 4.0.0</modelVersion>\n  <groupId> com.example </groupId>\n  <artifactId> my-se-project </artifactId>\n  <version> 1.0-SNAPSHOT </version>\n  <packaging> jar</packaging>\n  <name>my-se-project </name>\n  <url>http://com.example/ </url>\n  <properties>\n    <project.build.sourceEncoding> UTF-8</project.build.sourceEncoding>\n  </properties>\n  <dependencies>\n    <dependency>\n      <groupId> junit</groupId>\n      <artifactId> junit</artifactId>\n      <version> 4.8.1</version>\n      <scope>test</scope>\n1.7 Automating Dependencies, Compilation, Testing, and Deployment with Apache Maven | 23\n    </dependency>\n  </dependencies>\n</project>\nThis specifies a project called my-se-project  (my standard-edition project) that will be\npackaged into a JAR file; it depends on the JUnit 4.x framework for unit testing (see\nRecipe 1.10 ) but only needs it for compiling and running tests. If I type mvn install  in\nthe directory with this POM, Maven will ensure that it has a copy of the given version\nof JUnit (and anything that JUnit depends on). Then it will compile everything (set‐\nting CLASSPATH and other options for the compiler), run any and all unit tests, and\nif they all pass, generate a JAR file for the program. It will then install it in my\npersonal  Maven repo (under ~/.m2/repository ) so that other Maven projects can\ndepend on my new project JAR file. Note that I haven’t had to tell Maven where the\nsource files live, nor how to compile them—this is all handled by sensible defaults,\nbased on a well-defined project structure. The program source is expected to be\nfound in src/main/java , and the tests in src/test/java ; if it’s a web application, the web\nroot is expected to be in src/main/webapp  by default. Of course, you can override\nthese settings.\nNote that even the preceding config file does not have to be, and was not, written by\nhand; Maven’s archetype generation rules let it build the starting version of any of\nseveral hundred types of projects. Here is how the file was created:\n$ mvn archetype:generate \\n    -DarchetypeGroupId=org.apache.maven.archetypes \\n    -DarchetypeArtifactId=maven-archetype-quickstart \\n    -DgroupId=com.example -DartifactId=my-se-project\n[INFO] Scanning for projects...\nDownloading: http://repo1.maven.org/maven2/org/apache/maven/plugins/\n    maven-deploy-plugin/2.5/maven-deploy-plugin-2.5.pom\n[several dozen or hundred lines of downloading POM files and Jar files...]\n[INFO] Generating project in Interactive mode\n[INFO] Archetype [org.apache.maven.archetypes:maven-archetype-quickstart:1.1]\n    found in catalog remote\n[INFO] Using property: groupId = com.example\n[INFO] Using property: artifactId = my-se-project\nDefine value for property 'version':  1.0-SNAPSHOT: :\n[INFO] Using property: package = com.example\nConfirm properties configuration:\ngroupId: com.example\nartifactId: my-se-project\nversion: 1.0-SNAPSHOT\npackage: com.example\n Y: : y\n[INFO] ------------------------------------------------------------------------\n[INFO] Using following parameters for creating project from Old (1.x) Archetype:\n    maven-archetype-quickstart:1.1\n[INFO] ------------------------------------------------------------------------\n[INFO] Parameter: groupId, Value: com.example\n24 | Chapter 1: Getting Started: Compiling and Running Java\n[INFO] Parameter: packageName, Value: com.example\n[INFO] Parameter: package, Value: com.example\n[INFO] Parameter: artifactId, Value: my-se-project\n[INFO] Parameter: basedir, Value: /private/tmp\n[INFO] Parameter: version, Value: 1.0-SNAPSHOT\n[INFO] project created from Old (1.x) Archetype in dir: /private/tmp/\n    my-se-project\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 6:38.051s\n[INFO] Finished at: Sun Jan 06 19:19:18 EST 2013\n[INFO] Final Memory: 7M/81M\n[INFO] ------------------------------------------------------------------------\nAlternately, you can do mvn archetype:generate  and select the default from a rather\nlong list of choices. The default is a quickstart Java archetype, which makes it easy to\nget started.\nThe IDEs (see Recipe 1.3 ) have support for Maven. For example, if you use Eclipse,\nM2Eclipse (m2e) is an Eclipse plug-in that will build your Eclipse project dependen‐\ncies from your POM file; this plug-in ships by default with current Java Developer\nbuilds of Eclipse. It is also available for some older releases; see the  Eclipse website  for\nplug-in details.\nA POM file can redefine any of the standard goals. Common Maven goals (prede‐\nfined by default to do something sensible) include the following:\nclean\nRemoves all generated artifacts\ncompile\nCompiles all source files\ntest\nCompiles and runs all unit tests\npackage\nBuilds the package\ninstall\nInstalls pom.xml  and the package into your local Maven repository for use by\nyour other projects\ndeploy\nTries to install the package (e.g., on an application server)\nMost of the steps implicitly invoke the previous ones. For example, package  will com‐\npile any missing .class  files and run the tests if that hasn’t already been done in this\nrun.\n1.7 Automating Dependencies, Compilation, Testing, and Deployment with Apache Maven | 25",6408
38-1.8 Automating Dependencies Compilation Testing and Deployment with Gradle.pdf,38-1.8 Automating Dependencies Compilation Testing and Deployment with Gradle,"There is an optional distributionManagement  element in the POM file or a -\nDaltDeploymentRepository  on the command line to specify an alternate deployment\nlocation. There are application-server–specific targets provided by the app server\nvendors; as a single example, with the WildFly Application Server (known as JBoss\nAS a decade or more ago), you would install some additional plug-in(s) as per their\ndocumentation and then deploy to the app server using\nmvn wildfly:deploy\ninstead of the regular deploy. Since I use this Maven incantation frequently, I have a\nshell alias or batch file mwd to automate even that.\nMaven pros and cons\nMaven can handle complex projects and is very configurable. I build the  darwinsys-\napi and javasrc  projects with Maven and let it handle finding dependencies, making\nthe download of the project source code smaller (actually, moving the download\noverhead to the servers of the projects themselves). The only real downsides to\nMaven are that it takes a while to get fully up to speed with it, and it can be hard to\ndiagnose when things go wrong. A good web search engine is your friend when\nthings fail.\nOne issue I fear is that a hacker could gain access to a project’s site and modify, or\ninstall a new version of, a POM. Maven automatically fetches updated POM versions.\nHowever, it does use hash signatures to verify that files have not been tampered with\nduring the download process, and all files to be uploaded must be signed with PGP/\nGPG, so an attacker would have to compromise both the upload account and the\nsigning keys. I am not aware of this ever having happened though.\nSee Also\nStart at http://maven.apache.org .\nMaven Central: Mapping the World of Java Software\nThere is an immense collection of software freely available to Maven users just for\nadding a <dependency>  element or “Maven Artifact” into your pom.xml . Y ou can\nsearch this repository at http://search.maven.org  or https://repository.sonatype.org/\nindex.html .\nFigure 1-5  shows a search for my darwinsys-api  project and the information it reveals.\nNote that the dependency  information listed there is all you need to have the library\nadded to your Maven project; just copy the Dependency Information section and\npaste it into the <dependencies>  of your POM, and you’re done! Because Maven\nCentral has become the definitive place to look for software, many other Java build\ntools piggyback on Maven Central. To accommodate these users, in turn, Maven\n26 | Chapter 1: Getting Started: Compiling and Running Java",2571
39-Problem.pdf,39-Problem,,0
40-See Also.pdf,40-See Also,"Central  offers to serve up the dependency information in a form that half a dozen\nother build tools can directly use in the same copy-and-paste fashion.\nWhen you get to the stage of having a useful open source project that others can build\nupon, you may, in turn, want to share it on Maven Central. The process is longer than\nbuilding for yourself but not onerous. Refer to this Maven guide  or the Sonatype OSS\nMaven Repository Usage Guide .\nFigure 1-5. Maven Central search results\n1.8 Automating Dependencies, Compilation, Testing, and\nDeployment with Gradle\nProblem\nY ou want a build tool that doesn’t make you use a lot of XML in your configuration\nfile.\nSolution\nUse Gradle’s simple build file format with configuration by convention for shorter\nbuild files and fast builds.\n1.8 Automating Dependencies, Compilation, Testing, and Deployment with Gradle | 27\nDiscussion\nGradle is the latest in the succession of build tools (Make, Ant, and Maven). Gradle\nbills itself as “the enterprise automation tool” and has integration with the other build\ntools and IDEs.\nUnlike the other Java-based tools, Gradle doesn’t use XML as its scripting language,\nbut rather a Domain-Specific Language (DSL) based on the JVM-based and Java-\nbased scripting language Groovy .\nY ou can install Gradle by downloading from the Gradle website , unpacking the ZIP ,\nand adding its bin subdirectory to your path.\nThen you can begin to use Gradle. Assuming you use the standard source directory\n(src/main/java , src/main/test ) that is shared by Maven and Gradle, among other tools,\nthe example build.gradle  file in Example 1-1  will build your app and run your unit\ntests.\nExample 1-1. Example build.gradle file\n# Simple Gradle Build for the Java-based DataVis project\napply plugin: 'java'\n# Set up mappings  for Eclipse project too\napply plugin: 'eclipse'\n# The version of Java to use\nsourceCompatibility  = 11\n# The version of my project\nversion = '1.0.3'\n# Configure  JAR file packaging\njar {\n    manifest  {\n        attributes  'Main-class' : 'com.somedomainnamehere.data.DataVis' ,\n        'Implementation-Version' : version\n    }\n}\n# optional  feature:  like -Dtesting =true but only when running tests (""test task"" )\ntest {\n    systemProperties  'testing' : 'true'\n}\nY ou can bootstrap the industry’s vast investment in Maven infrastructure by adding\nlines like these into your build.gradle :\n# Tell Gradle to look in Maven Central\nrepositories  {\n    mavenCentral ()\n}\n28 | Chapter 1: Getting Started: Compiling and Running Java",2573
41-1.9 Dealing with Deprecation Warnings.pdf,41-1.9 Dealing with Deprecation Warnings,,0
42-Problem.pdf,42-Problem,,0
43-Solution.pdf,43-Solution,,0
44-Discussion.pdf,44-Discussion,"# We need darwinsys -api for compiling  as well as JUnit for testing\ndependencies  {\n    compile group: 'com.darwinsys' , name: 'darwinsys-api' , version:  '1.0.3+'\n    testCompile  group: 'junit', name: 'junit', version:  '4.+'\n}\nSee Also\nThere is much more functionality in Gradle. Start at Gradle’s website , and see the\ndocumentation .\n1.9 Dealing with Deprecation Warnings\nProblem\nY our code used to compile cleanly, but now it gives deprecation warnings.\nSolution\nY ou must have blinked. Either live—dangerously—with the warnings or revise your\ncode to eliminate them.\nDiscussion\nEach new release of Java includes a lot of powerful new functionality, but at a price:\nduring the evolution of this new stuff, Java’s maintainers find some old stuff that\nwasn’t done right and shouldn’t be used anymore because they can’t really fix it. In the\nfirst major revision, for example, they realized that the java.util.Date  class had\nsome serious limitations with regard to internationalization. Accordingly, many of\nthe Date  class methods and constructors are marked “deprecated. ” According to the\nAmerican Heritage Dictionary , to deprecate something means to “express disapproval\nof; deplore. ” Java’s developers are therefore disapproving of the old way of doing\nthings. Try compiling this code:\nimport java.util.Date ;\n/** Demonstrate deprecation warning */\npublic class Deprec {\n    public static void main(String[] av) {\n        // Create a Date object for May 5, 1986\n        @SuppressWarnings (""deprecation"" )\n        // EXPECT DEPRECATION WARNING without @SuppressWarnings\n        Date d = new Date(86, 04, 05);\n        System.out.println(""Date is ""  + d);\n1.9 Dealing with Deprecation Warnings | 29\n    }\n}\nWhat happened? When I compiled it (prior to adding the @SuppressWarnings()\nannotation), I got this warning:\nC:\javasrc> javac Deprec.java\nNote: Deprec.java uses or overrides a deprecated API.  Recompile with\n""-deprecation"" for details.\n1 warning\nC:\javasrc>\nSo, we follow orders. For details, recompile with -deprecation  to see the additional\ndetails:\nC:\javasrc> javac -deprecation Deprec.java\nDeprec.java:10: warning: constructor Date(int,int,int) in class java.util.Date\nhas been deprecated\n                Date d = new Date(86, 04, 05);          // May 5, 1986\n                         ^\n1 warning\nC:\javasrc>\nThe warning is simple: the Date  constructor that takes three integer arguments has\nbeen deprecated. How do you fix it? The answer is, as in most questions of usage, to\nrefer to the javadoc documentation for the class. The introduction to the Date  page\nsays, in part:\nThe class Date  represents a specific instant in time, with millisecond precision.\nPrior to JDK 1.1, the class Date  had two additional functions. It allowed the interpreta‐\ntion of dates as year, month, day, hour, minute, and second values. It also allowed the\nformatting and parsing of date strings. Unfortunately, the API for these functions was\nnot amenable to internationalization. As of JDK 1.1, the  Calendar  class should be used\nto convert between dates and time fields and the DateFormat  class should be used to\nformat and parse date strings. The corresponding methods in Date  are deprecated.\nAnd more specifically, in the description of the three-integer constructor, the Date\njavadoc says:\nDate(int year, int month, int date)\nDeprecated. As of JDK version 1.1, replaced by Calendar.set(year + 1900 , month ,\ndate)  or GregorianCalendar(year + 1900 , month , date) .\nOf course, the older Date  class is replaced by LocalDate  and LocalDateTime  (see\nChapter 6 ), so you’ d only see that particular example in legacy code, but the principles\nof dealing with deprecation warnings matter, because many new releases of Java add\ndeprecation warnings to parts of the API that were previously “OK” to use.\nAs a general rule, when something has been deprecated, you should not use it in any\nnew code; and, when maintaining code, strive to eliminate the deprecation warnings.\n30 | Chapter 1: Getting Started: Compiling and Running Java",4113
45-See Also.pdf,45-See Also,,0
46-1.10 Maintaining Code Correctness with Unit Testing JUnit.pdf,46-1.10 Maintaining Code Correctness with Unit Testing JUnit,,0
47-Problem.pdf,47-Problem,,0
48-Solution.pdf,48-Solution,,0
49-Discussion.pdf,49-Discussion,"In addition to Date  (Java 8 includes a whole new date/time API; see Chapter 6 ), the\nmain areas of deprecation warnings in the standard API are the really ancient event\nhandling and some methods (a few of them important) in the Thread  class.\nY ou can also deprecate your own code, when you come up with a better way of doing\nthings. Put an @Deprecated  annotation immediately before the class or method you\nwish to deprecate and/or use a @deprecated  tag in a javadoc comment (see Recipe\n15.2). The javadoc comment allows you to explain the deprecation, whereas the\nannotation is easier for some tools to recognize because it is present at runtime (so\nyou can use Reflection; see Chapter 17 ).\nSee Also\nNumerous other tools perform extra checking on your Java code. See my Checking\nJava Programs  website.\n1.10 Maintaining Code Correctness with Unit Testing:\nJUnit\nProblem\nY ou don’t want to have to debug your code.\nSolution\nUse unit testing to validate each class as you develop it.\nDiscussion\nStopping to use a debugger is time-consuming, and finding a bug in released code is\nmuch worse! It’s better to test beforehand. The methodology of unit testing has been\naround for a long time; it is a tried-and-true means of getting your code tested in\nsmall blocks. Typically, in an OO language like Java, unit testing is applied to individ‐\nual classes, in contrast to system or integration testing where a complete slice or even\nthe entire application is tested.\nI have long been an advocate of this very basic testing methodology. Indeed, develop‐\ners of the software methodology known as Extreme Programming  (XP for short)\nadvocate  Test-Driven Development  (TDD): writing the unit tests before  you write the\ncode. They also advocate running your tests almost every time you build your appli‐\ncation. And they ask one good question: If you don’t have a test, how do you know your\ncode (still) works?  This group of unit-testing advocates has some well-known leaders,\nincluding Erich Gamma of Design Patterns  book fame and Kent Beck of eXtreme Pro‐\n1.10 Maintaining Code Correctness with Unit Testing: JUnit | 31\ngramming  book fame (both Addison-Wesley). I definitely go along with their advo‐\ncacy of unit testing.\nIndeed, many of my classes used to come with a “built-in” unit test. Classes that are\nnot main programs in their own right would often include a main  method that just\ntests out or at least exercises the functionality of the class. What surprised me is that,\nbefore encountering XP , I used to think I did this often, but an actual inspection of\ntwo projects indicated that only about a third of my classes had test cases, either\ninternally or externally. Clearly what is needed is a uniform methodology. That is\nprovided by JUnit.\nJUnit is a Java-centric methodology for providing test cases, and can be downloaded\nfor free . It is a very simple but useful testing tool. It is easy to use—you just write a\ntest class that has a series of methods and annotate them with @Test  (the older JUnit\n3.8 required you to have test methods’ names begin with test ). JUnit uses introspec‐\ntion (see Chapter 17 ) to find all these methods and then runs them for you. Exten‐\nsions to JUnit handle tasks as diverse as load testing and testing enterprise compo‐\nnents; the JUnit website provides links to these extensions. All modern IDEs provide\nbuilt-in support for generating and running JUnit tests.\nHow do you get started using JUnit? All that’s necessary is to write a test. Here I have\nwritten a simple test of my Person  class and placed it into a class called PersonTest\n(note the obvious naming pattern):\npublic class PersonTest  {\n    @Test\n    public void testNameConcat () {\n        Person p = new Person(""Ian"", ""Darwin"" );\n        String f = p.getFullName ();\n        assertEquals (""Name concatenation"" , ""Ian Darwin"" , f);\n    }\n}\nJUnit 4 has been around for ages and works well. JUnit 5 is only a few years old and\nhas some improvements. A simple test like this PersonTest  class will be the same in\nJUnit 4 or 5 (but with different imports). Using additional features, like setup meth‐\nods to be run before each test, requires different annotations between JUnit 4 and 5.\nTo show you running PersonTest  manually, I compile the test and invoke the\ncommand-line test harness TestRunner :\n32 | Chapter 1: Getting Started: Compiling and Running Java",4439
50-1.11 Maintaining Your Code with Continuous Integration.pdf,50-1.11 Maintaining Your Code with Continuous Integration,"$ javac PersonTest.java\n$ java -classpath .:junit4.x.x.jar junit.textui.TestRunner testing.PersonTest\n.\nTime: 0.188\nOK (1 tests)\n$\nIn practice, running tests that way is incredibly tedious, so I just put my tests in the\nstandard directory structure (i.e., src/test/java/ ) with the same package as the code\nbeing tested and run Maven (see Recipe 1.7 ), which will automatically compile and\nrun all the unit tests and will halt the build if any test fails, every time you try to build,\npackage, or deploy your application . Gradle will do so too.\nAll modern IDEs provide built-in support for running JUnit tests; in Eclipse, you can\nright-click a project in the Package Explorer and select Run As→Unit Test to have it\nfind and run all the JUnit tests in the entire project. The MoreUnit  plugin (free in the\nEclipse Marketplace) aims to simplify creation and running of tests.\nThe Hamcrest matchers  allow you to write more expressive tests at the cost of an addi‐\ntional download. Support for them is built into JUnit 4 with the assertThat  static\nmethod, but you need to download the matchers from Hamcrest  or via the Maven\nartifact.\nHere’s an example of using the Hamcrest matchers:\npublic class HamcrestDemo  {\n    @Test\n    public void testNameConcat () {\n        Person p = new Person(""Ian"", ""Darwin"" );\n        String f = p.getFullName ();\n        assertThat (f, containsString (""Ian""));\n        assertThat (f, equalTo(""Ian Darwin"" ));\n        assertThat (f, not(containsString (""/""))); // contrived, to show syntax\n    }\n}\nSee Also\nJUnit offers considerable documentation of its own; download it from the website lis‐\nted earlier.\nAn alternative unit test framework for Java is TestNG ; it got some early traction by\nadopting features such as Java annotations before JUnit did; but since JUnit got with\nthe annotations program, it has remained the dominant package for Java unit testing.\nAnother package of interest is AssertJ , which appears to offer similar power to the\ncombination of JUnit with Hamcrest.\n1.10 Maintaining Code Correctness with Unit Testing: JUnit | 33",2118
51-Problem.pdf,51-Problem,,0
52-Solution.pdf,52-Solution,,0
53-Discussion.pdf,53-Discussion,"Finally, one often needs to create substitute objects for use by the class being tested\n(the dependencies of the class under test). While you can code these by hand, in gen‐\neral I encourage use of packages such as Mockito , which can generate mock objects\ndynamically, have these mocks provide fixed return values, verify that the dependen‐\ncies were called correctly, and so on.\nRemember: test early and often!  \n1.11 Maintaining Your Code with Continuous Integration\nProblem\nY ou want to be sure that your entire code base compiles and passes its tests\nperiodically.\nSolution\nUse a Continuous Integration server such as Jenkins/Hudson.\nDiscussion\nIf you haven’t previously used Continuous Integration, you are going to wonder how\nyou got along without it. CI is simply the practice of having all developers on a\nproject periodically integrate  (e.g., commit) their changes into a single master copy of\nthe project’s source and then building and testing the project to make sure it still\nworks and passes its tests. This might be a few times a day, or every few days, but\nshould not be more than that or else the integration will likely run into larger hurdles\nwhere multiple developers have modified the same file.\nBut it’s not just big projects that benefit from CI. Even on a one-person project, it’s\ngreat to have a single button you can click that will check out the latest version of\neverything, compile it, link or package it, run all the automated tests, and give a red\nor green pass/fail indicator. Better yet, it can do this automatically every day or even\non every commit to the master branch.\nIt’s not just code-based projects that benefit from CI. If you have a number of small\nwebsites, putting them all under CI control is one of several important steps toward\ndeveloping an automated, DevOps culture around website deployment and\nmanagement.\nIf you are new to the idea of CI, I can do no better than to plead with you to read \nMartin Fowler’s insightful (as ever) paper on the topic . One of the key points is to\nautomate both the management  of the code and all the other artifacts needed to build\n34 | Chapter 1: Getting Started: Compiling and Running Java\n1If the deployment or build includes a step like “Get Smith to process file X on his desktop and copy to the\nserver, ” you probably don’t quite get the notion of automated testing.\n2Jenkins  and Hudson  began as Hudson, largely written by Kohsuke Kawaguchi while working for Sun Micro‐\nsystems. There was later a cultural spat that resulted in Jenkins splitting off from Hudson, creating a new fork\nof the project. Kohsuke works on the half now known as Jenkins. I’ll just use the name Jenkins, because that’s\nthe one I use, and because it takes too long to say “Jenkins/Hudson” all the time. But almost everything here\napplies to Hudson as well.your project, and to automate the actual process of building  it, possibly using one of\nthe build tools discussed earlier in this chapter.1\nThere are many CI servers, both free and commercial. In the open source world,\nCruiseControl  and Jenkins/Hudson2 are among the best known CI servers that you\ndeploy yourself. There are also hosted solutions such as Travis CI , TeamCity , or Cir‐\ncleCI . These hosted ones eliminate the need for setting up and running your own CI\nserver. They also tend to have their configuration right in your repo ( travis.yml  etc.)\nso deployment to them is simplified.\nJenkins runs as a web application, either inside a Jakarta EE server or in its own\nstandalone web server. Once it’s started, you can use any standard web browser as its\nuser interface. Installing and starting Jenkins can be as simple as unpacking a distri‐\nbution and invoking it as follows:\njava -jar jenkins.war\nThis will start up its own tiny web server. If you do that, be sure to configure security\nif your machine is reachable from the internet!\nMany people find it more secure to run Jenkins in a full-function Java EE or Java web\nserver; anything from Tomcat to JBoss to WebSphere or Weblogic will do the job and\nlet you impose additional security constraints.\nOnce Jenkins is up and running and you have enabled security and are logged in on\nan account with sufficient privilege, you can create  jobs. A job usually corresponds to\none project, both in terms of origin (one source code checkout) and in terms of\nresults (one .war  file, one executable, one library, one whatever). Setting up a project\nis as simple as clicking the New Job button at the top left of the dashboard, as shown\nin Figure 1-6 .\nY ou can fill in the first few pieces of information: the project’s name and a brief\ndescription. Note that each and every input field has a question mark icon beside it,\nwhich will give you hints as you go along. Don’t be afraid to peek at these hints!\nFigure 1-7  shows the first few steps of setting up a new job.\nIn the next few sections of the form, Jenkins uses dynamic HTML to make entry\nfields appear based on what you’ve checked. My demo project “TooSmallToFail” starts\noff with no Source Code Management (SCM) repository, but your real project is\n1.11 Maintaining Your Code with Continuous Integration | 35\nprobably already in Git, Subversion, or ome other SCM. Don’t worry if yours is not\nlisted; there are hundreds of plug-ins to handle almost any SCM. Once you’ve chosen\nyour SCM, you will enter the parameters to fetch the project’s source from that SCM\nrepository, using text fields that ask for the specifics needed for that SCM: a URL for\nGit, a CVSROOT for CVS, and so on.\nFigure 1-6. The dashboard in Jenkins\nFigure 1-7. Creating a new job in Jenkins\nY ou also have to tell Jenkins when  and how to build (and package, test, deploy…) your\nproject. For the when , you have several choices such as building it after another Jen‐\nkins project, building it every so often based on a cron-like schedule, or based on\npolling the SCM to see if anything has changed (using the same cron-like scheduler).\nIf your project is at GitHub (not just a local Git server), or some other SCMs, you can\nhave the project built whenever somebody pushes changes up to the repository. It’s all\na matter of finding the right plug-ins and following the documentation for them.\n36 | Chapter 1: Getting Started: Compiling and Running Java\nThen we have the how, or the build process. Again, a few build types are included\nwith Jenkins, and many more are available as plug-ins: I’ve used Apache Maven, Gra‐\ndle, the traditional Unix make  tool, and even shell or command lines. As before, text\nfields specific to your chosen tool will appear once you select the tool. In the toy\nexample, TooSmallToFail , I just use the shell command /bin/false  (which should be\npresent on any Unix or Linux system) to ensure that the project does, in fact, fail to\nbuild, just so you can see what that looks like.\nY ou can have zero or more build steps; just keep clicking the Add button and add\nadditional ones, as shown in Figure 1-8 .\nFigure 1-8. Configuration  for SCM and adding build steps in Jenkins\nOnce you think you’ve entered all the necessary information, click the Save button at\nthe bottom of the page, and you’ll go back to the project’s main page. Here you can\nclick the funny little Build Now icon at the far left to initiate a build right away. Or if\nyou have set up build triggers, you could wait until they kick in; but then again,\nwouldn’t you rather know right away whether you’ve got it just right? Figure 1-9\nshows the build starting.\nShould a job fail to build, you get a red ball instead of a green one. Actually, a success‐\nful build shows a blue ball by default (the go bulb in Japanese traffic lights, where\nKohsuke lives, is blue rather than green), but most people outside Japan prefer green\nfor success, so the optional Green Balls plug-in is often one of the first to be added to\na new installation.\nBeside the red or green ball, you will see a weather report ranging from sunny (the\nlast several builds have succeeded) to cloudy, rainy, or stormy (no recent builds have\nsucceeded).\n1.11 Maintaining Your Code with Continuous Integration | 37",8194
54-1.12 Getting Readable Stack Traces.pdf,54-1.12 Getting Readable Stack Traces,,0
55-Solution.pdf,55-Solution,"Click the link to the project that failed, and then the link to Console Output, and fig‐\nure out what went wrong. The usual workflow is then to make changes to the project,\ncommit/push them to the source code repository, and run the Jenkins build again.\nFigure 1-9. After  a new job is added in Jenkins\nThere are hundreds  of optional plug-ins for Jenkins. To make your life easier, almost\nall of them can be installed by clicking the Manage Jenkins link and then going to\nManage Plug-ins. The Available tab lists all the ones that are available from Jen‐\nkins.org; you just need to click the checkbox beside the ones you want, and click\nApply. Y ou can also find updates there. If your plug-in addtion or upgrade requires a\nrestart, you’ll see a yellow ball and words to that effect; otherwise you should see a\ngreen (or blue) ball indicating plug-in success. Y ou can also see the list of plug-ins\ndirectly on the web .\nI mentioned that Jenkins began life under the name Hudson. The Hudson project still\nexists and is hosted at the Eclipse website. Last I checked, both projects had main‐\ntained plug-in compatibility, so many or most plug-ins from one can be used with the\nother. In fact, the most popular plug-ins appear in the Available tab of both, and most\nof what’s said in this recipe about Jenkins applies equally to Hudson. If you use a dif‐\nferent CI system, you’ll need to check that system’s documentation, but the concepts\nand the benefits will be similar.\n1.12 Getting Readable Stack Traces\nProblem\nY ou’re getting an exception stack trace at runtime, but most of the important parts\ndon’t have line numbers.\n38 | Chapter 1: Getting Started: Compiling and Running Java",1707
56-Discussion.pdf,56-Discussion,,0
57-1.13 Finding More Java Source Code.pdf,57-1.13 Finding More Java Source Code,,0
58-Problem.pdf,58-Problem,,0
59-Solution.pdf,59-Solution,,0
60-1.14 Finding Runnable Java Libraries.pdf,60-1.14 Finding Runnable Java Libraries,"Solution\nBe sure you have compiled with debugging enabled.\nDiscussion\nWhen a Java program throws an exception, the exception propagates up the call stack\nuntil there is a  catch  clause that matches it. If none is found, the Java interpreter pro‐\ngram that invoked your main()  method catches the exception and prints a stack\ntraceback showing all the method calls that got from the top of the program to the\nplace where the exception was thrown. Y ou can print this traceback yourself in any\ncatch  clause: the Throwable  class has several overloads of the method called print\nStackTrace() .\nThe traceback includes line numbers only if they were compiled in. When using\njavac , this is the default. If you add the -g option, javac  will also include local variable\nnames and other information in the compiled code, which will make for better\ndebugging information in the event of a crash.\n1.13 Finding More Java Source Code\nProblem\nY ou want to build a large application and need to minimize coding, avoiding the “Not\nInvented Here” syndrome.\nSolution\nUse the Source, Luke. There are thousands of Java apps, frameworks, and libraries\navailable in open source.\nDiscussion\nJava source code is everywhere. As mentioned earlier, all the code examples from this\nbook can be downloaded: see Recipe 1.6 .\nAnother valuable resource is the source code for the Java API. Y ou may not have real‐\nized it, but the source code for all the public parts of the Java API are included with\neach release of the Java Development Kit. Want to know how java.util.ArrayList\nactually works? Y ou have the source code. Got a problem making a JTable  behave?\nThe standard JDK includes the source for all the public classes! Look for a file called\nsrc.zip  or src.jar ; some versions unzip this and some do not.\nIf that’s not enough, you can get the source for the whole JDK for free over the inter‐\nnet, either via the Mercurial source code librarian at openjdk.java.net  or from the Git\n1.13 Finding More Java Source Code | 39",2035
61-Problem.pdf,61-Problem,,0
62-Solution.pdf,62-Solution,,0
63-Discussion.pdf,63-Discussion,"mirror at AdoptOpenJDK at github.com . This includes the source for the public and\nnonpublic parts of the API, as well as the compiler (written in Java) and a large body\nof code written in C/C++ (the runtime itself and the interfaces to the native library).\nFor example, java.io.Reader  has a method called read() , which reads bytes of data\nfrom a file or network connection. There is a version of this written in C for each\noperating system because it calls down to the read()  system call for Unix, Windows,\nmacOS, or whatever. The JDK source kit includes the source for all this stuff.\n1.14 Finding Runnable Java Libraries\nProblem\nY ou want to reuse a published library rather than reinventing a well-known solution\nto your problem at hand.\nSolution\nUse the internet to find reusable software.\nDiscussion\nAlthough most of this book is about writing Java code, this recipe is about not writing\ncode, but about using code written by others. There are hundreds of good frame‐\nworks to add to your Java application—why reinvent the flat tire when you can buy a\nperfectly round one? Many of these frameworks have been around for years and have\nbecome well rounded by feedback from users.\nWhat, though, is the difference between a library and a framework? It’s sometimes a\nbit vague, but in general, a framework is a program with holes that you fill in,\nwhereas a library is code you call. It is roughly the difference between building a car\nby buying a car almost complete but with no engine and building a car by buying all\nthe pieces and bolting them together yourself.\nWhen considering using a third-party framework, there are many choices and issues\nto consider. One is cost, which gets into the issue of open source versus closed source.\nMost open source tools can be downloaded for free and used, either without any con‐\nditions or with conditions that you must comply with. There is not the space here to\ndiscuss these licensing issues, so I will refer you to Understanding Open Source and\nFree Software  Licensing  (O’Reilly).\nMuch open source software is available in compiled library form on Maven Central,\nas discussed in “Maven Central: Mapping the World of Java Software” on page 26 .\n40 | Chapter 1: Getting Started: Compiling and Running Java\nSome well-known collections of open source frameworks and libraries for Java are lis‐\nted in Table 1-5 . Most of the projects on these sites are curated—that is, judged and\nfound worthy—by some sort of community process.\nTable 1-5. Reputable open source Java collections\nOrganization URL Notes\nApache Software Foundation http://projects.apache.org Not just a web server!\nEclipse Software Foundation https://eclipse.org/projects Home of IDE and of Jakarta EE\nSpring Framework http://spring.io/projects Home to a dozen frameworks: Spring IOC (DI\nfactory), Spring MVC (web), more\nJBoss community https://redhatofficial.github.io/ Lists half a dozen of their projects, plus a\nlong list of current open source projects they\nuse and/or support.\nCodehaus  — See footnotea\na Codehaus itself went offline  a few years ago. As of 2019, the domain is owned by the Apache Software Foundation but does\nnot respond to browser requests. There is also a Codehaus account on github  holding some of the projects that were\npreviously on Codehaus, some active and some not. See this article  for more on the history of Codehaus.\nThere are also a variety of open source code repositories, which are not curated—\nanybody who signs up can create a project there, regardless of the existing commu‐\nnity size (if any). Sites like this that are successful accumulate too many projects to\nhave a single page listing them—you have to search. Most are not specific to Java.\nTable 1-6  shows some of the open source code repos.\nTable 1-6. Open source code repositories\nName URL Notes\nSourceforge.net https://sourceforge.net/ One of the oldest\nGitHub http://github.com/ “Social Coding”; probably most heavily used, now owned by Microsoft\nBitbucket https://bitbucket.org/ Public and private repos; free and paid plans\nGitLab https://gitlab.org/ Public and private repos; free and paid plans\nMaven Central https://search.maven.org/ Has compiled jar, source jar and javadoc jar for each project\nI’m not trying to disparage these repositories—indeed, the collection of demo pro‐\ngrams for this book is hosted on GitHub. I’m only saying that you have to know what\nyou’re looking for and exercise a bit of care before deciding on a framework. Is there\na community around it, or is it a dead end?\nI maintain a small Java site  that may be of value. It includes a listing of Java resources\nand material related to this book.\nFor the Java enterprise or web tier, there are two main frameworks that also provide\ndependency injection: the first is JavaServer Faces (JSF) and CDI, and the second is\n1.14 Finding Runnable Java Libraries | 41\nthe Spring Framework SpringMVC package. JSF and the built-in CDI (Contexts and\nDependency Injection) provides DI as well as some additional contexts, such as a\nvery useful Web Conversation context that holds objects across multiple web page\ninteractions. The Spring Framework provides dependency injection and the\nSpringMVC web-tier helper classes. Table 1-7  shows some web tier resources. Spring\nMVC and JSF are far from the only web frameworks; the list in Table 1-7  includes\nmany others, which may be a better fit for your application. Y ou have to decide!\nTable 1-7. Web tier resources\nName URL Notes\nIan’s List of 100 Java Web\nFrameworkshttp://darwinsys.com/jwf/\nJSF http://www.oracle.com/technetwork/java/javaee/overview/ Java EE standard technology\nfor web pages\nBecause JSF is a component-based framework, there are many add-on components\nthat will make your JSF-based website much more capable (and better looking) than\nthe default JSF components. Table 1-8  shows some of the JSF add-on libraries.\nTable 1-8. JSF add-on libraries\nName URL Notes\nBootsFaces https://bootsfaces.net/ Combines BootStrap with JSF\nButterFaces http://butterfaces.org/ Rich components library\nICEfaces http://icefaces.org/ Rich components library\nOpenFaces http://openfaces.org/ Rich components library\nPrimeFaces http://primefaces.org/ Rich components library\nRichFaces http://richfaces.org/ Rich components; no longer maintained\nApache DeltaSpike http://deltaspike.apache.org/ Numerous code add-ons for JSF\nJSFUnit http://www.jboss.org/jsfunit/ JUnit Testing for JSF\nOmniFaces http://omnifaces.org/ JSF Utilities add-on\nThere are frameworks and libraries for almost everything these days. If my lists don’t\nlead you to what you need, a web search probably will. Try not to reinvent the flat\ntire!\nAs with all free software, be sure that you understand the ramifications of the various\nlicensing schemes. Code covered by the GPL, for example, automatically transfers the\nGPL to any code that uses even a small part of it. Consult a lawyer. Y our mileage may\nvary. Despite these caveats, the source code is an invaluable resource to the person\nwho wants to learn more Java.\n42 | Chapter 1: Getting Started: Compiling and Running Java",7181
64-Chapter 2. Interacting with the Environment.pdf,64-Chapter 2. Interacting with the Environment,,0
65-2.0 Introduction.pdf,65-2.0 Introduction,,0
66-2.1 Getting Environment Variables.pdf,66-2.1 Getting Environment Variables,,0
67-Problem.pdf,67-Problem,,0
68-Solution.pdf,68-Solution,,0
69-2.2 Getting Information from System Properties.pdf,69-2.2 Getting Information from System Properties,"CHAPTER 2\nInteracting with the Environment\n2.0 Introduction\nThis chapter describes how your Java program can deal with its immediate surround‐\nings with what we call the runtime environment. In one sense, everything you do in a\nJava program using almost any Java API involves the environment. Here we focus\nmore narrowly on things that directly surround your program. Along the way we’ll be\nintroduced to the System  class, which knows a lot about your particular system.\nTwo other runtime classes deserve brief mention. The first, java.lang.Runtime , lies\nbehind many of the methods in the System  class. System.exit() , for example, just\ncalls  Runtime.exit() . Runtime  is technically part of the environment, but the only\ntime we use it directly is to run other programs, which is covered in Recipe 18.1 .\n2.1 Getting Environment Variables\nProblem\nY ou want to get the value of environment variables from within your Java program.\nSolution\nUse System.getenv() .\nDiscussion\nThe seventh edition of Unix, released in 1979, had a new feature known as environ‐\nment variables. Environment variables are in all modern Unix systems (including\nmacOS) and in most later command-line systems, such as the DOS or Command\n43",1237
70-Solution.pdf,70-Solution,"Prompt in Windows, but they are not in some older platforms or other Java runtimes.\nEnvironment variables are commonly used for customizing an individual computer\nuser’s runtime environment, hence the name. To take one familiar example, on Unix\nor DOS the environment variable PATH  determines where the system looks for exe‐\ncutable programs. So, of course people want to know how they access environment\nvariables from their Java program.\nThe answer is that you can do this in all modern versions of Java, but you should\nexercise caution in depending on being able to specify environment variables because\nsome rare operating systems may not provide them. That said, it’s unlikely you’ll run\ninto such a system because all “standard” desktop systems provide them at present.\nIn some ancient versions of Java, System.getenv()  was deprecated and/or just didn’t\nwork. Nowadays the getenv()  method is no longer deprecated, though it still carries\nthe warning that system properties (see Recipe 2.2 ) should be used instead. Even\namong systems that support environment variables, their names are case sensitive on\nsome platforms and case insensitive on others. The code in Example 2-1  is a short\nprogram that uses the getenv()  method.\nExample 2-1. main/src/main/java/environ/GetEnv.java\npublic class GetEnv {\n    public static void main(String[] argv) {\n        System.out.println(""System.getenv(\""PATH\"") = ""  + System.getenv(""PATH""));\n    }\n}\nRunning this code will produce output similar to the following:\nC:\javasrc> java environ.GetEnv\nSystem.getenv(""PATH"") = C:\windows\bin;c:\jdk1.8\bin;c:\documents\n    and settings\ian\bin\nC:\javasrc>\nThe no-argument form of the method System.getenv()  returns all the environment\nvariables in the form of an immutable String Map . Y ou can iterate through this map\nand access all the user’s settings or retrieve multiple environment settings.\nBoth forms of getenv()  require you to have permissions to access the environment,\nso they typically do not work in restricted environments such as applets.\n2.2 Getting Information from System Properties\nProblem\nY ou need to get information from the system properties.\n44 | Chapter 2: Interacting with the Environment",2240
71-See Also.pdf,71-See Also,"Solution\nUse System.getProperty()  or System.getProperties() .\nDiscussion\nWhat is a property  anyway? A property is just a name and value pair stored in a\njava.util.Properties  object, which we discuss more fully in Recipe 7.10 .\nThe System.Properties  object controls and describes the Java runtime. The System\nclass has a static Properties  member whose content is the merger of operating sys‐\ntem specifics ( os.name , for example), system and user tailoring ( java.class.path ),\nand properties defined on the command line (as we’ll see in a moment). Note that the\nuse of periods in these names (like os.arch , os.version , java.class.path , and\njava.lang.version ) makes it look as though there is a hierarchical relationship simi‐\nlar to that for package/class names. The Properties  class, however, imposes no such\nrelationships: each key is just a string, and dots are not special.\nTo view all the defined system properties, you can iterate through the output of call‐\ning System.getProperties()  as in Example 2-2 .\nExample 2-2. jshell System.getProperties()\njshell> System.getProperties ().forEach((k,v) -> System.out.println(k + ""->"" +v))\nawt.toolkit->sun.awt.X11.XToolkit\njava.specification .version->11\nsun.cpu.isalist->\nsun.jnu.encoding ->UTF-8\njava.class.path->.\njava.vm.vendor->Oracle Corporation\nsun.arch.data.model->64\njava.vendor.url->http://java.oracle.com/\nuser.timezone ->\nos.name->OpenBSD\njava.vm.specification .version->11\n... many more ...\njshell>\nRemember that properties whose names begin with “sun” are unsupported and sub‐\nject to change.\nTo retrieve one system-provided property, use System.getProperty(propName) . If I\njust wanted to find out if the System Properties  had a property named ""pen\ncil_color"" , I could say:\n        String sysColor  = System.getProperty (""pencil_color"" );\n2.2 Getting Information from System Properties | 45",1903
72-2.3 Dealing with Code That Depends on the Java Version or the Operating System.pdf,72-2.3 Dealing with Code That Depends on the Java Version or the Operating System,,0
73-Solution.pdf,73-Solution,"But what does that return? Surely Java isn’t clever enough to know about everybody’s\nfavorite pencil color? Right you are! But we can easily tell Java about our pencil color\n(or anything else we want to tell it) using the -D argument.\nWhen starting a Java runtime, you can define a value in the system properties object\nusing a -D option. Its argument must have a name, an equals sign, and a value, which\nare parsed the same way as in a properties file (see Recipe 7.10 ). Y ou can have more\nthan one -D definition between the java  command and your class name on the com‐\nmand line. At the Unix or Windows command line, type:\njava -D""pencil_color=Deep Sea Green"" environ.SysPropDemo\nWhen running this under an IDE, put the variable’s name and value in the appropri‐\nate dialog box, for example, in Eclipse’s Run Configuration dialog under Program\nArguments. Y ou can also set environment variables and system properties using the\nbuild tools (Maven, Gradle, etc.).\nThe SysPropDemo  program has code to extract just one or a few properties, so you can\nrun it like this:\n$ java environ.SysPropDemo os.arch\nos.arch = x86\nIf you invoke the SysPropDemo  program with no arguments, it outputs the same\ninformation as the jshell  fragment in Example 2-2 .\nWhich reminds me—this is a good time to mention system-dependent code. Recipe\n2.3 talks about OS-dependent code and release-dependent code.\nSee Also\nRecipe 7.10  lists more details on using and naming your own Properties  files. The\njavadoc page for java.util.Properties  lists the exact rules used in the load()\nmethod, as well as other details.\n2.3 Dealing with Code That Depends on the Java Version\nor the Operating System\nProblem\nY ou need to write code that adapts to the underlying operating system.\n46 | Chapter 2: Interacting with the Environment",1833
74-Discussion.pdf,74-Discussion,"Solution\nY ou can use System.Properties  to find out the Java version and the operating sys‐\ntem, various features in the File  class to find out some platform-dependent features,\nand java.awt.TaskBar  to see if you can use the system-dependent Taskbar or Dock.\nDiscussion\nSome things depend on the version of Java you are running. Use System.getProp\nerty()  with an argument of java.specification.version .\nAlternatively, and with greater generality, you may want to test for the presence or\nabsence of particular classes. One way to do this is with Class.forName(""class"")\n(see Chapter 17 ), which throws an exception if the class cannot be loaded—a good\nindication that it’s not present in the runtime’s library. Example 2-3  shows code for\nthis, from an application wanting to find out whether the common Swing UI compo‐\nnents are available. The javadoc for the standard classes reports the version of the\nJDK in which this class first appeared, under the heading “Since. ” If there is no such\nheading, it normally means that the class has been present since the beginnings of\nJava:\nExample 2-3. main/src/main/java/starting/CheckForSwing.java\npublic class CheckForSwing  {\n    public static void main(String[] args) {\n        try {\n            Class.forName(""javax.swing.JButton"" );\n        } catch (ClassNotFoundException  e) {\n            String failure =\n                ""Sorry, but this version of MyApp needs \n""  +\n                ""a Java Runtime with JFC/Swing components\n""  +\n                ""having the final names (javax.swing.*)"" ;\n            // Better to make something appear in the GUI. Either a\n            // JOptionPane, or: myPanel.add(new Label(failure));\n            System.err.println(failure);\n        }\n        // No need to print anything here - the GUI should work...\n    }\n}\nIt’s important to distinguish between testing this code at compile time and at runtime.\nIn both cases, it must be compiled on a system that includes the classes you are test‐\ning for: JDK >= 1.1 and Swing, respectively. These tests are only attempts to help the\npoor backwater Java runtime user trying to run your up-to-date application. The goal\nis to provide this user with a message more meaningful than the simple “class not\nfound” error that the runtime gives. It’s also important to note that this test becomes\nunreachable if you write it inside any code that depends on the code you are testing.\n2.3 Dealing with Code That Depends on the Java Version or the Operating System | 47\n1When compiling strings for use on Windows, remember to double them because \ is an escape character in\nmost places other than the MS-DOS command line: String rootDir = ""C:\\""; .Put the test early in the main flow of your application, before any GUI objects are\nconstructed. Otherwise the code just sits there wasting space on newer runtimes and\nnever gets run on Java systems that don’t include Swing. Obviously this is a very early\nexample, but you can use the same technique to test for any runtime feature added at\nany stage of Java’s evolution (see Appendix A  for an outline of the features added in\neach release of Java). Y ou can also use this technique to determine whether a needed\nthird-party library has been successfully added to your CLASSPATH.\nAlso, although Java is designed to be portable, some things aren’t. These include such\nvariables as the filename separator. Everybody on Unix knows that the filename sepa‐\nrator is a slash character (/) and that a backward slash, or backslash (\), is an escape\ncharacter. Back in the late 1970s, a group at Microsoft was actually working on Unix\n—their version was called Xenix, later taken over by SCO—and the people working\non DOS saw and liked the Unix filesystem model. The earliest versions of MS-DOS\ndidn’t have directories; it just had user numbers like the system it was a clone of, Digi‐\ntal Research CP/M (itself a clone of various other systems). So the Microsoft develop‐\ners set out to clone the Unix filesystem organization. Unfortunately, MS-DOS had\nalready committed the slash character for use as an option delimiter, for which Unix\nhad used a dash ( -); and the PATH  separator (:) was also used as a drive letter delim‐\niter, as in C: or A:. So we now have commands like those shown in Table 2-1 .\nTable 2-1. Directory listing commands\nSystem Directory list command Meaning Example PATH setting\nUnix ls -R / Recursive listing of /, the top-level directory PATH=/bin:/usr/bin\nDOS dir/s \ Directory with subdirectories option (i.e., recursive) of \, the\ntop-level directory (but only of the current drive)PATH=C:\windows;D:\n\mybin\nWhere does this get us? If we are going to generate filenames in Java, we may need to\nknow whether to put a / or a \ or some other character. Java has two solutions to this.\nFirst, when moving between Unix and Microsoft systems, at least, it is permissive :\neither / or \ can be used,1 and the code that deals with the operating system sorts it\nout. Second, and more generally, Java makes the platform-specific information avail‐\nable in a platform-independent way. For the file separator (and also the PATH  separa‐\ntor), the java.io.File  class makes available some static variables containing this\ninformation. Because the File  class manages platform-dependent information, it\nmakes sense to anchor this information here. The variables are shown in Table 2-2 .\n48 | Chapter 2: Interacting with the Environment\nTable 2-2. Table 2-2. File properties\nName Type Meaning\nseparator static String The system-dependent filename  separator character (e.g., / or \)\nseparatorChar static char The system-dependent filename  separator character (e.g., / or \)\npathSeparator static String The system-dependent path separator character, represented as a\nstring for convenience\npathSeparatorChar static char The system-dependent path separator character\nBoth filename and path separators are normally characters, but they are also available\nin String  form for convenience.\nA second, more general, mechanism is the System  Properties  object mentioned in\nRecipe 2.2 . Y ou can use this to determine the operating system you are running on.\nHere is code that simply lists the system properties; it can be informative to run this\non several different implementations:\npublic class SysPropDemo  {\n    public static void main(String[] argv) throws IOException  {\n        if (argv.length == 0)\n            // tag::sysprops[]\n            System.getProperties ().list(System.out);\n            // end::sysprops[]\n        else {\n            for (String s : argv) {\n                System.out.println(s + "" = "" +\n                    System.getProperty (s));\n            }\n        }\n    }\n}\nSome OSes, for example, provide a mechanism called the null device that can be used\nto discard output (typically used for timing purposes). Here is code that asks the sys‐\ntem properties for the os.name  and uses it to make up a name that can be used for\ndiscarding data (if no null device is known for the given platform, we return the name\njnk, which means that on such platforms, we’ll occasionally create, well, junk files; I\njust remove these files when I stumble across them):\npackage com.darwinsys .lang;\nimport java.io.File ;\n/** Some things that are system-dependent.\n * All methods are static.\n * @author Ian Darwin\n */\npublic class SysDep {\n2.3 Dealing with Code That Depends on the Java Version or the Operating System | 49\n    final static String UNIX_NULL_DEV  = ""/dev/null"" ;\n    final static String WINDOWS_NULL_DEV  = ""NUL:"";\n    final static String FAKE_NULL_DEV  = ""jnk"";\n    /** Return the name of the null device on platforms which support it,\n     * or ""jnk"" (to create an obviously well-named temp file) otherwise.\n     * @return The name to use for output.\n     */\n    public static String getDevNull () {\n        if (new File(UNIX_NULL_DEV ).exists()) {     \n            return UNIX_NULL_DEV ;\n        }\n        String sys = System.getProperty (""os.name"" ); \n        if (sys==null) {                            \n            return FAKE_NULL_DEV ;\n        }\n        if (sys.startsWith (""Windows"" )) {            \n            return WINDOWS_NULL_DEV ;\n        }\n        return FAKE_NULL_DEV ;                       \n    }\n}\nIf /dev/null  exists, use it.\nIf not, ask System properties  if it knows the OS name.\nNope, so give up, return jnk.\nWe know it’s Microsoft Windows, so use NUL: .\nAll else fails, go with jnk.\nAlthough Java’s Swing GUI aims to be portable, Apple’s implementation for macOS\ndoes not automatically do the right thing for everyone. For example, a JMenuBar\nmenu container appears by default at the top of the application window. This is the\nnorm on Windows and on most Unix platforms, but Mac users expect the menu bar\nfor the active application to appear at the top of the screen. To enable normal behav‐\nior, you have to set the System  property apple.laf.useScreenMenuBar  to the value\ntrue  before the Swing GUI starts up. Y ou might want to set some other properties\ntoo, such as a short name for your application to appear in the menu bar (the default\nis the full class name of your main application class).\nThere is an example of this in the book’s source code, at src/main/java/gui/MacOsUi‐\nHints.java .\n50 | Chapter 2: Interacting with the Environment",9425
75-2.4 Using Extensions or Other Packaged APIs.pdf,75-2.4 Using Extensions or Other Packaged APIs,,0
76-Problem.pdf,76-Problem,,0
77-Solution.pdf,77-Solution,,0
78-2.5 Using the Java Modules System.pdf,78-2.5 Using the Java Modules System,"There is probably no point in setting these properties unless you are, in fact, being\nrun under macOS. How do you tell? Apple’s recommended way is to check for the\nsystem property mrj.runtime  and, if so, assume you are on macOS:\nboolean isMacOS = System.getProperty(""mrj.version"") != null;\nif (isMacOS) {\n  System.setProperty(""apple.laf.useScreenMenuBar"",  ""true"");\n  System.setProperty(""com.apple.mrj.application.apple.menu.about.name"",\n  ""My Super App"");\n}\nOn the other hand, these properties are likely harmless on non-Mac systems, so you\ncould just skip the test and set the two properties unconditionally.\nFinally, the Mac’s Dock or the Taskbar on most other systems can be accessed using\nthe java.awt.Taskbar  class that was added in Java 9. This is not discussed here, but\nthere is an example TaskbarDemo  in the main/gui  subdirectory.\n2.4 Using Extensions or Other Packaged APIs\nProblem\nY ou have a JAR file of classes you want to use.\nSolution\nSimply add the JAR file to your CLASSPATH .\nDiscussion\nAs you build more sophisticated applications, you will need to use more and more\nthird-party libraries. Y ou can add these to your CLASSPATH .\nIt used to be recommended that you drop these JAR files into the Java Extensions\nmechanism directory, typically something like \jdk1.x\jre\lib\ext ., instead of listing\neach JAR file in your CLASSPATH  variable. However, this is no longer generally recom‐\nmended and is no longer available in the latest JDKs. Instead, you may wish to use\nbuild tools like Maven (see Recipe 1.7 ) or Gradle, as well as IDEs, to automate the\naddition of JAR files to your CLASSPATH .\nOne reason I’ve never been fond of using the extensions directory is that it requires\nmodifying the installed JDK or JRE, which can lead to maintenance issues and prob‐\nlems when a new JDK or JRE is installed.\nJava 9 introduced a major change to Java, the Java 9 Modules system for program\nmodularization, which we discuss in Recipe 2.5 .\n2.4 Using Extensions or Other Packaged APIs | 51",2039
79-Problem.pdf,79-Problem,,0
80-Solution.pdf,80-Solution,,0
81-Discussion.pdf,81-Discussion,"2.5 Using the Java Modules System\nProblem\nY ou are using Java 9 or later, and need to deal with the Modules mechanism.\nSolution\nRead on.\nDiscussion\nJava’s Modules system, formerly known as Project Jigsaw, was designed to handle the\nneed to build large applications out of many small pieces. To an extent this problem\nhad been solved by tools like Maven and Gradle, but the Modules system solves a\nslightly different problem than those tools. Maven or Gradle will find dependencies,\ndownload them, install them on your development and test runtimes, and package\nthem into runnable JAR files. The Modules system is more concerned with the visbil‐\nity of classes from one chunk of application code to another, typically provided by\ndifferent developers who may not know or trust each other. As such, it is an admis‐\nsion that Java’s original set of access modifiers—such as public , private , protected ,\nand default visibility—was not sufficient for building large-scale applications.\nWhat follows is a brief discussion of using JPMS, the Java Platform Module System,\nto import modules into your application. There is an introduction to creating your\nown modules in Chapter 15 . For a more detailed presentation, you should refer to a\nbook-length treatment such as Java 9 Modularity: Patterns and Practices for Develop‐\ning Maintainable Applications  by Sander Mak and Paul Bakker (O’Reilly).\nJava has always been a language for large-scale development. Object orientation is\none of the keys: classes and objects group methods, and access modifiers can be\napplied so that public and private methods are clearly separated. When developing\nlarge applications, having just a single flat namespace of classes is still not enough.\nEnter packages: they gather classes into logical groups within their own namespace.\nAccess control can be applied at the package level as well so that some classes are only\naccessible inside a package. Modules are the next logical step up. A module groups\nsome number of related packages, has a distinct name, and can restrict access to some\npackages while exposing other packages to different modules as public API.\nOne thing to understand at the outset: JPMS is not a replacement for your existing\nbuild tool. Whether you use Maven, Gradle, Ant, or just dump all needed JAR files\ninto a lib directory, you still need to do that. Also, don’t confuse Maven’s modules\nwith JPMS modules; the former is the physical structuring of a project into subpro‐\njects, and the latter is something the Java platform (compiler, runtime) understands.\n52 | Chapter 2: Interacting with the Environment\nUsually  when working with Java modules, each Java module will equate to a single\nMaven module.\nWhen you’re dealing with a tiny, self-contained program, you don’t need to be con‐\ncerned with modules. Just put all the necessary JAR files on your CLASSPATH  at com‐\npile time and runtime, and all will be well. Probably.\nY ou may see warning messages like this along the way:\nIllegal reflective access by com.foo.Bar\n    (file:/Users/ian/.m2/repository/com/foo/1.3.1/foo-1.3.1.jar)\n    to field java.util.Properties.defaults\nPlease consider reporting this to the maintainers of com.foo.Bar\nUse --illegal-access=warn to enable warnings of further\n illegal reflective access operations\nAll illegal access operations will be denied in a future release\nThe warning message comes about as a result of JPMS doing its job, checking that no\ntypes are accessed in encapsulated packages within a module. Such messages will go\naway over time as all public Java libraries and all apps being developed get\nmodularized.\nWhy will all be well only “probably”? If you are using certain classes that were depre‐\ncated over the last few releases, things won’t compile. For that, you must make the\nrequisite modules available. In the unsafe  subdirectory (also a Maven module) under\njavasrc , there is a class called LoadAverage . The load average is a feature of Unix/\nLinux systems that gives a rough measure of system load or busyness, by reporting\nthe number of processes that are waiting to be run. There are almost always more\nprocesses running than CPU cores to run them on, so some always have to wait.\nHigher numbers mean a busier system with slower response.\nSun’s unsupported Unsafe  class has a method for obtaining the load average, on sys‐\ntems that support it. The code has to use the Reflection API (see Chapter 17 ) to\nobtain the Unsafe  object; if you try to instantiate Unsafe  directly you will get a Secur\nityException  (this was the case before the Modules system). Once the instance is\nobtained and casted to Unsafe , you can invoke methods such as loadAverage()\n(Example 2-4 ).\nExample 2-4. unsafe/src/main/java/unsafe/LoadAverage.java (use of Unsafe.java)\npublic class LoadAverage  {\n    public static void main(String[] args) throws Exception  {\n        Field f = Unsafe.class.getDeclaredField (""theUnsafe"" );\n        f.setAccessible (true);\n        Unsafe unsafe = (Unsafe) f.get(null);\n        int nelem = 3;\n        double loadAvg[] = new double[nelem];\n        unsafe.getLoadAverage (loadAvg, nelem);\n2.5 Using the Java Modules System | 53\n        for (double d : loadAvg) {\n            System.out.printf(""%4.2f "" , d);\n        }\n        System.out.println();\n    }\n}\nThis code, which used to compile, gives warnings. If we are using Java Modules, we\nmust modify our module-info.java  file to tell the compiler and VM that we require use\nof the module with the semi-obvious name jdk.unsupported .\nmodule javasrc.unsafe {\n    requires  jdk.unsupported ;\n // others...\n}\nWe’ll say more about the module file format in Recipe 15.9 .\nNow that we have the code in place and the module file in the top level of the source\nfolder, we can build the project, run the program, and compare its output against the\nsystem-level tool for displaying the load average, uptime . We’ll still get the “internal\nproprietary API” warnings, but it works:\n$ java -version\nopenjdk version ""14-ea"" 2020-03-17\nOpenJDK Runtime Environment  (build 14-ea+27-1339)\nOpenJDK 64-Bit Server VM (build 14-ea+27-1339, mixed mode, sharing)\n$ mvn clean package\n[INFO] Scanning  for projects ...\n[INFO]\n[INFO] --------------------<  com.darwinsys :javasrc-unsafe >--------------------\n[INFO] Building  javasrc - Unsafe 1.0.0-SNAPSHOT\n[INFO] --------------------------------[  jar ]---------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ javasrc-unsafe ---\n[INFO] Deleting  /Users/ian/workspace /javasrc/unsafe/target\n[INFO]\n[INFO] --- maven-resources -plugin:2.6:resources  (default-resources ) @ javasrc-\nunsafe ---\n[INFO] Using 'UTF-8' encoding  to copy filtered  resources .\n[INFO] skip non existing  resourceDirectory  /Users/ian/workspace /javasrc/\nunsafe/src/main/resources\n[INFO]\n[INFO] --- maven-compiler -plugin:3.1:compile (default-compile) @ javasrc-unsafe \n---\n[INFO] Changes detected  - recompiling  the module!\n[INFO] Compiling  2 source files to /Users/ian/workspace /javasrc/unsafe/target/\nclasses\n[WARNING] /Users/ian/workspace /javasrc/unsafe/src/main/java/unsafe/LoadAver\nage.java:[3,16] sun.misc.Unsafe is internal  proprietary  API and may be removed \nin a future release\n[WARNING] /Users/ian/workspace /javasrc/unsafe/src/main/java/unsafe/LoadAver\n54 | Chapter 2: Interacting with the Environment\nage.java:[12,27] sun.misc.Unsafe is internal  proprietary  API and may be removed \nin a future release\n[WARNING] /Users/ian/workspace /javasrc/unsafe/src/main/java/unsafe/LoadAver\nage.java:[14,17] sun.misc.Unsafe is internal  proprietary  API and may be removed \nin a future release\n[WARNING] /Users/ian/workspace /javasrc/unsafe/src/main/java/unsafe/LoadAver\nage.java:[14,34] sun.misc.Unsafe is internal  proprietary  API and may be removed \nin a future release\n[INFO]\n[INFO] --- maven-resources -plugin:2.6:testResources  (default-testResources ) @ \njavasrc-unsafe ---\n[INFO] Using 'UTF-8' encoding  to copy filtered  resources .\n[INFO] skip non existing  resourceDirectory  /Users/ian/workspace /javasrc/\nunsafe/src/test/resources\n[INFO]\n[INFO] --- maven-compiler -plugin:3.1:testCompile  (default-testCompile ) @ \njavasrc-unsafe ---\n[INFO] No sources to compile\n[INFO]\n[INFO] --- maven-surefire -plugin:2.12.4:test (default-test) @ javasrc-unsafe ---\n[INFO] No tests to run.\n[INFO]\n[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ javasrc-unsafe ---\n[INFO] Building  jar: /Users/ian/workspace /javasrc/unsafe/target/javasrc-\nunsafe-1.0.0-SNAPSHOT .jar\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  4.668 s\n[INFO] Finished  at: 2020-01-05T14:53:55-05:00\n[INFO] ------------------------------------------------------------------------\n$\n$ java -cp target/classes unsafe/LoadAverage\n3.54 1.94 1.62\n$ uptime\n14:54  up 1 day, 21:50, 5 users, load averages:  3.54 1.94 1.62\n$\nThankfully, it works and gives the same numbers as the standard Unix uptime  com‐\nmand. At least, it works on Java 11. As the warnings imply, it may (i.e., probably will)\nbe removed in a later release.\nIf you are building a more complex app, you will probably need to put together a\nmore complete module-info.java  file. But at this stage it’s primarily a matter of requir‐\ning the modules you need. The standard Java API is divided into several modules,\nwhich you can list using the java command:\n$ java --list-modules\njava.base\njava.compiler\njava.datatransfer\njava.desktop\n2.5 Using the Java Modules System | 55\njava.instrument\njava.logging\njava.management\njava.management .rmi\njava.naming\njava.net.http\njava.prefs\njava.rmi\njava.scripting\njava.se\njava.security .jgss\njava.security .sasl\njava.smartcardio\njava.sql\njava.sql.rowset\njava.transaction .xa\njava.xml\njava.xml.crypto\n... plus a bunch of JDK modules ...\nOf these, java.base  is always available and doesn’t need to be listed in your module\nfile, java.desktop  adds AWT and Swing for graphics, and java.se  includes basically\nall of what used to be public API in the Java SDK. If our load average program wanted\nto display the result in a Swing window, for example, it would need to add this into its\nmodule file:\nrequires java.desktop;\nWhen your application is big enough to be divided into tiers or layers, you will proba‐\nbly want to describe these modules using JPMS. Since that topic comes under the\nheading of packaging, it is described in Recipe 15.9 .\n56 | Chapter 2: Interacting with the Environment",10742
82-Chapter 3. Strings and Things.pdf,82-Chapter 3. Strings and Things,,0
83-3.0 Introduction.pdf,83-3.0 Introduction,"1The two .equals()  calls are equivalent with the exception that the first can throw a NullPointerException\nwhile the second cannot.CHAPTER 3\nStrings and Things\n3.0 Introduction\nCharacter strings are an inevitable part of just about any programming task. We use\nthem for printing messages for the user; for referring to files on disk or other external\nmedia; and for people’s names, addresses, and affiliations. The uses of strings are\nmany, almost without number (actually, if you need numbers, we’ll get to them in\nChapter 5 ).\nIf you’re coming from a programming language like C, you’ll need to remember that\nString  is a defined type (class) in Java—that is, a string is an object and therefore has\nmethods. It is not an array of characters (though it contains one) and should not\nbe thought of as an array. Operations like fileName.endsWith("".gif"")  and\nextension.equals("".gif"")  (and the equivalent "" .gif"".equals(extension) ) are\ncommonplace.1\nJava old-timers should note that Java 11 and 12 added several new String  methods,\nincluding  indent(int n) , stripLeading()  and stripTrailing() , Stream<T>\nlines() , isBlank() , and transform() . Most of these provide obvious functionality;\nthe last one allows applying an instance of a functional interface (see Recipe 9.0 ) to a\nstring and returning the result of that operation.\nAlthough we haven’t discussed the details of the java.io  package yet (we will, in\nChapter 10 ), you need to be able to read text files for some of these programs. Even if\nyou’re not familiar with java.io , you can probably see from the examples of reading\n57\ntext files that a BufferedReader  allows you to read chunks of data and that this class\nhas a very convenient readLine()  method.\nGoing the other way, System.out.println()  is normally used to print strings or\nother values to the terminal or standard output. String concatenation is commonly\nused here, like this:\nSystem.out.println(""The answer is "" + result);\nOne caveat with string concatenation is that if you are appending a bunch of things,\nand a number and a character are concatenated at the front, they are added before\nconcatenation due to Java’s precedence rules. So don’t do as I did in this contrived\nexample:\nint result = ...;\nSystem.out.println(result + '=' + "" the answer."" );\nGiven that result  is an integer, then result + '=' ( result added to the equals\nsign, which is of the numeric type +char ) is a valid  numeric  expression, which\nwill result in a single value of type int. If the variable result  has the value 42, and\ngiven that the character = in a Unicode (or ASCII) code chart has the value 61, the\ntwo-line fragment would print:\n103 the answer.\nThe wrong value and no equals sign! Safer approaches include using parentheses,\ndouble quotes around the equals sign, a StringBuilder  (see Recipe 3.2 ), or\nString.format()  (see Recipe 10.4 ). Of course in this simple example you could just\nmove the = to be part of the string literal, but the example was chosen to illustrate the\nproblem of arithmetic on char  values being confused with string contatenation. I\nwon’t show you how to sort an array of strings here; the more general notion of sort‐\ning a collection of objects will be taken up in Recipe 7.11 .\nJava 14 enables text blocks, also known as multiline text strings. These are delimited\nwith a set of three double quotes, the opening of which must  have a newline after the\nquotes (which doesn’t become part of the string; the following newlines do):\nString long = """"""\nThis is a long\ntext String.""""""\nTimeless, Immutable, and Unchangeable\nNotice that a given String  object, once constructed, is immutable. In other words,\nonce I have said String s =  ""Hello "" + yourName; , the contents of the particular\nobject that reference variable s refers to can never be changed. Y ou can assign s to\nrefer to a different string, even one derived from the original, as in s = s.trim() .\nAnd you can retrieve characters from the original string using charAt() , but it isn’t\n58 | Chapter 3: Strings and Things\n2StringBuilder  was added in Java 5. It is functionally equivalent to the older\nStringBuffer . We will delve into the details in Recipe 3.2 .called getCharAt()  because there is not, and never will be, a setCharAt()  method.\nEven methods like toUpperCase()  don’t change the String ; they return a new String\nobject containing the translated characters. If you need to change characters within a\nString , you should instead create a StringBuilder  (possibly initialized to the start‐\ning value of the String ), manipulate the StringBuilder  to your heart’s content, and\nthen convert that to String  at the end, using the ubiquitous toString()  method.2\nHow can I be so sure they won’t add a setCharAt()  method in the next release?\nBecause the immutability of strings is one of the fundamentals of the Java Virtual\nMachine. Immutable objects are generally good for software reliability (some lan‐\nguages do not even allow mutable objects). Immutability avoids conflicts, particularly\nwhere multiple threads are involved, or where software from multiple organizations\nhas to work together; for example, you can safely pass immutable objects to a third-\nparty library and expect that the objects will not be modifed.\nIt may be possible to tinker with the String ’s internal data structures using the Reflec‐\ntion API, as shown in Recipe 17.3 , but then all bets are off. Secured environments do\nnot permit access to the Reflection API, and the Java Modules system from Java 9\ntightens reflective access to such internals even further.\nRemember also that the String  is a fundamental type in Java. Unlike most of the\nother classes in the core API, the behavior of strings is not changeable; the class is\nmarked final  so it cannot be subclassed. So you can’t declare your own String  sub‐\nclass. Think if you could—you could masquerade as a String  but provide a setCh\narAt()  method! Again, they thought of that. If you don’t believe me, try it out:\npublic class WolfInStringsClothing\n    extends java.lang.String {//EXPECT COMPILE ERROR\n    public void setCharAt (int index, char newChar) {\n        // The implementation of this method\n        // would be left as an exercise for the reader.\n        // Hint: compile this code exactly as is before bothering!\n    }\n}\nGot it? They thought of that!\nOf course you do need to be able to modify strings. Some methods extract part of a\nString ; these are covered in the first few recipes in this chapter. And StringBuilder\nis an important set of classes that deals in characters and strings and has many meth‐\nods for changing the contents, including, of course, a toString()  method. Reformed\nC programmers should note that Java strings are not arrays of chars as in C. There‐\nfore you must use methods for such operations as processing a string one character at\n3.0 Introduction | 59",6959
84-3.1 Taking Strings Apart with Substrings or Tokenizing.pdf,84-3.1 Taking Strings Apart with Substrings or Tokenizing,,0
85-Problem.pdf,85-Problem,,0
86-Solution.pdf,86-Solution,,0
87-Discussion.pdf,87-Discussion,"a time; see Recipe 3.3 . Figure 3-1  shows an overview of String , StringBuilder , and\nC-language strings.\nFigure 3-1. String, StringBuilder, and C-language strings\n3.1 Taking Strings Apart with Substrings or Tokenizing\nProblem\nY ou want to break a string apart, either by indexing positions or by using fixed token\ncharacters (e.g., break on spaces to get words).\nSolution\nFor substrings, use the String  object’s substring()  method. For tokenizing, con‐\nstruct a StringTokenizer  around your string and call its methods hasMoreTokens()\nand nextToken() .\nOr, use regular expressions (see Chapter 4 ).\nDiscussion\nWe’ll look first at substrings, and then discuss tokenizing.\n60 | Chapter 3: Strings and Things\nSubstrings\nThe substring()  method constructs a new String  object made up of a run of char‐\nacters contained somewhere in the original string, the one whose substring()  you\ncalled. The substring  method is overloaded: both forms require a starting index\n(which is always zero-based ). The one-argument form returns from startIndex  to\nthe end. The two-argument form takes an ending index (not a length, as in some lan‐\nguages) so that an index can be generated by the String  methods indexOf()  or last\nIndexOf() :\npublic class SubStringDemo  {\n    public static void main(String[] av) {\n        String a = ""Java is great."" ;\n        System.out.println(a);\n        String b = a.substring (5);    // b is the String ""is great.""\n        System.out.println(b);\n        String c = a.substring (5,7);// c is the String ""is""\n        System.out.println(c);\n        String d = a.substring (5,a.length());// d is ""is great.""\n        System.out.println(d);\n    }\n}\nWhen run, this prints the following:\nC:> java strings.SubStringDemo\nJava is great.\nis great.\nis\nis great.\nC:>\nNote that the end index is one beyond the last character! Java\nadopts this policy of having a half-open interval (or inclusive start,\nexclusive end) fairly consistently; there are good practical reasons\nfor adopting this approach, and some other languages do so too.\nTokenizing\nThe easiest way is to use a regular expression. We’ll discuss regular expressions in\nChapter 4 , but for now, a string containing a space is a valid regular expression to\nmatch space characters, so you can most easily split a string into words like this:\nfor (String word : some_input_string .split("" "")) {\n    System.out.println(word);\n}\nIf you need to match multiple spaces, or spaces and tabs, use the string ""\s+"" .\n3.1 Taking Strings Apart with Substrings or Tokenizing | 61\n3Unless, perhaps, you’re as slow at updating personal records as I am.If you want to split a file, you can try the string "","" or use one of several third-party\nlibraries for CSV files.\nAnother method is to use StringTokenizer . The StringTokenizer  methods imple‐\nment the Iterator  interface and design pattern (see Recipe 7.6 ):\nmain/src/main/java/strings/StrTokDemo.java\nStringTokenizer  st = new StringTokenizer (""Hello World of Java"" );\nwhile (st.hasMoreTokens ( ))\n    System.out.println(""Token: ""  + st.nextToken ( ));\nStringTokenizer  also implements the Enumeration  interface (see Recipe 7.6 ), but if\nyou use the methods thereof, you need to cast the results to String .\nA StringTokenizer  normally breaks the String  into tokens at what we would think\nof as word boundaries in European languages. Sometimes you want to break at some\nother character. No problem. When you construct your StringTokenizer , in addi‐\ntion to passing in the string to be tokenized, pass in a second string that lists the\nbreak characters, like this:\nmain/src/main/java/strings/StrTokDemo2.java\nStringTokenizer  st = new StringTokenizer (""Hello, World|of|Java"" , "", |"");\nwhile (st.hasMoreElements ( ))\n    System.out.println(""Token: ""  + st.nextElement ( ));\nIt outputs the four words, each on a line by itself, with no punctuation.\nBut wait, there’s more! What if you are reading lines like\nFirstName|LastName|Company|PhoneNumber\nand your dear old Aunt Begonia hasn’t been employed for the last 38 years? Her Com\npany  field will in all probability be blank.3 If you look very closely at the previous\ncode example, you’ll see that it has two delimiters together (the comma and the\nspace); but if you run it, there are no “extra” tokens—that is, the StringTokenizer\nnormally discards adjacent consecutive delimiters. For cases like the phone list, where\nyou need to preserve null fields, there is good news and bad news. The good news is\nthat you can do it: you simply add a second argument of true  when constructing the\nStringTokenizer , meaning that you wish to see the delimiters as tokens. The bad\nnews is that you now get to see the delimiters as tokens, so you have to do the arith‐\nmetic yourself. Want to see it? Run this program:\nmain/src/main/java/strings/StrTokDemo3.java\n62 | Chapter 3: Strings and Things\nStringTokenizer  st =\n    new StringTokenizer (""Hello, World|of|Java"" , "", |"", true);\nwhile (st.hasMoreElements ( ))\n    System.out.println(""Token: ""  + st.nextElement ( ));\nY ou will get this output:\nC:\>java strings.StrTokDemo3\nToken: Hello\nToken: ,\nToken:\nToken: World\nToken: |\nToken: of\nToken: |\nToken: Java\nC:\>\nThis isn’t how you’ d like StringTokenizer  to behave, ideally, but it is serviceable\nenough most of the time. Example 3-1  processes and ignores consecutive tokens,\nreturning the results as an array of String s.\nExample 3-1. main/src/main/java/strings/StrTokDemo4.java (StringTokenizer)\npublic class StrTokDemo4  {\n    public final static int MAXFIELDS  = 5;\n    public final static String DELIM = ""|"";\n    /** Processes one String, returns it as an array of Strings */\n    public static String[] process(String line) {\n        String[] results = new String[MAXFIELDS ];\n        // Unless you ask StringTokenizer to give you the tokens,\n        // it silently discards multiple null tokens.\n        StringTokenizer  st = new StringTokenizer (line, DELIM, true);\n        int i = 0;\n        // Stuff each token into the current slot in the array.\n        while (st.hasMoreTokens ()) {\n            String s = st.nextToken ();\n            if (s.equals(DELIM)) {\n                if (i++>=MAXFIELDS )\n                    // This is messy: See StrTokDemo4b which uses\n                    // a List to allow any number of fields.\n                    throw new IllegalArgumentException (""Input line ""  +\n                        line + "" has too many fields"" );\n                continue ;\n            }\n            results[i] = s;\n        }\n        return results;\n3.1 Taking Strings Apart with Substrings or Tokenizing | 63",6707
88-3.2 Putting Strings Together with StringBuilder.pdf,88-3.2 Putting Strings Together with StringBuilder,"}\n    public static void printResults (String input, String[] outputs) {\n        System.out.println(""Input: ""  + input);\n        for (String s : outputs)\n            System.out.println(""Output ""  + s + "" was: ""  + s);\n    }\n    public static void main(String[] a) {\n        printResults (""A|B|C|D"" , process(""A|B|C|D"" ));\n        printResults (""A||C|D"" , process(""A||C|D"" ));\n        printResults (""A|||D|E"" , process(""A|||D|E"" ));\n    }\n}\nWhen you run this, you will see that A is always in Field 1, B (if present) is in Field 2,\nand so on. In other words, the null fields are being handled properly:\nInput: A|B|C|D\nOutput 0 was: A\nOutput 1 was: B\nOutput 2 was: C\nOutput 3 was: D\nOutput 4 was: null\nInput: A||C|D\nOutput 0 was: A\nOutput 1 was: null\nOutput 2 was: C\nOutput 3 was: D\nOutput 4 was: null\nInput: A|||D|E\nOutput 0 was: A\nOutput 1 was: null\nOutput 2 was: null\nOutput 3 was: D\nOutput 4 was: E\nSee Also\nMany occurrences of StringTokenizer  may be replaced with regular expressions (see\nChapter 4 ) with considerably more flexibility. For example, to extract all the numbers\nfrom a String , you can use this code:\nMatcher tokenizer = Pattern.compile(""\\d+"").matcher(inputString);\nwhile (tokenizer.find( )) {\n        String courseString = tokenizer.group(0);\n        int courseNumber = Integer.parseInt(courseString);\n        ...\nThis allows user input to be more flexible than you could easily handle with a String\nTokenizer . Assuming that the numbers represent course numbers at some educa‐\n64 | Chapter 3: Strings and Things",1576
89-Problem.pdf,89-Problem,,0
90-Solution.pdf,90-Solution,,0
91-Discussion.pdf,91-Discussion,"4String  and StringBuilder  have several methods that are forced to be identical by their implementation of\nthe CharSequence  interface.tional institution, the inputs “471,472,570” or “Courses 471 and 472, 570” or just “471\n472 570” should all give the same results.\n3.2 Putting Strings Together with StringBuilder\nProblem\nY ou need to put some String  pieces (back) together.\nSolution\nUse string concatenation: the + operator. The compiler implicitly constructs a\nStringBuilder  for you and uses its append()  methods (unless all the string parts are\nknown at compile time).\nBetter yet, construct and use a StringBuilder  yourself.\nDiscussion\nAn object of one of the StringBuilder  classes basically represents a collection of\ncharacters. It is similar to a String  object.4 However, as mentioned, String s are\nimmutable; StringBuilder s are mutable and designed for, well, building String s.\nY ou typically construct a StringBuilder , invoke the methods needed to get the char‐\nacter sequence just the way you want it, and then call toString()  to generate a\nString  representing the same character sequence for use in most of the Java API,\nwhich deals in String s.\nStringBuffer  is historical—it’s been around since the beginning of time. Some of its\nmethods are synchronized (see Recipe 16.5 ), which involves unneeded overhead in a\nsingle-threaded context. In Java 5, this class was split into StringBuffer  (which is\nsynchronized) and StringBuilder  (which is not synchronized); thus, it is faster and\npreferable for single-threaded use. Another new class, AbstractStringBuilder , is the\nparent of both. In the following discussion, I’ll use “the StringBuilder  classes” to\nrefer to all three because they mostly have the same methods.\nThe book’s example code provides a StringBuilderDemo  and a StringBufferDemo .\nExcept for the fact that StringBuilder  is not thread-safe, these API classes are\nidentical  and can be used interchangeably, so my two demo programs are almost\nidentical except that each one uses the appropriate builder class.\n3.2 Putting Strings Together with StringBuilder | 65\nThe StringBuilder  classes have a variety of methods for inserting, replacing, and\notherwise modifying a given StringBuilder . Conveniently, the append()  methods\nreturn a reference to the StringBuilder  itself, so stacked statements\nlike .append(…).append(…)  are fairly common. This style of coding is referred to as a\nfluent  API  because it reads smoothly, like prose from a native speaker of a human lan‐\nguage. Y ou might even see this style of coding in a toString()  method, for example.\nExample 3-2  shows three ways of concatenating strings.\nExample 3-2. main/src/main/java/strings/StringBuilderDemo.java\npublic class StringBuilderDemo  {\n    public static void main(String[] argv) {\n        String s1 = ""Hello"" + "", "" + ""World"";\n        System.out.println(s1);\n        // Build a StringBuilder, and append some things to it.\n        StringBuilder  sb2 = new StringBuilder ();\n        sb2.append(""Hello"");\n        sb2.append(',');\n        sb2.append(' ');\n        sb2.append(""World"");\n        // Get the StringBuilder's value as a String, and print it.\n        String s2 = sb2.toString ();\n        System.out.println(s2);\n        // Now do the above all over again, but in a more\n        // concise (and typical ""real-world"" Java) fashion.\n        System.out.println(\n          new StringBuilder ()\n            .append(""Hello"")\n            .append(',')\n            .append(' ')\n            .append(""World""));\n    }\n}\nIn fact, all the methods that modify more than one character of a StringBuilder ’s\ncontents (i.e., append() , delete() , deleteCharAt() , insert() , replace() , and\nreverse() ) return a reference to the builder object to facilitate this fluent API style of\ncoding.\nAs another example of using a StringBuilder , consider the need to convert a list of\nitems into a comma-separated list while avoiding getting an extra comma after the\nlast element of the list. This can be done using a StringBuilder , although in Java 8+\n66 | Chapter 3: Strings and Things",4151
92-3.3 Processing a String One Character at a Time.pdf,92-3.3 Processing a String One Character at a Time,,0
93-Solution.pdf,93-Solution,"there is a static String  method to do the same. Code for these are shown in\nExample 3-3 .\nExample 3-3. main/src/main/java/strings/StringBuilderCommaList.java\n        System.out.println(\n            ""Split using String.split; joined using 1.8 String join"" );\n        System.out.println(String.join("", "", SAMPLE_STRING .split("" "")));\n        System.out.println(\n            ""Split using String.split; joined using StringBuilder"" );\n        StringBuilder  sb1 = new StringBuilder ();\n        for (String word : SAMPLE_STRING .split("" "")) {\n            if (sb1.length() > 0) {\n                sb1.append("", "");\n            }\n            sb1.append(word);\n        }\n        System.out.println(sb1);\n        System.out.println(\n            ""Split using StringTokenizer; joined using StringBuilder"" );\n        StringTokenizer  st = new StringTokenizer (SAMPLE_STRING );\n        StringBuilder  sb2 = new StringBuilder ();\n        while (st.hasMoreElements ()) {\n            sb2.append(st.nextToken ());\n            if (st.hasMoreElements ()) {\n                sb2.append("", "");\n            }\n        }\n        System.out.println(sb2);\nThe first method is clearly the most compact; the static String.join()  makes short\nwork of this task. The next method uses the StringBuilder.length()  method, so it\nwill only work correctly when you are starting with an empty StringBuilder . The\nsecond method relies on calling the informational method hasMoreElements()  in the\nEnumeration  (or hasNext()  in an Iterator , as discussed in Recipe 7.6 ) more than\nonce on each element. An alternative method, particularly when you aren’t starting\nwith an empty builder, would be to use a boolean  flag variable to track whether you’re\nat the beginning of the list.\n3.3 Processing a String One Character at a Time\nProblem\nY ou want to process the contents of a string, one character at a time.\n3.3 Processing a String One Character at a Time | 67",1961
94-3.4 Aligning Indenting and Unindenting Strings.pdf,94-3.4 Aligning Indenting and Unindenting Strings,"Solution\nUse a for loop and the String ’s charAt()  or codePointAt()  method. Or use a “for\neach” loop and the String ’s toCharArray  method.\nDiscussion\nA string’s charAt()  method retrieves a given character by index number (starting at\nzero) from within the String  object. Since Unicode has had to expand beyond 16\nbits, not all Unicode characters can fit into a Java char  variable. There is thus an anal‐\nogous codePointAt()  method, whose return type is int. To process all the characters\nin a String , one after another, use a for loop ranging from zero to\nString.length()-1 . Here we process all the characters in a String :\nmain/src/main/java/strings/strings/StrCharAt.java\npublic class StrCharAt  {\n    public static void main(String[] av) {\n        String a = ""A quick bronze fox"" ;\n        for (int i=0; i < a.length(); i++) { // no forEach, need the index\n            String message = String.format(\n                ""charAt is '%c', codePointAt is %3d, casted it's '%c'"" ,\n                     a.charAt(i),\n                     a.codePointAt (i),\n                     (char)a.codePointAt (i));\n            System.out.println(message);\n        }\n    }\n}\nGiven that the “for each” loop has been in the language for ages, you might be\nexcused for expecting to be able to write something like for (char ch : myString)\n{…}. Unfortunately, this does not work. But you can use myString.toCharArray()  as\nin the following:\npublic class ForEachChar  {\n    public static void main(String[] args) {\n        String mesg = ""Hello world"" ;\n        // Does not compile, Strings are not iterable\n        // for (char ch : mesg) {\n        //        System.out.println(ch);\n        // }\n        System.out.println(""Using toCharArray:"" );\n        for (char ch : mesg.toCharArray ()) {\n            System.out.println(ch);\n        }\n        System.out.println(""Using Streams:"" );\n68 | Chapter 3: Strings and Things",1946
95-Problem.pdf,95-Problem,,0
96-Discussion.pdf,96-Discussion,"mesg.chars().forEach(c -> System.out.println((char)c));\n    }\n}\nA checksum  is a numeric quantity representing and confirming the contents of a\nfile. If you transmit the checksum of a file separately from the contents, a recipient\ncan checksum the file—assuming the algorithm is known—and verify that the file\nwas received intact. Example 3-4  shows the simplest possible checksum, computed\njust by adding the numeric values of each character. Note that on files, it does not\ninclude the values of the newline characters; in order to fix this, retrieve System.get\nProperty(""line.separator"");  and add its character value(s) into the sum at the end\nof each line. Or give up on line mode and read the file a character at a time.\nExample 3-4. main/src/main/java/strings/CheckSum.java\n    /** CheckSum one text file, given an open BufferedReader.\n     * Checksum does not include line endings, so will give the\n     * same value for given text on any platform. Do not use\n     * on binary files!\n     */\n    public static int process(BufferedReader  is) {\n        int sum = 0;\n        try {\n            String inputLine ;\n            while ((inputLine  = is.readLine ()) != null) {\n                for (char c : inputLine .toCharArray ()) {\n                    sum += c;\n                }\n            }\n        } catch (IOException  e) {\n            throw new RuntimeException (""IOException: ""  + e);\n        }\n        return sum;\n    }\n3.4 Aligning, Indenting, and Unindenting Strings\nProblem\nY ou want to align strings to the left, right, or center.\nSolution\nDo the math yourself, and use substring  (see Recipe 3.1 ) and a StringBuilder  (see\nRecipe 3.2 ). Or, use my StringAlign  class, which is based on the java.text.Format\nclass. For left or right alignment, use String.format() .\n3.4 Aligning, Indenting, and Unindenting Strings | 69\nDiscussion\nCentering and aligning text comes up fairly often. Suppose you want to print a simple\nreport with centered page numbers. There doesn’t seem to be anything in the stan‐\ndard API that will do the job fully for you. But I have written a class called String\nAlign  that will. Here’s how you might use it:\npublic class StringAlignSimple  {\n    public static void main(String[] args) {\n        // Construct a ""formatter"" to center strings.\n        StringAlign  formatter  = new StringAlign (70, StringAlign .Justify.CENTER);\n        // Try it out, for page ""i""\n        System.out.println(formatter .format(""- i -""));\n        // Try it out, for page 4. Since this formatter is\n        // optimized for Strings, not specifically for page numbers,\n        // we have to convert the number to a String\n        System.out.println(formatter .format(Integer.toString (4)));\n    }\n}\nIf you compile and run this class, it prints the two demonstration line numbers cen‐\ntered, as shown:\n> javac -d . StringAlignSimple.java\n> java strings.StringAlignSimple\n                                - i -\n                                  4\n>\nExample 3-5  is the code for the StringAlign  class. Note that this class extends the\nclass Format  in the package java.text . There is a series of Format  classes that all have\nat least one method called format() . It is thus in a family with numerous other for‐\nmatters, such as DateFormat  and NumberFormat , that we’ll take a look at in upcoming\nchapters.\nExample 3-5. main/src/main/java/strings/StringAlign.java\npublic class StringAlign  extends Format {\n    private static final long serialVersionUID  = 1L;\n    public enum Justify {\n        /* Constant for left justification. */\n        LEFT,\n        /* Constant for centering. */\n        CENTER,\n        /** Constant for right-justified Strings. */\n        RIGHT,\n    }\n70 | Chapter 3: Strings and Things\n    /** Current justification */\n    private Justify just;\n    /** Current max length */\n    private int maxChars ;\n    /** Construct a StringAlign formatter; length and alignment are\n     * passed to the Constructor instead of each format() call as the\n     * expected common use is in repetitive formatting e.g., page numbers.\n     * @param maxChars - the maximum length of the output\n     * @param just - one of the enum values LEFT, CENTER or RIGHT\n     */\n    public StringAlign (int maxChars , Justify just) {\n        switch(just) {\n        case LEFT:\n        case CENTER:\n        case RIGHT:\n            this.just = just;\n            break;\n        default:\n            throw new IllegalArgumentException (""invalid justification arg."" );\n        }\n        if (maxChars  < 0) {\n            throw new IllegalArgumentException (""maxChars must be positive."" );\n        }\n        this.maxChars  = maxChars ;\n    }\n    /** Format a String.\n     * @param input - the string to be aligned.\n     * @parm where - the StringBuilder to append it to.\n     * @param ignore - a FieldPosition (may be null, not used but\n     * specified by the general contract of Format).\n     */\n    @Override\n    public StringBuffer  format(\n        Object input, StringBuffer  where, FieldPosition  ignore)  {\n        String s = input.toString ();\n        String wanted = s.substring (0, Math.min(s.length(), maxChars ));\n        // Get the spaces in the right place.\n        switch (just) {\n            case RIGHT:\n                pad(where, maxChars  - wanted.length());\n                where.append(wanted);\n                break;\n            case CENTER:\n                int toAdd = maxChars  - wanted.length();\n                pad(where, toAdd/2);\n                where.append(wanted);\n                pad(where, toAdd - toAdd/2);\n3.4 Aligning, Indenting, and Unindenting Strings | 71",5723
97-3.5 Converting Between Unicode Characters and Strings.pdf,97-3.5 Converting Between Unicode Characters and Strings,"break;\n            case LEFT:\n                where.append(wanted);\n                pad(where, maxChars  - wanted.length());\n                break;\n            }\n        return where;\n    }\n    protected  final void pad(StringBuffer  to, int howMany) {\n        for (int i=0; i<howMany; i++)\n            to.append(' ');\n    }\n    /** Convenience Routine */\n    String format(String s) {\n        return format(s, new StringBuffer (), null).toString ();\n    }\n    /** ParseObject is required, but not useful here. */\n    public Object parseObject  (String source, ParsePosition  pos)  {\n        return source;\n    }\n}\nJava 12 introduced a new method public String indent(int n)  that prepends n\nspaces to the string, which is treated as a sequence of lines with line separators. This\nworks well in conjunction with the Java 11 Stream<String> lines()  method. For\nexample, for the case where a series of lines, already stored in a single string, needs\nthe same indent ( Streams , and the “::” notation, are explained in Recipe 9.0 ):\njshell> ""abc\ndef"" .indent(30).lines().forEach(System.out::println);\n                              abc\n                              def\njshell> ""abc\ndef"" .indent(30).indent(-10).lines().forEach(System.out::println);\n                    abc\n                    def\njshell>\nSee Also\nThe alignment of numeric columns is considered in Chapter 5 .\n72 | Chapter 3: Strings and Things",1444
98-Problem.pdf,98-Problem,,0
99-Solution.pdf,99-Solution,,0
100-Discussion.pdf,100-Discussion,"5Indeed, there are so many characters in Unicode that a fad has emerged of displaying your name upside down\nusing characters that approximate upside-down versions of the Latin alphabet. Do a web search for “upside-\ndown Unicode. ”3.5 Converting Between Unicode Characters and Strings\nProblem\nY ou want to convert between Unicode characters and String s.\nSolution\nUse Java char  or String  data types to deal with characters; these intrinsically support\nUnicode. Print characters as integers to display their raw value if needed.\nDiscussion\nUnicode is an international standard that aims to represent all known characters used\nby people in their various languages. Though the original ASCII character set is a\nsubset, Unicode is huge. At the time Java was created, Unicode was a 16-bit character\nset, so it seemed natural to make Java char  values be 16 bits in width, and for years a\nchar  could hold any Unicode character. However, over time, Unicode has grown, to\nthe point that it now includes over a million code points, or characters, more than the\n65,525 that could be represented in 16 bits.5 Not all possible 16-bit values were\ndefined as characters in UCS-2, the 16-bit version of Unicode originally used in Java.\nA few were reserved as escape characters, which allows for multicharacter-length\nmappings to less common characters. Fortunately, there is a go-between standard,\ncalled UTF-16 (16-bit Unicode Transformation Format). As the String  class docu‐\nmentation puts it:\nA String  represents a string in the UTF-16 format in which supplementary characters\nare represented by surrogate pairs  (see the section Unicode Character Representations\nin the Character  class for more information). Index values refer to char code units, so\na supplementary character uses two positions in a String .\nThe String  class provides methods for dealing with Unicode code points (i.e., charac‐\nters), in addition to those for dealing with Unicode code units (i.e., char values ).\nThe charAt()  method of String  returns the char  value for the character at the speci‐\nfied offset. The StringBuilder append()  method has a form that accepts a char .\nBecause char  is an integer type, you can even do arithmetic on char s, though this is\nnot needed as frequently as in, say, C. Nor is it often recommended, because the Char\nacter  class provides the methods for which these operations were normally used in\n3.5 Converting Between Unicode Characters and Strings | 73\nlanguages such as C. Here is a program that uses arithmetic on char s to control a\nloop and that also appends the characters into a StringBuilder  (see Recipe 3.2 ):\n        // UnicodeChars.java\n        StringBuilder  b = new StringBuilder ();\n        for (char c = 'a'; c<'d'; c++) {\n            b.append(c);\n        }\n        b.append('\u00a5' );    // Japanese Yen symbol\n        b.append('\u01FC' );    // Roman AE with acute accent\n        b.append('\u0391' );    // GREEK Capital Alpha\n        b.append('\u03A9' );    // GREEK Capital Omega\n        for (int i=0; i<b.length(); i++) {\n            System.out.printf(\n                ""Character #%d (%04x) is %c%n"" ,\n                i, (int)b.charAt(i), b.charAt(i));\n        }\n        System.out.println(""Accumulated characters are ""  + b);\nWhen you run it, the expected results are printed for the ASCII characters. On Unix\nand characters in Mac systems, the default fonts don’t include all the additional char‐\nacters, so they are either omitted or mapped to irregular characters:\n$ java -cp target/classes strings.UnicodeChars\nCharacter  #0 (0061) is a\nCharacter  #1 (0062) is b\nCharacter  #2 (0063) is c\nCharacter  #3 (00a5) is ¥\nCharacter  #4 (01fc) is Ǽ\nCharacter  #5 (0391) is Α\nCharacter  #6 (03a9) is Ω\nAccumulated  characters  are abc¥ǼΑΩ\n$\nThe Windows system used to try this doesn’t have most of those characters either, but\nat least it prints as question marks the ones it knows are lacking (Windows system\nfonts are more homogenous than those of the various Unix systems, so it is easier to\nknow what won’t work). On the other hand, it tries to print the yen sign as an N with\na tilde:\nCharacter  #0 is a\nCharacter  #1 is b\nCharacter  #2 is c\nCharacter  #3 is ¥\nCharacter  #4 is ?\nCharacter  #5 is ?\nCharacter  #6 is ?\nAccumulated  characters  are abc¥___\nThe “_” characters are unprintable characters.\n74 | Chapter 3: Strings and Things",4444
101-See Also.pdf,101-See Also,,0
102-3.6 Reversing a String by Word or by Character.pdf,102-3.6 Reversing a String by Word or by Character,,0
103-Problem.pdf,103-Problem,,0
104-Solution.pdf,104-Solution,,0
105-3.7 Expanding and Compressing Tabs.pdf,105-3.7 Expanding and Compressing Tabs,"See Also\nThe Unicode  program in this book’s online source displays any 256-character section\nof the Unicode character set. Y ou can download documentation listing every charac‐\nter in the Unicode character set from the Unicode Consortium .\n3.6 Reversing a String by Word or by Character\nProblem\nY ou wish to reverse a string, a character at a time or a word at a time.\nSolution\nY ou can reverse a string by character easily, using a StringBuilder . There are several\nways to reverse a string a word at a time. One natural way is to use a StringToken\nizer  and a stack. Stack  is a class (defined in java.util ; see Recipe 7.16 ) that imple‐\nments an easy-to-use last-in, first-out (LIFO) stack of objects.\nDiscussion\nTo reverse the characters in a string, use the StringBuilder reverse()  method:\nmain/src/main/java/strings/StringRevChar.java\nString sh = ""FCGDAEB"" ;\nSystem.out.println(sh + "" -> "" + new StringBuilder (sh).reverse());\nThe letters in this example list the order of the sharps in the key signatures of Western\nmusic; in reverse, it lists the order of flats. Alternatively, of course, you could reverse\nthe characters yourself, using character-at-a-time mode (see Recipe 3.3 ).\nA popular mnemonic, or memory aid, to help music students remember the order of\nsharps and flats consists of one word for each sharp instead of just one letter. Let’s\nreverse this one word at a time . Example 3-6  adds each one to a Stack  (see Recipe\n7.16), then processes the whole lot in LIFO order, which reverses the order.\nExample 3-6. main/src/main/java/strings/StringReverse.java\n        String s = ""Father Charles Goes Down And Ends Battle"" ;\n        // Put it in the stack frontwards\n        Stack<String> myStack = new Stack<>();\n        StringTokenizer  st = new StringTokenizer (s);\n        while (st.hasMoreTokens ()) {\n            myStack.push(st.nextToken ());\n        }\n3.6 Reversing a String by Word or by Character | 75",1963
106-Problem.pdf,106-Problem,,0
107-Solution.pdf,107-Solution,,0
108-Discussion.pdf,108-Discussion,"// Print the stack backwards\n        System.out.print('""' + s + '""' + "" backwards by word is:\n\t\"""" );\n        while (!myStack.empty()) {\n            System.out.print(myStack.pop());\n            System.out.print(' ');    // inter-word spacing\n        }\n        System.out.println('""');\n3.7 Expanding and Compressing Tabs\nProblem\nY ou need to convert space characters to tab characters in a file, or vice versa. Y ou\nmight want to replace spaces with tabs to save space on disk or go the other way to\ndeal with a device or program that can’t handle tabs.\nSolution\nUse my Tabs  class or its subclass EnTab .\nDiscussion\nBecause programs that deal with tabbed text or data expect tab stops to be at fixed\npositions, you cannot use a typical text editor to replace tabs with spaces or vice\nversa. Example 3-7  is a listing of EnTab , complete with a sample main program. The\nprogram works a line at a time. For each character on the line, if the character is a\nspace, we see if we can coalesce it with previous spaces to output a single tab charac‐\nter. This program depends on the Tabs  class, which we’ll come to shortly. The Tabs\nclass is used to decide which column positions represent tab stops and which do not.\nExample 3-7. main/src/main/java/strings/Entab.java\npublic class EnTab {\n    private static Logger logger = Logger.getLogger (EnTab.class.getSimpleName ());\n    /** The Tabs (tab logic handler) */\n    protected  Tabs tabs;\n    /**\n     * Delegate tab spacing information to tabs.\n     */\n    public int getTabSpacing () {\n        return tabs.getTabSpacing ();\n    }\n76 | Chapter 3: Strings and Things\n    /**\n     * Main program: just create an EnTab object, and pass the standard input\n     * or the named file(s) through it.\n     */\n    public static void main(String[] argv) throws IOException  {\n        EnTab et = new EnTab(8);\n        if (argv.length == 0) // do standard input\n            et.entab(\n                new BufferedReader (new InputStreamReader (System.in)),\n                System.out);\n        else\n            for (String fileName  : argv) { // do each file\n                et.entab(\n                    new BufferedReader (new FileReader (fileName )),\n                    System.out);\n            }\n    }\n    /**\n     * Constructor: just save the tab values.\n     * @param n The number of spaces each tab is to replace.\n     */\n    public EnTab(int n) {\n        tabs = new Tabs(n);\n    }\n    public EnTab() {\n        tabs = new Tabs();\n    }\n    /**\n     * entab: process one file, replacing blanks with tabs.\n     * @param is A BufferedReader opened to the file to be read.\n     * @param out a PrintWriter to send the output to.\n     */\n    public void entab(BufferedReader  is, PrintWriter  out) throws IOException  {\n        // main loop: process entire file one line at a time.\n        is.lines().forEach(line -> {\n            out.println(entabLine (line));\n        });\n    }\n    /**\n     * entab: process one file, replacing blanks with tabs.\n     *\n     * @param is A BufferedReader opened to the file to be read.\n     * @param out A PrintStream to write the output to.\n     */\n    public void entab(BufferedReader  is, PrintStream  out) throws IOException  {\n        entab(is, new PrintWriter (out));\n    }\n3.7 Expanding and Compressing Tabs | 77\n    /**\n     * entabLine: process one line, replacing blanks with tabs.\n     * @param line the string to be processed\n     */\n    public String entabLine (String line) {\n        int N = line.length(), outCol = 0;\n        StringBuilder  sb = new StringBuilder ();\n        char ch;\n        int consumedSpaces  = 0;\n        for (int inCol = 0; inCol < N; inCol++) { // Cannot use foreach here\n            ch = line.charAt(inCol);\n            // If we get a space, consume it, don't output it.\n            // If this takes us to a tab stop, output a tab character.\n            if (ch == ' ') {\n                logger.info(""Got space at ""  + inCol);\n                if (tabs.isTabStop (inCol)) {\n                    logger.info(""Got a Tab Stop ""  + inCol);\n                    sb.append('\t');\n                    outCol += consumedSpaces ;\n                    consumedSpaces  = 0;\n                } else {\n                    consumedSpaces ++;\n                }\n                continue ;\n            }\n            // We're at a non-space; if we're just past a tab stop, we need\n            // to put the ""leftover"" spaces back out, since we consumed\n            // them above.\n            while (inCol-1 > outCol) {\n                logger.info(""Padding space at ""  + inCol);\n                sb.append(' ');\n                outCol++;\n            }\n            // Now we have a plain character to output.\n            sb.append(ch);\n            outCol++;\n        }\n        // If line ended with trailing (or only!) spaces, preserve them.\n        for (int i = 0; i < consumedSpaces ; i++) {\n            logger.info(""Padding space at end # ""  + i);\n            sb.append(' ');\n        }\n        return sb.toString ();\n    }\n}\n78 | Chapter 3: Strings and Things\nThis code was patterned after a program in Kernighan and Plauger’s classic work Soft‐\nware  Tools . While their version was in a language called RatFor (Rational Fortran),\nmy version has since been through several translations. Their version actually worked\none character at a time, and for a long time I tried to preserve this overall structure.\nEventually, I rewrote it to be a line-at-a-time program.\nThe program that goes in the opposite direction—putting tabs in rather than taking\nthem out—is the DeTab  class shown in Example 3-8 ; only the core methods are\nshown.\nExample 3-8. main/src/main/java/strings/DeTab.java\npublic class DeTab {\n    Tabs ts;\n    public static void main(String[] argv) throws IOException  {\n        DeTab dt = new DeTab(8);\n        dt.detab(new BufferedReader (new InputStreamReader (System.in)),\n                new PrintWriter (System.out));\n    }\n    public DeTab(int n) {\n        ts = new Tabs(n);\n    }\n    public DeTab() {\n        ts = new Tabs();\n    }\n    /** detab one file (replace tabs with spaces)\n     * @param is - the file to be processed\n     * @param out - the updated file\n     */\n    public void detab(BufferedReader  is, PrintWriter  out) throws IOException  {\n        is.lines().forEach(line -> {\n            out.println(detabLine (line));\n        });\n    }\n    /** detab one line (replace tabs with spaces)\n     * @param line - the line to be processed\n     * @return the updated line\n     */\n    public String detabLine (String line) {\n        char c;\n        int col;\n        StringBuilder  sb = new StringBuilder ();\n        col = 0;\n        for (int i = 0; i < line.length(); i++) {\n            // Either ordinary character or tab.\n            if ((c = line.charAt(i)) != '\t') {\n3.7 Expanding and Compressing Tabs | 79\n                sb.append(c); // Ordinary\n                ++col;\n                continue ;\n            }\n            do { // Tab, expand it, must put >=1 space\n                sb.append(' ');\n            } while (!ts.isTabStop (++col));\n        }\n        return sb.toString ();\n    }\n}\nThe Tabs  class provides two methods: settabpos()  and istabstop() . Example 3-9  is\nthe source for the Tabs  class.\nExample 3-9. main/src/main/java/strings/Tabs.java\npublic class Tabs {\n    /** tabs every so often */\n    public final static int DEFTABSPACE  =   8;\n    /** the current tab stop setting. */\n    protected  int tabSpace  = DEFTABSPACE ;\n    /** the longest line that we initially set tabs for */\n    public final static int MAXLINE  = 255;\n    /** Construct a Tabs object with a given tab stop settings */\n    public Tabs(int n) {\n        if (n <= 0) {\n            n = 1;\n        }\n        tabSpace  = n;\n    }\n    /** Construct a Tabs object with a default tab stop settings */\n    public Tabs() {\n        this(DEFTABSPACE );\n    }\n    /**\n     * @return Returns the tabSpace.\n     */\n    public int getTabSpacing () {\n        return tabSpace ;\n    }\n    /** isTabStop - returns true if given column is a tab stop.\n     * @param col - the current column number\n     */\n    public boolean isTabStop (int col) {\n        if (col <= 0)\n            return false;\n80 | Chapter 3: Strings and Things",8432
109-3.8 Controlling Case.pdf,109-3.8 Controlling Case,,0
110-Problem.pdf,110-Problem,,0
111-See Also.pdf,111-See Also,"return (col+1) % tabSpace  == 0;\n    }\n}\n3.8 Controlling Case\nProblem\nY ou need to either convert strings to uppercase or lowercase or compare strings\nwithout regard for case.\nSolution\nThe String  class has a number of methods for dealing with documents in a particular\ncase.  toUpperCase()  and toLowerCase()  each return a new string that is a copy of\nthe current string but converted, as the name implies. Each can be called either with\nno arguments or with a Locale  argument specifying the conversion rules; this is nec‐\nessary because of internationalization. Java’s API provides significant internationaliza‐\ntion and localization features, as covered in “Ian’s Basic Steps: Internationalization\nand Localization” on page 85. Whereas the equals()  method tells you if another\nstring is exactly the same, equalsIgnoreCase()  tells you if all characters are the same\nregardless of case. Here, you can’t specify an alternative locale; the system’s default\nlocale is used:\n        String name = ""Java Cookbook"" ;\n        System.out.println(""Normal:\t""  + name);\n        System.out.println(""Upper:\t""  + name.toUpperCase ());\n        System.out.println(""Lower:\t""  + name.toLowerCase ());\n        String javaName  = ""java cookBook"" ; // If it were Java identifiers :-)\n        if (!name.equals(javaName ))\n            System.err.println(""equals() correctly reports false"" );\n        else\n            System.err.println(""equals() incorrectly reports true"" );\n        if (name.equalsIgnoreCase (javaName ))\n            System.err.println(""equalsIgnoreCase() correctly reports true"" );\n        else\n            System.err.println(""equalsIgnoreCase() incorrectly reports false"" );\nIf you run this, it prints the first name changed to uppercase and lowercase, then it\nreports that both methods work as expected:\nC:\javasrc\strings> java strings.Case\nNormal: Java Cookbook\nUpper:  JAVA COOKBOOK\nLower:  java cookbook\nequals( ) correctly reports false\nequalsIgnoreCase( ) correctly reports true\n3.8 Controlling Case | 81",2054
112-3.9 Entering Nonprintable Characters.pdf,112-3.9 Entering Nonprintable Characters,,0
113-Problem.pdf,113-Problem,,0
114-Solution.pdf,114-Solution,,0
115-3.10 Trimming Blanks from the End of a String.pdf,115-3.10 Trimming Blanks from the End of a String,"See Also\nRegular expressions make it simpler to ignore case in string searching (as we see in\nChapter 4 ).\n3.9 Entering Nonprintable Characters\nProblem\nY ou need to put nonprintable characters into strings.\nSolution\nUse the backslash character and one of the Java string escapes.\nDiscussion\nThe Java string escapes are listed in Table 3-1 .\nTable 3-1. String escapes\nTo get Use Notes\nTab \t\nLinefeed (Unix newline) \n The call System.getProperty(""line.separator"")  will give you the\nplatform’s line end.\nCarriage return \r\nForm feed \f\nBackspace \b\nSingle quote \'\nDouble quote \""\nUnicode character \u NNNN Four hexadecimal digits (no \x as in C/C++). See http://www.unicode.org  for codes.\nOctal(!) character +\+NNN Who uses octal (base 8) these days?\nBackslash \\\nHere is a code example that shows most of these in action:\npublic class StringEscapes  {\n    public static void main(String[] argv) {\n        System.out.println(""Java Strings in action:"" );\n        // System.out.println(""An alarm or alert: \a"");    // not supported\n        System.out.println(""An alarm entered in Octal: \007"" );\n        System.out.println(""A tab key: \t(what comes after)"" );\n        System.out.println(""A newline: \n(what comes after)"" );\n        System.out.println(""A UniCode character: \u0207"" );\n        System.out.println(""A backslash character: \\"" );\n82 | Chapter 3: Strings and Things",1409
116-Problem.pdf,116-Problem,,0
117-Solution.pdf,117-Solution,,0
118-Discussion.pdf,118-Discussion,"}\n}\nIf you have a lot of non-ASCII characters to enter, you may wish to consider using\nJava’s input methods, discussed briefly in the online documentation .\n3.10 Trimming Blanks from the End of a String\nProblem\nY ou need to work on a string without regard for extra leading or trailing spaces a user\nmay have typed.\nSolution\nUse the String  class strip()  or trim()  methods.\nDiscussion\nThere are four methods in the String  class for this:\nstrip()\nReturns a string with all leading and trailing whitespace removed\nstripLeading()\nReturns a string whose value is this string, with all leading white space removed\nstripTrailing()\nReturns the string with all trailing whitespace removed\nString trim()\nReturns the string with all leading and trailing spaces removed\nFor the strip()  methods, whitespace is as defined by Character.isSpace() . For the\ntrim()  method, space includes any character whose numeric value is less than or\nequal to 32, or U+0020  (the space character).\nExample 3-10  uses trim()  to strip an arbitrary number of leading spaces and/or tabs\nfrom lines of Java source code in order to look for the characters //+ and //-. These\nstrings are special Java comments I previously used to mark the parts of the programs\nin this book that I wanted to include in the printed copy.\nExample 3-10. main/src/main/java/strings/GetMark.java (trimming and comparing\nstrings)\npublic class GetMark {\n    /** the default starting mark */\n3.10 Trimming Blanks from the End of a String | 83\n    public final String START_MARK  = ""//+"";\n    /** the default ending mark */\n    public final String END_MARK  = ""//-"";\n    /** Set this to TRUE for running in ""exclude"" mode (e.g., for\n     * building exercises from solutions) and to FALSE for running\n     * in ""extract"" mode (e.g., writing a book and omitting the\n     * imports and ""public class"" stuff).\n     */\n    public final static boolean START = true;\n    /** True if we are currently inside marks */\n    protected  boolean printing  = START;\n    /** True if you want line numbers */\n    protected  final boolean number = false;\n    /** Get Marked parts of one file, given an open LineNumberReader.\n     * This is the main operation of this class, and can be used\n     * inside other programs or from the main() wrapper.\n     */\n    public void process(String fileName ,\n        LineNumberReader  is,\n        PrintStream  out) {\n        int nLines = 0;\n        try {\n            String inputLine ;\n            while ((inputLine  = is.readLine ()) != null) {\n                if (inputLine .trim().equals(START_MARK )) {\n                    if (printing )\n                        // These go to stderr, so you can redirect the output\n                        System.err.println(""ERROR: START INSIDE START, ""  +\n                            fileName  + ':' + is.getLineNumber ());\n                    printing  = true;\n                } else if (inputLine .trim().equals(END_MARK )) {\n                    if (!printing )\n                        System.err.println(""ERROR: STOP WHILE STOPPED, ""  +\n                            fileName  + ':' + is.getLineNumber ());\n                    printing  = false;\n                } else if (printing ) {\n                    if (number) {\n                        out.print(nLines);\n                        out.print("": "");\n                    }\n                    out.println(inputLine );\n                    ++nLines;\n                }\n            }\n            is.close();\n            out.flush(); // Must not close - caller may still need it.\n            if (nLines == 0)\n                System.err.println(""ERROR: No marks in ""  + fileName  +\n                    ""; no output generated!"" );\n        } catch (IOException  e) {\n84 | Chapter 3: Strings and Things",3834
119-3.11 Creating a Message with I18N Resources.pdf,119-3.11 Creating a Message with I18N Resources,,0
120-Problem.pdf,120-Problem,,0
121-Solution.pdf,121-Solution,"System.out.println(""IOException: ""  + e);\n        }\n    }\nIan’s Basic Steps: Internationalization and Localization\nInternationalization and localization consist of the following:\nSensitivity training (Internationalization, or I18N)\nMaking your software sensitive to these issues\nLanguage lessons (Localization, or L10N)\nWriting configuration files for each language\nCulture lessons (optional)\nCustomizing the presentation of numbers, fractions, dates, and message\nformatting\nFor more information, see Java Internationalization  by Andy Deitsch and David Czar‐\nnecki (O’Reilly).\n3.11 Creating a Message with I18N Resources\nProblem\nY ou want your program to take sensitivity training so that it can communicate well\ninternationally.\nSolution\nY our program must obtain all control and message strings via the internationalization\nsoftware. Here’s how:\n1.Get a ResourceBundle :\nResourceBundle rb = ResourceBundle.getBundle(""Menus"");\nI’ll talk about ResourceBundle  in Recipe 3.13 , but briefly, a ResourceBundle  rep‐\nresents a collection of name-value pairs (resources). The names are names you\nassign to each GUI control or other user interface text, and the values are the text\nto assign to each control in a given language.\n2.Use this ResourceBundle  to fetch the localized version of each control name.\nOld way:\nString label = ""Exit"";\n// Create the control, e.g., new JButton(label);\n3.11 Creating a Message with I18N Resources | 85\nNew way:\ntry { label = rb.getString(""exit.label""); }\ncatch (MissingResourceException e) { label=""Exit""; } // fallback\n// Create the control, e.g., new JButton(label);\nThis may seem quite a bit of code for one control, but you can write a convenience\nroutine to simplify it, like this:\nJButton exitButton = I18NUtil.getButton(""exit.label"", ""Exit"");\nThe file I18NUtil.java  is included in the book’s code distribution.\nWhile the example is a Swing JButton , the same approach goes with other UIs, such\nas the web tier. In JSF, for example, you might place your strings in a properties file\ncalled resources.properties  and store it in src/main/resources . Y ou would load this in\nfaces-config.xml :\n  <application>\n    <locale-config>\n        <default-locale> en</default-locale>\n        <supported-locale> en</supported-locale>\n        <supported-locale> es</supported-locale>\n        <supported-locale> fr</supported-locale>\n    </locale-config>\n    <resource-bundle>\n        <base-name> resources </base-name>\n        <var>msg</var>\n    </resource-bundle>\n  </application>\nThen in each web page that needs these strings, refer to the resource using the msg\nvariable in an expression:\n// In signup.xhtml:\n<h:outputText  value=""#{msg.prompt_firstname}"" />\n<h:inputText  required= ""true"" id=""firstName""  value=""#{person.firstName}""  />\nWhat happens at runtime?\nThe default locale is used, because we didn’t specify one. The default locale is platform\ndependent:\nUnix/POSIX\nLANG environment variable (per user)\nWindows\nControl Panel→Regional Settings\nmacOS\nSystem Preferences→Language & Text\n86 | Chapter 3: Strings and Things\nOthers\nSee platform documentation\nResourceBundle.getBundle()  locates a file with the named resource bundle name\n(Menus , in the previous example), plus an underscore and the locale name (if a non-\ndefault locale is set), plus another underscore and the locale variation (if any variation\nis set), plus the extension .properties . If a variation is set but the file can’t be found, it\nfalls back to just the country code. If that can’t be found, it falls back to the original\ndefault. Table 3-2  shows some examples for various locales.\nNote that Android apps—usually written in Java or Kotlin—use a similar mechanism\nbut with the files in XML format instead of Java Properties and with some small\nchanges in the name of the file in which the properties files are found.\nTable 3-2. Property filenames  for different  locales\nLocale Filename\nDefault locale Menus.Properties\nSwedish Menus_sv.properties\nSpanish Menus_es.properties\nFrench Menus_fr.properties\nFrench-Canadian Menus_fr_CA.properties\nLocale names are two-letter ISO-639 language codes (lowercase), and they normally\nabbreviate the country’s endonym  (the name its language speakers refer to it by); thus,\nSweden is sv for Sverige , Spain is es for Espanol , etc. Locale variations are two-letter\nISO country codes (uppercase); for example, e.g., CA for Canada, US for the United\nStates, SV for Sweden, ES for Spain, etc.\nSetting the locale\nOn Windows, go into Regional Settings in the Control Panel. Changing this setting\nmay entail a reboot, so exit any editor windows.\nOn Unix, set your LANG  environment variable. For example, a Korn shell user in Mex‐\nico might have this line in her .profile :\nexport LANG=es_MX\nOn either system, for testing a different locale, you need only define the locale in the\nSystem Properties at runtime using the command-line option -D, as in:\njava -Duser.language=es i18n.Browser\nThis runs the Java program named Browser  in package i18n  in the Spanish locale.\n3.11 Creating a Message with I18N Resources | 87",5166
122-3.12 Using a Particular Locale.pdf,122-3.12 Using a Particular Locale,,0
123-Problem.pdf,123-Problem,,0
124-Solution.pdf,124-Solution,,0
125-3.13 Creating a Resource Bundle.pdf,125-3.13 Creating a Resource Bundle,"Y ou can get a list of the available locales with a call to Locale.getAvailable\nLocales() .\n3.12 Using a Particular Locale\nProblem\nY ou want to use a locale other than the default in a particular operation.\nSolution\nObtain a Locale  by using a predefined instance or the Locale  constructor. Optionally\nmake it global to your application by using Locale.setDefault(newLocale) .\nDiscussion\nClasses that provide formatting services, such as DateTimeFormatter  and NumberFor\nmat, provide overloads so they can be called either with or without a Locale -related\nargument.\nTo obtain a Locale  object, you can employ one of the predefined locale variables pro‐\nvided by the Locale  class, or you can construct your own Locale  object giving a lan‐\nguage code and a country code:\nLocale locale1 = Locale.FRANCE;    // predefined\nLocale locale2 = new Locale(""en"", ""UK"");    // English, UK version\nThese can then be used in the various formatting operations:\nDateFormat frDateFormatter = DateFormat.getDateInstance(\n  DateFormat.MEDIUM, frLocale);\nDateFormat ukDateFormatter = DateFormat.getDateInstance(\n  DateFormat.MEDIUM, ukLocale);\nEither of these can be used to format a date or a number, as shown in class Use\nLocales :\npackage i18n;\nimport java.time.LocalDateTime ;\nimport java.time.format.DateTimeFormatter ;\nimport java.time.format.FormatStyle ;\nimport java.util.Locale ;\n/** Use some locales; based on user's OS ""settings""\n * choices or -Duser.lang= or -Duser.region=.\n */\npublic class UseLocales  {\n    public static void main(String[] args) {\n88 | Chapter 3: Strings and Things",1615
126-Problem.pdf,126-Problem,,0
127-Discussion.pdf,127-Discussion,"Locale frLocale  = Locale.FRANCE;    // predefined\n        Locale ukLocale  = new Locale(""en"", ""UK"");    // English, UK version\n        DateTimeFormatter  defaultDateFormatter  =\n            DateTimeFormatter .ofLocalizedDateTime (\n                FormatStyle .MEDIUM);\n        DateTimeFormatter  frDateFormatter  =\n            DateTimeFormatter .ofLocalizedDateTime (\n                FormatStyle .MEDIUM).localizedBy (frLocale );\n        DateTimeFormatter  ukDateFormatter  =\n            DateTimeFormatter .ofLocalizedDateTime (\n                FormatStyle .MEDIUM).localizedBy (ukLocale );\n        LocalDateTime  now = LocalDateTime .now();\n        System.out.println(""Default: ""  + ' ' +\n            now.format(defaultDateFormatter ));\n        System.out.println(frLocale .getDisplayName () + ' ' +\n            now.format(frDateFormatter ));\n        System.out.println(ukLocale .getDisplayName () + ' ' +\n            now.format(ukDateFormatter ));\n    }\n}\nThe program prints the locale name and formats the date in each of the locales:\n$ java i18n.UseLocales\nDefault:  Oct 16, 2019, 4:41:45 PM\nFrench (France) 16 oct. 2019 à 16:41:45\nEnglish (UK) Oct 16, 2019, 4:41:45 PM$\n3.13 Creating a Resource Bundle\nProblem\nY ou need to create a resource bundle for use with I18N.\nSolution\nA resource bundle is simply a collection of names and values. Y ou could write a\njava.util.ResourceBundle  subclass, but it is easier to create textual Properties  files\n(see Recipe 7.10 ) that you then load with ResourceBundle.getBundle() . The files\ncan be created using any plain text editor. Leaving it in a text file format also allows\nuser customization in desktop applications; a user whose language is not provided\nfor, or who wishes to change the wording somewhat due to local variations in dialect,\nshould be able to edit the file.\n3.13 Creating a Resource Bundle | 89",1896
128-3.14 Program A Simple Text Formatter.pdf,128-3.14 Program A Simple Text Formatter,"Note that the resource bundle text file should not have the same name as any of your\nJava classes. The reason is that the ResourceBundle  constructs a class dynamically\nwith the same name as the resource files.\nDiscussion\nHere is a sample properties file for a few menu items:\n# Default Menu properties\n# The File Menu\nfile.label=File Menu\nfile.new.label=New File\nfile.new.key=N\nfile.save.label=Save\nfile.new.key=S\nCreating the default properties file is usually not a problem, but creating properties\nfiles for other languages might be. Unless you are a large multinational corporation,\nyou will probably not have the resources (pardon the pun) to create resource files in-\nhouse. If you are shipping commercial software or using the web for global reach, you\nneed to identify your target markets and understand which of these are most sensitive\nto wanting menus and the like in their own languages. Then, hire a professional\ntranslation service that has expertise in the required languages to prepare the files.\nTest them well before you ship, as you would any other part of your software.\nIf you need special characters, multiline text, or other complex entry, remember that\na ResourceBundle  is also a Properties  file, so see the documentation for\njava.util.Properties .\n3.14 Program: A Simple Text Formatter\nThis program is a primitive text formatter, representative of what people used on\nmost computing platforms before the rise of standalone graphics-based word pro‐\ncessors, laser printers, and, eventually, desktop publishing and office suites. It simply\nreads words from a file, previously created with a text editor, and outputs them until\nit reaches the right margin, when it calls println()  to append a line ending. For\nexample, here is an input file:\nIt's a nice\nday, isn't it, Mr. Mxyzzptllxy?\nI think we should\ngo for a walk.\nGiven that file as the input, the Fmt program prints the lines formatted neatly:\nIt's a nice day, isn't it, Mr. Mxyzzptllxy? I think we should go for a\nwalk.\n90 | Chapter 3: Strings and Things\nAs you can see, it fits the text we gave it to the margin and discards all the line breaks\npresent in the original. Here’s the code:\npublic class Fmt {\n    /** The maximum column width */\n    public static final int COLWIDTH =72;\n    /** The file that we read and format */\n    final BufferedReader  in;\n    /** Where the output goes */\n    PrintWriter  out;\n    /** If files present, format each one, else format the standard input. */\n    public static void main(String[] av) throws IOException  {\n        if (av.length == 0)\n            new Fmt(System.in).format();\n        else for (String name : av) {\n            new Fmt(name).format();\n        }\n    }\n    public Fmt(BufferedReader  inFile, PrintWriter  outFile) {\n        this.in = inFile;\n        this.out = outFile;\n    }\n    public Fmt(PrintWriter  out) {\n        this(new BufferedReader (new InputStreamReader (System.in)), out);\n    }\n    /** Construct a Formatter given an open Reader */\n    public Fmt(BufferedReader  file) throws IOException  {\n        this(file, new PrintWriter (System.out));\n    }\n    /** Construct a Formatter given a filename */\n    public Fmt(String fname) throws IOException  {\n        this(new BufferedReader (new FileReader (fname)));\n    }\n    /** Construct a Formatter given an open Stream */\n    public Fmt(InputStream  file) throws IOException  {\n        this(new BufferedReader (new InputStreamReader (file)));\n    }\n    /** Format the File contained in a constructed Fmt object */\n    public void format() throws IOException  {\n        format(in.lines(), out);\n    }\n    /** Format a Stream of lines, e.g., bufReader.lines() */\n    public static void format(Stream<String> s, PrintWriter  out) {\n        StringBuilder  outBuf = new StringBuilder ();\n3.14 Program: A Simple Text Formatter | 91",3909
129-3.15 Program Soundex Name Comparisons.pdf,129-3.15 Program Soundex Name Comparisons,"s.forEachOrdered ((line -> {\n            if (line.length() == 0) {    // null line\n                out.println(outBuf);    // end current line\n                out.println();    // output blank line\n                outBuf.setLength (0);\n            } else {\n                // otherwise it's text, so format it.\n                StringTokenizer  st = new StringTokenizer (line);\n                while (st.hasMoreTokens ()) {\n                    String word = st.nextToken ();\n                    // If this word would go past the margin,\n                    // first dump out anything previous.\n                    if (outBuf.length() + word.length() > COLWIDTH ) {\n                        out.println(outBuf);\n                        outBuf.setLength (0);\n                    }\n                    outBuf.append(word).append(' ');\n                }\n            }\n        }));\n        if (outBuf.length() > 0) {\n            out.println(outBuf);\n        } else {\n            out.println();\n        }\n    }\n}\nA slightly fancier version of this program, Fmt2 , is in the online source for this book.\nIt uses dot commands —lines beginning with periods—to give limited control over the\nformatting. A family of dot-command formatters includes Unix’s roff, nroff,  troff, and\ngroff , which are in the same family with programs called runoff  on Digital Equipment\nsystems. The original for this is J. Saltzer’s runoff , which first appeared on Multics and\nfrom there made its way into various OSes. To save trees, I did not include Fmt2  here;\nit subclasses Fmt and overrides the format()  method to include additional function‐\nality (the source code is in the full javasrc  repository for the book).\n3.15 Program: Soundex Name Comparisons\nThe difficulties in comparing American-style names inspired the US Census Bureau\nto develop the Soundex algorithm in the early 1900s. Each of a given set of conso‐\nnants maps to a particular number, the effect being to map similar-sounding names\ntogether, on the grounds that in those days many people were illiterate and could not\nspell their family names consistently. But it is still useful today, for example, in a\ncompany-wide telephone book application. The names Darwin and Derwin map to\n92 | Chapter 3: Strings and Things\n6In Unix terminology, a daemon is a server. The old English word has nothing to do with satanic demons but\nrefers to a helper or assistant. Derwin Daemon was actually a character in Susannah Coleman’s Source Wars\nonline comic strip, which long ago was online at a now-departed site called darby.daemonnews.org .D650, and Darwent maps to D653, which puts it adjacent to D650. All of these are\nbelieved to be historical variants of the same name. Suppose we needed to sort lines\ncontaining these names together: if we could output the Soundex numbers at the\nbeginning of each line, this would be easy. Here is a simple demonstration of the\nSoundex  class:\npublic class SoundexSimple  {\n    /** main */\n    public static void main(String[] args) {\n        String[] names = {\n            ""Darwin, Ian"" ,\n            ""Davidson, Greg"" ,\n            ""Darwent, William"" ,\n            ""Derwin, Daemon""\n        };\n        for (String name : names) {\n            System.out.println(Soundex.soundex(name) + ' ' + name);\n        }\n    }\n}\nLet’s run it:\n> javac -d . SoundexSimple.java\n> java strings.SoundexSimple | sort\nD132 Davidson, Greg\nD650 Darwin, Ian\nD650 Derwin, Daemon\nD653 Darwent, William\n>\nAs you can see, the Darwin-variant names (including Daemon Derwin6) all sort\ntogether and are distinct from the Davidson (and Davis, Davies, etc.) names that nor‐\nmally appear between Darwin and Derwin when using a simple alphabetic sort. The\nSoundex algorithm has done its work.\nHere is the Soundex  class itself—it uses String s and StringBuilder s to convert\nnames into Soundex codes:\nmain/src/main/java/strings/Soundex.java\npublic class Soundex {\n    static boolean debug = false;\n3.15 Program: Soundex Name Comparisons | 93\n    /* Implements the mapping\n     * from: AEHIOUWYBFPVCGJKQSXZDTLMNR\n     * to:   00000000111122222222334556\n     */\n    public static final char[] MAP = {\n        //A  B   C   D   E   F   G   H   I   J   K   L   M\n        '0','1','2','3','0','1','2','0','0','2','2','4','5',\n        //N  O   P   W   R   S   T   U   V   W   X   Y   Z\n        '5','0','1','2','6','2','3','0','1','0','2','0','2'\n    };\n    /** Convert the given String to its Soundex code.\n     * @return null If the given string can't be mapped to Soundex.\n     */\n    public static String soundex(String s) {\n        // Algorithm works on uppercase (mainframe era).\n        String t = s.toUpperCase ();\n        StringBuilder  res = new StringBuilder ();\n        char c, prev = '?', prevOutput  = '?';\n        // Main loop: find up to 4 chars that map.\n        for (int i=0; i<t.length() && res.length() < 4 &&\n            (c = t.charAt(i)) != ','; i++) {\n            // Check to see if the given character is alphabetic.\n            // Text is already converted to uppercase. Algorithm\n            // only handles ASCII letters, do NOT use Character.isLetter()!\n            // Also, skip double letters.\n            if (c>='A' && c<='Z' && c != prev) {\n                prev = c;\n                // First char is installed unchanged, for sorting.\n                if (i==0) {\n                    res.append(c);\n                } else {\n                    char m = MAP[c-'A'];\n                    if (debug) {\n                        System.out.println(c + "" --> "" + m);\n                    }\n                    if (m != '0' && m != prevOutput ) {\n                        res.append(m);\n                        prevOutput  = m;\n                    }\n                }\n            }\n        }\n        if (res.length() == 0)\n            return null;\n        for (int i=res.length(); i<4; i++)\n            res.append('0');\n94 | Chapter 3: Strings and Things",6029
130-See Also.pdf,130-See Also,"return res.toString ();\n    }\nThere are apparently some nuances of the full Soundex algorithm that are not imple‐\nmented by this application. A more complete test using JUnit (see Recipe 1.10 ) is also\nonline as SoundexTest.java , in the src/tests/java/strings  directory. The dedicated reader\nmay use this to provoke failures of such nuances and send a pull request with updated\nversions of the test and the code.\nSee Also\nThe Levenshtein string edit distance algorithm can be used for doing approximate\nstring comparisons in a different fashion. Y ou can find this in  Apache Commons\nStringUtils . I show a non-Java (Perl) implementation of this algorithm in Recipe 18.5 . \n3.15 Program: Soundex Name Comparisons | 95",730
131-Chapter 4. Pattern Matching with Regular Expressions.pdf,131-Chapter 4. Pattern Matching with Regular Expressions,,0
132-4.0 Introduction.pdf,132-4.0 Introduction,"CHAPTER 4\nPattern Matching with Regular Expressions\n4.0 Introduction\nSuppose you have been on the internet for a few years and have been faithful about\nsaving all your correspondence, just in case you (or your lawyers, or the prosecution)\nneed a copy. The result is that you have a 5 GB disk partition dedicated to saved mail.\nLet’s further suppose that you remember that somewhere in there is an email message\nfrom someone named Angie or Anjie. Or was it Angy? But you don’t remember what\nyou called it or where you stored it. Obviously, you have to look for it.\nBut while some of you go and try to open up all 15,000,000 documents in a word pro‐\ncessor, I’ll just find it with one simple command. Any system that provides regular\nexpression support allows me to search for the pattern in several ways. The simplest\nto understand is:\nAngie|Anjie|Angy\nwhich you can probably guess means just to search for any of the variations. A more\nconcise form (more thinking, less typing) is:\nAn[^ dn]\nThe syntax will become clear as we go through this chapter. Briefly, the “ A ” and the\n“n” match themselves, in effect finding words that begin with “ An” , while the cryptic\n[^ dn]  requires the “ An” to be followed by a character other than ( ^ means not in this\ncontext) a space (to eliminate the very common English word “an” at the start of a\nsentence) or “d” (to eliminate the common word “and”) or “n” (to eliminate “ Anne, ”\n“ Announcing, ” etc.). Has your word processor gotten past its splash screen yet? Well,\nit doesn’t matter, because I’ve already found the missing file. To find the answer, I just\ntyped this command:\ngrep 'An[^ dn]' *\n97\n6Non-Unix fans fear not, for you can use tools like grep on Windows systems using one of several packages.\nOne is an open source package alternately called CygWin (after Cygnus Software) or GnuWin32 . Another is\nMicrosoft’s findstr  command for Windows. Or you can use my Grep  program in Recipe 4.6  if you don’t have\ngrep on your system. Incidentally, the name grep comes from an ancient Unix line editor command g/RE/p ,\nthe command to find the regex globally in all lines in the edit buffer and print the lines that match—just what\nthe grep program does to lines in files.Regular expressions , or regexes  for short, provide a concise and precise specification of\npatterns to be matched in text. One good way to think of regular expressions is as a\nlittle language for matching patterns of characters in text contained in strings. A reg‐\nular expression API is an interpreter  for matching regular expressions.\nAs another example of the power of regular expressions, consider the problem of\nbulk-updating hundreds of files. When I started with Java, the syntax for declaring\narray references was baseType arrayVariableName[] . For example, a method with\nan array argument, such as every program’s main method, was commonly written like\nthis:\npublic static void main(String args[]) {\nBut as time went by, it became clear to the stewards of the Java language that it would\nbe better to write it as baseType[] arrayVariableName , like this:\npublic static void main(String[] args) {\nThis is better Java style because it associates the “array-ness” of the type with the type\nitself, rather than with the local argument name, and the compiler still accepts both\nmodes. I wanted to change all occurrences of main  written the old way to the new\nway. I used the pattern main(String [a-z]  with the grep utility described earlier to\nfind the names of all the files containing old-style main declarations (i.e.,\nmain(String  followed by a space and a name character rather than an open square\nbracket). I then used another regex-based Unix tool, the stream editor sed, in a little\nshell script to change all occurrences in those files from main(String *([a-z][a-\nz]*)[]  to main(String[] $1  (the regex syntax used here is discussed later in this\nchapter). Again, the regex-based approach was orders of magnitude faster than doing\nit interactively, even using a reasonably powerful editor such as vi or emacs , let alone\ntrying to use a graphical word processor.\nHistorically, the syntax of regexes has changed as they get incorporated into more\ntools and more languages, so the exact syntax in the previous examples is not exactly\nwhat you’ d use in Java, but it does convey the conciseness and power of the regex\nmechanism.6\nAs a third example, consider parsing an Apache web server logfile, where some fields\nare delimited with quotes, others with square brackets, and others with spaces.\nWriting  ad hoc code to parse this is messy in any language, but a well-crafted regex\n98 | Chapter 4: Pattern Matching with Regular Expressions",4737
133-See Also.pdf,133-See Also,,0
134-4.1 Regular Expression Syntax.pdf,134-4.1 Regular Expression Syntax,,0
135-Problem.pdf,135-Problem,,0
136-Solution.pdf,136-Solution,,0
137-Discussion.pdf,137-Discussion,"can break the line into all its constituent fields in one operation (this example is\ndeveloped in Recipe 4.10 ).\nThese same time gains can be had by Java developers. Regular expression support has\nbeen in the standard Java runtime for ages and is well integrated (e.g., there are regex\nmethods in the standard class java.lang.String  and in the new I/O package). There\nare a few other regex packages for Java, and you may occasionally encounter code\nusing them, but pretty well all code from this century can be expected to use the\nbuilt-in package. The syntax of Java regexes themselves is discussed in Recipe 4.1 , and\nthe syntax of the Java API for using regexes is described in Recipe 4.2 . The remaining\nrecipes show some applications of regex technology in Java.\nSee Also\nMastering Regular Expressions  by Jeffrey Friedl (O’Reilly) is the definitive guide to all\nthe details of regular expressions. Most introductory books on Unix and Perl include\nsome discussion of regexes; Unix Power Tools  by Mike Loukides, Tim O’Reilly, Jerry\nPeek, and Shelley Powers (O’Reilly) devotes a chapter to them.\n4.1 Regular Expression Syntax\nProblem\nY ou need to learn the syntax of Java regular expressions.\nSolution\nConsult Table 4-1  for a list of the regular expression characters.\nDiscussion\nThese pattern characters let you specify regexes of considerable power. In building\npatterns, you can use any combination of ordinary text and the metacharacters , or\nspecial characters, in Table 4-1 . These can all be used in any combination that makes\nsense. For example, a+ means any number of occurrences of the letter a, from one up\nto a million or a gazillion. The pattern Mrs? \. matches Mr. or Mrs.  And .* indicates\nany character, any number of times, and is similar in meaning to most command-line\ninterpreters’ meaning of the \* alone. The pattern \d+ means any number of numeric\ndigits. \d{2,3}  means a two- or three-digit number.\n4.1 Regular Expression Syntax | 99\nTable 4-1. Regular expression metacharacter syntax\nSubexpression Matches Notes\nGeneral\n\^ Start of line/string\n$ End of line/string\n\b Word boundary\n\B Not a word boundary\n\A Beginning of entire string\n\z End of entire string\n\Z End of entire string (except allowable final  line\nterminator)See Recipe 4.9\n. Any one character (except line terminator)\n[…] “Character class”; any one character from those listed\n[\^…] Any one character not from those listed See Recipe 4.2\nAlternation and grouping\n(…) Grouping (capture groups) See Recipe 4.3\n| Alternation\n(?:_re_ ) Noncapturing parenthesis\n\G End of the previous match\n+\+n Back-reference to capture group number n\nNormal (greedy)\nquantifiers\n{ m,n } Quantifier  for from m to n repetitions See Recipe 4.4\n{ m ,} Quantifier  for m or more repetitions\n{ m } Quantifier  for exactly m repetitions See Recipe 4.10\n{,n } Quantifier  for 0 up to n repetitions\n\* Quantifier  for 0 or more repetitions Short for {0,}\n+ Quantifier  for 1 or more repetitions Short for {1,} ; see Recipe 4.2\n? Quantifier  for 0 or 1 repetitions (i.e., present exactly\nonce, or not at all)Short for {0,1}\nReluctant (nongreedy)\nquantifiers\n{ m,n }? Reluctant quantifier  for from m to n repetitions\n{ m ,}? Reluctant quantifier  for m or more repetitions\n{,n }? Reluctant quantifier  for 0 up to n repetitions\n\*? Reluctant quantifier:  0 or more\n+? Reluctant quantifier:  1 or more See Recipe 4.10\n?? Reluctant quantifier:  0 or 1 times\n100 | Chapter 4: Pattern Matching with Regular Expressions\nSubexpression Matches Notes\nPossessive (very greedy)\nquantifiers\n{ m,n }+ Possessive quantifier  for from m to n repetitions\n{ m ,}+ Possessive quantifier  for m or more repetitions\n{,n }+ Possessive quantifier  for 0 up to n repetitions\n\*+ Possessive quantifier:  0 or more\n++ Possessive quantifier:  1 or more\n?+ Possessive quantifier:  0 or 1 times\nEscapes and shorthands\n\ Escape (quote) character: turns most metacharacters off;\nturns subsequent alphabetic into metacharacters\n\Q Escape (quote) all characters up to \E\n\E Ends quoting begun with \Q\n\t Tab character\n\r Return (carriage return) character\n\n Newline character See Recipe 4.9\n\f Form feed\n\w Character in a word Use \w+  for a word; see Recipe\n4.10\n\W A nonword character\n\d Numeric digit Use \d+  for an integer; see\nRecipe 4.2\n\D A nondigit character\n\s Whitespace Space, tab, etc., as determined\nby java.lang.Charac\nter.isWhitespace()\n\S A nonwhitespace character See Recipe 4.10\nUnicode blocks\n(representative samples)\n\p{InGreek} A character in the Greek block (Simple block)\n\P{InGreek} Any character not in the Greek block\n\p{Lu} An uppercase letter (Simple category)\n\p{Sc} A currency symbol\nPOSIX-style character\nclasses (defined  only for\nUS-ASCII)\n\p{Alnum} Alphanumeric characters [A-Za-z0-9]\n\p{Alpha} Alphabetic characters [A-Za-z]\n\p{ASCII} Any ASCII character [\x00-\x7F]\n4.1 Regular Expression Syntax | 101\n6REDemo was inspired by (but does not use any code from) a similar program provided with the now-retired\nApache Jakarta Regular Expressions package.Subexpression Matches Notes\n\p{Blank} Space and tab characters\n\p{Space} Space characters [ \t\n\x0B\f\r]\n\p{Cntrl} Control characters [\x00-\x1F\x7F]\n\p{Digit} Numeric digit characters [0-9]\n\p{Graph} Printable and visible characters (not spaces or control\ncharacters)\n\p{Print} Printable characters Same as \p{Graph}\n\p{Punct} Punctuation characters One of !""#$%&'()\*\n+,-./:;<=>?@[]\^_`{|}\n\~\n\p{Lower} Lowercase characters [a-z]\n\p{Upper} Uppercase characters [A-Z]\n\p{XDigit} Hexadecimal digit characters [0-9a-fA-F]\nRegexes match any place possible in the string. Patterns followed by greedy quanti‐\nfiers (the only type that existed in traditional Unix regexes) consume (match) as\nmuch as possible without compromising any subexpressions that follow. Patterns fol‐\nlowed by possessive quantifiers match as much as possible without regard to follow‐\ning subexpressions. Patterns followed by reluctant quantifiers consume as few charac‐\nters as possible to still get a match.\nAlso, unlike regex packages in some other languages, the Java regex package was\ndesigned to handle Unicode characters from the beginning. The standard Java escape\nsequence \u+nnnn  is used to specify a Unicode character in the pattern. We use meth‐\nods of java.lang.Character  to determine Unicode character properties, such as\nwhether a given character is a space. Again, note that the backslash must be doubled\nif this is in a Java string that is being compiled because the compiler would otherwise\nparse this as “backslash-u” followed by some numbers.\nTo help you learn how regexes work, I provide a little program called REDemo.6 The\ncode for REDemo is too long to include in the book; in the online directory regex  of\nthe darwinsys-api  repo, you will find REDemo.java , which you can run to explore\nhow regexes work.\nIn the uppermost text box (see Figure 4-1 ), type the regex pattern you want to test.\nNote that as you type each character, the regex is checked for syntax; if the syntax is\nOK, you see a checkmark beside it. Y ou can then select Match, Find, or Find All.\nMatch means that the entire string must match the regex, and Find means the regex\n102 | Chapter 4: Pattern Matching with Regular Expressions\nmust be found somewhere in the string (Find All counts the number of occurrences\nthat are found). Below that, you type a string that the regex is to match against.\nExperiment to your heart’s content. When you have the regex the way you want it,\nyou can paste it into your Java program. Y ou’ll need to escape (backslash) any charac‐\nters that are treated specially by both the Java compiler and the Java regex package,\nsuch as the backslash itself, double quotes, and others. Once you get a regex the way\nyou want it, there is a Copy button (not shown in these screenshots) to export the\nregex to the clipboard, with or without backslash doubling, depending on how you\nwant to use it.\nRemember that because a regex is entered as a string that will be\ncompiled by a Java compiler, you usually need two levels of escap‐\ning for any special characters, including backslash and double\nquotes. For example, the regex (which includes the double quotes):\n""You said it\.""\nhas to be typed like this to be a valid compile-time Java language\nString :\nString pattern = ""\""You said it\\.\""""\nIn Java 14+ you could also use a text block to avoid escaping the\nquotes:\nString pattern = """"""\n ""You said it\\.""""""""\nI can’t tell you how many times I’ve made the mistake of forgetting\nthe extra backslash in \d+, \w+, and their kin!\nIn Figure 4-1 , I typed qu into the REDemo  program’s Pattern box, which is a syntacti‐\ncally valid regex pattern: any ordinary characters stand as regexes for themselves, so\nthis looks for the letter q followed by u. In the top version, I typed only a q into the\nstring, which is not matched. In the second, I have typed quack  and the q of a second\nquack . Because I have selected Find All, the count shows one match. As soon as I type\nthe second u, the count is updated to two, as shown in the third version.\nRegexes can do far more than just character matching. For example, the two-\ncharacter regex ^T would match beginning of line ( ^) immediately followed by a capi‐\ntal T—that is, any line beginning with a capital T. It doesn’t matter whether the line\nbegins with “Tiny trumpets, ” “Titanic tubas, ” or “Triumphant twisted trombones, ” as\nlong as the capital T is present in the first position.\nBut here we’re not very far ahead. Have we really invested all this effort in regex tech‐\nnology just to be able to do what we could already do with the java.lang.String\nmethod startsWith() ? Hmmm, I can hear some of you getting a bit restless. Stay in\nyour seats! What if you wanted to match not only a letter T in the first position, but\n4.1 Regular Expression Syntax | 103\nalso a vowel immediately after it, followed by any number of letters in a word, fol‐\nlowed by an exclamation point? Surely you could do this in Java by checking starts\nWith(""T"")  and charAt(1) == 'a' || charAt(1) == 'e' , and so on? Y es, but by the\ntime you did that, you’ d have written a lot of very highly specialized code that you\ncouldn’t use in any other application. With regular expressions, you can just give the\npattern ^T[aeiou]\w*! . That is, ^ and T as before, followed by a character class listing\nthe vowels, followed by any number of word characters ( \w*), followed by the excla‐\nmation point.\nFigure 4-1. REDemo with simple examples\n“But wait, there’s more!” as my late, great boss Yuri Rubinsky  used to say. What if you\nwant to be able to change the pattern you’re looking for at runtime ? Remember all\nthat Java code you just wrote to match T in column 1, plus a vowel, some word char‐\nacters, and an exclamation point? Well, it’s time to throw it out. Because this morning\nwe need to match Q, followed by a letter other than u, followed by a number of digits,\nfollowed by a period. While some of you start writing a new function to do that, the\nrest of us will just saunter over to the RegEx Bar & Grille, order a ^Q[^u]\d+\. . from\nthe bartender, and be on our way.\n104 | Chapter 4: Pattern Matching with Regular Expressions\nOK, if you want an explanation: the [^u]  means match any one character that is not\nthe character u. The \d+ means one or more numeric digits. The + is a quantifier\nmeaning one or more occurrences of what it follows, and \d is any one numeric digit.\nSo \d+ means a number with one, two, or more digits. Finally, the \.? Well, . by itself\nis a metacharacter. Most single metacharacters are switched off by preceding them\nwith an escape character. Not the Esc key on your keyboard, of course. The regex\nescape character is the backslash. Preceding a metacharacter like . with this escape\nturns off its special meaning, so we look for a literal period rather than any character.\nPreceding a few selected alphabetic characters (e.g., n, r, t, s, w) with escape turns\nthem into metacharacters. Figure 4-2  shows the ^Q[^u]\d+\..  regex in action. In the\nfirst frame, I have typed part of the regex as ^Q[^u . Because there is an unclosed\nsquare bracket, the Syntax OK flag is turned off; when I complete the regex, it will be\nturned back on. In the second frame, I have finished typing the regex, and I’ve typed\nthe data string as QA577  (which you should expect to match the $$^Q[^u]\d+$$  but\nnot the period since I haven’t typed it). In the third frame, I’ve typed the period so the\nMatches flag is set to Y es.\nFigure 4-2. REDemo with “Q not followed by u” example\n4.1 Regular Expression Syntax | 105",12788
138-4.2 Using Regexes in Java Test for a Pattern.pdf,138-4.2 Using Regexes in Java Test for a Pattern,,0
139-Problem.pdf,139-Problem,,0
140-Solution.pdf,140-Solution,,0
141-Discussion.pdf,141-Discussion,"Because backslashes need to be escaped when pasting the regex into Java code, the\ncurrent version of REDemo  has both a Copy Pattern  button, which copies the regex\nverbatim for use in documentation and in Unix commands, and a Copy Pattern\nBackslashed  button, which copies the regex to the clipboard with backslashes dou‐\nbled, for pasting into Java strings.\nBy now you should have at least a basic grasp of how regexes work in practice. The\nrest of this chapter gives more examples and explains some of the more powerful top‐\nics, such as capture groups. As for how regexes work in theory—and there are a lot of\ntheoretical details and differences among regex flavors—the interested reader is\nreferred to Mastering Regular Expressions . Meanwhile, let’s start learning how to write\nJava programs that use regular expressions.\n4.2 Using Regexes in Java: Test for a Pattern\nProblem\nY ou’re ready to get started using regular expression processing to beef up your Java\ncode by testing to see if a given pattern can match in a given string.\nSolution\nUse the Java Regular Expressions Package, java.util.regex .\nDiscussion\nThe good news is that the Java API for regexes is actually easy to use. If all you need is\nto find out whether a given regex matches a string, you can use the convenient \nboolean matches()  method of the String  class, which accepts a regex pattern in\nString  form as its argument:\nif (inputString .matches(stringRegexPattern )) {\n    // it matched... do something with it...\n}\nThis is, however, a convenience routine, and convenience always comes at a price. If\nthe regex is going to be used more than once or twice in a program, it is more effi‐\ncient to construct and use a Pattern  and its Matcher (s). A complete program con‐\nstructing a Pattern  and using it to match  is shown here:\npublic class RESimple  {\n    public static void main(String[] argv) {\n        String pattern = ""^Q[^u]\\d+\\."" ;\n        String[] input = {\n            ""QA777. is the next flight. It is on time."" ,\n            ""Quack, Quack, Quack!""\n        };\n106 | Chapter 4: Pattern Matching with Regular Expressions\n        Pattern p = Pattern.compile(pattern);\n        for (String in : input) {\n            boolean found = p.matcher(in).lookingAt ();\n            System.out.println(""'"" + pattern + ""'"" +\n            (found ? "" matches '""  : "" doesn't match '"" ) + in + ""'"");\n        }\n    }\n}\nThe java.util.regex  package contains two classes, Pattern  and Matcher , which\nprovide the public API shown in Example 4-1 .\nExample 4-1. Regex public API\n/**\n * The main public API of the java.util.regex package.\n */\npackage java.util.regex;\npublic final class Pattern {\n    // Flags values ('or' together)\n    public static final int\n        UNIX_LINES , CASE_INSENSITIVE , COMMENTS , MULTILINE ,\n        DOTALL, UNICODE_CASE , CANON_EQ ;\n    // No public constructors; use these Factory methods\n    public static Pattern compile(String patt);\n    public static Pattern compile(String patt, int flags);\n    // Method to get a Matcher for this Pattern\n    public Matcher matcher(CharSequence  input);\n    // Information methods\n    public String pattern();\n    public int flags();\n    // Convenience methods\n    public static boolean matches(String pattern, CharSequence  input);\n    public String[] split(CharSequence  input);\n    public String[] split(CharSequence  input, int max);\n}\npublic final class Matcher {\n    // Action: find or match methods\n    public boolean matches();\n    public boolean find();\n    public boolean find(int start);\n    public boolean lookingAt ();\n    // ""Information about the previous match"" methods\n    public int start();\n    public int start(int whichGroup );\n    public int end();\n4.2 Using Regexes in Java: Test for a Pattern | 107\n    public int end(int whichGroup );\n    public int groupCount ();\n    public String group();\n    public String group(int whichGroup );\n    // Reset methods\n    public Matcher reset();\n    public Matcher reset(CharSequence  newInput );\n    // Replacement methods\n    public Matcher appendReplacement (StringBuffer  where, String newText);\n    public StringBuffer  appendTail (StringBuffer  where);\n    public String replaceAll (String newText);\n    public String replaceFirst (String newText);\n    // information methods\n    public Pattern pattern();\n}\n/* String, showing only the RE-related methods */\npublic final class String {\n    public boolean matches(String regex);\n    public String replaceFirst (String regex, String newStr);\n    public String replaceAll (String regex, String newStr);\n    public String[] split(String regex);\n    public String[] split(String regex, int max);\n}\nThis API is large enough to require some explanation. These are the normal steps for\nregex matching in a production program:\n1.Create a Pattern  by calling the static method Pattern.compile() .\n2.Request a Matcher  from the pattern by calling pattern.matcher(CharSequence)\nfor each String  (or other CharSequence ) you wish to look through.\n3.Call (once or more) one of the finder methods (discussed later in this section) in\nthe resulting Matcher .\nThe java.lang.CharSequence  interface provides simple read-only access to objects\ncontaining a collection of characters. The standard implementations are String  and\nStringBuffer /StringBuilder  (described in Chapter 3 ), and the new I/O class\njava.nio.CharBuffer .\nOf course, you can perform regex matching in other ways, such as using the conve‐\nnience methods in Pattern  or even in java.lang.String , like this:\npublic class StringConvenience  {\n    public static void main(String[] argv) {\n        String pattern = "".*Q[^u]\\d+\\..*"" ;\n        String line = ""Order QT300. Now!"" ;\n        if (line.matches(pattern)) {\n            System.out.println(line + "" matches \""""  + pattern + ""\"""");\n108 | Chapter 4: Pattern Matching with Regular Expressions",5975
142-4.3 Finding the Matching Text.pdf,142-4.3 Finding the Matching Text,,0
143-Solution.pdf,143-Solution,"} else {\n            System.out.println(""NO MATCH"" );\n        }\n    }\n}\nBut the three-step list is the standard pattern for matching. Y ou’ d likely use the\nString  convenience routine in a program that only used the regex once; if the regex\nwere being used more than once, it is worth taking the time to compile it because the\ncompiled version runs faster.\nIn addition, the Matcher  has several finder methods, which provide more flexibility\nthan the String  convenience routine match() . These are the Matcher  methods:\nmatch()\nUsed to compare the entire string against the pattern; this is the same as the rou‐\ntine in java.lang.String . Because it matches the entire String , I had to put .*\nbefore and after the pattern.\nlookingAt()\nUsed to match the pattern only at the beginning of the string.\nfind()\nUsed to match the pattern in the string (not necessarily at the first character of\nthe string), starting at the beginning of the string or, if the method was previously\ncalled and succeeded, at the first character not matched by the previous match.\nEach of these methods returns boolean , with true  meaning a match and false\nmeaning no match. To check whether a given string matches a given pattern, you\nneed only type something like the following:\nMatcher m = Pattern.compile(patt).matcher(line);\nif (m.find( )) {\n    System.out.println(line + "" matches ""  + patt)\n}\nBut you may also want to extract the text that matched, which is the subject of the\nnext recipe.\nThe following recipes cover uses of the Matcher API. Initially, the examples just use\narguments of type String  as the input source. Use of other CharSequence  types is\ncovered in Recipe 4.5 .\n4.3 Finding the Matching Text\nProblem\nY ou need to find the text that the regex matched.\n4.3 Finding the Matching Text | 109\nSolution\nSometimes you need to know more than just whether a regex matched a string. In\neditors and many other tools, you want to know exactly what characters were\nmatched. Remember that with quantifiers such as *, the length of the text that was\nmatched may have no relationship to the length of the pattern that matched it. Do not\nunderestimate the mighty .*, which happily matches thousands or millions of char‐\nacters if allowed to. As you saw in the previous recipe, you can find out whether a\ngiven match succeeds just by using find()  or matches() . But in other applications,\nyou will want to get the characters that the pattern matched.\nAfter a successful call to one of the preceding methods, you can use these information\nmethods on the Matcher  to get information on the match:\nstart(), end()\nReturns the character position in the string of the starting and ending characters\nthat matched.\ngroupCount()\nReturns the number of parenthesized capture groups, if any; returns 0 if no\ngroups were used.\ngroup(int i)\nReturns the characters matched by group i of the current match, if i is greater\nthan or equal to zero and less than or equal to the return value of groupCount() .\nGroup 0 is the entire match, so group(0)  (or just group() ) returns the entire por‐\ntion of the input that matched.\nThe notion of parentheses, or capture groups, is central to regex processing. Regexes\nmay be nested to any level of complexity. The group(int)  method lets you retrieve\nthe characters that matched a given parenthesis group. If you haven’t used any explicit\nparens, you can just treat whatever matched as level zero. Example 4-2  shows part of\nREMatch.java .\nExample 4-2. Part of main/src/main/java/regex/REMatch.java\npublic class REmatch {\n    public static void main(String[] argv) {\n        String patt = ""Q[^u]\\d+\\."" ;\n        Pattern r = Pattern.compile(patt);\n        String line = ""Order QT300. Now!"" ;\n        Matcher m = r.matcher(line);\n        if (m.find()) {\n            System.out.println(patt + "" matches \""""  +\n                m.group(0) +\n                ""\"" in \""""  + line + ""\"""");\n110 | Chapter 4: Pattern Matching with Regular Expressions\n        } else {\n            System.out.println(""NO MATCH"" );\n        }\n    }\n}\nWhen run, this prints:\nQ[\^u]\d+\. matches ""QT300."" in ""Order QT300. Now!""\nWith the Match  button checked, REDemo provides a display of all the capture groups\nin a given regex; one example is shown in Figure 4-3 .\nFigure 4-3. REDemo in action\nIt is also possible to get the starting and ending indices and the length of the text that\nthe pattern matched (remember that terms with quantifiers, such as the \d+ in this\nexample, can match an arbitrary number of characters in the string). Y ou can use\nthese in conjunction with the String.substring()  methods as follows:\n        String patt = ""Q[^u]\\d+\\."" ;\n        Pattern r = Pattern.compile(patt);\n        String line = ""Order QT300. Now!"" ;\n        Matcher m = r.matcher(line);\n        if (m.find()) {\n            System.out.println(patt + "" matches \""""  +\n                line.substring (m.start(0), m.end(0)) +\n                ""\"" in \""""  + line + ""\"""");\n        } else {\n            System.out.println(""NO MATCH"" );\n        }\nSuppose you need to extract several items from a string. If the input is\nSmith, John\nAdams, John Quincy\nand you want to get out\nJohn Smith\nJohn Quincy Adams\n4.3 Finding the Matching Text | 111",5315
144-4.4 Replacing the Matched Text.pdf,144-4.4 Replacing the Matched Text,,0
145-Problem.pdf,145-Problem,,0
146-Solution.pdf,146-Solution,,0
147-Discussion.pdf,147-Discussion,"just use the following: \npublic class REmatchTwoFields  {\n    public static void main(String[] args) {\n        String inputLine  = ""Adams, John Quincy"" ;\n        // Construct an RE with parens to ""grab"" both field1 and field2\n        Pattern r = Pattern.compile(""(.*), (.*)"" );\n        Matcher m = r.matcher(inputLine );\n        if (!m.matches())\n            throw new IllegalArgumentException (""Bad input"" );\n        System.out.println(m.group(2) + ' ' + m.group(1));\n    }\n}\n4.4 Replacing the Matched Text\nProblem\nHaving found some text using a Pattern, you want to replace the text with different\ntext, without disturbing the rest of the string.\nSolution\nAs we saw in the previous recipe, regex patterns involving quantifiers can match a lot\nof characters with very few metacharacters. We need a way to replace the text that the\nregex matched without changing other text before or after it. We could do this man‐\nually using the String  method substring() . However, because it’s such a common\nrequirement, the Java Regular Expression API provides some substitution methods.\nDiscussion\nThe Matcher  class provides several methods for replacing just the text that matched\nthe pattern. In all these methods, you pass in the replacement text, or “righthand\nside, ” of the substitution (this term is historical: in a command-line text editor’s sub‐\nstitute command, the lefthand side is the pattern and the righthand side is the\nreplacement text). These are the replacement methods:\nreplaceAll(newString)\nReplaces all occurrences that matched with the new string\nreplaceFirst(newString)\nAs above but only the first occurence\nappendReplacement(StringBuffer, newString)\nCopies up to before the first match, plus the given newString\n112 | Chapter 4: Pattern Matching with Regular Expressions\nappendTail(StringBuffer)\nAppends text after the last match (normally used after appendReplacement )\nDespite their names, the replace*  methods behave in accord with the immutability\nof Strings  (see “Timeless, Immutable, and Unchangeable” on page 58): they create a\nnew String  object with the replacement performed; they do not (indeed, could not)\nmodify the string referred to in the Matcher  object.\nExample 4-3  shows use of these three methods.\nExample 4-3. main/src/main/java/regex/ReplaceDemo.java\n/**\n * Quick demo of RE substitution: correct U.S. 'favor'\n * to Canadian/British 'favour', but not in ""favorite""\n * @author Ian F. Darwin, http://www.darwinsys.com/\n */\npublic class ReplaceDemo  {\n    public static void main(String[] argv) {\n        // Make an RE pattern to match as a word only (\b=word boundary)\n        String patt = ""\\bfavor\\b"" ;\n        // A test input\n        String input = ""Do me a favor? Fetch my favorite."" ;\n        System.out.println(""Input: ""  + input);\n        // Run it from a RE instance and see that it works\n        Pattern r = Pattern.compile(patt);\n        Matcher m = r.matcher(input);\n        System.out.println(""ReplaceAll: ""  + m.replaceAll (""favour"" ));\n        // Show the appendReplacement method\n        m.reset();\n        StringBuffer  sb = new StringBuffer ();\n        System.out.print(""Append methods: "" );\n        while (m.find()) {\n            // Copy to before first match,\n            // plus the word ""favor""\n            m.appendReplacement (sb, ""favour"" );\n        }\n        m.appendTail (sb);        // copy remainder\n        System.out.println(sb.toString ());\n    }\n}\nSure enough, when you run it, it does what we expect:\nInput: Do me a favor? Fetch my favorite.\nReplaceAll: Do me a favour? Fetch my favorite.\nAppend methods: Do me a favour? Fetch my favorite.\n4.4 Replacing the Matched Text | 113\nThe replaceAll()  method handles the case of making the same change all through a\nstring. If you want to change each matching occurrence to a different value, you can\nuse replaceFirst()  in a loop, as in Example 4-4 . Here we make a pass through an\nentire string, turning each occurrence of either cat or dog into feline  or canine .\nThis is simplified from a real example that looked for bit.ly  URLs and replaced them\nwith the actual URL; the computeReplacement  method there used the network client\ncode from Recipe 12.1 .\nExample 4-4. main/src/main/java/regex/ReplaceMulti.java\n/**\n * To perform multiple distinct substitutions in the same String,\n * you need a loop, and must call reset() on the matcher.\n */\npublic class ReplaceMulti  {\n    public static void main(String[] args) {\n        Pattern patt = Pattern.compile(""cat|dog"" );\n        String line = ""The cat and the dog never got along well."" ;\n        System.out.println(""Input: ""  + line);\n        Matcher matcher = patt.matcher(line);\n        while (matcher.find()) {\n            String found = matcher.group(0);\n            String replacement  = computeReplacement (found);\n            line = matcher.replaceFirst (replacement );\n            matcher.reset(line);\n        }\n        System.out.println(""Final: ""  + line);\n    }\n    static String computeReplacement (String in) {\n        switch(in) {\n        case ""cat"": return ""feline"" ;\n        case ""dog"": return ""canine"" ;\n        default: return ""animal"" ;\n        }\n    }\n}\nIf you need to refer to portions of the occurrence that matched the regex, you can\nmark them with extra parentheses in the pattern and refer to the matching portion\nwith $1, $2, and so on in the replacement string. Example 4-5  uses this to interchange\ntwo fields, in this case, turn names in the form Firstname Lastname  into Lastname,\nFirstName .\n114 | Chapter 4: Pattern Matching with Regular Expressions",5668
148-4.5 Printing All Occurrences of a Pattern.pdf,148-4.5 Printing All Occurrences of a Pattern,,0
149-Problem.pdf,149-Problem,,0
150-Solution.pdf,150-Solution,"Example 4-5. main/src/main/java/regex/ReplaceDemo2.java\npublic class ReplaceDemo2  {\n    public static void main(String[] argv) {\n        // Make an RE pattern\n        String patt = ""(\\w+)\\s+(\\w+)"" ;\n        // A test input\n        String input = ""Ian Darwin"" ;\n        System.out.println(""Input: ""  + input);\n        // Run it from a RE instance and see that it works\n        Pattern r = Pattern.compile(patt);\n        Matcher m = r.matcher(input);\n        m.find();\n        System.out.println(""Replaced: ""  + m.replaceFirst (""$2, $1"" ));\n        // The short inline version:\n        // System.out.println(input.replaceFirst(""(\\w+)\\s+(\\w+)"", ""$2, $1""));\n    }\n}\n4.5 Printing All Occurrences of a Pattern\nProblem\nY ou need to find all the strings that match a given regex in one or more files or other\nsources.\nSolution\nThis example reads through a file one line at a time. Whenever a match is found, I\nextract it from the line  and print it.\nThis code takes the group()  methods from Recipe 4.3 , the substring  method from\nthe CharacterIterator  interface, and the match()  method from the regex and sim‐\nply puts them all together. I coded it to extract all the names from a given file; in run‐\nning the program through itself, it prints the words import , java , until , regex , and\nso on, each on its own line:\nC:\> java ReaderIter.java ReaderIter.java\nimport\njava\nutil\nregex\nimport\njava\nio\n4.5 Printing All Occurrences of a Pattern | 115\nPrint\nall\nthe\nstrings\nthat\nmatch\ngiven\npattern\nfrom\nfile\npublic\n...\nC:\\>\nI interrupted it here to save paper. This can be written two ways: a line-at-a-time pat‐\ntern shown in Example 4-6  and a more compact form using new I/O shown in\nExample 4-7  (the new I/O package used in both examples is described in Chapter 10 ).\nExample 4-6. main/src/main/java/regex/ReaderIter.java\npublic class ReaderIter  {\n    public static void main(String[] args) throws IOException  {\n        // The RE pattern\n        Pattern patt = Pattern.compile(""[A-Za-z][a-z]+"" );\n        // See the I/O chapter\n        // For each line of input, try matching in it.\n        Files.lines(Path.of(args[0])).forEach(line -> {\n            // For each match in the line, extract and print it.\n            Matcher m = patt.matcher(line);\n            while (m.find()) {\n                // Simplest method:\n                // System.out.println(m.group(0));\n                // Get the starting position of the text\n                int start = m.start(0);\n                // Get ending position\n                int end = m.end(0);\n                // Print whatever matched.\n                // Use CharacterIterator.substring(offset, end);\n                System.out.println(line.substring (start, end));\n            }\n        });\n    }\n}\nExample 4-7. main/src/main/java/regex/GrepNIO.java\npublic class GrepNIO {\n    public static void main(String[] args) throws IOException  {\n        if (args.length < 2) {\n116 | Chapter 4: Pattern Matching with Regular Expressions\n            System.err.println(""Usage: GrepNIO patt file [...]"" );\n            System.exit(1);\n        }\n        Pattern p=Pattern.compile(args[0]);\n        for (int i=1; i<args.length; i++)\n            process(p, args[i]);\n    }\n    static void process(Pattern pattern, String fileName ) throws IOException  {\n        // Get a FileChannel from the given file\n        FileInputStream  fis = new FileInputStream (fileName );\n        FileChannel  fc = fis.getChannel ();\n        // Map the file's content\n        ByteBuffer  buf = fc.map(FileChannel .MapMode.READ_ONLY , 0, fc.size());\n        // Decode ByteBuffer into CharBuffer\n        CharBuffer  cbuf =\n            Charset.forName(""ISO-8859-1"" ).newDecoder ().decode(buf);\n        Matcher m = pattern.matcher(cbuf);\n        while (m.find()) {\n            System.out.println(m.group(0));\n        }\n        fis.close();\n    }\n}\nThe non-blocking I/O (NIO) version shown in Example 4-7  relies on the fact that an\nNIO Buffer  can be used as a CharSequence . This program is more general in that the\npattern argument is taken from the command-line argument. It prints the same out‐\nput as the previous example if invoked with the pattern argument from the previous\nprogram on the command line:\njava regex.GrepNIO ""[A-Za-z][a-z]+""  ReaderIter.java\nY ou might think of using \w+ as the pattern; the only difference is that my pattern\nlooks for well-formed capitalized words, whereas \w+ would include Java-centric odd‐\nities like theVariableName , which have capitals in nonstandard positions.\nAlso note that the NIO version will probably be more efficient because it doesn’t reset\nthe Matcher  to a new input source on each line of input as ReaderIter  does.\n4.5 Printing All Occurrences of a Pattern | 117",4851
151-4.6 Printing Lines Containing a Pattern.pdf,151-4.6 Printing Lines Containing a Pattern,,0
152-Problem.pdf,152-Problem,,0
153-Solution.pdf,153-Solution,,0
154-4.7 Controlling Case in Regular Expressions.pdf,154-4.7 Controlling Case in Regular Expressions,"6On Unix, the shell or command-line interpreter expands *.txt  to all the matching filenames before running\nthe program, but the normal Java interpreter does this for you on systems where the shell isn’t energetic or\nbright enough to do it.4.6 Printing Lines Containing a Pattern\nProblem\nY ou need to look for lines matching a given regex in one or more files.\nSolution\nWrite a simple grep-like program.\nDiscussion\nAs I’ve mentioned, once you have a regex package, you can write a grep-like program.\nI gave an example of the Unix grep program earlier. grep is called with some optional\narguments, followed by one required regular expression pattern, followed by an arbi‐\ntrary number of filenames. It prints any line that contains the pattern, differing from\nRecipe 4.5 , which prints only the matching text itself. Here’s an example:\ngrep ""[dD]arwin"" *.txt \nThe code searches for lines containing either darwin  or Darwin  in every line of every\nfile whose name ends in .txt.6 Example 4-8  is the source for the first version of a pro‐\ngram to do this, called Grep0 . It reads lines from the standard input and doesn’t take\nany optional arguments, but it handles the full set of regular expressions that the Pat\ntern  class implements (it is, therefore, not identical to the Unix programs of the same\nname). We haven’t covered the java.io  package for input and output yet (see Chap‐\nter 10 ), but our use of it here is simple enough that you can probably intuit it. The\nonline source includes Grep1 , which does the same thing but is better structured (and\ntherefore longer). Later in this chapter, Recipe 4.11  presents a JGrep  program that\nparses a set of command-line options.\nExample 4-8. main/src/main/java/regex/Grep0.java\npublic class Grep0 {\n    public static void main(String[] args) throws IOException  {\n        BufferedReader  is =\n            new BufferedReader (new InputStreamReader (System.in));\n        if (args.length != 1) {\n            System.err.println(""Usage: MatchLines pattern"" );\n            System.exit(1);\n        }\n118 | Chapter 4: Pattern Matching with Regular Expressions",2138
155-Problem.pdf,155-Problem,,0
156-4.8 Matching Accented or Composite Characters.pdf,156-4.8 Matching Accented or Composite Characters,"Pattern patt = Pattern.compile(args[0]);\n        Matcher matcher = patt.matcher("""");\n        String line = null;\n        while ((line = is.readLine ()) != null) {\n            matcher.reset(line);\n            if (matcher.find()) {\n                System.out.println(""MATCH: ""  + line);\n            }\n        }\n    }\n}\n4.7 Controlling Case in Regular Expressions\nProblem\nY ou want to find text regardless of case.\nSolution\nCompile the Pattern  passing in the flags  argument Pattern.CASE_INSENSITIVE\nto indicate that matching should be case-independent (i.e., that it should fold, ignore\ndifferences in case). If your code might run in different locales (see Recipe 3.12 ),\nthen you should add Pattern.UNICODE_CASE . Without these flags, the default is nor‐\nmal, case-sensitive matching behavior. This flag (and others) are passed to the \nPattern.compile()  method, like this:\n// regex/CaseMatch.java\nPattern  reCaseInsens = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE |\n    Pattern.UNICODE_CASE);\nreCaseInsens.matches(input);        // will match case-insensitively\nThis flag must be passed when you create the Pattern ; because Pattern  objects are\nimmutable, they cannot be changed once constructed.\nThe full source code for this example is online as CaseMatch.java .\nPattern.compile() Flags\nHalf a dozen flags can be passed as the second argument to Pattern.compile() . If\nmore than one value is needed, they can be or’ d together using the bitwise or operator\n|. In alphabetical order, these are the flags:\nCANON_EQ\nEnables so-called canonical equivalence. In other words, characters are matched\nby their base character so that the character e followed by the combining charac‐\n4.7 Controlling Case in Regular Expressions | 119",1771
157-Problem.pdf,157-Problem,,0
158-Solution.pdf,158-Solution,,0
159-4.9 Matching Newlines in Text.pdf,159-4.9 Matching Newlines in Text,"ter mark for the acute accent ( ´) can be matched either by the composite charac‐\nter é or the letter e followed by the character mark for the accent (see Recipe 4.8 ).\nCASE_INSENSITIVE\nTurns on case-insensitive matching (see Recipe 4.7 ).\nCOMMENTS\nCauses whitespace and comments (from # to end-of-line) to be ignored in the\npattern. See CommentedRegEx.java  in the regex  source directory.\nDOTALL\nAllows dot (.) to match any regular character or the newline, not just any regular\ncharacter other than newline (see Recipe 4.9 ).\nMULTILINE\nSpecifies multiline mode (see Recipe 4.9 ).\nUNICODE_CASE\nEnables Unicode-aware case folding (see Recipe 4.7 ).\nUNIX_LINES\nMakes \n the only valid newline sequence for MULTILINE  mode (see Recipe 4.9 ).\n4.8 Matching Accented, or Composite, Characters\nProblem\nY ou want characters to match regardless of the form in which they are entered.\nSolution\nCompile the Pattern  with the flags  argument Pattern.CANON_EQ  for canonical\nequality.\nDiscussion\nComposite characters can be entered in various forms. Consider, as a single example,\nthe letter e with an acute accent. This character may be found in various forms in\nUnicode text, such as the single character é (Unicode character \u00e9 ) or the two-\ncharacter sequence e´ (e followed by the Unicode combining acute accent, \u0301 ).\nTo allow you to match such characters regardless of which of possibly multiple fully\ndecomposed forms are used to enter them, the regex package has an option for can‐\nonical matching , which treats any of the forms as equivalent. This option is enabled by\npassing CANON_EQ  as (one of) the flags in the second argument to Pattern.com\npile() . This program shows CANON_EQ  being used to match several forms:\n120 | Chapter 4: Pattern Matching with Regular Expressions",1818
160-Problem.pdf,160-Problem,,0
161-Solution.pdf,161-Solution,,0
162-Discussion.pdf,162-Discussion,"public class CanonEqDemo  {\n    public static void main(String[] args) {\n        String pattStr = ""\u00e9gal"" ; // egal\n        String[] input = {\n                ""\u00e9gal"" , // egal - this one had better match :-)\n                ""e\u0301gal"" , // e + ""Combining acute accent""\n                ""e\u02cagal"" , // e + ""modifier letter acute accent""\n                ""e'gal"", // e + single quote\n                ""e\u00b4gal"" , // e + Latin-1 ""acute""\n        };\n        Pattern pattern = Pattern.compile(pattStr, Pattern.CANON_EQ );\n        for (int i = 0; i < input.length; i++) {\n            if (pattern.matcher(input[i]).matches()) {\n                System.out.println(\n                    pattStr + "" matches input ""  + input[i]);\n            } else {\n                System.out.println(\n                    pattStr + "" does not match input ""  + input[i]);\n            }\n        }\n    }\n}\nThis program correctly matches the combining accent and rejects the other charac‐\nters, some of which, unfortunately, look like the accent on a printer, but are not con‐\nsidered combining accent characters:\négal matches input égal\négal matches input e?gal\négal does not match input e?gal\négal does not match input e'gal\négal does not match input e´gal\nFor more details, see the character charts .\n4.9 Matching Newlines in Text\nProblem\nY ou need to match newlines in text.\nSolution\nUse \n or \r in your regex pattern. See also the flags constant Pattern.MULTILINE ,\nwhich makes newlines match as beginning-of-line and end-of-line ( \^ and $).\nDiscussion\nThough line-oriented tools from Unix such as  sed and grep match regular expressions\none line at a time, not all tools do. The sam text editor from Bell Laboratories was the\n4.9 Matching Newlines in Text | 121\n6Or a few related Unicode characters, including the next-line ( \u0085 ), line-separator ( \u2028 ), and\nparagraph-separator ( \u2029 ) characters.first interactive tool I know of to allow multiline regular expressions; the Perl script‐\ning language followed shortly after. In the Java API, the newline character by default\nhas no special significance. The BufferedReader  method readLine()  normally strips\nout whichever newline characters it finds. If you read in gobs of characters using\nsome method other than readLine() , you may have some number of \n, \r, or \r\n\nsequences in your text string.6 Normally all of these are treated as equivalent to \n. If\nyou want only \n to match, use the UNIX_LINES  flag to the Pattern.compile()\nmethod.\nIn Unix, ^ and $ are commonly used to match the beginning or end of a line, respec‐\ntively. In this API, the regex metacharacters \^ and $ ignore line terminators and only\nmatch at the beginning and the end, respectively, of the entire string. However, if you\npass the MULTILINE  flag into Pattern.compile() , these expressions match just after\nor just before, respectively, a line terminator; $ also matches the very end of the\nstring. Because the line ending is just an ordinary character, you can match it with .\nor similar expressions; and, if you want to know exactly where it is, \n or \r in the\npattern match it as well. In other words, to this API, a newline character is just\nanother character with no special significance. See the sidebar “Pattern.compile()\nFlags” on page 119 . An example of newline matching is shown in Example 4-9 .\nExample 4-9. main/src/main/java/regex/NLMatch.java\npublic class NLMatch {\n    public static void main(String[] argv) {\n        String input = ""I dream of engines\nmore engines, all day long"" ;\n        System.out.println(""INPUT: ""  + input);\n        System.out.println();\n        String[] patt = {\n            ""engines.more engines"" ,\n            ""ines\nmore"" ,\n            ""engines$""\n        };\n        for (int i = 0; i < patt.length; i++) {\n            System.out.println(""PATTERN ""  + patt[i]);\n            boolean found;\n            Pattern p1l = Pattern.compile(patt[i]);\n            found = p1l.matcher(input).find();\n            System.out.println(""DEFAULT match ""  + found);\n122 | Chapter 4: Pattern Matching with Regular Expressions",4163
163-4.10 Program Apache Logfile Parsing.pdf,163-4.10 Program Apache Logfile Parsing,"Pattern pml = Pattern.compile(patt[i],\n                Pattern.DOTALL|Pattern.MULTILINE );\n            found = pml.matcher(input).find();\n            System.out.println(""MultiLine match ""  + found);\n            System.out.println();\n        }\n    }\n}\nIf you run this code, the first pattern (with the wildcard character .) always matches,\nwhereas the second pattern (with $) matches only when MATCH_MULTILINE  is set:\n> java regex.NLMatch\nINPUT: I dream of engines\nmore engines, all day long\nPATTERN engines\nmore engines\nDEFAULT match true\nMULTILINE match: true\nPATTERN engines$\nDEFAULT match false\nMULTILINE match: true\n4.10 Program: Apache Logfile  Parsing\nThe Apache web server is the world’s leading web server and has been for most of the\nweb’s history. It is one of the world’s best-known open source projects, and it’s the first\nof many fostered by the Apache Foundation. The name Apache is often claimed to be\na pun on the origins of the server; its developers began with the free NCSA server\nand kept hacking at it, or patching, it until it did what they wanted. When it was suffi‐\nciently different from the original, a new name was needed. Because it was now a pat‐\nchy server, the name Apache was chosen. Officialdom denies the story, but it’s cute\nanyway. One place actual patchiness does show through is in the logfile format. Con‐\nsider Example 4-10 .\nExample 4-10. Apache log file excerpt\n123.45.67.89 - - [27/Oct/2000:09:27:09 -0400] ""GET /java/javaResources.html\nHTTP/1.0"" 200 10450 ""-"" ""Mozilla/4.6 [en] (X11; U; OpenBSD 2.8 i386; Nav)""\nThe file format was obviously designed for human inspection but not for easy pars‐\ning. The problem is that different delimiters are used: square brackets for the date,\nquotes for the request line, and spaces sprinkled all through. Consider trying to use a\nStringTokenizer ; you might be able to get it working, but you’ d spend a lot of time\nfiddling with it. Actually, no, you wouldn’t get it working. However, this somewhat\n4.10 Program: Apache Logfile  Parsing | 123\n6Y ou might think this would hold some kind of world record for complexity in regex competitions, but I’m\nsure it’s been outdone many times.contorted regular expression6 makes it easy to parse (this is one single Moby-sized\nregex; we had to break it over two lines to make it fit the book’s margins):\n\^([\d.]+) (\S+) (\S+) \[([\w:/]+\s[+\-]\d{4})\] ""(.+?)"" (\d{3}) (\d+)\n  ""([\^""]+)"" ""([\^""]+)""\nY ou may find it informative to refer back to Table 4-1  and review the full syntax used\nhere. Note in particular the use of the nongreedy quantifier +? in \""(.+?)\ "" to match\na quoted string; you can’t just use .+ because that would match too much (up to the\nquote at the end of the line). Code to extract the various fields such as IP address,\nrequest, referrer URL, and browser version is shown in Example 4-11 .\nExample 4-11. main/src/main/java/regex/LogRegExp.java\npublic class LogRegExp  {\n    final static String logEntryPattern  =\n            ""^([\\d.]+) (\\S+) (\\S+) \\[([\\w:/]+\\s[+-]\\d{4})\\] ""  +\n            ""\""(.+?)\"" (\\d{3}) (\\d+) \""([^\""]+)\"" \""([^\""]+)\"""" ;\n    public static void main(String argv[]) {\n        System.out.println(""RE Pattern:"" );\n        System.out.println(logEntryPattern );\n        System.out.println(""Input line is:"" );\n        String logEntryLine  = LogParseInfo .LOG_ENTRY_LINE ;\n        System.out.println(logEntryLine );\n        Pattern p = Pattern.compile(logEntryPattern );\n        Matcher matcher = p.matcher(logEntryLine );\n        if (!matcher.matches() ||\n            LogParseInfo .MIN_FIELDS  > matcher.groupCount ()) {\n            System.err.println(""Bad log entry (or problem with regex):"" );\n            System.err.println(logEntryLine );\n            return;\n        }\n        System.out.println(""IP Address: ""  + matcher.group(1));\n        System.out.println(""UserName: ""  + matcher.group(3));\n        System.out.println(""Date/Time: ""  + matcher.group(4));\n        System.out.println(""Request: ""  + matcher.group(5));\n        System.out.println(""Response: ""  + matcher.group(6));\n        System.out.println(""Bytes Sent: ""  + matcher.group(7));\n        if (!matcher.group(8).equals(""-""))\n            System.out.println(""Referer: ""  + matcher.group(8));\n        System.out.println(""User-Agent: ""  + matcher.group(9));\n124 | Chapter 4: Pattern Matching with Regular Expressions",4431
164-4.11 Program Full Grep.pdf,164-4.11 Program Full Grep,"}\n}\nThe implements  clause is for an interface that just defines the input string; it was used\nin a demonstration to compare the regular expression mode with the use of a String\nTokenizer . The source for both versions is in the online source for this chapter. Run‐\nning the program against the sample input from Example 4-10  gives this output:\nUsing regex Pattern:\n\^([\d.]+) (\S+) (\S+) \[([\w:/]+\s[+\-]\d{4})\] ""(.+?)"" (\d{3}) (\d+) ""([\^""]\n+)""\n""([\^""]+)""\nInput line is:\n123.45.67.89 - - [27/Oct/2000:09:27:09 -0400] ""GET /java/javaResources.html\nHTTP/1.0"" 200 10450 ""-"" ""Mozilla/4.6 [en] (X11; U; OpenBSD 2.8 i386; Nav)""\nIP Address: 123.45.67.89\nDate&Time: 27/Oct/2000:09:27:09 -0400\nRequest: GET /java/javaResources.html HTTP/1.0\nResponse: 200\nBytes Sent: 10450\nBrowser: Mozilla/4.6 [en] (X11; U; OpenBSD 2.8 i386; Nav)\nThe program successfully parsed the entire logfile format entry with one call to\nmatcher.matches() .\n4.11 Program: Full Grep\nNow that we’ve seen how the regular expressions package works, it’s time to write\nJGrep, a full-blown version of the line-matching program with option parsing.\nTable 4-2  lists some typical command-line options that a Unix implementation of\ngrep might include. For those not familiar with grep, it is a command-line tool that\nsearches for regular expressions in text files. There are three or four programs in the\nstandard grep family, and a newer replacement ripgrep , or rg. This program is my\naddition to this family of programs.\nTable 4-2. Grep command-line options\nOption Meaning\n-c Count only; don’t print lines, just count them\n-C Context; print some lines above and below each line that matches (not implemented in this version; left as an\nexercise for the reader)\n-f pattern Take pattern from file named after -f instead of from command line\n-h Suppress printing filename  ahead of lines\n-i Ignore case\n-l List filenames  only: don’t print lines, just the names they’re found in\n-n Print line numbers before matching lines\n4.11 Program: Full Grep | 125\nOption Meaning\n-s Suppress printing certain error messages\n-v Invert: print only lines that do NOT match the pattern\nThe Unix world features several getopt  library routines for parsing command-line\narguments, so I have a reimplementation of this in Java. As usual, because main()\nruns in a static context but our application main line does not, we could wind up\npassing a lot of information into the constructor. To save space, this version just uses\nglobal variables to track the settings from the command line. Unlike the Unix grep\ntool, this one does not yet handle combined options, so -l -r -i  is OK, but -lri  will\nfail, due to a limitation in the GetOpt  parser used.\nThe program basically just reads lines, matches the pattern in them, and, if a match is\nfound (or not found, with -v), prints the line (and optionally some other stuff, too).\nHaving said all that, the code is shown in Example 4-12 .\nExample 4-12. darwinsys-api/src/main/java/regex/JGrep.java\n/** A command-line grep-like program. Accepts some command-line options,\n * and takes a pattern and a list of text files.\n * N.B. The current implementation of GetOpt does not allow combining short\n * arguments, so put spaces e.g., ""JGrep -l -r -i pattern file..."" is OK, but\n * ""JGrep -lri pattern file..."" will fail. Getopt will hopefully be fixed soon.\n */\npublic class JGrep {\n    private static final String USAGE =\n        ""Usage: JGrep pattern [-chilrsnv][-f pattfile][filename...]"" ;\n    /** The pattern we're looking for */\n    protected  Pattern pattern;\n    /** The matcher for this pattern */\n    protected  Matcher matcher;\n    private boolean debug;\n    /** Are we to only count lines, instead of printing? */\n    protected  static boolean countOnly  = false;\n    /** Are we to ignore case? */\n    protected  static boolean ignoreCase  = false;\n    /** Are we to suppress printing of filenames? */\n    protected  static boolean dontPrintFileName  = false;\n    /** Are we to only list names of files that match? */\n    protected  static boolean listOnly  = false;\n    /** Are we to print line numbers? */\n    protected  static boolean numbered  = false;\n    /** Are we to be silent about errors? */\n    protected  static boolean silent = false;\n    /** Are we to print only lines that DONT match? */\n    protected  static boolean inVert = false;\n    /** Are we to process arguments recursively if directories? */\n    protected  static boolean recursive  = false;\n126 | Chapter 4: Pattern Matching with Regular Expressions\n    /** Construct a Grep object for the pattern, and run it\n     * on all input files listed in args.\n     * Be aware that a few of the command-line options are not\n     * acted upon in this version - left as an exercise for the reader!\n     * @param args args\n     */\n    public static void main(String[] args) {\n        if (args.length < 1) {\n            System.err.println(USAGE);\n            System.exit(1);\n        }\n        String patt = null;\n        GetOpt go = new GetOpt(""cf:hilnrRsv"" );\n        char c;\n        while ((c = go.getopt(args)) != 0) {\n            switch(c) {\n                case 'c':\n                    countOnly  = true;\n                    break;\n                case 'f':    /* External file contains the pattern */\n                    try (BufferedReader  b =\n                        new BufferedReader (new FileReader (go.optarg()))) {\n                        patt = b.readLine ();\n                    } catch (IOException  e) {\n                        System.err.println(\n                            ""Can't read pattern file ""  + go.optarg());\n                        System.exit(1);\n                    }\n                    break;\n                case 'h':\n                    dontPrintFileName  = true;\n                    break;\n                case 'i':\n                    ignoreCase  = true;\n                    break;\n                case 'l':\n                    listOnly  = true;\n                    break;\n                case 'n':\n                    numbered  = true;\n                    break;\n                case 'r':\n                case 'R':\n                    recursive  = true;\n                    break;\n                case 's':\n                    silent = true;\n                    break;\n4.11 Program: Full Grep | 127\n                case 'v':\n                    inVert = true;\n                    break;\n                case '?':\n                    System.err.println(""Getopts was not happy!"" );\n                    System.err.println(USAGE);\n                    break;\n            }\n        }\n        int ix = go.getOptInd ();\n        if (patt == null)\n            patt = args[ix++];\n        JGrep prog = null;\n        try {\n            prog = new JGrep(patt);\n        } catch (PatternSyntaxException  ex) {\n            System.err.println(""RE Syntax error in ""  + patt);\n            return;\n        }\n        if (args.length == ix) {\n            dontPrintFileName  = true; // Don't print filenames if stdin\n            if (recursive ) {\n                System.err.println(""Warning: recursive search of stdin!"" );\n            }\n            prog.process(new InputStreamReader (System.in), null);\n        } else {\n            if (!dontPrintFileName )\n                dontPrintFileName  = ix == args.length - 1; // Nor if only one file\n            if (recursive )\n                dontPrintFileName  = false;                // unless a directory!\n            for (int i=ix; i<args.length; i++) { // note starting index\n                try {\n                    prog.process(new File(args[i]));\n                } catch(Exception  e) {\n                    System.err.println(e);\n                }\n            }\n        }\n    }\n    /**\n     * Construct a JGrep object.\n     * @param patt The regex to look for\n     * @throws PatternSyntaxException if pattern is not a valid regex\n     */\n    public JGrep(String patt) throws PatternSyntaxException  {\n        if (debug) {\n128 | Chapter 4: Pattern Matching with Regular Expressions\n            System.err.printf(""JGrep.JGrep(%s)%n"" , patt);\n        }\n        // compile the regular expression\n        int caseMode  = ignoreCase  ?\n            Pattern.UNICODE_CASE  | Pattern.CASE_INSENSITIVE  :\n            0;\n        pattern = Pattern.compile(patt, caseMode );\n        matcher = pattern.matcher("""");\n    }\n    /** Process one command line argument (file or directory)\n     * @param file The input File\n     * @throws FileNotFoundException If the file doesn't exist\n     */\n    public void process(File file) throws FileNotFoundException  {\n        if (!file.exists() || !file.canRead()) {\n            throw new FileNotFoundException (\n                ""Can't read file ""  + file.getAbsolutePath ());\n        }\n        if (file.isFile()) {\n            process(new BufferedReader (new FileReader (file)),\n                file.getAbsolutePath ());\n            return;\n        }\n        if (file.isDirectory ()) {\n            if (!recursive ) {\n                System.err.println(\n                    ""ERROR: -r not specified but directory given ""  +\n                    file.getAbsolutePath ());\n                return;\n            }\n            for (File nf : file.listFiles ()) {\n                process(nf);    // ""Recursion, n.: See Recursion.""\n            }\n            return;\n        }\n        System.err.println(\n            ""WEIRDNESS: neither file nor directory: ""  + file.getAbsolutePath ());\n    }\n    /** Do the work of scanning one file\n     * @param    ifile    Reader    Reader object already open\n     * @param    fileName String    Name of the input file\n     */\n    public void process(Reader ifile, String fileName ) {\n        String inputLine ;\n        int matches = 0;\n        try (BufferedReader  reader = new BufferedReader (ifile)) {\n            while ((inputLine  = reader.readLine ()) != null) {\n4.11 Program: Full Grep | 129\n                matcher.reset(inputLine );\n                if (matcher.find()) {\n                    if (listOnly ) {\n                        // -l, print filename on first match, and we're done\n                        System.out.println(fileName );\n                        return;\n                    }\n                    if (countOnly ) {\n                        matches++;\n                    } else {\n                        if (!dontPrintFileName ) {\n                            System.out.print(fileName  + "": "");\n                        }\n                        System.out.println(inputLine );\n                    }\n                } else if (inVert) {\n                    System.out.println(inputLine );\n                }\n            }\n            if (countOnly )\n                System.out.println(matches + "" matches in ""  + fileName );\n        } catch (IOException  e) {\n            System.err.println(e);\n        }\n    }\n}\n130 | Chapter 4: Pattern Matching with Regular Expressions",11121
165-Chapter 5. Numbers.pdf,165-Chapter 5. Numbers,,0
166-5.0 Introduction.pdf,166-5.0 Introduction,"CHAPTER 5\nNumbers\n5.0 Introduction\nNumbers are basic to just about any computation. They’re used for array indices,\ntemperatures, salaries, ratings, and an infinite variety of things. Y et they’re not as sim‐\nple as they seem. With floating-point numbers, how accurate is accurate? With ran‐\ndom numbers, how random is random? With strings that should contain a number,\nwhat actually constitutes a number?\nJava has several built-in, or primitive , types that can be used to represent numbers,\nsummarized in Table 5-1  with their wrapper  (object) types, as well as some numeric\ntypes that do not represent primitive types. Note that unlike languages such as C or\nPerl, which don’t specify the size or precision of numeric types, Java—with its goal of\nportability—specifies these exactly and states that they are the same on all platforms.\nTable 5-1. Numeric types\nBuilt-in type Object wrapper Size of built-in (bits) Contents\nbyte Byte 8 Signed integer\nshort Short 16 Signed integer\nint Integer 32 Signed integer\nlong Long 64 Signed integer\nfloat Float 32 IEEE-754 floating  point\ndouble Double 64 IEEE-754 floating  point\nchar Character 16 Unsigned Unicode character\nn/a BigInteger unlimited Arbitrary-size immutable integer value\nn/a BigDecimal unlimited Arbitrary-size-and-precision immutable floating-point  value\n131\nAs you can see, Java provides a numeric type for just about any purpose. There are\nfour sizes of signed integers for representing various sizes of whole numbers. There\nare two sizes of floating-point numbers to approximate real numbers. There is also a\ntype specifically designed to represent and allow operations on Unicode characters.\nThe primitive numeric types are discussed here. The “Big” value types are described\nin Recipe 5.12 .\nWhen you read a string representing a number from user input or a text file, you\nneed to convert it to the appropriate type. The object wrapper classes in the second\ncolumn have several functions, one of which is to provide this basic conversion func‐\ntionality—replacing the C programmer’s atoi/atof family of functions and the\nnumeric arguments to scanf .\nGoing the other way, you can convert any number (indeed, anything at all in Java) to\na string just by using string concatenation. If you want a little bit of control over\nnumeric formatting, Recipe 5.5  shows you how to use some of the object wrappers’\nconversion routines. And if you want full control, that recipe also shows the use of\nNumberFormat  and its related classes to provide full control of formatting.\nAs the name  object wrapper  implies, these classes are also used to wrap a number in a\nJava object, as many parts of the standard API are defined in terms of objects. Later\non, “Solution”  on page 394 shows using an Integer  object to save an int’s value to a\nfile using object serialization and retrieving the value later.\nBut I haven’t yet mentioned the issues of floating point. Real numbers, you may recall,\nare numbers with a fractional part. There is an infinite number of real numbers. A\nfloating-point number—what a computer uses to approximate a real number—is not\nthe same as a real number. The number of floating-point numbers is finite, with only\n2^32 different bit patterns for float s, and 2^64 for double s. Thus, most real values\nhave only an approximate correspondence to floating point. The result of printing the\nreal number 0.3 works correctly, like this:\n// numbers/RealValues.java\nSystem.out.println(""The real value 0.3 is ""  + 0.3);\nThat code results in this printout:\nThe real value 0.3 is 0.3\nBut the difference between a real value and its floating-point approximation can\naccumulate if the value is used in a computation; this is often called a rounding error .\nContinuing the previous example, the real 0.3 multiplied by 3 yields:\nThe real 0.3 times 3 is 0.89999999999999991\n132 | Chapter 5: Numbers",3921
167-5.1 Checking Whether a String Is a Valid Number.pdf,167-5.1 Checking Whether a String Is a Valid Number,"6For a low-cost source of randomness, check out the now-defunct Lavarand . The process used digitized video\nof 1970s lava lamps to provide “hardware-based” randomness. Fun!Surprised? Not only is it off by a bit from what you might expect, but you will of\ncourse get the same output on any conforming Java implementation. I ran it on\nmachines as disparate as an AMD/Intel PC with OpenBSD, a PC with Windows and\nthe standard JDK, and on macOS. Always the same answer.\nAnd what about random numbers? How random are they? Y ou have probably heard\nthe term Pseudorandom Number Generator , or PRNG. All conventional random\nnumber generators, whether written in Fortran, C, or Java, generate pseudorandom\nnumbers. That is, they’re not truly random! True randomness comes only from spe‐\ncially built hardware: an analog source of Brownian noise connected to an analog-to-\ndigital converter, for example.6 Y our average PC of today may have some good sour‐\nces of entropy, or even hardware-based sources of randomness (which have not been\nwidely used or tested yet). However, pseudorandom number generators are good\nenough for most purposes, so we use them. Java provides one random generator in\nthe base library java.lang.Math , and several others; we’ll examine these in Recipe\n5.9.\nThe class java.lang.Math  contains an entire math library in one class, including trig‐\nonometry, conversions (including degrees to radians and back), rounding, truncating,\nsquare root, minimum, and maximum. It’s all there. Check the javadoc for\njava.lang.Math .\nThe package java.math  contains support for  big numbers —those larger than the nor‐\nmal built-in long integers, for example. See Recipe 5.12 .\nJava works hard to ensure that your programs are reliable. The usual ways you’ d\nnotice this are in the common requirement to catch potential exceptions—all through\nthe Java API—and in the need to cast, or convert, when storing a value that might or\nmight not fit into the variable you’re trying to store it in. I’ll show examples of these.\nOverall, Java’s handling of numeric data fits well with the ideals of portability, reliabil‐\nity, and ease of programming.\nSee Also\nThe Java Language Specification , and the javadoc page for java.lang.Math .\n5.0 Introduction | 133",2284
168-Problem.pdf,168-Problem,,0
169-Solution.pdf,169-Solution,,0
170-See Also.pdf,170-See Also,"5.1 Checking Whether a String Is a Valid Number\nProblem\nY ou need to check whether a given string contains a valid number, and, if so, convert\nit to binary (internal) form.\nSolution\nTo accomplish this, use the appropriate wrapper class’s conversion routine and catch\nthe NumberFormatException . This code converts a string to a double :\n    public static void main(String[] argv) {\n        String aNumber = argv[0];    // not argv[1]\n        double result;\n        try {\n            result = Double.parseDouble (aNumber);\n            System.out.println(""Number is ""  + result);\n        } catch(NumberFormatException  exc) {\n            System.out.println(""Invalid number ""  + aNumber);\n            return;\n        }\n    }\nDiscussion\nThis code lets you validate only numbers in the format that the designers of the wrap‐\nper classes expected. If you need to accept a different definition of numbers, you\ncould use regular expressions (see Chapter 4 ) to make the determination.\nThere may also be times when you want to tell if a given number is an integer number\nor a floating-point number. One way is to check for the characters ., d, e, or f in the\ninput; if one of these characters is present, convert the number as a double . Other‐\nwise, convert it as an int:\n    /*\n     * Process one String, returning it as a Number subclass\n     */\n    public static Number process(String s) {\n        if (s.matches(""[+-]*\\d*\\.\\d+[dDeEfF]*"" )) {\n            try {\n                double dValue = Double.parseDouble (s);\n                System.out.println(""It's a double: ""  + dValue);\n                return Double.valueOf(dValue);\n            } catch (NumberFormatException  e) {\n                System.out.println(""Invalid double: ""  + s);\n                return Double.NaN;\n            }\n        } else // did not contain . d e or f, so try as int.\n134 | Chapter 5: Numbers",1910
171-5.2 Converting Numbers to Objects and Vice Versa.pdf,171-5.2 Converting Numbers to Objects and Vice Versa,,0
172-Problem.pdf,172-Problem,,0
173-Solution.pdf,173-Solution,,0
174-5.3 Taking a Fraction of an Integer Without Using Floating Point.pdf,174-5.3 Taking a Fraction of an Integer Without Using Floating Point,"try {\n                int iValue = Integer.parseInt (s);\n                System.out.println(""It's an int: ""  + iValue);\n                return Integer.valueOf(iValue);\n            } catch (NumberFormatException  e2) {\n                System.out.println(""Not a number: ""  + s);\n                return Double.NaN;\n            }\n    }\nSee Also\nA more involved form of parsing is offered by the DecimalFormat  class, discussed in\nRecipe 5.5 .\nThere is also the Scanner  class; see Recipe 10.6 .\n5.2 Converting Numbers to Objects and Vice Versa\nProblem\nY ou need to convert numbers to objects and objects to numbers.\nSolution\nUse the object wrapper classes listed in Table 5-1  at the beginning of this chapter.\nDiscussion\nOften you have a primitive number and you need to pass it into a method where an\nObject  is required, or vice versa. Long ago you had to invoke the conversion routines\nthat are part of the wrapper  classes, but now you  can generally use automatic conver‐\nsion (called auto-boxing /auto-unboxing ). See Example 5-1  for examples of both.\nExample 5-1. main/src/main/java/structure/AutoboxDemo.java\npublic class AutoboxDemo  {\n    /** Shows auto-boxing (in the call to foo(i), i is wrapped automatically)\n     * and auto-unboxing (the return value is automatically unwrapped).\n     */\n    public static void main(String[] args) {\n        int i = 42;\n        int result = foo(i);            \n        System.out.println(result);\n    }\n    public static Integer foo(Integer i) {\n5.2 Converting Numbers to Objects and Vice Versa | 135",1580
175-Problem.pdf,175-Problem,,0
176-Solution.pdf,176-Solution,,0
177-5.4 Working with Floating-Point Numbers.pdf,177-5.4 Working with Floating-Point Numbers,"System.out.println(""Object = ""  + i);\n        return Integer.valueOf(123);    \n    }\n}\nAuto-boxing: int 42  is converted to Integer(42) . Also auto-unboxing: the\nInteger  returned from foo()  is auto-unboxed to assign to int result .\nNo auto-boxing: valueOf()  returns Integer . If the line said return Inte\nger.intValueOf(123) , then it would be a second example of auto-boxing\nbecause the method return value is Integer .\nTo explicitly convert between an int and an Integer  object, or vice versa, you can\nuse the wrapper  class methods:\npublic class IntObject  {\n    public static void main(String[] args) {\n        // int to Integer\n        Integer i1 = Integer.valueOf(42);\n        System.out.println(i1.toString ());        // or just i1\n        // Integer to int\n        int i2 = i1.intValue ();\n        System.out.println(i2);\n    }\n}\n5.3 Taking a Fraction of an Integer Without Using Floating\nPoint\nProblem\nY ou want to multiply an integer by a fraction without converting the fraction to a\nfloating-point number.\nSolution\nMultiply the integer by the numerator and divide by the denominator.\nThis technique should be used only when efficiency is more important than clarity\nbecause it tends to detract from the readability—and therefore the maintainability—\nof your code.\nDiscussion\nBecause integers and floating-point numbers are stored differently, it may sometimes\nbe desirable and feasible, for efficiency purposes, to multiply an integer by a\n136 | Chapter 5: Numbers",1515
178-Problem.pdf,178-Problem,,0
179-Discussion.pdf,179-Discussion,"fractional value without converting the values to floating point and back, and without\nrequiring a cast:\npublic class FractMult  {\n    public static void main(String[] u) {\n        double d1 = 0.666 * 5;  // fast but obscure and inaccurate: convert\n        System.out.println(d1); // 2/3 to 0.666 in programmer's head\n        double d2 = 2/3 * 5;    // wrong answer - 2/3 == 0, 0*5 = 0\n        System.out.println(d2);\n        double d3 = 2d/3d * 5;  // ""normal""\n        System.out.println(d3);\n        double d4 = (2*5)/3d;   // one step done as integers, almost same answer\n        System.out.println(d4);\n        int i5 = 2*5/3;         // fast, approximate integer answer\n        System.out.println(i5);\n    }\n}\nRunning the code looks like this:\n$ java numbers.FractMult\n3.33\n0.0\n3.333333333333333\n3.3333333333333335\n3\n$\nY ou should beware of the possibility of numeric overflow and avoid this optimization\nif you cannot guarantee that the multiplication by the numerator will not overflow.\n5.4 Working with Floating-Point Numbers\nProblem\nY ou want to be able to compare and round floating-point numbers.\nSolution\nCompare with the INFINITY  constants, and use isNaN()  to check for NaN (not a num‐\nber).\nCompare floating values with an epsilon value.\nRound floating point values with Math.round()  or custom code.\n5.4 Working with Floating-Point Numbers | 137\nDiscussion\nComparisons can be a bit tricky: fixed-point operations that can do things like divide\nby zero result in Java notifying you abruptly by throwing an exception. This is\nbecause integer division by zero is considered a logic error .\nFloating-point operations, however, do not throw an exception because they are\ndefined over an (almost) infinite range of values. Instead, they signal errors by pro‐\nducing the constant POSITIVE_INFINITY  if you divide a positive floating-point num‐\nber by zero, the constant NEGATIVE_INFINITY  if you divide a negative floating-point\nvalue by zero, and NaN if you otherwise generate an invalid result. Values for these\nthree public constants are defined in both the Float  and the Double  wrapper classes.\nThe value NaN has the unusual property that it is not equal to itself (i.e., NaN != NaN).\nThus, it would hardly make sense to compare a (possibly suspect) number against\nNaN, because the following expression can never be true:\nx == NaN\nInstead, the methods Float.isNaN(float)  and Double.isNaN(double)  must be\nused:\n    public static void main(String[] argv) {\n        double d = 123;\n        double e = 0;\n        if (d/e == Double.POSITIVE_INFINITY )\n            System.out.println(""Check for POSITIVE_INFINITY works"" );\n        double s = Math.sqrt(-1);\n        if (s == Double.NaN)\n            System.out.println(""Comparison with NaN incorrectly returns true"" );\n        if (Double.isNaN(s))\n            System.out.println(""Double.isNaN() correctly returns true"" );\n    }\nNote that this, by itself, is not sufficient to ensure that floating-point calculations have\nbeen done with adequate accuracy. For example, the following program demonstrates\na contrived calculation—Heron’s formula for the area of a triangle—both in float\nand in double . The double values are correct, but the floating-point value comes out\nas zero due to rounding errors. This happens because, in Java, operations involving\nonly float  values are performed as 32-bit calculations. Related languages such as C\nautomatically promote these to double during the computation, which can eliminate\nsome loss of accuracy. Let’s take a look:\npublic class Heron {\n    public static void main(String[] args) {\n        // Sides for triangle in float\n        float af, bf, cf;\n        float sf, areaf;\n        // Ditto in double\n138 | Chapter 5: Numbers\n6Note that an expression consisting entirely of compile-time constants, like Math.PI \* 2.1e17 , is also consid‐\nered to be Strict-FP .        double ad, bd, cd;\n        double sd, aread;\n        // Area of triangle in float\n        af = 12345679.0f ;\n        bf = 12345678.0f ;\n        cf = 1.01233995f ;\n        sf = (af+bf+cf)/2.0f;\n        areaf = (float)Math.sqrt(sf * (sf - af) * (sf - bf) * (sf - cf));\n        System.out.println(""Single precision: ""  + areaf);\n        // Area of triangle in double\n        ad = 12345679.0 ;\n        bd = 12345678.0 ;\n        cd = 1.01233995 ;\n        sd = (ad+bd+cd)/2.0d;\n        aread = Math.sqrt(sd * (sd - ad) * (sd - bd) * (sd - cd));\n        System.out.println(""Double precision: ""  + aread);\n    }\n}\nNow let’s run it:\n$ java numbers.Heron\nSingle precision: 0.0\nDouble precision: 972730.0557076167\nIf in doubt, use double !\nTo ensure consistency of very large-magnitude double computations on different Java\nimplementations, Java provides the keyword strictfp , which can apply to classes,\ninterfaces, or methods within a class.6 If a computation is Strict-FP , then it must\nalways, for example, return the value INFINITY  if a calculation would overflow the\nvalue of Double.MAX_VALUE  (or underflow the value Double.MIN_VALUE ). Non-Strict-\nFP calculations—the default—are allowed to perform calculations on a greater range\nand can return a valid final result that is in range even if the interim product was out\nof range. This is pretty esoteric and affects only computations that approach the\nbounds of what fits into a double.\nComparing floating-point  values\nBased on what we’ve just discussed, you probably won’t just go comparing two floats\nor doubles for equality. Y ou might expect the floating-point wrapper classes, Float\nand Double , to override the equals()  method, which they do. The equals()  method\n5.4 Working with Floating-Point Numbers | 139\nreturns true  if the two values are the same bit for bit (i.e., if and only if the numbers\nare the same or are both NaN). It returns false  otherwise, including if the argument\npassed in is null, or if one object is +0.0 and the other is –0.0.\nI said earlier that NaN != Nan , but if you compare with equals() , the result is true:\njshell> Float f1 = Float.valueOf(Float.NaN)\nf1 ==> NaN\njshell> Float f2 = Float.valueOf(Float.NaN)\nf2 ==> NaN\njshell> f1 == f2 # Comparing object identities\n$4 ==> false\njshell> f1.equals(f1) # bitwise comparison of values\n$5 ==> true\nIf this sounds weird, remember that the complexity comes partly from the nature of\ndoing real number computations in the less-precise floating-point hardware. It also\ncomes partly from the details of the IEEE Standard 754, which specifies the floating-\npoint functionality that Java tries to adhere to so that underlying floating-point pro‐\ncessor hardware can be used even when Java programs are being interpreted.\nTo actually compare floating-point numbers for equality, it is generally desirable to\ncompare them within some tiny range of allowable differences; this range is often\nregarded as a tolerance or as epsilon . Example 5-2  shows an equals()  method you\ncan use to do this comparison, as well as comparisons on values of NaN. When run, it\nprints that the first two numbers are equal within epsilon:\n$ java numbers.FloatCmp\nTrue within epsilon 1.0E-7\n$\nExample 5-2. main/src/main/java/numbers/FloatCmp.java\npublic class FloatCmp  {\n    final static double EPSILON = 0.0000001 ;\n    public static void main(String[] argv) {\n        double da = 3 * .3333333333 ;\n        double db = 0.99999992857 ;\n        // Compare two numbers that are expected to be close.\n        if (da == db) {\n            System.out.println(""Java considers ""  + da + ""=="" + db);\n        // else compare with our own equals overload\n        } else if (equals(da, db, 0.0000001 )) {\n            System.out.println(""Equal within epsilon ""  + EPSILON);\n140 | Chapter 5: Numbers\n        } else {\n            System.out.println(da + "" != "" + db);\n        }\n        System.out.println(""NaN prints as ""  + Double.NaN);\n        // Show that comparing two NaNs is not a good idea:\n        double nan1 = Double.NaN;\n        double nan2 = Double.NaN;\n        if (nan1 == nan2)\n            System.out.println(""Comparing two NaNs incorrectly returns true."" );\n        else\n            System.out.println(""Comparing two NaNs correctly reports false."" );\n        if (Double.valueOf(nan1).equals(Double.valueOf(nan2)))\n            System.out.println(""Double(NaN).equals(NaN) correctly returns true."" );\n        else\n            System.out.println(\n                ""Double(NaN).equals(NaN) incorrectly returns false."" );\n    }\n    /** Compare two doubles within a given epsilon */\n    public static boolean equals(double a, double b, double eps) {\n        if (a==b) return true;\n        // If the difference is less than epsilon, treat as equal.\n        return Math.abs(a - b) < eps;\n    }\n    /** Compare two doubles, using default epsilon */\n    public static boolean equals(double a, double b) {\n        return equals(a, b, EPSILON);\n    }\n}\nNote that neither of the System.err  messages about incorrect returns prints. The\npoint of this example with NaNs is that you should always make sure values are not\nNaN before entrusting them to Double.equals() .\nRounding\nIf you simply cast a floating value to an integer value, Java truncates the value. A value\nlike 3.999999 cast to an int or long  becomes 3, not 4. To round floating-point num‐\nbers properly, use Math.round() . It has two overloads: if you give it a double , you get\na long  result; if you give it a float , you get an int.\nWhat if you don’t like the rounding rules used by round ? If, for some bizarre reason,\nyou wanted to round numbers greater than 0.54 instead of the normal 0.5, you could\nwrite your own version of round() :\n5.4 Working with Floating-Point Numbers | 141",9808
180-5.5 Formatting Numbers.pdf,180-5.5 Formatting Numbers,,0
181-Problem.pdf,181-Problem,,0
182-Solution.pdf,182-Solution,"public class Round {\n    /** We round a number up if its fraction exceeds this threshold. */\n    public static final double THRESHOLD  = 0.54;\n    /*\n     * Round floating values to integers.\n     * @return the closest int to the argument.\n     * @param d A non-negative values to be rounded.\n     */\n    public static int round(double d) {\n        return (int)Math.floor(d + 1.0 - THRESHOLD );\n    }\n    public static void main(String[] argv) {\n        for (double d = 0.1; d<=1.0; d+=0.05) {\n            System.out.println(""My way:  ""  + d + ""-> "" + round(d));\n            System.out.println(""Math way:""  + d + ""-> "" + Math.round(d));\n        }\n    }\n}\nIf, on the other hand, you simply want to display a number with less precision than it\nnormally gets, you probably want to use a DecimalFormat  object or a Formatter\nobject, which we look at in Recipe 5.5 .\n5.5 Formatting Numbers\nProblem\nY ou need to format numbers.\nSolution\nUse a NumberFormat  subclass.\nJava did not originally provide C-style printf/scanf  functions because they tend to\nmix together formatting and input/output in a very inflexible way. Programs using\nprintf/scanf  can be hard to internationalize, for example. Of course, by popular\ndemand, Java did eventually introduce printf() , which along with String.format()\nis now standard in Java; see Recipe 10.4 .\nJava has an entire package, java.text , full of formatting routines as general and flexi‐\nble as anything you might imagine. As with printf , it has an involved formatting lan‐\nguage, described in the javadoc page. Consider the presentation of long numbers. In\nNorth America, the number one thousand twenty-four and a quarter is written\n1,024.25; in most of Europe it is 1 024,25; and in some other part of the world it\nmight be written 1.024,25. Not to mention how currencies and percentages are\n142 | Chapter 5: Numbers\nformatted!  Trying to keep track of this yourself would drive the average small soft‐\nware shop around the bend rather quickly.\nFortunately, the java.text  package includes a Locale  class; and, furthermore, the\nJava runtime automatically sets a default Locale  object based on the user’s environ‐\nment (on the Macintosh and Windows, the user’s preferences, and on Unix, the user’s\nenvironment variables). To provide a nondefault locale in code, see Recipe 3.12 . To\nprovide formatters customized for numbers, currencies, and percentages, the Number\nFormat  class has static factory methods  that normally return a DecimalFormat  with\nthe correct pattern already instantiated. A DecimalFormat  object appropriate to the\nuser’s locale can be obtained from the factory method NumberFormat.getInstance()\nand manipulated using set methods. Surprisingly, the method setMinimumIntegerDi\ngits()  turns out to be the easy way to generate a number format with leading zeros.\nHere is an example:\npublic class NumFormat2  {\n    /** A number to format */\n    public static final double data[] = {\n        0, 1, 22d/7, 100.2345678\n    };\n    /** The main (and only) method in this class. */\n    public static void main(String[] av) {\n        // Get a format instance\n        NumberFormat  form = NumberFormat .getInstance ();\n        // Set it to look like 999.99[99]\n        form.setMinimumIntegerDigits (3);\n        form.setMinimumFractionDigits (2);\n        form.setMaximumFractionDigits (4);\n        // Now print using it\n        for (int i=0; i<data.length; i++)\n            System.out.println(data[i] + ""\tformats as ""  +\n                form.format(data[i]));\n    }\n}\nThis prints the contents of the array using the NumberFormat  instance form :\n$ java numbers.NumFormat2\n0.0     formats as 000.00\n1.0     formats as 001.00\n3.142857142857143       formats as 003.1429\n100.2345678     formats as 100.2346\n$\nY ou can also construct a DecimalFormat  with a particular pattern or change the pat‐\ntern dynamically using applyPattern() . Some of the more common pattern charac‐\nters are shown in Table 5-2 .\n5.5 Formatting Numbers | 143\nTable 5-2. DecimalFormat pattern characters\nCharacter Meaning\n# Numeric digit (leading zeros suppressed)\n0 Numeric digit (leading zeros provided)\n. Locale-specific  decimal separator (decimal point)\n, Locale-specific  grouping separator (comma in English)\n- Locale-specific  negative indicator (minus sign)\n% Shows the value as a percentage\n; Separates two formats: the first  for positive and the second for negative values\n' Escapes one of the above characters so it appears\nAnything else Appears as itself\nThe NumFormatDemo  program uses one DecimalFormat  to print a number with only\ntwo decimal places and a second to format the number according to the default\nlocale:\n    /** A number to format */\n    public static final double intlNumber  = 1024.25;\n    /** Another number to format */\n    public static final double ourNumber  = 100.2345678 ;\n        NumberFormat  defForm = NumberFormat .getInstance ();\n        NumberFormat  ourForm = new DecimalFormat (""##0.##"" );\n        // toPattern() will reveal the combination of #0., etc\n        // that this particular Locale uses to format with!\n        System.out.println(""defForm's pattern is ""  +\n            ((DecimalFormat )defForm).toPattern ());\n        System.out.println(intlNumber  + "" formats as ""  +\n            defForm.format(intlNumber ));\n        System.out.println(ourNumber  + "" formats as ""  +\n            ourForm.format(ourNumber ));\n        System.out.println(ourNumber  + "" formats as ""  +\n            defForm.format(ourNumber ) + "" using the default format"" );\nThis program prints the given pattern and then formats the same number using sev‐\neral formats:\n$ java numbers.NumFormatDemo\ndefForm's pattern is #,##0.###\n1024.25 formats as 1,024.25\n100.2345678 formats as 100.23\n100.2345678 formats as 100.235 using the default format\n$\n144 | Chapter 5: Numbers\nHuman-readable number formatting\nTo print a number in what Linux/Unix calls “human readable format” (many display\ncommands accept a -h  argument for this format), use the Java 12 CompactNumberFor\nmat, as shown in Example 5-3 .\nExample 5-3. nmain/src/main/java/numbers/CompactFormatDemo.java\npublic class CompactFormatDemo  {\n    static final Number[] nums = {\n        0, 1, 1.25, 1234, 12345, 123456.78 , 123456789012L\n    };\n    static final String[] strs = {\n        ""1"", ""1.25"", ""1234"", ""12.345K"" , ""1234556.78"" , ""123456789012L""\n    };\n    public static void main(String[] args) throws ParseException  {\n        NumberFormat  cnf = NumberFormat .getCompactNumberInstance ();\n        System.out.println(""Formatting:"" );\n        for (Number n : nums) {\n            cnf.setParseIntegerOnly (false);\n            cnf.setMinimumFractionDigits (2);\n            System.out.println(n + "": "" + cnf.format(n));\n        }\n        System.out.println(""Parsing:"" );\n        for (String s : strs) {\n            System.out.println(s + "": "" + cnf.parse(s));\n        }\n    }\n}\nRoman numeral formatting\nTo work with roman numerals, use my RomanNumberFormat  class, as in this demo:\n        RomanNumberFormat  nf = new RomanNumberFormat ();\n        int year = LocalDate .now().getYear();\n        System.out.println(year + "" -> "" + nf.format(year));\nRunning RomanNumberSimple  in 2020 produces this output:\n2020->MMXX\nThe source of the RomanNumberFormat  class is in src/main/java/numbers/RomanNum‐\nberFormat.java . Several of the public methods are required because I wanted it to be a\nsubclass of Format , which is abstract. This accounts for some of the complexity, like\nhaving three different format methods.\n5.5 Formatting Numbers | 145",7696
183-See Also.pdf,183-See Also,,0
184-5.6 Converting Among Binary Octal Decimal and Hexadecimal.pdf,184-5.6 Converting Among Binary Octal Decimal and Hexadecimal,,0
185-Problem.pdf,185-Problem,,0
186-Discussion.pdf,186-Discussion,"Note that the RomanNumberFormat.parseObject( )  method is also required, but the\ncode doesn’t implement parsing in this version.\nSee Also\nJava I/O  by Elliotte Harold (O’Reilly) includes an entire chapter on NumberFormat\nand develops the subclass ExponentialNumberFormat .\n5.6 Converting Among Binary, Octal, Decimal, and\nHexadecimal\nProblem\nY ou want to display an integer as a series of bits—for example, when interacting with\ncertain hardware devices—or in some alternative number base (binary is base 2, octal\nis base 8, decimal is 10, hexadecimal is 16). Y ou want to convert a binary number or a\nhexadecimal value into an integer.\nSolution\nThe class java.lang.Integer  provides the solutions. Most of the time you can use\nInteger.parseInt(String input, int radix)  to convert from any type of number\nto an Integer , and Integer.toString(int input, int radix)  to go the other way.\nExample 5-4  shows some examples of using the Integer  class.\nExample 5-4. main/src/main/java/numbers/IntegerBinOctHexEtc.java\n        String input = ""101010"" ;\n        for (int radix : new int[] { 2, 8, 10, 16, 36 }) {\n            System.out.print(input + "" in base ""  + radix + "" is ""\n                    + Integer.valueOf(input, radix) + ""; "");\n            int i = 42;\n            System.out.println(i + "" formatted in base ""  + radix + "" is ""\n                    + Integer.toString (i, radix));\n        }\nThis program prints the binary string as an integer in various bases, and the integer\n42 in those same number bases:\n$ java numbers.IntegerBinOctHexEtc\n101010 in base 2 is 42; 42 formatted in base 2 is 101010\n101010 in base 8 is 33288; 42 formatted in base 8 is 52\n101010 in base 10 is 101010; 42 formatted in base 10 is 42\n101010 in base 16 is 1052688; 42 formatted in base 16 is 2a\n101010 in base 36 is 60512868; 42 formatted in base 36 is 16\n$ \n146 | Chapter 5: Numbers",1903
187-5.7 Operating on a Series of Integers.pdf,187-5.7 Operating on a Series of Integers,,0
188-Problem.pdf,188-Problem,,0
189-Solution.pdf,189-Solution,,0
190-Discussion.pdf,190-Discussion,"Discussion\nThere are also specialized versions of toString(int)  that don’t require you to specify\nthe radix, for example, toBinaryString()  to convert an integer to binary, toHex\nString()  for hexadecimal, toOctalString() , and so on. The javadoc page for the\nInteger  class is your friend here.\nThe String  class itself includes a series of static methods— valueOf(int) , value\nOf(double) , and so on—that also provide default formatting. That is, they return the\ngiven numeric value formatted as a string.\n5.7 Operating on a Series of Integers\nProblem\nY ou need to work on a range of integers.\nSolution\nFor a contiguous set, use IntStream::range  and rangeClosed , or the older for loop.\nFor discontinuous ranges of numbers, use a java.util.BitSet .\nDiscussion\nTo process a contiguous set of integers, Java provides both range()  / rangeClosed()\nmethods in the IntStream  and LongStream  classes. These take a starting and ending\nnumber; range()  excludes the ending number while rangeClosed()  closes on, or\nincludes, the ending number. Y ou can also iterate over a range of numbers using the\ntraditional for loop. Loop control for the for loop is in three parts: initialize, test, and\nchange. If the test part is initially false, the loop will never be executed, not even once.\nY ou can iterate over the elements of an array or collection (see Chapter 7 ) using a for-\neach loop.\nThe program in Example 5-5  demonstrates these techniques.\n5.7 Operating on a Series of Integers | 147\nExample 5-5. main/src/main/java/numbers/NumSeries.java\npublic class NumSeries  {\n    public static void main(String[] args) {\n        // For ordinal list of numbers n to m, use rangeClosed(start, endInclusive)\n        IntStream .rangeClosed (1, 12).forEach(\n            i -> System.out.println(""Month # ""  + i));\n        // Or, use a for loop starting at 1.\n        for (int i = 1; i <= months.length; i++)\n            System.out.println(""Month # ""  + i);\n        // Or a foreach loop\n        for (String month : months) {\n            System.out.println(month);\n        }\n        // When you want a set of array indices, use range(start, endExclusive)\n        IntStream .range(0, months.length).forEach(\n            i -> System.out.println(""Month ""  + months[i]));\n        // Or, use a for loop starting at 0.\n        for (int i = 0; i < months.length; i++)\n            System.out.println(""Month ""  + months[i]);\n        // For e.g., counting by 3 from 11 to 27, use a for loop\n        for (int i = 11; i <= 27; i += 3) {\n            System.out.println(""i = "" + i);\n        }\n        // A discontiguous set of integers, using a BitSet\n        // Create a BitSet and turn on a couple of bits.\n        BitSet b = new BitSet();\n        b.set(0);    // January\n        b.set(3);    // April\n        b.set(8);    // September\n        // Presumably this would be somewhere else in the code.\n        for (int i = 0; i<months.length; i++) {\n            if (b.get(i))\n                System.out.println(""Month ""  + months[i]);\n        }\n        // Same example but shorter:\n        // a discontiguous set of integers, using an array\n        int[] numbers = {0, 3, 8};\n        // Presumably somewhere else in the code... Also a foreach loop\n        for (int n : numbers) {\n            System.out.println(""Month: ""  + months[n]);\n148 | Chapter 5: Numbers",3396
191-5.8 Formatting with Correct Plurals.pdf,191-5.8 Formatting with Correct Plurals,,0
192-Problem.pdf,192-Problem,,0
193-5.9 Generating Random Numbers.pdf,193-5.9 Generating Random Numbers,"}\n    }\n    /** Names of months. See Dates/Times chapter for a better way to get these */\n    protected  static String months[] = {\n        ""January"" , ""February"" , ""March"", ""April"",\n        ""May"", ""June"", ""July"", ""August"" ,\n        ""September"" , ""October"" , ""November"" , ""December""\n    };\n}\n5.8 Formatting with Correct Plurals\nProblem\nY ou’re printing something like ""We used "" + n + "" items"" , but in English, “We\nused 1 items” is ungrammatical. Y ou want “We used 1 item. ”\nSolution\nUse a ChoiceFormat  or a conditional statement.\nUse Java’s ternary operator ( cond ? trueval  : falseval ) in a string concatenation.\nBoth zero and plurals get an “s” appended to the noun in English (“no books, one\nbook, two books”), so we test for n==1 :\npublic class FormatPlurals  {\n    public static void main(String[] argv) {\n        report(0);\n        report(1);\n        report(2);\n    }\n    /** report -- using conditional operator */\n    public static void report(int n) {\n        System.out.println(""We used ""  + n + "" item"" + (n==1?"""":""s""));\n    }\n}\nDoes it work?\n$ java numbers.FormatPlurals\nWe used 0 items\nWe used 1 item\nWe used 2 items\n$\nThe final println  statement is effectively equivalent to the following:\nif (n==1)\n    System.out.println(""We used ""  + n + "" item"");\n5.8 Formatting with Correct Plurals | 149\nelse\n    System.out.println(""We used ""  + n + "" items"" );\nThis is a lot longer, so the ternary conditional operator is worth learning.\nThe ChoiceFormat  is ideal for this. It is actually capable of much more, but here I’ll\nshow only this simplest use. I specify the values 0, 1, and 2 (or more), and the string\nvalues to print corresponding to each number. The numbers are then formatted\naccording to the range they fall into:\npublic class FormatPluralsChoice  extends FormatPlurals  {\n    // ChoiceFormat to just give pluralized word\n    static double[] limits = { 0, 1, 2 };\n    static String[] formats = { ""reviews"" , ""review"" , ""reviews"" };\n    static ChoiceFormat  pluralizedFormat  = new ChoiceFormat (limits, formats);\n    // ChoiceFormat to give English text version, quantified\n    static ChoiceFormat  quantizedFormat  = new ChoiceFormat (\n        ""0#no reviews|1#one review|1<many reviews"" );\n    // Test data\n    static int[] data = { -1, 0, 1, 2, 3 };\n    public static void main(String[] argv) {\n        System.out.println(""Pluralized Format"" );\n        for (int i : data) {\n            System.out.println(""Found ""  + i + "" "" + pluralizedFormat .format(i));\n        }\n        System.out.println(""Quantized Format"" );\n        for (int i : data) {\n            System.out.println(""Found ""  + quantizedFormat .format(i));\n        }\n    }\n}\nThis generates the same output as the basic version. It is slightly longer, but more\ngeneral, and lends itself better to internationalization.\nSee Also\nIn addition to ChoiceFormat , the same result can be achieved with a MessageFormat .\nThe online source in file main/src/main/java/i18n/MessageFormatDemo.java  has an\nexample.\n150 | Chapter 5: Numbers",3088
194-Problem.pdf,194-Problem,,0
195-Solution.pdf,195-Solution,"5.9 Generating Random Numbers\nProblem\nY ou need to generate pseudorandom numbers in a hurry.\nSolution\nUse java.lang.Math.random()  to generate random numbers. There is no claim that\nthe random values it returns are very good  random numbers, however. Like most\nsoftware-only implementations, these are Pseudorandom Number Generators\n(PRNGs), meaning that the numbers are not totally random, but devised from an\nalgorithm. That said, they are adequate for casual use. This code exercises the ran\ndom()  method:\n// numbers/Random1.java\n// java.lang.Math.random( ) is static, don't need any constructor calls\nSystem.out.println(""A random from java.lang.Math is ""  + Math.random( ));\nNote that this method only generates double values. If you need integers, construct a\njava.util.Random  object and call its nextInt()  method; if you pass it an integer\nvalue, this will become the upper bound. Here I generate integers from 1 to 10:\npublic class RandomInt  {\n    public static void main(String[] a) {\n        Random r = new Random();\n        for (int i=0; i<1000; i++)\n            // nextInt(10) goes from 0-9; add 1 for 1-10;\n            System.out.println(1+r.nextInt(10));\n    }\n}\nTo see if my RandomInt  demo was really working well, I used the Unix tools sort and\nuniq , which together give a count of how many times each value was chosen. For\n1,000 integers, each of 10 values should be chosen about 100 times. I ran it twice to\nget a better idea of the distribution:\n$ java numbers.RandomInt | sort | uniq -c | sort -k 2 -n\n  96 1\n 107 2\n 102 3\n 122 4\n  99 5\n 105 6\n  97 7\n  96 8\n  79 9\n  97 10\n$ java -cp build numbers.RandomInt | sort | uniq -c | sort -k 2 -n\n  86 1\n5.9 Generating Random Numbers | 151\n  88 2\n 110 3\n  97 4\n  99 5\n 109 6\n  82 7\n 116 8\n  99 9\n 114 10\n$\nThe next step is to run these through a statistical program to see how really random\nthey are; we’ll return to this in a minute.\nIn general, to generate random numbers, you need to construct a java.util.Random\nobject (not just any old random object) and call its next*()  methods. These methods\ninclude nextBoolean() , nextBytes()  (which fills the given array of bytes with ran‐\ndom values), nextDouble() , nextFloat() , nextInt() , and nextLong() . Don’t be\nconfused by the capitalization of Float , Double , etc. They return the primitive types\nboolean , float , double , etc., not the capitalized wrapper objects. Clear enough?\nMaybe an example will help:\n    // java.util.Random methods are non-static, so need to construct\n    Random r = new Random();\n    for (int i=0; i<10; i++)\n    System.out.println(""A double from java.util.Random is ""  + r.nextDouble ());\n    for (int i=0; i<10; i++)\n    System.out.println(""An integer from java.util.Random is ""  + r.nextInt());\nA fixed value (starting seed ) can be provided to generate repeatable values, as for test‐\ning. Y ou can also use the java.util.Random nextGaussian()  method, as shown\nnext. The nextDouble()  methods try to give a flat distribution between 0 and 1.0, in\nwhich each value has an equal chance of being selected. A Gaussian or normal distri‐\nbution is a bell curve of values from negative infinity to positive infinity, with the\nmajority of the values around zero (0.0).\n// numbers/Random3.java\nRandom r = new Random();\nfor (int i = 0; i < 10; i++)\n    System.out.println(""A gaussian random double is ""  + r.nextGaussian ());\nTo illustrate the different distributions, I generated 10,000 numbers using nextRan\ndom()  first and then using nextGaussian() . The code for this is in Random4.java\n(not shown here) and is a combination of the previous programs with code to print\nthe results into files. I then plotted histograms using the R statistics package (see\nChapter 11  and http://www.r-project.org ). The R script used to generate the graph,\nrandomnesshistograms.r , is in javasrc  under main/src/main/resources . The results are\nshown in Figure 5-1 .\n152 | Chapter 5: Numbers",4010
196-See Also.pdf,196-See Also,,0
197-5.10 Multiplying Matrices.pdf,197-5.10 Multiplying Matrices,,0
198-Problem.pdf,198-Problem,,0
199-Solution.pdf,199-Solution,,0
200-Discussion.pdf,200-Discussion,"Looks like both PRNGs do their job!\nFigure 5-1. Flat (left)  and Gaussian (right) distributions\nSee Also\nThe javadoc documentation for java.util.Random , and the warning in Recipe 5.0\nabout pseudorandomness versus real randomness.\nFor cryptographic use, see class java.security.SecureRandom , which provides cryp‐\ntographically strong pseudorandom number generators.\n5.10 Multiplying Matrices\nProblem\nY ou need to multiply a pair of two-dimensional arrays, as is common in mathematical\nand engineering applications.\nSolution\nUse the following code as a model.\nDiscussion\nIt is straightforward to multiply an array of a numeric type. In real life you would\nprobably use a full-blown package such as the Efficient Java Matrix Library (EJML)  or \nDeepLearning4Java’s ND4J package . However a simple implementation can serve to\nshow the concepts involved; the code in Example 5-6  implements matrix\nmultiplication.\nExample 5-6. Matrix.java\npublic class Matrix {\n5.10 Multiplying Matrices | 153\n    /* Matrix-multiply two arrays together.\n     * The arrays MUST be rectangular.\n     * @author Adapted from Tom Christiansen & Nathan Torkington's\n     * implementation in their Perl Cookbook.\n     */\n    public static int[][] multiply (int[][] m1, int[][] m2) {\n        int m1rows = m1.length;\n        int m1cols = m1[0].length;\n        int m2rows = m2.length;\n        int m2cols = m2[0].length;\n        if (m1cols != m2rows)\n            throw new IllegalArgumentException (\n                ""matrices don't match: ""  + m1cols + "" != "" + m2rows);\n        int[][] result = new int[m1rows][m2cols];\n        // multiply\n        for (int i=0; i<m1rows; i++) {\n            for (int j=0; j<m2cols; j++) {\n                for (int k=0; k<m1cols; k++) {\n                    result[i][j] += m1[i][k] * m2[k][j];\n                }\n            }\n        }\n        return result;\n    }\n    /** Matrix print.\n     */\n    public static void mprint(int[][] a) {\n        int rows = a.length;\n        int cols = a[0].length;\n        System.out.println(""array["" +rows+""][""+cols+""] = {"");\n        for (int i=0; i<rows; i++) {\n            System.out.print(""{"");\n            for (int j=0; j<cols; j++)\n                System.out.print("" "" + a[i][j] + "","");\n            System.out.println(""},"");\n        }\n        System.out.println(""};"");\n    }\n}\nHere is a program that uses the Matrix  class to multiply two arrays of ints:\n        int x[][] = {\n            { 3, 2, 3 },\n            { 5, 9, 8 },\n        };\n        int y[][] = {\n            { 4, 7 },\n            { 9, 3 },\n154 | Chapter 5: Numbers",2639
201-See Also.pdf,201-See Also,,0
202-5.11 Using Complex Numbers.pdf,202-5.11 Using Complex Numbers,,0
203-Problem.pdf,203-Problem,,0
204-Solution.pdf,204-Solution,"{ 8, 1 },\n        };\n        int z[][] = Matrix.multiply (x, y);\n        Matrix.mprint(x);\n        Matrix.mprint(y);\n        Matrix.mprint(z);\nSee Also\nConsult a book on numerical methods for more things to do with matrices; one of\nour reviewers recommends the series of Numerical Recipes  books, available from\nhttp://nrbook.com . (Note that this site has a link to their new web presence, https://\nnumerical.recipes  however, that site requires Adobe Flash, which most browsers no\nlonger support due to security concerns.) There are several translations of the book’s\ncode into various languages, including Java. Pricing varies by package.\nCommercial software packages can do some of these calculations for you; for one\nexample, see the numeric libraries available from Rogue Wave Software .\n5.11 Using Complex Numbers\nProblem\nY ou need to manipulate complex numbers, as is common in mathematical, scientific,\nor engineering applications.\nSolution\nJava does not provide any explicit support for dealing with complex numbers. Y ou\ncould keep track of the real and imaginary parts and do the computations yourself,\nbut that is not a very well-structured solution.\nA better solution, of course, is to use a class that implements complex numbers.\nI once wrote just such a class, but now I recommend using the Apache Commons\nMath library for this. The build coordinates for this are\norg.apache.commons:commons-math3:3.6.1  (or later). First, an example of using\nApache’s library:\npublic class ComplexDemoACM  {\n    public static void main(String[] args) {\n        Complex c = new Complex(3,  5);\n        Complex d = new Complex(2, -2);\n        System.out.println(c);\n        System.out.println(c + "".getReal() = ""  + c.getReal());\n        System.out.println(c + "" + "" + d + "" = "" + c.add(d));\n        System.out.println(c + "" + "" + d + "" = "" + c.add(d));\n        System.out.println(c + "" * "" + d + "" = "" + c.multiply (d));\n5.11 Using Complex Numbers | 155\n        System.out.println(c.divide(d));\n    }\n}\nRunning this demo program produces the following output:\n(3.0, 5.0)\n(3.0, 5.0).getReal() = 3.0\n(3.0, 5.0) + (2.0, -2.0) = (5.0, 3.0)\n(3.0, 5.0) + (2.0, -2.0) = (5.0, 3.0)\n(3.0, 5.0) * (2.0, -2.0) = (16.0, 4.0)\n(-0.5, 2.0)\nExample 5-7  is the source for my version of the Complex  class and shouldn’t require\nmuch explanation. The Apache one is admittedly more sophisticated, but I leave\nmine here just to demystify the basic operation of complex numbers.\nTo keep the API general, I provide—for each of add, subtract, and multiply— both a\nstatic method that works on two complex objects and a nonstatic method that applies\nthe operation to the given object and one other object.\nExample 5-7. main/src/main/java/numbers/Complex.java\npublic class Complex {\n    /** The real part */\n    private double r;\n    /** The imaginary part */\n    private double i;\n    /** Construct a Complex */\n    Complex(double rr, double ii) {\n        r = rr;\n        i = ii;\n    }\n    /** Display the current Complex as a String, for use in\n     * println() and elsewhere.\n     */\n    public String toString () {\n        StringBuilder  sb = new StringBuilder ().append(r);\n        if (i>0)\n            sb.append('+');    // else append(i) appends - sign\n        return sb.append(i).append('i').toString ();\n    }\n    /** Return just the Real part */\n    public double getReal() {\n        return r;\n    }\n    /** Return just the Real part */\n    public double getImaginary () {\n        return i;\n156 | Chapter 5: Numbers\n    }\n    /** Return the magnitude of a complex number */\n    public double magnitude () {\n        return Math.sqrt(r*r + i*i);\n    }\n    /** Add another Complex to this one\n     */\n    public Complex add(Complex other) {\n        return add(this, other);\n    }\n    /** Add two Complexes\n     */\n    public static Complex add(Complex c1, Complex c2) {\n        return new Complex(c1.r+c2.r, c1.i+c2.i);\n    }\n    /** Subtract another Complex from this one\n     */\n    public Complex subtract (Complex other) {\n        return subtract (this, other);\n    }\n    /** Subtract two Complexes\n     */\n    public static Complex subtract (Complex c1, Complex c2) {\n        return new Complex(c1.r-c2.r, c1.i-c2.i);\n    }\n    /** Multiply this Complex times another one\n     */\n    public Complex multiply (Complex other) {\n        return multiply (this, other);\n    }\n    /** Multiply two Complexes\n     */\n    public static Complex multiply (Complex c1, Complex c2) {\n        return new Complex(c1.r*c2.r - c1.i*c2.i, c1.r*c2.i + c1.i*c2.r);\n    }\n    /** Divide c1 by c2.\n     * @author Gisbert Selke.\n     */\n    public static Complex divide(Complex c1, Complex c2) {\n        return new Complex(\n            (c1.r*c2.r+c1.i*c2.i)/(c2.r*c2.r+c2.i*c2.i),\n            (c1.i*c2.r-c1.r*c2.i)/(c2.r*c2.r+c2.i*c2.i));\n    }\n    /* Compare this Complex number with another\n5.11 Using Complex Numbers | 157",5014
205-5.12 Handling Very Large Numbers.pdf,205-5.12 Handling Very Large Numbers,,0
206-Problem.pdf,206-Problem,,0
207-Solution.pdf,207-Solution,,0
208-Discussion.pdf,208-Discussion,"*/\n    public boolean equals(Object o) {\n        if (o.getClass () != Complex.class) {\n            throw new IllegalArgumentException (\n                    ""Complex.equals argument must be a Complex"" );\n        }\n        Complex other = (Complex)o;\n        return r == other.r && i == other.i;\n    }\n    /* Generate a hashCode; not sure how well distributed these are.\n     */\n    public int hashCode () {\n        return (int)(r) |  (int)i;\n    }\n}\n5.12 Handling Very Large Numbers\nProblem\nY ou need to handle integer numbers larger than Long.MAX_VALUE  or floating-point\nvalues larger than Double.MAX_VALUE .\nSolution\nUse the BigInteger  or BigDecimal  values in package java.math , as shown in\nExample 5-8 .\nExample 5-8. main/src/main/java/numbers/BigNums.java\n        System.out.println(""Here's Long.MAX_VALUE: ""  + Long.MAX_VALUE );\n        BigInteger  bInt = new BigInteger (""3419229223372036854775807"" );\n        System.out.println(""Here's a bigger number: ""  + bInt);\n        System.out.println(""Here it is as a double: ""  + bInt.doubleValue ());\nNote that the constructor takes the number as a string. Obviously you couldn’t just\ntype the numeric digits because, by definition, these classes are designed to represent\nnumbers larger than will fit in a Java long .\nDiscussion\nBoth BigInteger  and BigDecimal  objects are immutable; that is, once constructed,\nthey always represent a given number. That said, a number of methods return new\nobjects that are mutations of the original, such as negate() , which returns the nega‐\ntive of the given BigInteger  or BigDecimal . There are also methods corresponding\nto most of the Java language built-in operators defined on the base types int/long\n158 | Chapter 5: Numbers\nand float /double . The division method makes you specify the rounding method;\nconsult a book on numerical analysis for details. Example 5-9  is a simple stack-based\ncalculator using BigDecimal  as its numeric data type.\nExample 5-9. main/src/main/java/numbers/BigNumCalc.java\npublic class BigNumCalc  {\n    /** an array of Objects, simulating user input */\n    public static Object[] testInput  = {\n        new BigDecimal (""3419229223372036854775807.23343"" ),\n        new BigDecimal (""2.0""),\n        ""*"",\n    };\n    public static void main(String[] args) {\n        BigNumCalc  calc = new BigNumCalc ();\n        System.out.println(calc.calculate (testInput ));\n    }\n    /**\n     * Stack of numbers being used in the calculator.\n     */\n    Stack<BigDecimal > stack = new Stack<>();\n    /**\n     * Calculate a set of operands; the input is an Object array containing\n     * either BigDecimal objects (which may be pushed onto the Stack) and\n     * operators (which are operated on immediately).\n     * @param input\n     * @return\n     */\n    public BigDecimal  calculate (Object[] input) {\n        BigDecimal  tmp;\n        for (int i = 0; i < input.length; i++) {\n            Object o = input[i];\n            if (o instanceof  BigDecimal ) {\n                stack.push((BigDecimal ) o);\n            } else if (o instanceof  String) {\n                switch (((String)o).charAt(0)) {\n                // + and * are commutative, order doesn't matter\n                case '+':\n                    stack.push((stack.pop()).add(stack.pop()));\n                    break;\n                case '*':\n                    stack.push((stack.pop()).multiply (stack.pop()));\n                    break;\n                // - and /, order *does* matter\n                case '-':\n                    tmp = (BigDecimal )stack.pop();\n                    stack.push((stack.pop()).subtract (tmp));\n5.12 Handling Very Large Numbers | 159",3720
209-5.13 Program TempConverter.pdf,209-5.13 Program TempConverter,"break;\n                case '/':\n                    tmp = stack.pop();\n                    stack.push((stack.pop()).divide(tmp,\n                        BigDecimal .ROUND_HALF_UP ));\n                    break;\n                default:\n                    throw new IllegalStateException (""Unknown OPERATOR popped"" );\n                }\n            } else {\n                throw new IllegalArgumentException (""Syntax error in input"" );\n            }\n        }\n        return stack.pop();\n    }\n}\nRunning this produces the expected (very large) value:\n> javac -d . numbers/BigNumCalc.java\n> java numbers.BigNumCalc\n6838458446744073709551614.466860\n>\nThe current version has its inputs hardcoded, as does the JUnit test program, but in\nreal life you can use regular expressions to extract words or operators from an input\nstream (as in Recipe 4.5 ), or you can use the StreamTokenizer  approach of the simple\ncalculator (see Recipe 10.5 ). The stack of numbers is maintained using a\njava.util.Stack  (see Recipe 7.16 ).\nBigInteger  is mainly useful in cryptographic and security applications. Its method \nisProbablyPrime()  can create prime pairs for public key cryptography. BigDecimal\nmight also be useful in computing the size of the universe.\n5.13 Program: TempConverter\nThe program shown in Example 5-10  prints a table of Fahrenheit temperatures (still\nused in daily weather reporting in the US and its territories, Liberia, and some coun‐\ntries in the Caribbean) and the corresponding Celsius temperatures (used in science\neverywhere and in daily life in the rest of the world).\nExample 5-10. main/src/main/java/numbers/TempConverter.java\npublic class TempConverter  {\n    public static void main(String[] args) {\n        TempConverter  t = new TempConverter ();\n        t.start();\n        t.data();\n160 | Chapter 5: Numbers\n        t.end();\n    }\n    protected  void start() {\n    }\n    protected  void data() {\n        for (int i=-40; i<=120; i+=10) {\n            double c = fToC(i);\n            print(i, c);\n        }\n    }\n    public static double cToF(double deg) {\n        return ( deg * 9 / 5) + 32;\n    }\n    public static double fToC(double deg) {\n        return ( deg - 32 ) * ( 5d / 9 );\n    }\n    protected  void print(double f, double c) {\n        System.out.println(f + "" "" + c);\n    }\n    protected  void end() {\n    }\n}\nThis works, but these numbers print with about 15 digits of (useless) decimal frac‐\ntions! The second version of this program subclasses the first and uses printf  (see\nRecipe 10.4 ) to control the formatting of the converted temperatures (see\nExample 5-11 ). It will now look right, assuming you’re printing in a monospaced font.\nExample 5-11. main/src/main/java/numbers/TempConverter2.java\npublic class TempConverter2  extends TempConverter  {\n    public static void main(String[] args) {\n        TempConverter  t = new TempConverter2 ();\n        t.start();\n        t.data();\n        t.end();\n    }\n    @Override\n    protected  void print(double f, double c) {\n        System.out.printf(""%6.2f %6.2f%n"" , f, c);\n    }\n    @Override\n5.13 Program: TempConverter | 161",3187
210-5.14 Program Number Palindromes.pdf,210-5.14 Program Number Palindromes,"protected  void start() {\n        System.out.println(""Fahr    Centigrade"" );\n    }\n    @Override\n    protected  void end() {\n        System.out.println(""-------------------"" );\n    }\n}\nC:\javasrc\numbers> java numbers.TempConverter2\nFahr    Centigrade\n-40.00 -40.00\n-30.00 -34.44\n-20.00 -28.89\n-10.00 -23.33\n  0.00 -17.78\n 10.00 -12.22\n 20.00  -6.67\n 30.00  -1.11\n 40.00   4.44\n 50.00  10.00\n 60.00  15.56\n 70.00  21.11\n 80.00  26.67\n 90.00  32.22\n100.00  37.78\n110.00  43.33\n120.00  48.89\n5.14 Program: Number Palindromes\nMy wife, Betty, recently reminded me of a theorem that I must have studied in high\nschool but whose name I have long since forgotten: that any positive integer number\ncan be used to generate a palindrome by adding to it the number comprised of its\ndigits in reverse order. Palindromes are sequences that read the same in either direc‐\ntion, such as the name “ Anna” or the phrase “Madam, I’m Adam” (ignoring spaces\nand punctuation). We normally think of palindromes as composed of text, but the\nconcept can be applied to numbers: 13,531 is a palindrome. Start with the number 72,\nfor example, and add to it the number 27. The results of this addition is 99, which is a\n(short) palindrome. Starting with 142, add 241, and you get 383. Some numbers take\nmore than one try to generate a palindrome. 1,951 + 1,591 yields 3,542, which is not\npalindromic. The second round, however, 3,542 + 2,453, yields 5,995, which is. The\nnumber 17,892, which my son Benjamin picked out of the air, requires 12 rounds to\ngenerate a palindrome, but it does terminate:\nC:\javasrc\numbers> java  numbers.Palindrome 72 142 1951 17892\nTrying 72\n72->99\n162 | Chapter 5: Numbers\n6Certain values do not work; for example, Ashish Batia reported that this version gets an exception on the\nvalue 8,989 (which it does).Trying 142\n142->383\nTrying 1951\nTrying 3542\n1951->5995\nTrying 17892\nTrying 47763\nTrying 84537\nTrying 158085\nTrying 738936\nTrying 1378773\nTrying 5157504\nTrying 9215019\nTrying 18320148\nTrying 102422529\nTrying 1027646730\nTrying 1404113931\n17892->2797227972\nC:\javasrc\numbers>\nIf this sounds to you like a natural candidate for recursion, you are correct. Recursion\ninvolves dividing a problem into simple and identical steps that can be implemented\nby a function that calls itself and provides a way of termination. Our basic approach,\nas shown in method findPalindrome , is this:\nlong findPalindrome(long num) {\n    if (isPalindrome(num))\n        return num;\n    return findPalindrome(num + reverseNumber(num));\n}\nThat is, if the starting number is already a palindromic number, return it; otherwise,\nadd it to its reverse, and try again. The version of the code shown here handles simple\ncases directly (single digits are always palindromic, for example). We won’t think\nabout negative numbers because these have a character at the front that loses its\nmeaning if placed at the end, and hence are not strictly palindromic. Further, palin‐\ndromic forms of certain numbers are too long to fit in Java’s 64-bit long  integer.\nThese cause underflow, which is trapped. As a result, an error message like “too big”\nis reported.6 Having said all that, Example 5-12  shows the code.\nExample 5-12. main/src/main/java/numbers/Palindrome.java\npublic class Palindrome  {\n5.14 Program: Number Palindromes | 163\n    public static boolean verbose = true;\n    public static void main(String[] argv) {\n        for (String num : argv) {\n            try {\n                long l = Long.parseLong (num);\n                if (l < 0) {\n                    System.err.println(num + "" -> TOO SMALL"" );\n                    continue ;\n                }\n                System.out.println(num + ""->"" + findPalindrome (l));\n            } catch (NumberFormatException  e) {\n                System.err.println(num + ""-> INVALID"" );\n            } catch (IllegalStateException  e) {\n                System.err.println(num + ""-> "" + e);\n            }\n        }\n    }\n    /** find a palindromic number given a starting point, by\n     * recursing until we get a number that is palindromic.\n     */\n    static long findPalindrome (long num) {\n        if (num < 0)\n            throw new IllegalStateException (""negative"" );\n        if (isPalindrome (num))\n            return num;\n        if (verbose)\n             System.out.println(""Trying ""  + num);\n        return findPalindrome (num + reverseNumber (num));\n    }\n    /** The number of digits in Long.MAX_VALUE */\n    protected  static final int MAX_DIGITS  = 19;\n    // digits array is shared by isPalindrome and reverseNumber,\n    // which cannot both be running at the same time.\n    /* Statically allocated array to avoid new-ing each time. */\n    static long[] digits = new long[MAX_DIGITS ];\n    /** Check if a number is palindromic. */\n    static boolean isPalindrome (long num) {\n        // Consider any single digit to be as palindromic as can be\n        if (num >= 0 && num <= 9)\n            return true;\n        int nDigits = 0;\n        while (num > 0) {\n            digits[nDigits++] = num % 10;\n            num /= 10;\n        }\n164 | Chapter 5: Numbers",5221
211-See Also.pdf,211-See Also,"for (int i=0; i<nDigits/2; i++)\n            if (digits[i] != digits[nDigits - i - 1])\n                return false;\n        return true;\n    }\n    static long reverseNumber (long num) {\n        int nDigits = 0;\n        while (num > 0) {\n            digits[nDigits++] = num % 10;\n            num /= 10;\n        }\n        long ret = 0;\n        for (int i=0; i<nDigits; i++) {\n            ret *= 10;\n            ret += digits[i];\n        }\n        return ret;\n    }\n}\nWhile it’s not strictly a numerical solution, Daniel Hinojosa noted that you can use \nStringBuilder  to do the reversal portion, resulting in shorter, more elegant code that\nis only fractionally slower:\n    static boolean isPalindrome(long num) {\n        long result = reverseNumber(num);\n        return num == result;\n    }\n    private static long reverseNumber(long num) {\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(num);\n        return Long.parseLong(stringBuilder.reverse().toString());\n    }\nA full version of his code is in the file PalindromeViaStringBuilder.java .\nSee Also\nPeople using Java in scientific or large-scale numeric computing may wish to check\nout the value types forthcoming from “Project Valhalla” in Java . See also a 2019 pre‐\nsentation titled “Vectors and Numerics on the JVM” .\n5.14 Program: Number Palindromes | 165",1389
212-Chapter 6. Dates and Times.pdf,212-Chapter 6. Dates and Times,,0
213-6.0 Introduction.pdf,213-6.0 Introduction,"6For those with an interest in historical arcana, the differences are documented on his blog .CHAPTER 6\nDates and Times\n6.0 Introduction\nDevelopers suffered for a decade and a half under the inconsistencies and ambiguities\nof the Date  class from Java 1.0 and its replacement wannabe, the Calendar  class from\nJava 1.1. Several alternative Date  replacement packages emerged, including the\nsimple and sensible Date4J  and the more comprehensive Joda-Time package . Java 8\nintroduced a new, consistent, and well-thought-out package for date and time han‐\ndling under the aegis of the Java Community Process, JSR-310, shepherded by devel‐\noper Stephen Colebourne, based on his earlier package Joda-Time, but with several\nimportant design changes.6 This package is biased toward ISO 8601 dates; the default\nformat is, for example, 2015-10-23T10:22:45. But it can, of course, work with other\ncalendar schemes.\nOne of the key benefits of the new API is that it provides useful operations  such as\nadding/subtracting dates/times. Much time was wasted by developers reimplement‐\ning these useful operations again and again. With the new APIs, one can use the built-\nin functionality. That said, millions of lines of code are based on the old APIs, so we’ll\nreview them briefly, and consider interfacing the new API to legacy code in the final\nrecipe of this chapter, Recipe 6.9 .\nAnother advantage of the new API is that almost all objects are immutable and thus\nthread-safe. This can be of considerable benefit as we move headlong into the mas‐\nsively parallel era.\n167\nBecause there are no set methods, and thus the getter method paradigm doesn’t\nalways make sense, the API provides a series of new methods to replace such meth‐\nods, listed in Table 6-1 .\nTable 6-1. New date/time API: common methods\nName Description\nat Combines with another object\nformat Use provided formatter to produce a formatted string\nfrom Factory: convert input parameters to instance of target\nget Retrieve one field  from the instance\nis Examine the state of the given object\nminus Return a copy with the given amount subtracted\nnow BuilderFactory: get the current time, date, etc.\nof Factory: create new method by parsing inputs\nparse Factory: parse single input string to produce instance of target\nplus Return a copy with the given amount added\nto Convert this object to another type\nwith Return a copy with the given field  changed; replaces set  methods\nThe JSR 310 API specifies a dozen or so main classes. Those representing times are\neither continuous time or human time. Continuous time  is based on Unix time, a\ndeeper truth from the dawn of (computer) time, and is represented as a single monot‐\nonically increasing number. The time value of 0 in Unix represented the first second\nof January 1, 1970 UTC—about the time Unix was invented. Each unit of increment\nthere represented one second of time. This has been used as a time base in most oper‐\nating systems developed since. However, a 32-bit integer representing the number of\nseconds since 1970 runs out fairly soon—in the year 2038 AD. Most Unix systems\nhave, in the aftermath of the Y2K frenzy, quietly and well in advance headed off a\npossible Y2038 frenzy by converting the time value from a 32-bit quantity to a 64-bit\nquantity. Java also used this time base, but used 64 bits, and stored its time in milli‐\nseconds, because a 64-bit time in milliseconds since 1970 will not overlow until quite\na few years into the future (keep this date open in your calendar—August 17,\n292,278,994 CE). Here is a calculation that shows how I got that date:\n        Date endOfTime  = new Date(Long.MAX_VALUE );\n        System.out.println(""Java time overflows on ""  + endOfTime );\nThe new API is in five packages, as shown in Table 6-2 ; as usual, the top-level one\ncontains the most commonly used pieces.\n168 | Chapter 6: Dates and Times\nTable 6-2. New date/time API: packages\nName Description\njava.time Common classes for dates, times, instants, and durations\njava.time.chrono API for non-ISO calendar systems\njava.time.format Formatting classes (see Recipe 6.2 )\njava.time.temporal Date and time access using fields,  units, and adjusters\njava.time.zone Support for time zones and their rules\nThe basic java.time  package contains a dozen or so classes, as well as a couple of\nenums and one general-purpose exception (shown in Tables 6-3, 6-4, and 6-5).\nTable 6-3. New date/time API: basics\nClass Description\nClock Replaceable factory for getting current time\nInstant A point in time since January 1, 1970, expressed in nanoseconds\nDuration A length of time, also expressed in nanoseconds\nHuman time represents times and dates as we use them in our everyday life. These\nclasses are listed in Table 6-4 .\nTable 6-4. New date/time API: human time\nClass Description\nCalendrical Connects to the low-level API\nDateTimeFields Stores a map of field-value  pairs, which are not required to be consistent\nDayOfWeek A day of the week (e.g., Tuesday)\nLocalDate A bare date (day, month, and year) with no adjustments\nLocalTime A bare time (hour, minute, seconds) with no adjustments\nLocalDateTime The combination of the above\nMonthDay Month and day\nOffsetTime A time of day with a time zone offset  like –04:00, with no date or zone\nOffsetDateTime A date and time with a time zone offset  like –04:00, with no time zone\nPeriod A descriptive amount of time, such as “2 months and 3 days”\nZonedDateTime The date and time with a time zone and an offset\nYear A year by itself\nYearMonth A year and month\n6.0 Introduction | 169",5630
214-6.1 Finding Todays Date.pdf,214-6.1 Finding Todays Date,,0
215-Problem.pdf,215-Problem,,0
216-Solution.pdf,216-Solution,,0
217-Discussion.pdf,217-Discussion,"Almost all the top-level classes directly extend java.lang.Object  and are held to\nconsistency by a variety of interfaces, which are declared in the subpackages. The date\nand time classes mostly implement Comparable , which makes sense.\nTable 6-5  shows the two time-zone-specific classes used with ZonedDateTime , Offset\nDateTime , and OffsetTime .\nTable 6-5. New date/time API: support\nClass Description\nZoneOffset A time offset  from UTC (hours, minutes, seconds)\nZoneId Defines  a time zone such as Canada/Eastern  and its conversion rules\nThe new API is a fluent  API , in which most operations return the object they have\noperated upon, so that you can chain multiple calls without the need for tedious and\nannoying temporary variables:\nLocalTime time = LocalTime.now().minusHours(5); // the time 5 hours ago\nThis results in a more natural and convenient coding style, in my opinion. Y ou can\nalways write code with lots of temporary variables if you want; you’re the one who\nwill have to read through it later.\n6.1 Finding Today’s Date\nProblem\nY ou want to find today’s date and/or time.\nSolution\nInvoke the appropriate builder to obtain a LocalDate , LocalTime , or LocalDateTime\nobject and call its toString()  method.\nDiscussion\nThese classes do not provide public constructors, so you will need to call one of its\nfactory methods to get an instance. They all provide a now()  method, which does\nwhat its name implies. The CurrentDateTime  demo program shows simple use of all\nthree:\npublic class CurrentDateTime  {\n    public static void main(String[] args) {\n        LocalDate  dNow = LocalDate .now();\n        System.out.println(dNow);\n        LocalTime  tNow = LocalTime .now();\n170 | Chapter 6: Dates and Times\n        System.out.println(tNow);\n        LocalDateTime  now = LocalDateTime .now();\n        System.out.println(now);\n    }\n}\nRunning it produces this output:\n2013-10-28\n22:23:55.641\n2013-10-28T22:23:55.642\nThe formatting is nothing spectacular, but it’s adequate. We’ll deal with fancier for‐\nmatting in Recipe 6.2 .\nWhile this works, in full-scale applications, it’s recommended to pass a Clock  instance\ninto all the now()  methods. Clock  is a factory object that is used internally to find the\ncurrent time. In testing, you often want to have a known date or time used so you can\ncompare against known output. The Clock  class makes this easy. Example 6-1  uses a\nClock  and allows replacing the default Clock  by calling a setter. Alternately you could\nuse a dependency injection framework like CDI or Spring to provide the correct ver‐\nsion of the Clock  class.\nExample 6-1. main/src/main/java/datetime/TestableDateTime\npackage datetime ;\nimport java.time.Clock ;\nimport java.time.LocalDateTime ;\n/**\n * TestableDateTime allows test code to plug in a Fixed clock\n */\npublic class TestableDateTime  {\n    private static Clock clock = Clock.systemDefaultZone ();\n    public static void main(String[] args) {\n        System.out.println(""It is now ""  + LocalDateTime .now(clock));\n    }\n    public static void setClock (Clock clock) {\n        TestableDateTime .clock = clock;\n    }\n}\nIn normal operation this would get the current date and time. In testing you would\ncall the setClock()  method with a Clock  instance obtained from the static method\nClock.fixed(Instant fixedInstant, ZoneId zone) , passing in the time that your\ntesting code expects. The fixed clock does not tick, so don’t worry about the milli‐\nseconds between setting the clock to fixed and the invocation of your tests.\n6.1 Finding Today’s Date | 171",3622
218-6.2 Formatting Dates and Times.pdf,218-6.2 Formatting Dates and Times,,0
219-Problem.pdf,219-Problem,,0
220-Solution.pdf,220-Solution,,0
221-Discussion.pdf,221-Discussion,"6.2 Formatting Dates and Times\nProblem\nY ou want to provide better formatting for date and time objects.\nSolution\nUse java.time.format.DateTimeFormatter .\nDiscussion\nThe DateTimeFormatter  class provides an amazing number of possible formatting\nstyles. If you don’t want to use one of the provided 20 or so predefined formats, you\ncan define your own using DateTimeFormatter.ofPattern(String pattern) . The\npattern  string can contain any characters, but almost every letter of the alphabet has\nbeen defined to mean something, in addition to the obvious Y, M, D, h, m, and s. In\naddition, the quote character and square bracket characters are defined, and the\nsharp sign ( #) and curly braces are reserved for future use.\nAs is common with date formatting languages, the number of repetitions of a letter in\nthe pattern gives a clue to its intended length of detail. Thus, for example, “MMM”\ngives “Jan, ” whereas “MMMM” gives “January. ”\nTable 6-6  is an attempt at a complete list of the formatting characters, adapted from\nthe javadoc for JSR-310.\nTable 6-6. DateFormatter format characters\nSymbol Meaning Presentation Examples\nG Era Text AD; Anno Domini\ny Year of era Year 2004; 04\nu Year of era Year See note.\nD Day of year Number 189\nM/L Month of year Number/text 7; 07; Jul; July; J\nd Day of month Number 10\nQ/q Quarter of year Number/text 3; 03; Q3, 3rd quarter\nY Week based year Year 1996; 96\nw Week of week based year Number 27\nW Week of month Number 4\ne/c Localized day of week Number/text 2; 02; Tue; Tuesday; T\nE Day of week Text Tue; Tuesday; T\nF Week of month Number 3\n172 | Chapter 6: Dates and Times\nSymbol Meaning Presentation Examples\na am pm of day Text PM\nh Clock hour of am pm (1-12) Number 12\nK Hour of am pm (0-11) Number 0\nk Clock hour of am pm (1-24) Number 0\nH Hour of day (0-23) Number 0\nm Minute of hour Number 30\ns Second of minute Number 55\nS Fraction of second Fraction 978\nA Millisecond of day Number 1234\nn Nanosecond of second Number 987654321\nN Nanosecond of day Number 1234000000\nV Time zone ID Zone-id America/Los_Angeles; Z; –08:30\nz Time zone name Zone-name Pacific  Standard Time; PST\nX Zone offset  Z for zero Offset-X Z; –08; –0830; –08:30; –083015; –08:30:15;\nx Zone offset Offset-x +0000; –08; –0830; –08:30; –083015; –08:30:15;\nZ Zone offset Offset-Z +0000; –0800; –08:00;\nO Localized zone offset Offset-O GMT+8; GMT+08:00; UTC–08:00;\np Pad next Pad modifier 1\ny and u work the same for AD years; however, for a year of 3 BC,\nthe y pattern returns 3, whereas the u pattern returns –2 (a.k.a. pro‐\nleptic year).\nExample 6-2  contains some examples of converting in both directions between\nstrings and dates.\nExample 6-2. main/src/main/java/datetime/DateFormatter.java (example date\nformatting and parsing)\npublic class DateFormatter  {\n    public static void main(String[] args) {\n        // Format a date ISO8601-like but with slashes instead of dashes\n        DateTimeFormatter  df = DateTimeFormatter .ofPattern (""yyyy/LL/dd"" );\n        System.out.println(df.format(LocalDate .now()));\n        // Parse a String to a date using the same formatter\n        System.out.println(LocalDate .parse(""2014/04/01"" , df));\n        // Format a Date and Time without timezone information\n6.2 Formatting Dates and Times | 173",3327
222-6.3 Converting Among DatesTimes YMDHMS and Epoch Seconds.pdf,222-6.3 Converting Among DatesTimes YMDHMS and Epoch Seconds,,0
223-Problem.pdf,223-Problem,,0
224-Solution.pdf,224-Solution,,0
225-6.4 Parsing Strings into Dates.pdf,225-6.4 Parsing Strings into Dates,"DateTimeFormatter  nTZ =\n            DateTimeFormatter .ofPattern (""d MMMM, yyyy h:mm a"" );\n        System.out.println(ZonedDateTime .now().format(nTZ));\n    }\n}\n6.3 Converting Among Dates/Times, YMDHMS, and\nEpoch Seconds\nProblem\nY ou need to convert among dates/times, YMDHMS, epoch seconds, or some other\nnumeric value.\nSolution\nUse the appropriate date/time factory or retrieval methods.\nDiscussion\nThe epoch is the beginning of time as far as modern operating systems go. Unix time,\nand some versions of Windows time, count off inexorably the seconds since the\nepoch. When Ken Thompson and Dennis Ritchie came up with this format in 1970,\nseconds seemed like a fine measure, and 32 bits’ worth of seconds seemed nearly\ninfinite. On operating systems that store the epoch in a 32-bit integer, however, time\nis running out. Older versions of most operating systems stored this as a 32-bit\nsigned integer, which unfortunately will overflow in the year 2038.\nWhen Java first came out, it featured a method called System.currentTimeMillis() ,\npresenting epoch seconds with millisecond accuracy. The new Java API uses epoch\nnanoseconds that are still on the same time base and can be obtained with a call to \nSystem.nanoTime() .\nAny of these epoch-related numbers can be converted into, or obtained from, a local\ndate/time. Other numbers can also be used, such as integer years, months, and days.\nAs usual, there are factory methods that create new objects where a change is reques‐\nted. Here is a program that shows some of these conversions in action:\nmain/src/main/java/datetime/DateConversions.java\n        // Convert a number of seconds since the epoch to a local date/time\n        Instant epochSec  = Instant.ofEpochSecond (1000000000L );\n        ZoneId zId = ZoneId.systemDefault ();\n        ZonedDateTime  then = ZonedDateTime .ofInstant (epochSec , zId);\n        System.out.println(""The epoch was a billion seconds old on ""  + then);\n        // Convert a date/time to epoch seconds\n174 | Chapter 6: Dates and Times",2056
226-Problem.pdf,226-Problem,,0
227-Solution.pdf,227-Solution,,0
228-6.5 Difference Between Two Dates.pdf,228-6.5 Difference Between Two Dates,"long epochSecond  = ZonedDateTime .now().toInstant ().getEpochSecond ();\n        System.out.println(""Current epoch seconds = ""  + epochSecond );\n        LocalDateTime  now = LocalDateTime .now();\n        ZonedDateTime  there = now.atZone(ZoneId.of(""Canada/Pacific"" ));\n        System.out.printf(""When it's %s here, it's %s in Vancouver%n"" ,\n            now, there);\n6.4 Parsing Strings into Dates\nProblem\nY ou need to convert user input into java.time  objects.\nSolution\nUse a parse()  method.\nDiscussion\nMany of the date/time classes have a parse()  factory method, which tries to parse a\nstring into an object of that class. For example, LocalDate.parse(String)  returns a\nLocalDate  object for the date given in the input String :\npublic class DateParse  {\n    public static void main(String[] args) {\n        String armisticeDate  = ""1914-11-11"" ;\n        LocalDate  aLD = LocalDate .parse(armisticeDate );\n        System.out.println(""Date: ""  + aLD);\n        String armisticeDateTime  = ""1914-11-11T11:11"" ;\n        LocalDateTime  aLDT = LocalDateTime .parse(armisticeDateTime );\n        System.out.println(""Date/Time: ""  + aLDT);\nAs you probably expect by now, the default format is the ISO8601 date format. How‐\never, we often have to deal with dates in other formats. For this, the DateTimeFormat\nter allows you to specify a particular pattern. For example, “dd MMM uuuu” repre‐\nsents the day of the month (two digits), three letters of the name of the month (Jan,\nFeb, Mar, …), and a four-digit year:\n        DateTimeFormatter  df = DateTimeFormatter .ofPattern (""dd MMM uuuu"" );\n        String anotherDate  = ""27 Jan 2011"" ;\n        LocalDate  random = LocalDate .parse(anotherDate , df);\n        System.out.println(anotherDate  + "" parses as ""  + random);\nThe DateTimeFormatter  object is bidirectional; it can both parse input and format\noutput. We could add this line to the DateParse  example:\n6.4 Parsing Strings into Dates | 175",1978
229-Problem.pdf,229-Problem,,0
230-Solution.pdf,230-Solution,,0
231-See Also.pdf,231-See Also,"System.out.println(aLD + "" formats as ""  + df.format(aLD));\nWhen we run the program, we see the output as follows:\nDate: 1914-11-11\nDate/Time: 1914-11-11T11:11\n27 Jan 2011 parses as 2011-01-27\n1914-11-11 formats as 11 Nov 1914\nThe DateTimeFormatter  is also localized (see Recipe 3.12 ), and can be configured by\ncalling withLocale()  after calling ofPattern() .\n6.5 Difference  Between Two Dates\nProblem\nY ou need to compute the difference between two dates.\nSolution\nUse the static method Period.between()  to find the difference between two Local\nDates .\nDiscussion\nGiven two LocalDate  objects, you can find the difference between them, as a Period ,\nsimply using the static Period.between()  method. Y ou can toString()  the Period\nor, if its default format isn’t good enough, format the result yourself:\nimport java.time.LocalDate ;\nimport java.time.Period ;\n/**\n * Tutorial/Example of LocalDate date difference subtraction\n */\npublic class DateDiff  {\n    public static void main(String[] args) {\n        /** The date at the end of the last century */\n        LocalDate  endof20thCentury  = LocalDate .of(2000, 12, 31);\n        LocalDate  now = LocalDate .now();\n        if (now.getYear() > 2100) {\n            System.out.println(""The 21st century is over!"" );\n            return;\n        }\n        Period diff = Period.between(endof20thCentury , now);\n        System.out.printf(""The 21st century (up to %s) is %s old%n"" , now, diff);\n        System.out.printf(\n176 | Chapter 6: Dates and Times",1536
232-6.6 Adding to or Subtracting from a Date.pdf,232-6.6 Adding to or Subtracting from a Date,,0
233-Problem.pdf,233-Problem,,0
234-Solution.pdf,234-Solution,,0
235-6.7 Handling Recurring Events.pdf,235-6.7 Handling Recurring Events,"""The 21st century is %d years, %d months and %d days old"" ,\n                diff.getYears (), diff.getMonths (), diff.getDays());\n    }\n}\nI wrote this recipe at the end of October 2013; the 20th century AD ended at the end\nof 2000, so the value should be about 12 10/12 years, and it is:\n$ java datetime.DateDiff\nThe 21st century (up to 2013-10-28) is P12Y9M28D old\nThe 21st century is 12 years, 9 months and 28 days old\nBecause of the APIs regularity, you can use the same technique with LocalTime  or\nLocalDateTime .\nThere is also ChronoUnit , which has numerous range values such as DAYS , HOURS ,\nMINUTES , etc. (actually ranging from NANOS  for nanoseconds up to MILLENIA , ERAS ,\nand even FOREVER ). If you want difference information in a certain unit:\njshell> import java.time.temporal.*;\njshell> ChronoUnit.DAYS.between(LocalDate.now(), LocalDate.parse(""2022-02-22""))\n$6 ==> 786\njshell> ChronoUnit.DECADES.between(LocalDate.of(1970,01,01),\n  LocalDate.of(2020,01,01));\n$7 ==> 5\nUnix is on its fifth decade!\nSee Also\nA higher-level way of formatting date/time values is discussed in Recipe 6.2 .\n6.6 Adding to or Subtracting from a Date\nProblem\nY ou need to add or subtract a fixed period to or from a date.\nSolution\nCreate a past or future date by using a locution such as LocalDate.plus\n(Period.ofDays(N)); .\nDiscussion\njava.time  offers a Period  class to represent a length of time, such as a number of\ndays or hours and minutes. LocalDate  and friends offer plus()  and minus()\n6.6 Adding to or Subtracting from a Date | 177",1569
236-Problem.pdf,236-Problem,,0
237-Solution.pdf,237-Solution,,0
238-Discussion.pdf,238-Discussion,"methods  to add or subtract a Period  or other time-related object. Period  offers fac‐\ntory methods such as ofDays() . The following code computes what the date will be\n700 days from now:\nimport java.time.LocalDate ;\nimport java.time.Period ;\n/** DateAdd -- compute the difference between two dates\n * (e.g., today and 700 days from now).\n */\npublic class DateAdd {\n    public static void main(String[] av) {\n        /** Today's date */\n        LocalDate  now =  LocalDate .now();\n        Period p = Period.ofDays(700);\n        LocalDate  then = now.plus(p);\n        System.out.printf(""Seven hundred days from %s is %s%n"" , now, then);\n    }\n}\nRunning this program reports the current date and time and what the date and time\nwill be 700 days from now:\nSeven hundred days from 2013-11-09 is 2015-10-10\n6.7 Handling Recurring Events\nProblem\nY ou need to deal with recurring dates, for example, the third Wednesday of every\nmonth.\nSolution\nUse the TemporalAdjusters  class.\nDiscussion\nThe TemporalAdjuster  interface and the TemporalAdjusters  factory class provide\nmost of what you need for recurring events. There are many interesting and powerful\nadjusters available, shown in Table 6-7 , and you can, of course, develop your own.\n178 | Chapter 6: Dates and Times\nTable 6-7. New date/time API: TemporalAdjusters factory methods\nMethod signature\npublic static TemporalAdjuster firstDayOfMonth();\npublic static TemporalAdjuster lastDayOfMonth();\npublic static TemporalAdjuster firstDayOfNextMonth();\npublic static TemporalAdjuster firstDayOfYear();\npublic static TemporalAdjuster lastDayOfYear();\npublic static TemporalAdjuster firstDayOfNextYear();\npublic static TemporalAdjuster firstInMonth(java.time.DayOfWeek);\npublic static TemporalAdjuster lastInMonth(java.time.DayOfWeek);\npublic static TemporalAdjuster dayOfWeekInMonth(int, java.time.DayOfWeek);\npublic static TemporalAdjuster next(java.time.DayOfWeek);\npublic static TemporalAdjuster nextOrSame(java.time.DayOfWeek);\npublic static TemporalAdjuster previous(java.time.DayOfWeek);\npublic static TemporalAdjuster previousOrSame(java.time.DayOfWeek);\npublic static TemporalAdjuster ofDateAdjuster( java.util.function.UnaryOperator<java.time.LocalDate>);\nThe names of most of these tell you directly what they do. The last one will make\nsense after reading about functional interfaces such as UnaryOperator  in Chapter 9 .\nThese are used with the with()  method of a date/time object. For example, the\nGTABUG  group ( http://gtabug.org ) meets on the third Wednesday of every month.\nI have a RecurringEventDatePicker  class in the darwinsys-api  library; the core\nof it started as the method getMeetingDateInMonth(LocalDate dateContaining\nMonth) , which in our case picks the third Wednesday of a given month (given that\ndayOfWeek  and weekOfMonth  are both set in the constructor). We take the month\n(dateContainingMonth ), adjust it to the first Wednesday in the month using the \nfirstInMonth()  factory method to get a temporal adjuster, then add the number of\nweeks to get the Wednesday in the correct week:\n// Variant versions from older version of RecurringDatePicker.java\n// First version, not for production use!\nprivate LocalDate  getMeetingForMonth (LocalDate  dateContainingMonth ) {\n    return\n        dateContainingMonth .with(TemporalAdjusters .firstInMonth (dayOfWeek ))\n            .plusWeeks (Math.max(0, weekOfMonth  - 1));\n}\nThe second version simplified it to better use the existing API:\nprivate LocalDate  getMeetingForMonth (LocalDate  dateContainingMonth ) {\n    return dateWithMonth .with(\n        TemporalAdjusters .dayOfWeekInMonth (weekOfMonth ,dayOfWeek )\n}\n6.7 Handling Recurring Events | 179\nSince this version was only one statement and is only used twice, we inlined it into\nthe getNextMeeting(int howManyMonthsAway)  method, which returns a LocalDate\nfor the correct day of the given month. Its only complexity is that, for the current\nmonth, the meeting might be before or after today’s date, so we adjust accordingly:\npublic LocalDate  getEventLocalDate (int meetingsAway ) {\n    LocalDate  thisMeeting  = now.with(\n        TemporalAdjusters .dayOfWeekInMonth (weekOfMonth ,dayOfWeek ));\n    // Has the meeting already happened this month?\n    if (thisMeeting .isBefore (now)) {\n        // start from next month\n        meetingsAway ++;\n    }\n    if (meetingsAway  > 0) {\n        thisMeeting  = thisMeeting .plusMonths (meetingsAway ).\n            with(TemporalAdjusters .dayOfWeekInMonth (weekOfMonth ,dayOfWeek ));\n    }\n    return thisMeeting ;\n}\nThis in turn is called within a JavaServer Page (JSP) web view (somewhat simplified;\nthe real code has the complexities of an Add To Calendar API done in JavaScript). If\nyou’ve not used JSPs, plain HTML code is outputted  directly, the contents of <% %>\ntags are executed , and the contents of <%= %>  tags are evaluated and printed  into the\nHTML page, like this:\nUpcoming  Meetings:\n<ul>\n    <%\n    RecurringEventDatePicker  mp =\n      new RecurringEventDatePicker (3, DayOfWeek .WEDNESDAY );\n    DateTimeFormatter  dfm = DateTimeFormatter .ofPattern (""MMMM dd, yyyy"" );\n    for (int i = 0; i <= 2; i++) {\n        LocalDateTime  dt = mp.getEventLocalDateTime (i);\n    %>\n    <li>\n        <%= dt.format(dfm) %>\n    </li>\n    <%\n    }\n    %>\n</ul>\nWhen visiting this site in June or July of 2015, you would have seen something like\nthis:\nUpcoming Meetings:\n* July 15, 2015\n* August 19, 2015\n* September 16, 2015\n180 | Chapter 6: Dates and Times",5602
239-6.8 Computing Dates Involving Time Zones.pdf,239-6.8 Computing Dates Involving Time Zones,,0
240-Problem.pdf,240-Problem,,0
241-Solution.pdf,241-Solution,,0
242-6.9 Interfacing with Legacy Date and Calendar Classes.pdf,242-6.9 Interfacing with Legacy Date and Calendar Classes,"6.8 Computing Dates Involving Time Zones\nProblem\nImagine a problem like “Y our kids are traveling on a trans-Atlantic flight from Tor‐\nonto to London that takes 5 hours 10 minutes from the actual time of departure from\nYYZ. Y our in-laws need one hour to get to LHR and find parking. What time should\nyou phone them to leave for the airport?”\nSolution\nThe solution needs to take account of time zone differences. It can be solved using the\nZonedDateTime  class and methods such as plus()  and minus()  from that class.\nDiscussion\nThe basic steps are shown in Example 6-3 .\nExample 6-3. main/src/main/java/datetime/FlightArrivalTimeCalc.java\npublic class FlightArrivalTimeCalc  {\n    static Duration  driveTime  = Duration .ofHours(1);\n    public static void main(String[] args) {\n        LocalDateTime  when = null;\n        if (args.length == 0) {\n            when = LocalDateTime .now();                                        \n        } else {\n            String time = args[0];\n            LocalTime  localTime  = LocalTime .parse(time);\n            when = LocalDateTime .of(LocalDate .now(), localTime );               \n        }\n        calulateArrivalTime (when);\n    }\n    public static ZonedDateTime  calulateArrivalTime (LocalDateTime  takeOffTime ) {\n        ZoneId torontoZone  = ZoneId.of(""America/Toronto"" ),\n                londonZone  = ZoneId.of(""Europe/London"" );\n        ZonedDateTime  takeOffTimeZoned  =\n            ZonedDateTime .of(takeOffTime , torontoZone );                        \n        Duration  flightTime  =\n            Duration .ofHours(5).plus(10, ChronoUnit .MINUTES);                  \n        ZonedDateTime  arrivalTimeUnZoned  = takeOffTimeZoned .plus(flightTime );  \n        ZonedDateTime  arrivalTimeZoned  =\n            arrivalTimeUnZoned .toInstant ().atZone(londonZone );                 \n        ZonedDateTime  phoneTimeHere  = arrivalTimeUnZoned .minus(driveTime );     \n        System.out.println(""Flight departure time ""  + takeOffTimeZoned );\n6.8 Computing Dates Involving Time Zones | 181",2073
243-Problem.pdf,243-Problem,,0
244-Solution.pdf,244-Solution,,0
245-Discussion.pdf,245-Discussion,"System.out.println(""Flight expected length: ""  + flightTime );\n        System.out.println(\n            ""Flight arrives there at ""  + arrivalTimeZoned  + "" London time."" );\n        System.out.println(""You should phone at ""  + phoneTimeHere  + "" Toronto \ntime"");\n        return arrivalTimeZoned ;\n    }\n}\nGet the departure time as a LocalDateTime  (defaulting to now()  if no arguments\npassed into main() , on the assumption that we run the app when the flight takes\noff).\nConvert departure time to ZonedDateTime .\nConvert flight time to a Duration .\nGet the arrival time by adding the departure time to the flight duration.\nConvert the arrival time to London time with atZone() .\nSince the family takes an hour to get to the airport, subtract that from the arrival\ntime. This yields the time when you should phone them.\n6.9 Interfacing with Legacy Date and Calendar Classes\nProblem\nY ou need to deal with the old Date  and Calendar  classes.\nSolution\nAssuming you have code using the original java.util.Date  and java.util.Calen\ndar, you can convert values as needed using conversion methods.\nDiscussion\nAll the classes and interfaces in the new API were chosen to avoid conflicting with the\ntraditional API. It is thus possible, and will be common for a while, to have imports\nfrom both packages into the same code.\nTo keep the new API clean, most of the necessary conversion routines were added to\nthe old API . Table 6-8  summarizes these conversion routines; note that the methods\nare static if they are shown being invoked with a capitalized class name, otherwise\nthey are instance methods.\n182 | Chapter 6: Dates and Times\nTable 6-8. Legacy date/time interchange\nLegacy class Convert to legacy Convert to modern\njava.util.Date date.from(Instant) Date.toInstant()\njava.util.Calendar calendar.toInstant() -\njava.util.GregorianCalen\ndarGregorianCalendar.from(Zoned\nDateTime)calendar.toZonedDate\nTime()\njava.util.TimeZone - timeZone.toZoneId()\njava.time.DateTimeFormat\nter- dateTimeFormatter.toFor\nmat()\nExample 6-4  shows some of these APIs in action.\nExample 6-4. main/src/main/java/datetime/LegacyDates.java\npublic class LegacyDates  {\n    public static void main(String[] args) {\n        // There and back again, via Date\n        Date legacyDate  = new Date();\n        System.out.println(legacyDate );\n        LocalDateTime  newDate =\n            LocalDateTime .ofInstant (legacyDate .toInstant (),\n            ZoneId.systemDefault ());\n        System.out.println(newDate);\n        Date backAgain  =\n            Date.from(newDate.atZone(ZoneId.systemDefault ()).toInstant ());\n        System.out.println(""Converted back as ""  + backAgain );\n        // And via Calendar\n        Calendar  c = Calendar .getInstance ();\n        System.out.println(c);\n        LocalDateTime  newCal =\n            LocalDateTime .ofInstant (c.toInstant (),\n            ZoneId.systemDefault ());\n        System.out.println(newCal);\n    }\n}\nOf course you do not have to use these legacy converters; you are free to write your\nown. The file LegacyDatesDIY.java  in the javasrc  repository explores this option in\nthe unlikely event you wish to pursue it.\nGiven the amount of code written before Java 8, it is likely that the legacy Date  and\nCalendar  will be around until the end of Java time.\n6.9 Interfacing with Legacy Date and Calendar Classes | 183\nThe new date/time API has many capabilities that we have not explored. Almost\nenough for a small book on the subject, in fact. Meanwhile, you can study the API\ndetails at Oracle .\n184 | Chapter 6: Dates and Times",3622
246-Chapter 7. Structuring Data with Java.pdf,246-Chapter 7. Structuring Data with Java,,0
247-7.1 Using Arrays for Data Structuring.pdf,247-7.1 Using Arrays for Data Structuring,"CHAPTER 7\nStructuring Data with Java\n7.0 Introduction\nAlmost every application beyond “Hello, World” needs to keep track of some struc‐\ntured data. A simple numeric problem might work with three or four numbers only,\nbut most applications have groups of similar data items. A GUI-based application\nmay need to keep track of a number of dialog windows. A personal information man‐\nager, or PIM, needs to keep track of a number of, well, persons. An operating system\nneeds to keep track of who is allowed to log in, who is currently logged in, and what\nthose users are doing. A library needs to keep track of who has books checked out\nand when they’re due. A network server may need to keep track of its active clients. A\npattern emerges here, and it revolves around variations of what has traditionally been\ncalled data  structuring .\nThere are data structures in the memory of a running program; there is structure in\nthe data in a file on disk, and there is structure in the information stored in a data‐\nbase. In this chapter, we concentrate on the first aspect: in-memory data. We’ll cover\nthe second aspect in Chapter 10 ; the third is out of scope for this book.\nIf you had to think about in-memory data, you might want to compare it to a collec‐\ntion of index cards in a filing box or to a treasure hunt where each clue leads to the\nnext. Or you might think of it like my desk—apparently scattered, but actually a very\npowerful collection filled with meaningful information. Each of these is a good anal‐\nogy for a type of data structuring that Java provides. An array is a fixed-length linear\ncollection of data items, like the card filing box: it can only hold so much, then it\noverflows. The treasure hunt is like a data structure called a linked list . The first\nrelease of Java had no standard linked list class, but you could write your own tradi‐\ntional data structure classes (and still can; you see a DIY linked list implementation in\nRecipe 7.8 ). The complex collection represents Java’s Collection  classes. A document\n185",2067
248-Problem.pdf,248-Problem,,0
249-Solution.pdf,249-Solution,,0
250-Discussion.pdf,250-Discussion,"entitled Collections Framework Overview , distributed with the Java Development Kit\ndocumentation (and stored therein as file …/docs/guide/collections/overview.html\nonline ), provides a detailed discussion of the Collections Framework. The framework\naspects of Java collections are summarized in Recipe 7.3 .\nBeware of typographic issues. The word Arrays  (in constant width font) refers to the\nclass java.util.Arrays ; but in the normal typeface, the word “arrays” is simply the\nplural of “array” (and will be found capitalized at the beginning of a sentence). Also,\nnote that HashMap  and HashSet  follow the rule of having a midcapital at each word\nboundary, whereas the older Hashtable  does not (the t is not capitalized).\nThe java.util  package has become something of a catch-all over the years. Besides\nthe legacy date/time API covered in Recipe 6.9 , several other classes from java.util\nare not covered in this chapter. All the classes whose names begin with Abstract  are,\nin fact, abstract, and we’ll discuss their nonabstract subclasses. The StringTokenizer\nclass is covered in Recipe 3.1 . BitSet  is used less frequently than some of the classes\ndiscussed here and is simple enough to learn on your own. BitSet  stores the bits very\ncompactly in memory, but because it predates the Collection API and wasn’t retrofit‐\nted, it doesn’t implement any of the standard collection interfaces. Also not covered\nhere are EnumSet  and EnumMap , specialized for efficient storage/retrieval of enums.\nThese are newer than BitSet  and do implement the modern collection interfaces.\nWe start our discussion of data structuring techniques with one of the oldest struc‐\ntures, the array. We’ll discuss the overall structure of java.util ’s Collections Frame‐\nwork. Then we’ll go through a variety of structuring techniques using classes from\njava.util .\n7.1 Using Arrays for Data Structuring\nProblem\nY ou need to keep track of a fixed amount of information and retrieve it (usually)\nsequentially.\nSolution\nUse an array.\nDiscussion\nArrays can be used to hold any linear collection of data. The items in an array must\nall be of the same type. Y ou can make an array of any primitive type or any object\ntype. For arrays of primitive types , such as ints and boolean s, the data is stored in the\narray. For arrays of objects , a reference is stored in the array, so the normal rules of\n186 | Chapter 7: Structuring Data with Java\nreference variables and casting apply. Note in particular that if the array is declared as\nObject[] , object references of any type can be stored in it without casting, although a\nvalid cast is required to take an Object  reference out and use it as its original type. I’ll\nsay a bit more on two-dimensional arrays in Recipe 7.17 ; otherwise, you should treat\nthis as a review example:\nmain/src/main/java/lang/Array1.java\npublic class Array1  {\n    @SuppressWarnings (""unused"" )\n    public static void main(String[] argv) {\n        int[] monthLen1 ;            // declare a reference\n        monthLen1  = new int[12];        // construct it\n        int[] monthLen2  = new int[12];    // short form\n        // even shorter is this initializer form:\n        int[] monthLen3  = {\n                31, 28, 31, 30,\n                31, 30, 31, 31,\n                30, 31, 30, 31,\n        };\n        final int MAX = 10;\n        LocalDate [] days = new LocalDate [MAX];\n        for (int i=0; i<MAX; i++) {\n            days[i] = LocalDate .of(2022, 02, i + 1);\n        }\n        // Two-Dimensional Arrays\n        // Want a 10-by-24 array\n        int[][] me = new int[10][];\n        for (int i=0; i<10; i++)\n            me[i] = new int[24];\n        // Remember that an array has a "".length"" attribute\n        System.out.println(me.length);\n        System.out.println(me[0].length);\n    }\n}\nArrays in Java work nicely. The type checking provides reasonable integrity, and array\nbounds are always checked by the runtime system, further contributing to reliability.\nThe only problem with arrays is: what if the array fills up and you still have data com‐\ning in? See Recipe 7.2 .\n7.1 Using Arrays for Data Structuring | 187",4207
251-7.2 Resizing an Array.pdf,251-7.2 Resizing an Array,,0
252-Problem.pdf,252-Problem,,0
253-Solution.pdf,253-Solution,,0
254-7.3 The Collections Framework.pdf,254-7.3 The Collections Framework,"6Y ou could copy it yourself using a for loop if you wish, but System.arrayCopy()  is likely to be faster because\nit’s implemented in native code.7.2 Resizing an Array\nProblem\nThe array filled up, and you got an ArrayIndexOutOfBoundsException .\nSolution\nMake the array bigger. Or, use an ArrayList .\nDiscussion\nOne approach is to allocate the array at a reasonable size to begin with; but if you find\nyourself with more data than will fit, reallocate a new, bigger array and copy the ele‐\nments into it.6 Here is code that does so:\nmain/src/main/java/lang/Array2.java\npublic class Array2  {\n    public final static int INITIAL = 10,   \n        GROW_FACTOR  = 2;                    \n    public static void main(String[] argv) {\n        int nDates = 0;\n        LocalDateTime [] dates = new LocalDateTime [INITIAL];\n        StructureDemo  source = new StructureDemo (21);\n        LocalDateTime  c;\n        while ((c=source.getDate()) != null) {\n            // if (nDates >= dates.length) {\n            //     throw new RuntimeException(\n            //         ""Too Many Dates! Simplify your life!!"");\n            // }\n            // better: reallocate, making data structure dynamic\n            if (nDates >= dates.length) {\n                LocalDateTime [] tmp =\n                    new LocalDateTime [dates.length * GROW_FACTOR ];\n                System.arraycopy (dates, 0, tmp, 0, dates.length);\n                dates = tmp;    // copies the array reference\n                // old array will be garbage collected soon...\n            }\n            dates[nDates++] = c;\n        }\n        System.out.println(""Final array size = ""  + dates.length);\n188 | Chapter 7: Structuring Data with Java",1724
255-Problem.pdf,255-Problem,,0
256-Solution.pdf,256-Solution,,0
257-Discussion.pdf,257-Discussion,,0
258-7.4 Like an Array but More Dynamic.pdf,258-7.4 Like an Array but More Dynamic,"}\n}\nA good guess is necessary; know your data!\nThe growth factor is arbitary; 2 is a good value here but will continue to double\nexponentially. Y ou might want to use a factor like 1.5, which would mean more\nallocations at the low end but less explosive growth. Y ou need to manage this\nsomehow!\nThis technique works reasonably well for simple or relatively small linear collections\nof data. For data with a more variable structure, you probably want to use a more\ndynamic approach, as in Recipe 7.4 .\n7.3 The Collections Framework\nProblem\nY ou’re having trouble keeping track of all these lists, sets, and iterators.\nSolution\nThere’s a pattern to it. See Figure 7-1  and Table 7-1 .\nDiscussion\nList , Set, Map, and Queue  are the four fundamental data structures of the Collections\nFramework. List  and Set are both sequences, with the difference that List  preserves\norder and allows duplicate entries, whereas Set, true to the mathematical concept\nbehind it, does not. Map is a key/value store, also known as a hash, a dictionary, or an\nassociative store. Queues are, as the same suggests, structures that you can push into\nat one end and pull out from the other.\nTable 7-1  shows some of the important collection-based classes from package\njava.util . It is intentionally not 100% complete due to space limitations.\nSee Also\nThe javadoc documentation on Collections , Arrays , List , Set, and the classes that\nimplement them provides more details than there’s room for here. Table 7-1  may fur‐\nther help you to absorb the regularity of the Collections Framework.\n7.3 The Collections Framework | 189",1631
259-Problem.pdf,259-Problem,,0
260-Discussion.pdf,260-Discussion,"Table 7-1. Java collections\nInterfaces Implementations\nResizable array Hashed table Linked list Balanced tree\nList ArrayList, Vector LinkedList\nSet HashSet TreeSet\nMap HashMap, HashTable TreeMap\nQueue Deque s, BlockingQueue s, etc.\nFigure 7-1  shows the relationships among several of these types.\nFigure 7-1. The Collections Framework: Rectangles are interfaces; ovals classes; Solid\nlines are inheritance; dashed lines represent implements\nQueue  and its subtypes are treated in Chapter 16 .\n7.4 Like an Array, but More Dynamic\nProblem\nY ou don’t want to worry about storage reallocation (often because you don’t know\nhow big the incoming dataset is going to be); you want a standard class to handle it\nfor you. Y ou want to store your data in any of the Collection  classes defined in\nChapter 7  with type safety and without having to write downcasts when retrieving\ndata from the collection.\nSolution\nUse a List  implementation or one of the other Collections classes, along with Java’s\nGeneric Types mechanism, declaring the Collection  with a type parameter\n190 | Chapter 7: Structuring Data with Java\nidentifying the type of your data. The type parameter name appears in angle brackets\nafter the declaration and instantiation.\nDiscussion\nThe first of the Collections  classes we will discuss, ArrayList , is a standard class\nfrom java.util  that encapsulates the functionality of an array but allows it to expand\nautomatically. Y ou can just keep on adding things to it, and each addition behaves the\nsame. If you watch really  closely, you might notice a brief extra pause once in a while\nwhen adding objects as the ArrayList  reallocates and copies. But you don’t have to\nthink about it.\nHowever, because ArrayList  is a class and isn’t part of the syntax of Java, you can’t\nuse Java’s array syntax; you must use methods to access the ArrayList ’s data. It has\nmethods to add objects, retrieve objects, find objects, and tell you how big the List  is\nand how big it can become without having to reallocate (note that the ArrayList\nclass is but one implementation of the List  interface; more on that later). Like the\nother collection classes in java.util , ArrayList ’s storing and retrieval methods were\noriginally defined to have parameters and return values of java.lang.Object .\nBecause Object  is the ancestor of every defined type, you can store objects of any\ntype in a List  (or any collection) and cast it when retrieving it. If you need to store a\nsmall number of built-ins (like int and float ) into a collection containing other data,\nuse the appropriate wrapper class (see the introduction to Chapter 5 ). To store\nboolean s, either store them directly in a java.util.BitSet  (see the online documen‐\ntation) or store them in a List  using the Boolean  wrapper class.\nBecause Object  is usually too general for accurate work, all modern versions of Java\nprovide the generic types  mechanism. Nowadays, you declare an ArrayList  (or other\ncollection) with a type parameter in angle brackets, and the parameters and returns\nare treated as being of that type by the compiler, ensuring that objects of the wrong\ntype don’t make it into your collections, and avoiding the need to write casts when\nretrieving objects. For example, this is how you declare an ArrayList  for holding\nString  object references:\nList<String> myList = new ArrayList<>();\nIt is a good practice to declare  the variable as the interface type List , even though you\nare defining  it (constructing it) as an ArrayList . This makes it easier to change from\none List  implementation to another, and it avoids accidentally depending on an\nimplementation-specific method not in the List  interface (which would also make it\nharder to change the implementation).\n7.4 Like an Array, but More Dynamic | 191\nThe <> in the definition part is a vestige of legacy Java versions, in which you had to\nrepeat the type definition, so you’ d write new ArrayList<String>()  in that example.\nNowadays just use <> (as in the example) to indicate that you want the type copied\nfrom the declaration. The <> is called the diamond operator .\nAs of Java 13, you can simplify by using the new var keyword (for local variables\nonly):\nvar myList = new ArrayList <String>();\nTable 7-2  shows some of the most important methods of the List  interface, which is\nimplemented by ArrayList  and other List  implementations. This means that the\nexact same methods can be used with the older Vector  class and several other imple‐\nmenting classes. Y ou’ d just have to change the name used in the constructor call.\nTable 7-2. Common List<T> methods\nMethod signature Usage\nadd(T o) Add the given element at the end\nadd(int i, T o) Insert the given element at the specified  position\nclear() Remove all element references from the Collection\ncontains(T o) True if the List  contains the given object\nforEach(lambda) Perform the lambda for each element\nget(int i) Return the object reference at the specified  position\nindexOf(T o) Return the index where the given object is found, or –1\nof(T t, …) Create a list from multiple objects\nremove(T o), remove(int i) Remove an object by reference or by position\ntoArray() Return an array containing the objects in the Collection\nArrayListDemo  stores data in an ArrayList  and retrieves it for processing:\npublic class ArrayListDemo  {\n    public static void main(String[] argv) {\n        List<LocalDate > editions  = new ArrayList <>();\n        // Add lots of elements to the ArrayList...\n        editions .add(LocalDate .of(2001, 06, 01));\n        editions .add(LocalDate .of(2004, 06, 01));\n        editions .add(LocalDate .of(2014, 06, 20));\n        // Use old-style 'for' loop to get index number.\n        System.out.println(""Retrieving by index:"" );\n        for (int i = 0; i<editions .size(); i++) {\n            System.out.printf(""Edition %d was %s\n"" , i + 1, editions .get(i));\n        }\n        // Use normal 'for' loop for simpler access\n192 | Chapter 7: Structuring Data with Java\n        System.out.println(""Retrieving by Iterable:"" );\n        for (LocalDate  dt : editions ) {\n            System.out.println(""Edition ""  + dt);\n        }\n    }\n}\nThe older Vector  and Hashtable  classes predate the Collections Framework, so they\noffer additional methods with different names: Vector  provides addElement()  and \nelementAt() . Y ou may still run across these in legacy code, but you should use the\nCollection  methods add()  and get()  instead. Another difference is that the meth‐\nods of Vector  are synchronized, meaning that they can be accessed safely from multi‐\nple threads (see Recipe 16.5 ). This does mean more overhead, though, so for single-\nthreaded access it is faster to use an ArrayList  (see timing results in Recipe 7.19 ).\nThere are various conversion methods. Table 7-2  mentions toArray() , which will\nexpose the contents of a List  as an array. The List  interface in Java 9+ features a\nstatic of()  method, which converts in the other direction, from an array into a List .\nIn conjunction with the variable arguments feature of modern Java, you can create\nand populate a list in one call to List.of() , like this:\nList<String> firstNames  = List.of(""Robin"", ""Jaime"", ""Joey"");\nIn legacy code that you will find in older apps and in web searches, Arrays.asList()\nprovided this functionality, so you will come across code like this:\nList<String> lastNames  = Arrays.asList(""Smith"", ""Jones"", ""MacKenzie"" );\n// or even\nList<String> lastNames  =\n    Arrays.asList(new String[]{""Smith"", ""Jones"", ""MacKenzie"" });\nJava does indeed get less verbose as time goes by!\nY ou can still instantiate classes such as ArrayList  without using a specific type. In\nthis case, you will get a compiler warning, and the class will behave as in the old days;\nthat is, the objects returned from a Collection  or Iterator  will be of type\njava.lang.Object  and must be downcast before you can call any class-specific meth‐\nods or use them in any application-specific method calls.\nAs a further example, consider the Map interface mentioned in Chapter 7 . A Map\nrequires a key and a value in its put()  method. A Map, therefore, has two parameter‐\nized types. To set up a Map whose keys are Person  objects and whose values are\nAddress  objects (assuming these two classes exist in your application), you could\ndefine it like this:\nMap<Person, Address> addressMap = new HashMap<>();\n7.4 Like an Array, but More Dynamic | 193",8561
261-See Also.pdf,261-See Also,,0
262-7.5 Using Generic Types in Your Own Class.pdf,262-7.5 Using Generic Types in Your Own Class,,0
263-Problem.pdf,263-Problem,,0
264-Solution.pdf,264-Solution,,0
265-Discussion.pdf,265-Discussion,"This Map expects a Person  as its key and an Address  as its value in the put()  method.\nThe get()  method returns an Address  object, the keySet()  method returns Set<Per\nson>  (i.e., a Set specialized for Person  objects). There are also convenience routines\nfor when you want to create a Map from existing objects. The most useful is several\noverloads of before existing Map.of(key,value,key,value…)  similar to List.of()\n(but limited to 10 pairs), and so on.\nSee Also\nAlthough the generics avoid your having to write downcasts, the casts still occur at\nruntime; they are just provided by the compiler. The compiler techniques used in\ncompiling these new constructs in a backward-compatible way include erasure  and\nbridging , topics discussed in Java Generics and Collections  by Maurice Naftalin and\nPhilip Wadler.\n7.5 Using Generic Types in Your Own Class\nProblem\nY ou wish to define your own container classes using the generic type mechanism to\navoid needless casting.\nSolution\nDefine a class using < TypeName  > where the container type is declared and TypeName\nwhere it is used.\nDiscussion\nConsider the very simple Stack  class in Example 7-1 . (We discuss the nature and uses\nof stack classes in Recipe 7.16 .)\nThis version has been parameterized to take a type whose local name is T. This type T\nwill be the type of the argument of the push()  method, the return type of the  pop()\nmethod, and so on. Because of this return type—more specific than the Object  return\ntype of the original Collections—the return value from pop()  does not need to be\ndowncasted. All containers in the Collections Framework ( java.util ) are parame‐\nterized similarly.\nExample 7-1. main/src/main/java/structure/MyStack.java\npublic class MyStack<T> implements  SimpleStack <T> {\n    private int depth = 0;\n194 | Chapter 7: Structuring Data with Java\n    public static final int DEFAULT_INITIAL  = 10;\n    private T[] stack;\n    public MyStack() {\n        this(DEFAULT_INITIAL );\n    }\n    public MyStack(int howBig) {\n        if (howBig <= 0) {\n            throw new IllegalArgumentException (\n            howBig + "" must be positive, but was ""  + howBig);\n        }\n        stack = (T[])new Object[howBig];\n    }\n    @Override\n    public boolean empty() {\n        return depth == 0;\n    }\n    /** push - add an element onto the stack */\n    @Override\n    public void push(T obj) {\n        // Could check capacity and expand\n        stack[depth++] = obj;\n    }\n    /* pop - return and remove the top element */\n    @Override\n    public T pop() {\n        --depth;\n        T tmp = stack[depth];\n        stack[depth] = null;\n        return tmp;\n    }\n    /** peek - return the top element but don't remove it */\n    @Override\n    public T peek() {\n        if (depth == 0) {\n            return null;\n        }\n        return stack[depth-1];\n    }\n    public boolean hasNext() {\n        return depth > 0;\n    }\n    public boolean hasRoom() {\n        return depth < stack.length;\n    }\n7.5 Using Generic Types in Your Own Class | 195\n    public int getStackDepth () {\n        return depth;\n    }\n}\nThe association of a particular type is done at the time the class is instantiated. For\nexample, to instantiate a MyStack  specialized for holding BankAccount  objects, you\nwould need to code only the following:\nMyStack<BankAccount > theAccounts  = new MyStack<>( );\nIf you don’t provide a type parameter T, this collection, like the ones in java.util ,\nwill behave as they did in the days before generic collections—accepting input argu‐\nments of any type, returning java.lang.Object  from getter methods, and requiring\ndowncasting—as their default, backward-compatible behavior. Example 7-2  shows a\nprogram that creates two instances of MyStack , one specialized for String s and one\nleft general. The general one, called ms2, is loaded up with the same two String\nobjects as ms1 but also includes a Date  object. The printing code is now broken,\nbecause it will throw a ClassCastException : a Date  is not a String . I handle this case\nspecially for pedantic purposes: it is illustrative of the kinds of errors you can get into\nwhen using nonparameterized container classes.\nExample 7-2. main/src/main/java/structure/MyStackDemo.java\npublic class MyStackDemo  {\n    @SuppressWarnings ({""rawtypes"" ,""unchecked"" })\n    public static void main(String[] args) {\n        MyStack<String> ms1 = new MyStack<>();\n        ms1.push(""billg"");\n        ms1.push(""scottm"" );\n        while (ms1.hasNext()) {\n            String name = ms1.pop();\n            System.out.println(name);\n        }\n        // Old way of using Collections: not type safe.\n        // DO NOT GENERICIZE THIS\n        MyStack ms2 = new MyStack();\n        ms2.push(""billg"");               // EXPECT WARNING\n        ms2.push(""scottm"" );              // EXPECT WARNING\n        ms2.push(new java.util.Date());  // EXPECT WARNING\n        // Show that it is broken\n        try {\n            String bad = (String)ms2.pop();\n            System.err.println(""Didn't get expected exception, popped ""  + bad);\n196 | Chapter 7: Structuring Data with Java",5203
266-7.6 How Shall I Iterate Thee Let Me Enumerate the Ways.pdf,266-7.6 How Shall I Iterate Thee Let Me Enumerate the Ways,,0
267-Problem.pdf,267-Problem,,0
268-Discussion.pdf,268-Discussion,"} catch (ClassCastException  ex) {\n            System.out.println(""Did get expected exception."" );\n        }\n        // Removed the brokenness, print rest of it.\n        while (ms2.hasNext()) {\n            String name = (String)ms2.pop();\n            System.out.println(name);\n        }\n    }\n}\nBecause of this potential for error, the compiler warns that you have unchecked raw\ntypes. Like the deprecation warnings discussed in Recipe 1.9 , by default, these warn‐\nings are not printed in detail by the javac  compiler (they will appear in most IDEs).\nY ou ask for them with the rather lengthy option -Xlint:unchecked :\nC:> javac -source 1.5 structure/MyStackDemo.java\nNote: MyStackDemo.java uses unchecked or unsafe operations.\nNote: Recompile with -Xlint:unchecked for details.\nC:> javac -source 1.5 -Xlint:unchecked structure/MyStackDemo.java\nMyStackDemo.java:14: warning: unchecked call to push(T) as a member of the raw\ntype MyStack\n                ms2.push(""billg"");\n                   ^\nMyStackDemo.java:15: warning: unchecked call to push(T) as a member of the raw\ntype MyStack\n                ms2.push(""scottm"");\n                   ^\nMyStackDemo.java:16: warning: unchecked call to push(T) as a member of the raw\ntype MyStack\n                ms2.push(new java.util.Date( ));\n                   ^\n3 warnings\nC:>\nI say more about the development and evolution of MyStack  in Recipe 7.16 .\n7.6 How Shall I Iterate Thee? Let Me Enumerate the Ways\nProblem\nY ou need to iterate over some structured data.\nSolution\nJava provides many ways to iterate over collections of data. Here they are, in newest-\nfirst order:\n7.6 How Shall I Iterate Thee? Let Me Enumerate the Ways | 197\n•Stream.forEach()  method (Java 8)\n•Iterable.forEach()  method (Java 8)\n•Java “foreach” loop (Java 5)\n•java.util.Iterator  (Java 2)\n•Three-part for loop\n•while  loop * Enumeration\nPick one and use it. Or learn them all and save!\nDiscussion\nA few words on each of the iteration methods are given here. Note that the first few\nare the most common.\nStream.forEach method (Java 8)\nThe Stream  mechanism introduced as part of Java’s functional programming provides\none of the two most-recent ways of iterating, Stream.forEach() , and is discussed in\nRecipe 9.3 . For now, here’s a quick example, using the BufferedReader  method\nlines()  that returns a Stream :\n$ jshell\njshell> import java.io.* ;\njshell> BufferedReader  is =\n  new BufferedReader (new FileReader (""/home/ian/.profile"" ));\nis ==> java.io.BufferedReader @58651fd0\njshell> is.lines().forEach(System.out::println)\n... prints the lines of the file ...\nIterable.forEach method (Java 8)\nThe other recent iteration technique is the Iterable.forEach()  method, added in\nJava 8. This method can be called on any Iterable  (unfortunately, the array class\ndoes not yet implement Iterable ) and takes one argument implementing the func‐\ntional interface  java.util.function.Consumer . Functional interfaces are discussed\nin Chapter 9 , but here is one example:\npublic class IterableForEach  {\n    public static void main(String[] args) {\n        Collection <String> c =                    \n                List.of(""One"", ""Two"", ""Three"");   \n        c.forEach(s -> System.out.println(s));    \n    }\n}\n198 | Chapter 7: Structuring Data with Java\nDeclare a Collection  (a Collection  is an Iterable ).\nPopulate it with Arrays.of()  with an array or sequence of objects (see Recipe 7.4\nfor how this arbitrary argument list becomes an array).\nInvoke the collection’s forEach()  method, passing a lambda expression (see\nChapter 9  for a discussion of how s→System.out.println(s)  gets mapped to a\nConsumer  interface implementation without your even having to import this\ninterface).\nThis style of iteration—sometimes called internal iteration —inverts the control from\nthe traditional for loop; the collection is in charge of when and how the iteration\nworks.\nBoth Stream.forEach  and Iterable.forEach()  take one argu‐\nment, of type java.util.function.Consumer , so they work largely\nthe same way, at least syntactically. This is intentional.\nJava “foreach” loop (Java 5)\nThis is the for-each loop syntax:\nfor (Type var : Iterable<Type>) {\n // do something with ""var""\n}\nThe for-each loop is probably the most common style of loop in modern Java code.\nThe Iterable  can be an array or anything that implements Iterable  (the Collec\ntion  implementations included).\nThis style is used throughout the book. In addition, many third-party frameworks/\nlibraries provide their own types that implement Iterable  for use with the for loop.\njava.util.Iterator (Java 2)\nThe older Iterator  interface has three methods:\npublic interface  java.util.Iterator <E> {\n  public abstract  boolean hasNext();\n  public abstract  E next();\n  public default void remove();\n}\nIt was once common to write code like this, which you’ll still find occasionally in\nolder code:\n7.6 How Shall I Iterate Thee? Let Me Enumerate the Ways | 199\nIterator  it = ...; // legacy code; might not even have type parameter\nwhile (it.hasNext()) {\n (MyDataType ) c = it.next();\n // Do something with c\n}\nThe remove()  method throws an UnsupportedOperationException  if called on a\nread-only collection. In conjunction with Stream s and default methods, there is now\na fourth method:\npublic default void forEachRemaining (java.util.function .Consumer <? super E>);\nThree-part for loop\nThis is the traditional for loop invented by Dennis Ritchie in the early 1970s for the\nC language:\nfor (init; test; change) {\n // do something\n}\nIts most common form is with an int “index variable” or “loop variable”:\nMyDataType [] data = ...\nfor (int i = 0; i < data.length; i++)\n MyDataType  d = data[i];\n // do something with it\n}\nwhile loop\nA while  loop executes its loop body as long as (while) the test condition is true. It’s\ncommonly used in conjunction with an Enumeration  or Iterator , like this:\nIterator<MyData> iterator = ...\nwhile (iterator.hasNext()) {\n MyData md = iterator.next();\n //\n}\nEnumeration\nAn Enumeration  is like an Iterator  (shown earlier), but it lacks the remove()\nmethod, and the control methods have longer names—for example, hasMore\nElements()  and nextElement() . For new code, there is little to recommend imple‐\nmenting Enumeration .\n200 | Chapter 7: Structuring Data with Java",6426
269-7.7 Eschewing Duplicates with a Set.pdf,269-7.7 Eschewing Duplicates with a Set,,0
270-Problem.pdf,270-Problem,,0
271-Solution.pdf,271-Solution,,0
272-7.8 Structuring Data in a Linked List.pdf,272-7.8 Structuring Data in a Linked List,"6Both List  and Set extend Collection .\n7.7 Eschewing Duplicates with a Set\nProblem\nY ou want a structure that will avoid storing duplicates.\nSolution\nUse a Set implementation instead of a List  (e.g., Set<String> myNames = new Hash\nSet<>() ).\nDiscussion\nThe Set interface is similar to the List  interface,6 with methods like add() , remove() ,\ncontains() , size() , and isEmpty() . The difference is that it doesn’t preserve order;\ninstead, it enforces uniqueness—if you add the same item (as considered by its \nequals()  method) twice or more, it will only be present once in the set. For this rea‐\nson, the index-based methods such as add(int, Object)  and get(int)  are missing\nfrom the Set implementation: you might know that you’ve added seven objects but\nonly five of those were unique, so calling get()  to retrieve the sixth one would have\nto throw an ArrayIndexOutOfBoundsException ! It’s better not to think of a Set as\nbeing indexed.\nAs the Java 7 Set document states: “Note: Great care must be exer‐\ncised if mutable objects are used as set elements. The behavior of a\nset is not specified if the value of an object is changed in a manner\nthat affects equals comparisons while the object is an element in the\nset. A special case of this prohibition is that it is not permissible for\na set to contain itself as an element. ”\nThis code shows a duplicate entry being made to a Set, which will contain only one\ncopy of the string ""One"" :\n        Set<String> hashSet = new HashSet<>();\n        hashSet.add(""One"");\n        hashSet.add(""Two"");\n        hashSet.add(""One""); // DUPLICATE\n        hashSet.add(""Three"");\n        hashSet.forEach(s -> System.out.println(s));\nNot surprisingly, only the three distinct values are printed.\n7.7 Eschewing Duplicates with a Set | 201",1810
273-Problem.pdf,273-Problem,,0
274-Solution.pdf,274-Solution,,0
275-Discussion.pdf,275-Discussion,"If you need a sorted Set, there is in fact a SortedSet  interface, of which the most\ncommon implementation is a TreeSet ; see a TreeSet  example in Recipe 7.12 .\nAs with List s, the Set interface offers the of method as of Java 9:\nSet<Double> nums = Set.of(Math.PI, 22D/7, Math.E);\nSet<String> firstNames  = Set.of(""Robin"", ""Jaime"", ""Joey"");\n7.8 Structuring Data in a Linked List\nProblem\nY our data isn’t suitable for use in an array.\nSolution\nUse a linked list; Java’s LinkedList  class is quite suitable.\nDiscussion\nAnybody who’s taken Computer Science 101 (or any computer science course) should\nbe familiar with data structuring, such as linked lists and binary trees. A linked list is\ncommonly used when you have an unpredictably large number of data items, you\nwish to allocate just the right amount of storage, and you want to access them in the\nsame order that you created them. Figure 7-2  is a diagram showing the normal\narrangement.\nFigure 7-2. Linked list structure\nOf course, the Collections API provides a LinkedList  class; here is a simple program\nthat uses it:\npublic class LinkedListDemo  {\n    public static void main(String[] argv) {\n        System.out.println(""Here is a demo of Java's LinkedList class"" );\n        LinkedList <String> l = new LinkedList <>();\n        l.add(new Object().toString ());\n        l.add(""Hello"");\n        l.add(""end of the list"" );\n        System.out.println(""Here is a list of all the elements"" );\n202 | Chapter 7: Structuring Data with Java\n        l.forEach(o ->\n            System.out.println(""Next element: ""  + o));\n        if (l.indexOf(""Hello"") < 0)\n            System.err.println(""Lookup does not work"" );\n        else\n            System.err.println(""Lookup works"" );\n        // Now, for added fun, let's walk the linked list backwards.\n        ListIterator <String> li = l.listIterator ();\n        while (li.hasPrevious ()) {\n            System.out.println(""Back to: ""  + li.previous ());\n        }\n    }\n}\nThe ListIterator  used here is a subinterface of Iterator , which was discussed in\nRecipe 7.6 .\nJust to show how this kind of list works, here is code that shows part of the imple‐\nmention of a simple linked list:\npublic class LinkList <T> implements  List<T> {\n    /* A TNode stores one node or item in a Linked List */\n    private static class TNode<T> {\n        private TNode<T> next;\n        private T data;\n        TNode(T o, TNode<T> next) {\n            data = o;\n            this.next = next;\n        }\n        @Override\n        public String toString () {\n            return String.format(""TNode: data='%s', next='%d'"" , data,\n                    next == null ? 0 : next.hashCode ());\n        }\n    }\n    private boolean DIAGNOSTIC  = false;\n    /** The root or first TNode in the list; is a dummy pointer,\n     * so its data will always be null. Simpler this way.\n     */\n    protected  TNode<T> first;\n    /**\n     * For certain optimizations: A second ref to the last TNode in the list;\n     * initially == first; always valid (never null), always has next == null.\n     */\n    protected  TNode<T> last;\n    /** Construct a LinkList: initialize the first and last nodes */\n    public LinkList () {\n7.8 Structuring Data in a Linked List | 203\n        clear();\n    }\n    /** Construct a LinkList given another Collection.\n     * This method is recommended by the general contract of List.\n     */\n    public LinkList (Collection <T> c) {\n        this();\n        addAll(c);\n    }\n    /** Set the List (back) to its initial state.\n     * Any references held will be discarded.\n     */\n    @Override\n    public void clear() {\n        first = new TNode<T>(null, null);\n        last = first;\n    }\n    /** Add one object to the end of the list. Update the ""next""\n     * reference in the previous end, to refer to the new node.\n     * Update ""last"" to refer to the new node.\n     */\n    @Override\n    public boolean add(T o) {\n        last.next = new TNode<T>(o, null);\n        last = last.next;\n        return true;\n    }\n    @Override\n    public void add(int where, T o) {\n        TNode<T> t = first;\n        for (int i=0; i<=where; i++) {\n            t = t.next;\n            if (t == null) {\n                throw new IndexOutOfBoundsException (\n                    ""'add(n,T) went off end of list"" );\n            }\n            if (DIAGNOSTIC ) {\n                System.out.printf(""in add(int,T): i = %d, t = %s%n"" , i, t);\n            }\n        }\n        if (DIAGNOSTIC ) {\n            System.out.printf(""in add(int,T): to insert before %s\n"" , t);\n        }\n        final TNode<T> nn = new TNode<>(o, t.next);\n        t.next = nn;\n        if (DIAGNOSTIC ) {\n            System.out.printf(""add(%d,%s)\n"" , where, o);\n            dump(""add(int,T)"" );\n204 | Chapter 7: Structuring Data with Java\n        }\n    }\n    @Override\n    public boolean addAll(Collection <? extends T> c) {\n        c.forEach(o -> add((T) o));\n        return false;\n    }\n    @Override\n    public boolean addAll(int i, Collection <? extends T> c) {\n        AtomicInteger  j = new AtomicInteger (i);\n        c.forEach(o -> { add(j.getAndIncrement (), o); });\n        return true;\n    }\n    @Override\n    public boolean contains (Object o) {\n        TNode<T> t = first;\n        while ((t = t.next) != null) {\n            if (t.data.equals(o)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    @Override\n    public T get(int where) {\n        TNode<T> t = first;\n        int i=0;\n        // If we get to the end of list before 'where', error out\n        while (i++<=where) {\n            if (t.next == null) {\n                throw new IndexOutOfBoundsException ();\n            }\n            t = t.next;\n        }\n        return t.data;\n    }\n    @Override\n    public boolean isEmpty() {\n        return first == last;\n    }\n    public Iterator <T> iterator () {\n        return new Iterator <T>() {\n            final int size = size();\n            int n = 0;\n            TNode<T> t = first;\n            /**\n7.8 Structuring Data in a Linked List | 205\n             * Two cases in which next == null:\n             * 1) The list is empty, we are at first\n             * 2) The list is not empty, we are at last.\n             */\n            public boolean hasNext() {\n                return n < size;\n            }\n            public T next() {\n                if (t == first) {\n                    t = t.next;\n                }\n                TNode<T> result = t;\n                t = t.next;\n                ++n;\n                return result.data;\n            }\n            public void remove() {\n                throw new UnsupportedOperationException (""remove"" );\n            }\n        };\n    }\n    @Override\n    public boolean remove(Object o) {\n        TNode<T> p = first, prev = null;\n        while (p != null) {\n            if (p.data == o) {\n                prev.next = p.next;\n                return true;\n            }\n            prev = p; p = p.next;\n        }\n        return false;\n    }\n    @Override\n    public T set(int i, T o) {\n        TNode<T> tmp = find(i);\n        tmp.data = o;\n        return o;\n    }\n    @Override\n    public int size() {\n        TNode<T> t = first;\n        int i;\n        for (i=0; ; i++) {\n            if (t == null)\n                break;\n            t = t.next;\n        }\n206 | Chapter 7: Structuring Data with Java",7551
276-7.9 Mapping with Hashtable and HashMap.pdf,276-7.9 Mapping with Hashtable and HashMap,,0
277-Problem.pdf,277-Problem,,0
278-Solution.pdf,278-Solution,,0
279-Discussion.pdf,279-Discussion,"return i - 1;    // subtract one for mandatory head node\n    }\n    @SuppressWarnings (""unchecked"" )\n    public T[] toArray(Object[] data) {\n        // First is an empty anchor, start at its next\n        TNode<T> p = first.next;\n        for (int i = 0; p != null && i < data.length; i++) {\n            data[i] = p.data;\n            p = p.next;\n        }\n        return (T[]) data;\n    }\n    public Object[] toArray() {\n        Object[] data = new Object[size()];\n        return toArray(data);\n    }\nThis is just to show how the implementation of a linked list might\nwork. Do not use the simple LinkList  class shown here; use the\nreal one, java.util.LinkedList , shown in action in the first\nexample.\n7.9 Mapping with Hashtable and HashMap\nProblem\nY ou need a one-way mapping from one data item to another.\nSolution\nUse a HashMap .\nDiscussion\nHashMap  provides a one-way mapping from one set of object references to another.\nThey are completely general purpose. I’ve used them to map from Swing push but‐\ntons to the URL that is to be opened when the button is pushed, to map names to\naddresses, and to implement a simple in-memory cache in a web server. Y ou can map\nfrom anything to anything. In the following example, we map from company names\nto addresses; the addresses here are String  objects, but in real life they’ d probably be\nAddress  objects:\npublic class HashMapDemo  {\n    public static void main(String[] argv) {\n7.9 Mapping with Hashtable and HashMap | 207\n        // Construct and load the hash. This simulates loading a\n        // database or reading from a file, or wherever the data is.\n        Map<String,String> map = new HashMap<String,String>();\n        // The hash maps from company name to address.\n        // In real life this might map to an Address object...\n        map.put(""Adobe"", ""Mountain View, CA"" );\n        map.put(""IBM"", ""White Plains, NY"" );\n        map.put(""Learning Tree"" , ""Los Angeles, CA"" );\n        map.put(""Microsoft"" , ""Redmond, WA"" );\n        map.put(""Netscape"" , ""Mountain View, CA"" );\n        map.put(""O'Reilly"" , ""Sebastopol, CA"" );\n        map.put(""Sun"", ""Mountain View, CA"" );\n        // Two versions of the ""retrieval"" phase.\n        // Version 1: get one pair's value given its key\n        // (presumably the key would really come from user input):\n        String queryString  = ""O'Reilly"" ;\n        System.out.println(""You asked about ""  + queryString  + ""."");\n        String resultString  = map.get(queryString );\n        System.out.println(""They are located in: ""  + resultString );\n        System.out.println();\n        // Version 2: get ALL the keys and values\n        // (maybe to print a report, or to save to disk)\n        for( String key : map.keySet()) {\n            System.out.println(""Key "" + key +\n                ""; Value ""  + map.get(key));\n        }\n        // Version 3: Same but using a Map.Entry lambda\n        map.entrySet ().forEach(mE ->\n            System.out.println(""Key + ""  + mE.getKey()+\n                ""; Value ""  +mE.getValue ()));\n    }\n}\nFor this version we used both a for loop and a forEach()  loop; the latter uses the\nreturn from entrySet() , a set of Map.Entry , each of which contains one key and one\nvalue (this may be faster on large maps because it avoids going back into the map to\nget the value each time through the loop). If you are modifying the list as you are\ngoing through it (e.g., removing elements), either inside the loop or in another\nthread, then these forms will fail with a ConcurrentModificationException . Y ou\nthen need to use the Iterator  explicitly to control the loop:\n        // Version 2: get ALL the keys and values\n        // with concurrent modification\n        Iterator <String> it = map.keySet().iterator ();\n        while (it.hasNext()) {\n208 | Chapter 7: Structuring Data with Java",3889
280-7.10 Storing Strings in Properties and Preferences.pdf,280-7.10 Storing Strings in Properties and Preferences,,0
281-Problem.pdf,281-Problem,,0
282-Solution.pdf,282-Solution,,0
283-Discussion.pdf,283-Discussion,"String key = it.next();\n            if (key.equals(""Sun"") || key.equals(""Netscape"" )) {\n                it.remove();\n                continue ;\n            }\n            System.out.println(""Company ""  + key + ""; "" +\n                ""Address ""  + map.get(key));\n        }\nA more functional (see Chapter 9 ) way of writing the removal, not involving explicit\nlooping, would be this:\n        // Alternate to just do the removals, without explicit looping\n        map.keySet().removeIf (key -> Set.of(""Netscape"" , ""Sun"").contains (key));\n        // or\n        map .entrySet ()\n            .removeIf (entry -> Set.of(""Netscape"" , ""Sun"")\n            .contains (entry.getKey()));\n        map.entrySet ().forEach(System.out::println);\nHashMap  methods are not synchronized. The older and similar\nHashtable  methods are synchronized, for use with multiple\nthreads.\n7.10 Storing Strings in Properties and Preferences\nProblem\nY ou need to store keys and values that are both strings, possibly with persistence\nacross runs of a program—for example, program customization.\nSolution\nUse a java.util.prefs.Preferences  object or a java.util.Properties  object.\nDiscussion\nHere are three approaches to customization based on the user’s environment. Java\noffers Preferences  and Properties  for cross-platform customizations.\nPreferences\nThe Preferences  class java.util.prefs.Preferences  provides an easy-to-use\nmechanism for storing user customizations in a system-dependent way (which might\nmean dot files on Unix, a preferences file on the Mac, or the registry on Windows\nsystems). This class provides a hierarchical set of nodes representing a user’s\n7.10 Storing Strings in Properties and Preferences | 209\npreferences.  Data is stored in the system-dependent storage format but can also be\nexported to or imported from an XML format. Here is a simple demonstration of\nPreferences :\npublic class PrefsDemo  {\n    public static void main(String[] args) throws Exception  {\n        // Set up the Preferences for this application, by class.\n        Preferences  prefs = Preferences .userNodeForPackage (PrefsDemo .class);\n        // Retrieve some preferences previously stored, with defaults in case\n        // this is the first run.\n        String text    = prefs.get(""textFontName"" , ""lucida-bright"" );\n        String display = prefs.get(""displayFontName"" , ""lucida-blackletter"" );\n        System.out.println(text);\n        System.out.println(display);\n        // Assume the user chose new preference values: Store them back.\n        prefs.put(""textFontName"" , ""times-roman"" );\n        prefs.put(""displayFontName"" , ""helvetica"" );\n        // Toss in a couple more values for the curious who want to look\n        // at how Preferences values are actually stored.\n        Preferences  child = prefs.node(""a/b"");\n        child.putInt(""meaning"" , 42);\n        child.putDouble (""pi"", Math.PI);\n        // And dump the subtree from our first node on down, in XML.\n        prefs.exportSubtree (System.out);\n    }\n}\nWhen you run the PrefsDemo  program the first time, of course, it doesn’t find any\nsettings, so the calls to preferences.get()  return the default values:\n$ java -cp target/classes structure .PrefsDemo\nlucida-bright\nlucida-blackletter\n<?xml version=""1.0"" encoding =""UTF-8"" standalone =""no""?>\n<!DOCTYPE preferences  SYSTEM ""http://java.sun.com/dtd/preferences.dtd"" >\n<preferences  EXTERNAL_XML_VERSION =""1.0"">\n  <root type=""user"">\n    <map/>\n    <node name=""structure"" >\n      <map>\n        <entry key=""displayFontName""  value=""helvetica"" />\n        <entry key=""textFontName""  value=""times-roman"" />\n      </map>\n      <node name=""a"">\n        <map/>\n        <node name=""b"">\n210 | Chapter 7: Structuring Data with Java\n          <map>\n            <entry key=""meaning""  value=""42""/>\n            <entry key=""pi"" value=""3.141592653589793"" />\n          </map>\n        </node>\n      </node>\n    </node>\n  </root>\n</preferences >\nOn subsequent runs, it finds and returns the user-provided settings (I’ve elided the\nXML output from the second run because most of the XML output is the same):\n> java structure.PrefsDemo\ntimes-roman\nhelvetica\n...\n>\nProperties\nThe Properties  class is similar to a HashMap  or Hashtable  (it extends the latter) but\nwith methods defined specifically for string storage and retrieval and for loading/\nsaving. Properties  objects are used throughout Java, for everything from setting the\nplatform font names to customizing user applications into different Locale  settings as\npart of internationalization and localization. When stored on disk, a Properties\nobject looks just like a series of name=value  assignments, with optional comments.\nComments are added when you edit a Properties  file by hand, ignored when the\nProperties  object reads itself, and lost when you ask the Properties  object to save\nitself to disk. Here is an example of a Properties  file that could be used to interna‐\ntionalize the menus in a GUI-based program:\n# Default properties for MenuIntl\nprogram.title=Demonstrate I18N (MenuIntl)\nprogram.message=Welcome to an English-localized Java Program\n#\n# The File Menu\n#\nfile.label=File Menu\nfile.new.label=New File\nfile.new.key=N\nfile.open.label=Open...\nfile.open.key=O\nfile.save.label=Save\nfile.save.key=S\nfile.exit.label=Exit\nfile.exit.key=Q\nHere is another example, showing some personalization properties:\n7.10 Storing Strings in Properties and Preferences | 211\nname=Ian Darwin\nfavorite_popsicle=cherry\nfavorite_rock group=Fleetwood Mac\nfavorite_programming_language=Java\npencil_color=green\nA Properties  object can be loaded from a file. The rules are flexible: either =, :, or\nspaces can be used after a key name and its values. Spaces after a nonspace character\nare ignored in the key. A backslash can be used to continue lines or to escape other\ncharacters. Comment lines may begin with either # or !. Thus, a Properties  file con‐\ntaining the previous items, if prepared by hand, could look like this:\n# Here is a list of properties\n! first, my name\nname Ian Darwin\nfavorite_popsicle = cherry\nfavorite_rock\ group \\n Fleetwood Mac\nfavorite_programming_language=Java\npencil_color green\nFortunately, when a Properties  object writes itself to a file, it uses the following sim‐\nple format:\nkey=value\nHere is an example of a program that creates a Properties  object and adds into it the\nlist of companies and their locations from Recipe 7.9 . It then loads additional proper‐\nties from disk. To simplify the I/O processing, the program assumes that the Proper\nties  file to be loaded is contained in the standard input, as would be done using a\ncommand-line redirection on either Unix or DOS:\npublic class PropsCompanies  {\n    public static void main(String[] argv) throws java.io.IOException  {\n        Properties  props = new Properties ();\n        // Get my data\n        props.put(""Adobe"", ""Mountain View, CA"" );\n        props.put(""IBM"", ""White Plains, NY"" );\n        props.put(""Learning Tree"" , ""Los Angeles, CA"" );\n        props.put(""Microsoft"" , ""Redmond, WA"" );\n        props.put(""Netscape"" , ""Mountain View, CA"" );\n        props.put(""O'Reilly"" , ""Sebastopol, CA"" );\n        props.put(""Sun"", ""Mountain View, CA"" );\n        // Now load additional properties\n        props.load(System.in);\n        // List merged properties, using System.out\n        props.list(System.out);\n212 | Chapter 7: Structuring Data with Java",7536
284-7.11 Sorting a Collection.pdf,284-7.11 Sorting a Collection,,0
285-Problem.pdf,285-Problem,,0
286-Discussion.pdf,286-Discussion,"}\n}\nRunning it as\njava structure.PropsCompanies < PropsDemo.out\nproduces the following output in the file PropsDemo.out :\n-- listing properties --\nSony=Japan\nSun=Mountain View, CA\nIBM=White Plains, NY\nNetscape=Mountain View, CA\nNippon_Kogaku=Japan\nAcorn=United Kingdom\nAdobe=Mountain View, CA\nEricsson=Sweden\nO'Reilly & Associates=Sebastopol, CA\nLearning Tree=Los Angeles, CA\nIn case you didn’t notice in either the HashMap  or the Properties  examples, the order\nin which the outputs appear in these examples is neither sorted nor in the order we\nput them in. The hashing classes and the Properties  subclass make no claim about\nthe order in which objects are retrieved. If you need them sorted, see Recipe 7.11 .\nAs a convenient shortcut, my FileProperties  class includes a constructor that takes\na filename:\nimport com.darwinsys.util.FileProperties;\n...\nProperties p = new FileProperties(""PropsDemo.out"");\nNote that constructing a FileProperties  object causes it to be loaded, and therefore\nthe constructor may throw a checked exception of class IOException .\n7.11 Sorting a Collection\nProblem\nY ou put your data into a collection in random order or used a Properties  object that\ndoesn’t preserve the order, and now you want it sorted.\nSolution\nUse the static method Arrays.sort()  or Collections.sort() , optionally providing a\nComparator .\n7.11 Sorting a Collection | 213\nDiscussion\nIf your data is in an array, then you can sort it using the static sort()  method of the\nArrays  utility class. If it is in a Collection , you can use the static sort()  method of\nthe Collections  class. Here is a set of strings being sorted in place in an Array :\npublic class SortArray  {\n    public static void main(String[] unused) {\n        String[] strings = {\n            ""painful"" ,\n            ""mainly"" ,\n            ""gaining"" ,\n            ""raindrops""\n        };\n        Arrays.sort(strings);\n        for (int i=0; i<strings.length; i++) {\n            System.out.println(strings[i]);\n        }\n    }\n}\nWhat if the default sort order isn’t what you want? Well, you can create an object that\nimplements the Comparator<T>  interface and pass that as the second argument to\nsort. Fortunately, for the most common ordering next to the default, you don’t have\nto: a public constant String.CASE_INSENSITIVE_ORDER  can be passed as this second\nargument. The String  class defines it as a Comparator<String>  that orders String\nobjects as by compareToIgnoreCase . But if you need something fancier, you probably\nneed to write a Comparator<T> . In some cases you may be able to use the \nComparator.comparing()  method and other static methods on Comparator  to create\na custom comparator without having to create a class. Suppose that, for some strange\nreason, you need to sort strings using all but the first character of the string. One way\nto do this would be to write this Comparator<String> :\n/** Comparator for comparing strings ignoring first character.\n */\npublic class SubstringComparator  implements  Comparator <String> {\n    @Override\n    public int compare(String s1, String s2) {\n        s1 = s1.substring (1);\n        s2 = s2.substring (1);\n        return s1.compareTo (s2);\n        // or, more concisely:\n        // return s1.substring(1).compareTo(s2.substring(1));\n    }\n}\nUsing it is just a matter of passing it as the Comparator  argument to the correct form\nof sort() , as shown here:\n214 | Chapter 7: Structuring Data with Java\npublic class SubstringComparatorDemo  {\n    public static void main(String[] unused) {\n        String[] strings = {\n            ""painful"" ,\n            ""mainly"" ,\n            ""gaining"" ,\n            ""raindrops""\n        };\n        Arrays.sort(strings);\n        dump(strings, ""Using Default Sort"" );\n        Arrays.sort(strings, new SubstringComparator ());\n        dump(strings, ""Using SubstringComparator"" );\n        // tag::functional[]\n        System.out.println(""Functional approach:"" );\n        Arrays.stream(strings)\n            .sorted(Comparator .comparing (s->s.substring (1)))\n            .forEach(System.out::println);\n        // end::functional[]\n    }\n    static void dump(String[] args, String title) {\n        System.out.println(title);\n        for (String s : args)\n            System.out.println(s);\n    }\n}\nAgain, a more functional (see Chapter 9 ) way of writing this might be the following:\n        System.out.println(""Functional approach:"" );\n        Arrays.stream(strings)\n            .sorted(Comparator .comparing (s->s.substring (1)))\n            .forEach(System.out::println);\nHere is the output of running it:\n$ java structure.SubstrCompDemo\nUsing Default Sort\ngaining\nmainly\npainful\nraindrops\nUsing SubstringComparator\nraindrops\npainful\ngaining\nmainly\nAnd this is all as it should be.\nOn the other hand, you may be writing a class and want to build in the comparison\nfunctionality so that you don’t always have to remember to pass the Comparator  with\n7.11 Sorting a Collection | 215\nit. In this case, you can directly implement the java.lang.Comparable  interface, as is\ndone by many classes in the standard API. These include String  class; the wrapper\nclasses Byte , Character , Double , Float , Long , Short , and Integer ; BigInteger  and\nBigDecimal  from java.math ; most objects in the date/time API in java.time ; and\njava.text.CollationKey . Arrays or Collections  of these types can be sorted\nwithout providing a Comparator . Classes that implement Comparable  are said to have\na natural ordering. The documentation strongly recommends that a class’s natural\nordering be consistent with its equals()  method. It is consistent with equals()  if\nand only if e1.compareTo((Object)e2)  has the same Boolean value as\ne1.equals((Object)e2)  for every instance e1 and e2 of the given class. This means\nthat if you implement Comparable , you should also implement equals() , and the\nlogic of equals()  should be consistent with the logic of the compareTo()  method. If\nyou implement equals() , incidentally, you also should implement hashCode()  (as\ndiscussed in “hashCode() and equals()” on page 241 ). Here, for example, is part of the\nappointment class Appt  from a hypothetical scheduling program. The class has a\nLocalDate  date variable and a LocalTime  time variable; the latter may be null (e.g., an\nall-day appointment or a to-do item); this complicates the compareTo()  function a lit‐\ntle.\n// public class Appt implements Comparable {\n    // Much code and variables omitted - see online version\n    //-----------------------------------------------------------------\n    //    METHODS - COMPARISON\n    //-----------------------------------------------------------------\n    /** compareTo method, from Comparable interface.\n     * Compare this Appointment against another, for purposes of sorting.\n     * <P>Only date and time, then text, participate, not repetition!\n     * (Repetition has to do with recurring events, e.g.,\n     *  ""Meeting every Tuesday at 9"").\n     * This methods is consistent with equals().\n     * @return -1 if this<a2, +1 if this>a2, else 0.\n     */\n    @Override\n    public int compareTo (Appt a2) {\n        // If dates not same, trigger on their comparison\n        int dateComp  = date.compareTo (a2.date);\n        if (dateComp  != 0)\n            return dateComp ;\n        // Same date. If times not same, trigger on their comparison\n        if (time != null && a2.time != null) {\n            // Neither time is null\n            int timeComp  = time.compareTo (a2.time);\n            if (timeComp  != 0)\n                return timeComp ;\n        } else /* At least one time is null */  {\n            if (time == null && a2.time != null) {\n                return -1; // All-day appts sort low to appear first\n            } else if (time != null && a2.time == null)\n216 | Chapter 7: Structuring Data with Java\n                return +1;\n                // else both have no time set, so carry on\n        }\n        // Same date & time, trigger on text\n        return text.compareTo (a2.text);\n    }\n    @Override\n    public int hashCode () {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((date == null) ? 0 : date.hashCode ());\n        result = prime * result + ((text == null) ? 0 : text.hashCode ());\n        result = prime * result + ((time == null) ? 0 : time.hashCode ());\n        return result;\n    }\n    @Override\n    public boolean equals(Object o2) {\n        if (this == o2)\n            return true;\n        if (o2.getClass () != Appt.class)\n            return false;\n        Appt a2 = (Appt) o2;\n        if (!date.equals(a2.date))\n            return false;\n        if (time != null && !time.equals(a2.time))\n            return false;\n        return text.equals(a2.text);\n    }\n    /** Return a String representation of this Appt.\n     * Output is intended for debugging, not presentation!\n     */\n    @Override\n    public String toString () {\n        var sb = new StringBuilder ();\n        sb.append(date).append(' ');\n        if (time != null) {\n            sb.append(time.getHour())\n            .append(':')\n            .append(time.getMinute ())\n            .append(' ');\n        } else {\n            sb.append(""(All day)"" ).append(' ');\n        }\n        sb.append(text).toString ();\n        return sb.toString ();\n    }\nIf you’re still confused between Comparable  and Comparator , you’re probably not\nalone. Table 7-3  summarizes the two comparison interfaces.\n7.11 Sorting a Collection | 217",9674
287-7.12 Avoiding the Urge to Sort.pdf,287-7.12 Avoiding the Urge to Sort,,0
288-Problem.pdf,288-Problem,,0
289-Solution.pdf,289-Solution,,0
290-Discussion.pdf,290-Discussion,"Table 7-3. Comparable compared with Comparator\nInterface name Description Method(s)\njava.lang.Compara\nble<T>Provides a natural ordering to objects. Written in the class\nwhose objects are being sorted.int compareTo(T o);\njava.util.Compara\ntor<T>Provides total control over sorting objects of another class.\nStandalone strategy object; pass to sort()  method or Col\nlection  constructor.int compare(T o1, T \no2); boolean \nequals(T c2)\n7.12 Avoiding the Urge to Sort\nProblem\nY our data needs to be sorted, but you don’t want to stop and sort it periodically.\nSolution\nNot everything that requires order requires an explicit sort operation. Just keep the\ndata sorted at all times.\nDiscussion\nY ou can avoid the overhead and elapsed time of an explicit sorting operation by\nensuring that the data is in the correct order at all times, though this may or may not\nbe faster overall, depending on your data and how you choose to keep it sorted. Y ou\ncan keep it sorted either manually or by using a TreeSet  or a TreeMap . First, here is\nsome code from a call tracking program that I first wrote on the very first public\nrelease of Java (the code has been modernized slightly!) to keep track of people I had\nextended contact with. Far less functional than a Rolodex, my CallTrack  program\nmaintained a list of people sorted by last name and first name. It also had the city,\nphone number, and email address of each person. Here is a very small portion of the\ncode surrounding the event handling for the New User push button:\npublic class CallTrack  {\n    /** The list of Person objects. */\n    protected  List<Person> usrList = new ArrayList <>();\n    /** The scrolling list */\n    protected  java.awt.List visList = new java.awt.List();\n    /** Add one (new) Person to the list, keeping the list sorted. */\n    protected  void add(Person p) {\n        String lastName  = p.getLastName ();\n        int i;\n        // Find in ""i"" the position in the list where to insert this person\n        for (i=0; i<usrList.size(); i++)\n218 | Chapter 7: Structuring Data with Java\n            if (lastName .compareTo ((usrList.get(i)).getLastName ()) <= 0)\n                break; // If we don't break, OK, will insert at end of list.\n        usrList.add(i, p);\n        // Now insert them in the scrolling list, in the same position.\n        visList.add(p.getFullName (), i);\n        visList.select(i);      // ensure current\n    }\n}\nThis code uses the String  class compareTo(String)  routine.\nThis code uses a linear search, which was fine for the original appli‐\ncation but could get very slow on large lists (it is O(n) ). Y ou’ d need\nto use hashing or a binary search to find where to put the values on\nlarge lists.\nIf I were writing this code today, I might well use a TreeSet  (which keeps objects in\norder) or a TreeMap  (which keeps the keys in order and maps from keys to values; the\nkeys would be the name and the values would be the Person  objects). Both insert the\nobjects into a tree in the correct order, so an Iterator  that traverses the tree always\nreturns the objects in sorted order. In addition, they have methods such as headSet()\nand headMap() , which give a new Set or Map of objects of the same class, containing\nthe objects lexically before a given value. The tailSet()  and tailMap()  methods,\nsimilarly, return objects greater than a given value, and subSet()  and subMap()\nreturn a range. The first()  and last()  methods retrieve the obvious components\nfrom the collection. The following program uses a TreeSet  to sort some names:\n        // A TreeSet keeps objects in sorted order. Use a Comparator\n        // published by String for case-insensitive sorting order.\n        TreeSet<String> theSet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER );\n        theSet.add(""Gosling"" );\n        theSet.add(""da Vinci"" );\n        theSet.add(""van Gogh"" );\n        theSet.add(""Java To Go"" );\n        theSet.add(""Vanguard"" );\n        theSet.add(""Darwin"" );\n        theSet.add(""Darwin"" );    // TreeSet is Set, ignores duplicates.\n        System.out.printf(""Our set contains %d elements"" , theSet.size());\n        // Since it is sorted we can easily get various subsets\n        System.out.println(""Lowest (alphabetically) is ""  + theSet.first());\n        // Print how many elements are greater than ""k""\n        // Should be 2 - ""van Gogh"" and ""Vanguard""\n        System.out.println(theSet.tailSet(""k"").toArray().length +\n7.12 Avoiding the Urge to Sort | 219",4529
291-7.13 Finding an Object in a Collection.pdf,291-7.13 Finding an Object in a Collection,,0
292-Problem.pdf,292-Problem,,0
293-Solution.pdf,293-Solution,,0
294-Discussion.pdf,294-Discussion,""" elements higher than \""k\"""" );\n        // Print the whole list in sorted order\n        System.out.println(""Sorted list:"" );\n        theSet.forEach(name -> System.out.println(name));\nOne last point to note is that if you have a Hashtable  or HashMap , you can convert it\nto a TreeMap , and therefore get it sorted, just by passing it to the TreeMap  constructor: \nTreeMap sorted = new TreeMap(unsortedHashMap);\n7.13 Finding an Object in a Collection\nProblem\nY ou need to see whether a given collection contains a particular value.\nSolution\nAsk the collection if it contains an object of the given value.\nDiscussion\nIf you have created the contents of a collection, you probably know what is in it and\nwhat is not. But if the collection is prepared by another part of a large application, or\neven if you’ve just been putting objects into it and now need to find out if a given\nvalue was found, this recipe’s for you. There is quite a variety of methods, depending\non which collection class you have. The methods in Table 7-4  can be used.\nTable 7-4. Finding objects in a collection\nMethod(s) Meaning Implementing classes\nbinarySearch() Fairly fast search Arrays , Collections\ncontains() Search ArrayList , HashSet , Hashtable , Link\nList , Properties , Vector\ncontainsKey() ,\ncontainsValue()Checks if the collection contains the\nobject as a Key  or as a ValueHashMap , Hashtable , Properties ,\nTreeMap\nindexOf() Returns location where object is found ArrayList , LinkedList , List , Stack ,\nVector\nsearch() Search Stack\nThe methods whose names start with contains  will use a linear search if the collec‐\ntion is a collection ( List , Set) but will be quite fast if the collection is hashed ( Hash\nSet, HashMap ). So you do have to know what implementation is being used in order to\n220 | Chapter 7: Structuring Data with Java\nthink about performance, particularly when the collection is (or is likely to grow)\nlarge.\nThe next example plays a little game of find the hidden number (or needle in a hay‐\nstack): the numbers to look through are stored in an array. As games go, it’s fairly\npathetic: the computer plays against itself, so you probably know who’s going to win. I\nwrote it that way so I would know that the data array contains valid numbers. The\ninteresting part is not the generation of the random numbers (discussed in Recipe\n5.9). The array to be used with Arrays.binarySearch()  must be in sorted order, but\nbecause we just filled it with random numbers, it isn’t initially sorted. Hence, we call \nArrays.sort()  on the array. Then we are in a position to call Arrays.binary\nSearch() , passing in the array and the value to look for. If you run the program with\na number, it runs that many games and reports on how it fared overall. If you don’t\nbother, it plays only one game:\npublic class ArrayHunt   {\n    /** the maximum (and actual) number of random ints to allocate */\n    protected  final static int MAX    = 4000;\n    /** the value to look for */\n    protected  final static int NEEDLE = 1999;\n    int[] haystack ;\n    Random r;\n    public static void main(String[] argv) {\n        ArrayHunt  h = new ArrayHunt ();\n        if (argv.length == 0)\n            h.play();\n        else {\n            int won = 0;\n            int games = Integer.parseInt (argv[0]);\n            for (int i=0; i<games; i++)\n                if (h.play())\n                    ++won;\n            System.out.println(""Computer won ""  + won +\n                "" out of ""  + games + ""."");\n        }\n    }\n    /** Construct the hunting ground */\n    public ArrayHunt () {\n        haystack  = new int[MAX];\n        r = new Random();\n    }\n    /** Play one game. */\n    public boolean play() {\n        int i;\n        // Fill the array with random data (hay?)\n        for (i=0; i<MAX; i++) {\n7.13 Finding an Object in a Collection | 221",3900
295-7.14 Converting a Collection to an Array.pdf,295-7.14 Converting a Collection to an Array,,0
296-Problem.pdf,296-Problem,,0
297-Solution.pdf,297-Solution,,0
298-7.15 Making Your Data Iterable.pdf,298-7.15 Making Your Data Iterable,"haystack [i] = (int)(r.nextFloat () * MAX);\n        }\n        // Precondition for binary search is that data be sorted!\n        Arrays.sort(haystack );\n        // Look for needle in haystack\n        i = Arrays.binarySearch (haystack , NEEDLE);\n        if (i >= 0) {        // Found it, we win.\n            System.out.println(""Value ""  + NEEDLE +\n                "" occurs at haystack[""  + i + ""]"");\n            return true;\n        } else {        // Not found, we lose.\n            System.out.println(""Value ""  + NEEDLE +\n                "" does not occur in haystack; nearest value is ""  +\n                haystack [-(i+2)] + "" (found at ""  + -(i+2) + "")"");\n            return false;\n        }\n    }\n}\nCollections.binarySearch()  works almost exactly the same way, except it looks in\na Collection , which must be sorted (presumably using Collections.sort , as dis‐\ncussed in Recipe 7.11 ).\n7.14 Converting a Collection to an Array\nProblem\nY ou have a Collection  but you need a Java language array.\nSolution\nUse the Collection  method toArray() .\nDiscussion\nIf you have an ArrayList  or other Collection  and you need an array, you can get it\njust by calling the Collection ’s toArray()  method. With no arguments, you get an\narray whose type is Object[] . Y ou can optionally provide an array argument, which is\nused for two purposes:\n•The type of the array argument determines the type of array returned.\n•If the array is big enough (and you can ensure that it is by allocating the array\nbased on the Collection ’s size()  method), then this array is filled and returned.\nIf the array is not big enough, a new array is allocated instead. If you provide an\n222 | Chapter 7: Structuring Data with Java",1736
299-Problem.pdf,299-Problem,,0
300-Solution.pdf,300-Solution,,0
301-Discussion.pdf,301-Discussion,"array and objects in the Collection  cannot be cast to this type, then you will get\nan ArrayStoreException .\nExample 7-3  shows code for converting an ArrayList  to an array of type Object .\nExample 7-3. main/src/main/java/structure/ToArray.java\n        List<String> list = new ArrayList <>();\n        list.add(""Blobbo"" );\n        list.add(""Cracked"" );\n        list.add(""Dumbo"");\n        // Convert a collection to Object[], which can store objects\n        // of any type.\n        Object[] ol = list.toArray();\n        System.out.println(""Array of Object has length ""  + ol.length);\n        String[] sl = (String[]) list.toArray(new String[0]);\n        System.out.println(""Array of String has length ""  + sl.length);\n7.15 Making Your Data Iterable\nProblem\nY ou have written your own data structure, and you want to publish the data to be\niterable so it can be used in the for-each loop.\nSolution\nMake your data class Iterable : this interace has only one method, iterator() . Write\nyour own Iterator . Just implement (or provide an inner class that implements) the\nIterator  interface.\nDiscussion\nTo be usable in the modern Java for-each loop, your data class must implement\nIterable , a simple interface with one method, Iterator<T> iterator() . Whether\nyou use this interface or want to use the older Iterator  interface directly, the way to\nmake data from one part of your program available in a storage-independent way to\nother parts of the code is to generate an Iterator . Here is a short program that con‐\nstructs, upon request, an Iterator  for some data that it is storing—in this case, in an\narray. The Iterator  interface has only three methods —hasNext() , next() , and\nremove() —demonstrated in Example 7-4 .\n7.15 Making Your Data Iterable | 223\nExample 7-4. main/src/main/java/structure//IterableDemo\npublic class IterableDemo  {\n    /** Demo implements Iterable, meaning it must provide an Iterator,\n     * and that it can be used in a foreach loop.\n     */\n    static class Demo implements  Iterable <String> {\n        // Simple demo: use array instead of inventing new data structure\n        String[] data = { ""One"", ""Two"", ""Three""};\n        /** This is the Iterator that makes it all happen */\n        class DemoIterator  implements  Iterator <String> {\n            int i = 0;\n            /**\n             * Tell if there are any more elements.\n             * @return true if next() will succeed, false otherwise\n             */\n            public boolean hasNext() {\n                return i < data.length;\n            }\n            /** @return the next element from the data */\n            public String next() {\n                return data[i++];\n            }\n            /** Remove the object that next() just returned.\n             * An Iterator is not required to support this interface, and we don't.\n             * @throws UnsupportedOperationException unconditionally\n             */\n            public void remove() {\n                throw new UnsupportedOperationException (""remove"" );\n            }\n        }\n        /** Method by which the Demo class makes its iterator available */\n        public Iterator <String> iterator () {\n            return new DemoIterator ();\n        }\n    }\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        for (String s : demo) {\n            System.out.println(s);\n        }\n    }\n}\n224 | Chapter 7: Structuring Data with Java\nThe comments on the remove()  method remind me of an interesting point. This\ninterface introduces java.util ’s attempt at something Java doesn’t really have, the\noptional method. Because there is no syntax for this, and they didn’t want to intro‐\nduce any new syntax, the developers of the Collections Framework decided on an\nimplementation using existing syntax. Optional methods that are not implemented\nare required to throw an UnsupportedOperationException  if they ever get called. My\nremove()  method does just that. Note that UnsupportedOperationException  is sub‐\nclassed from RuntimeException , so it is not required to be declared or caught.\nThis code is simplistic, but it does show the syntax and demonstrates how the Itera\ntor interface works. In real code, the Iterator  and the data are usually separate\nobjects (the Iterator  might be an inner class from the data store class). Also, you\ndon’t even need to write this code for an array; you can just construct an ArrayList\nobject, copy the array elements into it, and ask it to provide the Iterator . However, I\nbelieve it’s worth showing this simple example of the internals of an Iterator  so that\nyou can understand both how it works and how you could provide one for a more\nsophisticated data structure, should the need arise.\nThe Iterable  interface has only one nondefault method, iterator() , which must\nprovide an Iterator  for objects of the given type. Because the ArrayIterator  class\nimplements this as well, we can use an object of type ArrayIterator  in a “foreach”\nloop, as in Example 7-5 .\nExample 7-5. main/src/main/java/structure/ArrayIteratorDemo.java\npackage structure ;\nimport com.darwinsys.util.ArrayIterator ;\npublic class ArrayIteratorDemo  {\n    private final static String[] names = {\n        ""rose"", ""petunia"" , ""tulip""\n    };\n    public static void main(String[] args) {\n        ArrayIterator <String> arrayIterator  = new ArrayIterator <>(names);\n        System.out.println(""Java 5, 6 way"" );\n        for (String s : arrayIterator ) {\n            System.out.println(s);\n        }\n        System.out.println(""Java 5, 6 ways"" );\n        arrayIterator .forEach(s->System.out.println(s));\n        arrayIterator .forEach(System.out::println);\n7.15 Making Your Data Iterable | 225",5803
302-7.16 Using a Stack of Objects.pdf,302-7.16 Using a Stack of Objects,,0
303-Problem.pdf,303-Problem,,0
304-Solution.pdf,304-Solution,,0
305-Discussion.pdf,305-Discussion,"}\n}\nJava 8 Iterable.foreach\nJava 8 adds foreach  to the Iterator  interface, a  default method  (discussed in Recipe\n9.0) that you don’t have to write. Thus, without changing the ArrayIterator , after\nmoving to Java 8 we can use the newest-style loop, Iterator.foreach(Consumer) ,\nwith a lambda expression (see Chapter 9 ) to print each element (see Example 7-5 ).\n7.16 Using a Stack of Objects\nProblem\nY ou need to process data in the order of last in, first out (LIFO) or most recently\nadded.\nSolution\nWrite your own code for creating a stack; it’s easy. Or, use a java.util.Stack .\nDiscussion\nY ou need to put things into a holding area quickly and retrieve them in last-in, first-\nout order. This is a common data structuring operation and is often used to reverse\nthe order of objects. The basic operations of any stack are push()  (add to stack), \npop()  (remove from stack), and peek()  (examine top element without removing).\nToyStack  in Example 7-6  is a simple class for stacking values of the primitive type\nint. I’ll expand it in a page or two to allow stacking of user-defined objects.\nExample 7-6. main/src/main/java/structure/ToyStack.java\npublic class ToyStack  {\n    /** The maximum stack depth */\n    protected  int MAX_DEPTH  = 10;\n    /** The current stack depth */\n    protected  int depth = 0;\n    /* The actual stack */\n    protected  int[] stack = new int[MAX_DEPTH ];\n    /** push - add an element onto the stack */\n    protected  void push(int n) {\n        stack[depth++] = n;\n    }\n    /** pop - return and remove the top element */\n    protected  int pop() {\n226 | Chapter 7: Structuring Data with Java\n        return stack[--depth];\n    }\n    /** peek - return the top element but don't remove it */\n    protected  int peek() {\n        return stack[depth-1];\n    }\n}\nIf you are not familiar with the basic idea of a stack, you should work through the\ncode here; if you are familiar with it, you can skip ahead. While looking at it, of\ncourse, think about what happens if pop()  or peek()  is called when push()  has never\nbeen called or if push()  is called to stack more data than will fit.\nWhile working on ToyStack2  (not shown but in the online source), I extracted its\ninterface into SimpleStack , which just lists the operations. At the same time I added\nthe empty()  method for some compatibility with the standard java.util.Stack\nclass. And importantly, I made it a generic type, so it can be used with values of any\ntype. This is shown in SimpleStack :\npublic interface  SimpleStack <T> {\n    /** empty - return true if the stack is empty */\n    abstract  boolean empty();\n    /** push - add an element onto the stack */\n    abstract  void push(T n);\n    /** pop - return and remove the top element */\n    abstract  T pop();\n    /** peek - return the top element but don't remove it */\n    abstract  T peek();\n}\nI then made another demo stack class, MyStack , to implement the new interface:\npublic class MyStack<T> implements  SimpleStack <T> {\n    private int depth = 0;\n    public static final int DEFAULT_INITIAL  = 10;\n    private T[] stack;\n    public MyStack() {\n        this(DEFAULT_INITIAL );\n    }\n    public MyStack(int howBig) {\n        if (howBig <= 0) {\n            throw new IllegalArgumentException (\n            howBig + "" must be positive, but was ""  + howBig);\n        }\n7.16 Using a Stack of Objects | 227\n        stack = (T[])new Object[howBig];\n    }\n    @Override\n    public boolean empty() {\n        return depth == 0;\n    }\n    /** push - add an element onto the stack */\n    @Override\n    public void push(T obj) {\n        // Could check capacity and expand\n        stack[depth++] = obj;\n    }\n    /* pop - return and remove the top element */\n    @Override\n    public T pop() {\n        --depth;\n        T tmp = stack[depth];\n        stack[depth] = null;\n        return tmp;\n    }\n    /** peek - return the top element but don't remove it */\n    @Override\n    public T peek() {\n        if (depth == 0) {\n            return null;\n        }\n        return stack[depth-1];\n    }\n    public boolean hasNext() {\n        return depth > 0;\n    }\n    public boolean hasRoom() {\n        return depth < stack.length;\n    }\n    public int getStackDepth () {\n        return depth;\n    }\n}\nThis version has a lot more error checking (and a unit test, in the src/test/java/struc‐\nture folder), as well as some additional methods not in the original. One example is \nhasRoom() . Unlike the full-blown java.util.Stack , MyStack  does not expand\nbeyond its original size, so we need a way to see if it is full without throwing an\nexception.\n228 | Chapter 7: Structuring Data with Java",4750
306-7.17 Multidimensional Structures.pdf,306-7.17 Multidimensional Structures,,0
307-Problem.pdf,307-Problem,,0
308-Solution.pdf,308-Solution,,0
309-Discussion.pdf,309-Discussion,"Now that you see how a stack works, I recommend using the provided\njava.util.Stack  instead of my demo versions; it is more fully fleshed out, more\nfully tested, and widely used. Unlike the major Collections API components List ,\nSet, and Map, java.util.Stack  does not have an interface and implementation\nclass(es); it is based on Vector , which is a List  implementation. The real\njava.util.Stack  works in a similar manner to mine but has more methods and\nmore flexibility. To see that in operation, Recipe 5.12  provides a simple stack-based\nnumeric calculator.\n7.17 Multidimensional Structures\nProblem\nY ou need a multidimensional array or ArrayList .\nSolution\nNo problem. Java supports this.\nDiscussion\nAs mentioned back in Recipe 7.1 , Java arrays can hold any reference type. Because an\narray is a reference type, it follows that you can have arrays of arrays or, in other ter‐\nminology, multidimensional  arrays. Further, because each array has its own length\nattribute, the columns of a two-dimensional array, for example, do not all have to be\nthe same length (see Figure 7-3 ).\nHere is code to allocate a couple of two-dimensional arrays, one using a loop and the\nother using an initializer. Both are selectively printed:\npublic class ArrayTwoDObjects  {\n    /** Return list of subscript names (unrealistic; just for demo). */\n    public static String[][] getArrayInfo () {\n        String info[][];\n        info = new String[10][10];\n        for (int i=0; i < info.length; i++) {\n            for (int j = 0; j < info[i].length; j++) {\n                info[i][j] = ""String[""  + i + "","" + j + ""]"";\n            }\n        }\n        return info;\n    }\n    /** Run the initialization method and print part of the results */\n    public static void main(String[] args) {\n        print(""from getArrayInfo"" , getArrayInfo ());\n7.17 Multidimensional Structures | 229\n    }\n    /** Print selected elements from the 2D array */\n    public static void print(String tag, String[][] array) {\n        System.out.println(""Array ""  + tag + "" is "" + array.length + "" x "" +\n            array[0].length);\n        System.out.println(""Array[0][0] = ""  + array[0][0]);\n        System.out.println(""Array[0][1] = ""  + array[0][1]);\n        System.out.println(""Array[1][0] = ""  + array[1][0]);\n        System.out.println(""Array[0][0] = ""  + array[0][0]);\n        System.out.println(""Array[1][1] = ""  + array[1][1]);\n    }\n}\nFigure 7-3. Multidimensional arrays\nRunning it produces this output:\n> java structure.ArrayTwoDObjects\nArray from getArrayInfo is 10 x 10\nArray[0][0] = String[0,0]\nArray[0][1] = String[0,1]\nArray[1][0] = String[1,0]\nArray[0][0] = String[0,0]\nArray[1][1] = String[1,1]\nArray from getParameterInfo is 2 x 3\nArray[0][0] = fontsize\nArray[0][1] = 9-18\nArray[1][0] = URL\nArray[0][0] = fontsize\nArray[1][1] = -\n>\n230 | Chapter 7: Structuring Data with Java",2923
310-7.18 Simplifying Data Objects with Lombok or Record.pdf,310-7.18 Simplifying Data Objects with Lombok or Record,,0
311-Problem.pdf,311-Problem,,0
312-Solution.pdf,312-Solution,,0
313-Discussion.pdf,313-Discussion,"The same kind of logic can be applied to any of the Collections . Y ou could have an\nArrayList  of ArrayLists , or a Vector  of linked lists, or whatever your little heart\ndesires.\nAs Figure 7-3  shows, it is not necessary for the array to be regular (i.e., it’s possible for\neach column of the 2D array to have a different height). That is why I used\narray[0].length  for the length of the first column in the code example.\n7.18 Simplifying Data Objects with Lombok or Record\nProblem\nY ou waste time writing data classes that are Plain Old Java Objects (POJO), with\nboilerplate code such as setters and getters, equals() , and toString() .\nSolution\nUse Lombok to autogenerate boilerplate methods. In Java 14+, use the new record\ndata type, which generates the boilerplate methods for you.\nDiscussion\nWhen Java was new, before there were good IDEs, developers had to write getters and\nsetters by hand, or by copy-paste-change. Back then I did a study of one existing large\ncode base and found about a 1/2% failure rate. The setter stored the value in the\nwrong place or the getter retrieved the wrong value. Assuming random distribution,\nthis meant that one getter call in a hundred gave the wrong answer! The application\nstill worked, so I must assume those wrong answers didn’t matter.\nNow we have IDEs that can generate all the boilerplate methods such as setters/\ngetters, equals, toString() , and so on. But you still have to remember to invoke these\ngenerators.\nLombok\nProject Lombok provides one solution. It reads your .class  files looking for its own\nannotations and, when it finds them, rewrites the class files to have the chosen\nmethods.\nTo use Lombok, you need to add the dependency org.projectlombok:lombok:\n1.18.4  (or newer) to your build script. Or, if you are using an IDE, download the\nLombok JAR file from https://projectlombok.org  and install it as per the instructions\nthere. Then you can annotate your class with annotations like these:\n@Setters @Getters\n7.18 Simplifying Data Objects with Lombok or Record | 231\nPresto! No more forgetting to generate these methods; Lombok will do the work for\nyou.\nOther annotations include the following:\n@ToString\n@EqualsAndHashCode\n@AllArgsConstructor\nFor data classes, there is even @Data , which is a shortcut for @ToString , @EqualsAnd\nHashCode , @Getter  on all fields, @Setter  on all nonfinal fields, and @RequiredArgs\nConstructor !\nJava 14 record (preview)\nThe new record  type provides another solution. A record  is a class-like construct for\ndata classes, a restricted form of class like enums and annotations. Y ou need only\nwrite the name of a data object and its fields, and the compiler will provide a con‐\nstructor, getters, hashCode()  and equals() , and toString() :\npublic record Person(String name, String emailAddress ) { }\nThe provided constructor has the same signature as the record declaration. All fields\nare implicitly final, and the record  provides getters but not setters. The getters have\nthe name of the field; they do not follow the JavaBeans getName()  pattern. Immutable\nobjects are important for reliable code (see Recipe 9.0 ). Y ou can provide other mem‐\nbers such as extra constructors, static fields, and static or instance methods. Records\ncannot be abstract and cannot declare additional instance fields. All in keeping with\nthe fact that the state of the object is as declared in the record  header. Here I create a\nPerson  record and make an instance of it, all in JShell:\n$ jshell --enable-preview\n|  Welcome to JShell -- Version 14-ea\n|  For an introduction  type: /help intro\njshell> record Person(String name, String email) {}\njshell> var p = new Person(""Covington Roderick Smythe"" , ""roddy@smythe.tld"" )\np ==> Person[name=Covington  Roderick  Smythe, email=roddy@smythe.tld ]\njshell> p.name()\n$3 ==> ""Covington Roderick Smythe""\njshell>\nOne-line record definitions typically don’t need to be in a source file all their own. To\nshow a complete example, I baked the Person  record into a new demo program Per\nsonRecordDemo . We can save this into a file, compile it with javac , and then use javap\nto view the class’s structure:\n232 | Chapter 7: Structuring Data with Java",4249
314-See Also.pdf,314-See Also,,0
315-7.19 Program Timing Comparisons.pdf,315-7.19 Program Timing Comparisons,"$ javac --enable-preview -source 14 PersonRecordDemo.java\nNote: PersonRecordDemo.java uses preview language features.\nNote: Recompile with -Xlint:preview for details.\n$ javap PersonRecordDemo'$'Person\nCompiled from ""PersonRecordDemo.java""\npublic final class PersonRecordDemo$Person extends java.lang.Record {\n  public PersonRecordDemo$Person(java.lang.String, java.lang.String);\n  public java.lang.String toString();\n  public final int hashCode();\n  public final boolean equals(java.lang.Object);\n  public java.lang.String name();\n  public java.lang.String email();\n}\nThe $ in the filename has to be escaped from the Unix shell. We see that the compiler\nhas generated the constructor, toString() , hashCode()  and equals() , and read-only\naccessors name()  and email() .\nAs of Java 14 the record  mechanism is a preview, so it may change\nfrom what is described here or might even (however unlikely) not\nappear in the final Java 14 or in a future Java release (though we\nhope it will appear as is, nonpreview, in Java 15). If you are using\nJava 14 you need the --enable-preview  option on commands like \njavap , javac , and jshell , as well as --source 14  on commands that\nread the source file.\nSee Also\nThe original description of and rationale for the record  mechanism is in Java\nEnhancement Proposal JEP-359  at OpenJDK.net.\n7.19 Program: Timing Comparisons\nNew developers sometimes worry about the overhead of these collections and think\nthey should use arrays instead of data structures. To investigate, I wrote a program\nthat creates and accesses 250,000 objects, once through a Java array and again\nthrough an ArrayList . This is a lot more objects than most programs use. First the\ncode for the Array  version:\npublic class Array {\n    public static final int MAX = 250000;\n    public static void main(String[] args) {\n        System.out.println(new Array().run());\n    }\n    public int run() {\n        MutableInteger  list[] = new MutableInteger [MAX];\n        for (int i=0; i<list.length; i++) {\n            list[i] = new MutableInteger (i);\n7.19 Program: Timing Comparisons | 233\n        }\n        int sum = 0;\n        for (int i=0; i<list.length; i++) {\n            sum += list[i].getValue ();\n        }\n        return sum;\n    }\n}\nAnd here’s the code for the ArrayList  version:\npublic class ArrayLst  {\n    public static final int MAX = 250000;\n    public static void main(String[] args) {\n        System.out.println(new ArrayLst ().run());\n    }\n    public int run() {\n        ArrayList <MutableInteger > list = new ArrayList <>();\n        for (int i=0; i<MAX; i++) {\n            list.add(new MutableInteger (i));\n        }\n        int sum = 0;\n        for (int i=0; i<MAX; i++) {\n            sum += ((MutableInteger )list.get(i)).getValue ();\n        }\n        return sum;\n    }\n}\nThe Vector -based version, ArrayVec , is sufficiently similar that I don’t feel the need\nto kill a tree reprinting its code—it’s online.\nHow can we time this? As covered in Recipe 17.7 , you can either use the operating\nsystem’s time  command, if available, or just use a bit of Java that times a run of your\nmain program. To be portable, I chose to use the latter on an older, slower machine.\nIts exact speed doesn’t matter because the important thing is to compare only versions\nof this program running on the same machine.\nFinally (drum roll, please), the results:\n$ java performance.Time Array \nStarting class class Array\n1185103928\nrunTime=4.310\n$ java performance.Time ArrayLst\nStarting class class ArrayLst\n1185103928\nrunTime=5.626\n$ java performance.Time ArrayVec\nStarting class class ArrayVec\n1185103928\nrunTime=6.699\n$\n234 | Chapter 7: Structuring Data with Java\nNotice that I have ignored one oft-quoted bit of advice that recommends giving a\ngood initial estimate on the size of the ArrayList . I did time it that way as well; in this\nexample, it made a difference of less than 4% in the total runtime.\nThe bottom line is that the efficiency of ArrayList  is not totally awful compared to\narrays. Obviously there is more overhead in calling a “get” method than in retrieving\nan element from an array. The overhead of objects whose methods actually do some\ncomputation probably outweighs the overhead of fetching and storing objects in an\nArrayList  rather than in an Array . Unless you are dealing with large numbers of\nobjects, you may not need to worry about it. Vector  is slightly slower but still only\nabout two-thirds the speed of the original array version. If you are concerned about\nthe time, once the finished size of the ArrayList  is known, you can convert the Array\nList  to an array (see Recipe 7.14 ).\n7.19 Program: Timing Comparisons | 235",4767
316-Chapter 8. Object-Oriented Techniques.pdf,316-Chapter 8. Object-Oriented Techniques,,0
317-8.0 Introduction.pdf,317-8.0 Introduction,,0
318-Advice or Mantras.pdf,318-Advice or Mantras,"CHAPTER 8\nObject-Oriented Techniques\n8.0 Introduction\nJava is an Object-Oriented (OO) language in the tradition of Simula-67, SmallTalk,\nand C++. It borrows syntax from C++ and ideas from SmallTalk. The Java API has\nbeen designed and built on the OO model. Design patterns (see the book of the same\nname), such as Factory and Delegate, are used throughout; an understanding of these\npatterns will help you better understand the use of the API and improve the design of\nyour own classes.\nAdvice, or Mantras\nThere are any number of short bits of advice that I could give. A few recurring themes\narise when learning the basics of Java, and I suggest reviewing them when learning\nmore Java.\nUse the API\nI can’t say this often enough. A lot of the things you need to do have already been\ndone by the good folks who develop the standard Java library (and third-party libra‐\nries). And this grows with every release. Learning the API well is a good grounds for\navoiding that deadly “reinventing the flat tire” syndrome—coming up with a second-\nrate equivalent of a first-rate product that was available to you the whole time. In fact,\npart of this book’s mission is to prevent you from reinventing what’s already there.\nOne example of this is the Collections API in java.util , discussed in Chapter 7 . The\nCollections API has a high degree of generality and regularity, so there is often no\nneed to invent your own data structuring code.\n237\nExceptions to the rule\nThere is one exception to the rule of using the API: the clone()  method in\njava.lang.Object  should generally not be used. If you need to copy an object, just\nwrite a copy method, or a copy constructor . Joshua Bloch’s arguments against the\nclone()  method in the book Effective  Java  (Addison-Wesley) are persuasive and\nshould be read by any dedicated Java programmer. While you’re at it, read that whole\nbook.\nAnother exception is the finalize()  method in java.lang.Object() . Don’t use it. It\nhas been deprecated since Java 9 because it isn’t guaranteed to be invoked; but\nbecause it might get invoked, it will cause your dead objects not to be garbage collec‐\nted, resulting in a memory leak. If you need some kind of cleanup, you must take\nresponsibility for defining a method and invoking it before you let any object of that\nclass go out of reference. Y ou might call such a method cleanUp() . For application-\nlevel cleanup, see https://darwinsys.com/java/shutdownhook.html .\nGeneralize\nThere is a trade-off between generality (and the resulting reusability), which is\nemphasized here, and the convenience of application specificity. If you’re writing one\nsmall part of a very large application designed according to OO design techniques,\nyou’ll have in mind a specific set of use cases. On the other hand, if you’re writing\ntoolkit-style code, you should write classes with few assumptions about how they’ll be\nused. Making code easy to use from a variety of programs is the route to writing reus‐\nable code.\nRead and write javadoc\nY ou’ve no doubt looked at the Java online documentation in a browser, in part\nbecause I just told you to learn the API well. Do you think Sun/Oracle hired millions\nof tech writers to produce all that documentation? No. That documentation exists\nbecause the developers of the API took the time to write javadoc comments, those\nfunny /** comments you’ve seen in code. So, one more bit of advice: use javadoc. The\nstandard JDK provides a good, standard mechanism for API documentation. And use\nit as you write the code—don’t think you’ll come back and write it in later. That kind\nof tomorrow never comes.\nSee Recipe 15.2  for details on using javadoc.\nUse subclassing and delegation\nUse subclassing. But don’t overuse subclassing. It is one of the best ways not only for\navoiding code duplication, but for developing software that works. See any number of\ngood books on the topic of object-oriented design and programming for more details.\n238 | Chapter 8: Object-Oriented Techniques\nThere are several alternatives. One alternative to subclassing is delegation. Think\nabout “is a” versus “has a. ” For example, instead of subclassing NameAndAddress  to\nmake BusinessPartner  and Customer , make BusinessPartner  and Customer  have\ninstances of NameAndAddress . That is a clearer structure; having BusinessPartner  be\na NameAndAddress  just because the partner has a  name and address would not make\nsense. And delegation also makes it easier for a Customer  to have both a billing\naddress and a shipping address. Another alternative is Aspect-Oriented Program‐\nming (AOP), which allows you to bolt on extra functionality from the outside of your\nclasses. AOP is provided by the Java EE using EJB Interception and by the Spring\nFramework AOP mechanism.\nUse design patterns\nIn the Preface , I mentioned Design Patterns  as one of the Very Important Books on\nobject-oriented programming. Often called the “Gang of Four” (GoF) book for its\nfour authors, it provides a powerful catalog of things that programmers often rein‐\nvent. Some people find the GoF book to be somewhat academic in tone; a less-formal\npresentation on patterns is Head First Design Patterns  by Bert Bates et al. (O’Reilly);\nthis covers the same two dozen patterns as the GoF book. A design pattern provides a\nstatement of a problem and its solution(s), rather like the present book, but generally\nat a higher level of abstraction. It is as important for giving a standard vocabulary of\ndesign as it is for its clear explanations of how the basic patterns work and how they\ncan be implemented.\nTable 8-1  shows some example uses of design patterns in the standard API.\nTable 8-1. Design patterns in the JavaSE API\nPattern\nnameMeaning Examples in Java API\nCommand Encapsulate requests, allowing queues of\nrequests, undoable operations, etc.javax.swing.Action; \njavax.swing.undo.UndoableEdit\nDecorator One class decorates another Swing Border s\nFactory\nMethodOne class makes up instances for you,\ncontrolled by subclassesgetInstance  (in Calendar , Format , Locale …);\nSocketFactory ; RMI InitialContext\nIterator Loop over all elements in a collection, visiting\neach exactly onceIterator ; older Enumeration ; java.sql.Result\nSet\nModel-View-\nControllerModel represents data; View is what the user\nsees; Controller responds to user requestsActionListener  and friends; Observer/Observa\nble ; used internally by all visible Swing components\nProxy One object stands in for another RMI, AOP, Dynamic Proxy\nSingleton Only one instance may exist java.lang.Runtime, java.awt.Toolkit\nI have written articles on the State , Proxy , Command , Decorator , and Visitor  patterns\nfor Oracle Java Magazine .\n8.0 Introduction | 239",6788
319-8.1 Object Methods Formatting Objects with toString Comparing with Equals.pdf,319-8.1 Object Methods Formatting Objects with toString Comparing with Equals,,0
320-Problem.pdf,320-Problem,,0
321-Solution.pdf,321-Solution,,0
322-Discussion.pdf,322-Discussion,"8.1 Object Methods: Formatting Objects with toString(),\nComparing with Equals\nProblem\nY ou want your objects to have a useful default format and to behave themselves when\nplaced in Collections  classes.\nSolution\nThere are four overridable methods inherited from java.lang.Object ; of these,\ntoString()  provides default formatting, while equals()  and hashCode()  provide\nequality testing and efficient usage in Map implementations. The fourth, clone() , is\nnot recommended for general use.\nDiscussion\ntoString()\nWhenever you pass an object to System.out.println()  or any equivalent method or\ninvolve it in string concatenation, Java automatically calls its toString()  method.\nJava knows that every object has a toString()  method because java.lang.Object\nhas one and all classes are ultimately subclasses of Object . The default implementa‐\ntion, in java.lang.Object , is neither pretty nor interesting: it just prints the class\nname, an @ sign, and the object’s hashCode()  value. For example, if you run the code\npublic class ToStringWithout  {\n    int x, y;\n    /** Simple constructor */\n    public ToStringWithout (int anX, int aY) {\n        x = anX; y = aY;\n    }\n    /** Main just creates and prints an object */\n    public static void main(String[] args) {\n        System.out.println(new ToStringWithout (42, 86));\n    }\n}\n240 | Chapter 8: Object-Oriented Techniques\nyou might see this uninformative output:\nToStringWithout@990c747b\nTo make it print better, you should provide an implementation of toString()  that\nprints the class name and some of the important states in all but the most trivial\nclasses. This gives you formatting control in println() , in debuggers, and anywhere\nyour objects get referred to in a String  context. Here is the previous program rewrit‐\nten with a toString()  method:\npublic class ToStringWith  {\n    int x, y;\n    /** Simple constructor */\n    public ToStringWith (int anX, int aY) {\n        x = anX; y = aY;\n    }\n    @Override\n    public String toString () {\n        return ""ToStringWith[""  + x + "","" + y + ""]"";\n    }\n    /** Main just creates and prints an object */\n    public static void main(String[] args) {\n        System.out.println(new ToStringWith (42, 86));\n    }\n}\nThis version produces the more useful output:\nToStringWith[42,86]\nThis example uses String  concatenation, but you may also want to use String.for\nmat()  or StringBuilder ; see Chapter 3 .\nhashCode() and equals()\nTo ensure your classes work correctly when any client code calls equals()  or when\nthese objects are stored in Map or other Collection  classes, outfit your class with\nequals()  and hashCode()  methods.\nHow do you determine equality? For arithmetic or Boolean operands, the answer is\nsimple: you test with the equals operator ( ==). For object references, though, Java pro‐\nvides both == and the equals()  method inherited from java.lang.Object . The\nequals  operator can be confusing because it simply compares two object references\nto see if they refer to the same object. This is not the same as comparing the values of\nthe objects themselves.\n8.1 Object Methods: Formatting Objects with toString(), Comparing with Equals | 241\n6A value class is one used mainly to hold state, rather than logic: a Person  is a value class, whereas\njava.lang.Math  is not. Many classes are somewhere in between.The inherited equals()  method is also not as useful as you might imagine. Some\npeople seem to start their lives as Java developers thinking that the default equals()\nmagically does some kind of detailed, field-by-field or even binary comparison of\nobjects. But it does not compare fields! It just does the simplest possible thing: it\nreturns the value of an == comparison on the two objects involved! So, for any value\nclasses  you write, you probably have to write an equals  method.6 Note that both the\nequals  and hashCode  methods are used by Maps or hashes (such as HashMap ; see\nRecipe 7.9 ). So if you think somebody using your class might want to create instances\nand put them into a Map, or even compare your objects, you owe it to them (and to\nyourself!) to implement both equals()  and hashCode()  and to implement them\nproperly.\nMost IDEs know how to generate correct equals()  and hashCode()  methods, but it’s\nworth your while to understand what these are doing, for the occasional case where\nyou need to tweak the generated code. The Eclipse IDE (see Recipe 1.3 ), for example,\noffers a Source  menu item Generate hashCode() and equals() ; it will only do both\nat the same time, not let you generate equals()  without hashCode()  nor vice versa.\nHere are the rules for a correct equals()  method:\nIt is reflexive\nx.equals(x)  must be true.\nIt is symmetrical\nx.equals(y)  must be true if and only if y.equals(x)  is also true.\nIt is transitive\nIf x.equals(y)  is true and y.equals(z)  is true, then x.equals(z)  must also be\ntrue.\nIt is idempotent (repeatable)\nMultiple calls on x.equals(y)  return the same value (unless state values used in\nthe comparison are changed, as by calling a set method).\nIt is cautious\nx.equals(null)  must return false rather than accidentally throwing a NullPoin\nterException .\nIn addition, beware of one common mistake: the argument to equals()  must be\ndeclared as java.lang.Object , not the class it is in; this is so that polymorphism will\nwork correctly (some classes may not have an equals()  method of their own). To\n242 | Chapter 8: Object-Oriented Techniques\nprevent this mistake, the @Override  annotation is usually added to the equals()\noverride, as mentioned in Recipe 15.3 .\nHere is a class that endeavors to implement these rules:\npublic class EqualsDemo  {\n    private int int1;\n    private SomeClass  obj1;\n    /** Constructor */\n    public EqualsDemo (int i, SomeClass  o) {\n        int1 = i;\n        if (o == null) {\n            throw new IllegalArgumentException (""Data Object may not be null"" );\n        }\n        obj1 = o;\n    }\n    /** Default Constructor */\n    public EqualsDemo () {\n        this(0, new SomeClass ());\n    }\n    /** Demonstration ""equals"" method */\n    @Override\n    public boolean equals(Object o) {\n        if (o == this)                    \n            return true;\n        if (o == null)                    \n            return false;\n        // Of the correct class?\n        if (o.getClass () != EqualsDemo .class) \n            return false;\n        EqualsDemo  other = (EqualsDemo )o; // OK, cast to this class\n        // compare field-by-field         \n        if (int1 != other.int1)           // compare primitives directly\n            return false;\n        if (!obj1.equals(other.obj1))     // compare objects using their equals\n            return false;\n        return true;\n    }\n    // ...\nOptimization: if same object, true by definition.\nIf other object null, false by definition.\n8.1 Object Methods: Formatting Objects with toString(), Comparing with Equals | 243\nCompare class descriptors using !=; see following paragraph.\nOptimization: compare primitives first. May or may not be worthwhile; may be\nbetter to order by those most likely to differ—depends on the data and the usage.\nAnother common mistake to avoid: note the use of class descriptor equality (i.e.,\no.getClass() != EqualsDemo.class ) to ensure the correct class, rather than via\ninstanceof , as is sometimes erroneously done. The reflexive requirement of the\nequals()  method contract pretty much makes it impossible to compare a subclass\nwith a superclass correctly, so we now use class equality (see Chapter 17, Reflection,  or\n“ A Class Named Class”  for details on the class descriptor).\nHere is a basic JUnit test (see Recipe 1.10 ) for the EqualsDemo  class:\n/** Some JUnit test cases for EqualsDemo.\n * Writing a full set is left as ""an exercise for the reader"".\n */\npublic class EqualsDemoTest  {\n    /** an object being tested */\n    EqualsDemo  d1;\n    /** another object being tested */\n    EqualsDemo  d2;\n    /** Method to be invoked before each test method */\n    @Before\n    public void setUp() {\n        d1 = new EqualsDemo ();\n        d2 = new EqualsDemo ();\n    }\n    @Test\n    public void testSymmetry () {\n        assertTrue (d1.equals(d1));\n    }\n    @Test\n    public void testSymmetric () {\n        assertTrue (d1.equals(d2) && d2.equals(d1));\n    }\n    @Test\n    public void testCaution () {\n        assertFalse (d1.equals(null));\n    }\n}\nWith all that testing, what could go wrong? Well, some things still need care. What if\nthe object is a subclass  of EqualsDemo ? We should test that it returns false in this case.\n244 | Chapter 8: Object-Oriented Techniques\nWhat else could go wrong? Well, what if either obj1  or other.obj1  is null? Y ou might\nhave just earned a nice shiny new NullPointerException . So you also need to test for\nany possible null values. Good constructors can avoid these NullPointerException s,\nas I’ve tried to do in EqualsDemo , or else test for them explicitly.\nFinally, you should never override equals()  without also overriding hashCode() , and\nthe same fields must take part in both computations.\nhashCode()\nThe hashCode()  method is supposed to return an int that should uniquely identify\nany set of values in objects of its class.\nA properly written hashCode()  method will follow these rules:\nIt is repeatable\nhashCode(x)  must return the same int when called repeatedly, unless set meth‐\nods have been called.\nIt is consistent with equality\nIf x.equals(y) , then x.hashCode()  must == y.hashCode() .\nDistinct objects should produce distinct hashCodes\nIf !x.equals(y) , it is not required that x.hashCode()  != y.hashCode() , but\ndoing so may improve performance of hash tables (i.e., hashes may call hash\nCode()  before equals() ).\nThe default hashCode()  on the standard JDK returns a machine address, which con‐\nforms to the first rule. Conformance to the second and third rules depends, in part,\non your equals()  method. Here is a program that prints the hashcodes of a small\nhandful of objects:\npublic class PrintHashCodes  {\n    /** Some objects to hashCode() on */\n    protected  static Object[] data = {\n        new PrintHashCodes (),\n        new java.awt.Color(0x44, 0x88, 0xcc),\n        new SomeClass ()\n    };\n    public static void main(String[] args) {\n        System.out.println(""About to hashCode ""  + data.length + "" objects."" );\n        for (int i=0; i<data.length; i++) {\n            System.out.println(data[i].toString () + "" --> "" +\n                data[i].hashCode ());\n        }\n        System.out.println(""All done."" );\n8.1 Object Methods: Formatting Objects with toString(), Comparing with Equals | 245",10808
323-8.2 Using Inner Classes.pdf,323-8.2 Using Inner Classes,"}\n}\nWhat does it print?\n> javac -d . oo/PrintHashCodes.java\n> java oo.PrintHashCodes\nAbout to hashCode 3 objects.\nPrintHashCodes@982741a0 --> -1742257760\njava.awt.Color[r=68,g=136,b=204] --> -12285748\nSomeClass@860b41ad --> -2046082643\nAll done.\n>\nThe hashcode value for the Color  object is interesting. It is actually computed as\nsomething like this:\nalpha<<24 + r<<16 + g<<8 + b\nIn this formula, r, g, and b are the red, green, and blue components, respectively, and\nalpha  is the transparency. Each of these quantities is stored in 8 bits of a 32-bit inte‐\nger. If the alpha value is greater than 128, the high bit in this word—having been set\nby shifting into the sign bit of the word—causes the integer value to appear negative\nwhen printed as a signed integer. Hashcode values are of type int, so they are allowed\nto be negative.\nDifficulties  and Alternatives to Clone\nThe java.util.Observable  class (designed to implement the Model-View-\nController pattern with AWT or Swing applications) contains a private Vector  but no\nclone method to deep-clone it. Thus, Observable  objects cannot safely be cloned,\never!\nThis and several other issues around clone() —such as the uncertainty of whether a\ngiven clone()  implementation is deep or shallow—suggest that clone()  was not as\nwell thought out as might be. An alternative is simply to provide a copy constructor\nor similar method: \npublic class CopyConstructorDemo  {\n    public static void main(String[] args) {\n        CopyConstructorDemo  object1 = new CopyConstructorDemo (123, ""Hello"");\n        CopyConstructorDemo  object2 = new CopyConstructorDemo (object1);\n        if (!object1.equals(object2)) {\n            System.out.println(""Something is terribly wrong..."" );\n        }\n        System.out.println(""All done."" );\n    }\n    private int number;\n    private String name;\n246 | Chapter 8: Object-Oriented Techniques",1922
324-Problem.pdf,324-Problem,,0
325-Solution.pdf,325-Solution,,0
326-Discussion.pdf,326-Discussion,"/** Default constructor */\n    public CopyConstructorDemo ()  {\n    }\n    /** Normal constructor */\n    public CopyConstructorDemo (int number, String name)  {\n        this.number = number;\n        this.name = name;\n    }\n    /** Copy constructor */\n    public CopyConstructorDemo (CopyConstructorDemo  other)  {\n        this.number = other.number;\n        this.name = other.name;\n    }\n    // hashCode() and equals() not shown\n8.2 Using Inner Classes\nProblem\nY ou need to write a private class, or a class to be used in one other class at most.\nSolution\nUse a nonpublic class or an inner class.\nDiscussion\nA nonpublic class can be written as part of another class’s source file, but not inside\nthat class. An inner class is Java terminology for a class defined inside another class.\nInner classes were first popularized with early Java for use as event handlers for GUI\napplications, but they have a much wider application.\nInner classes can, in fact, be constructed in several contexts. An inner class defined as\na member of a class can be instantiated anywhere in that class. An inner class defined\ninside a method can be referred to later only in the same method. Inner classes can\nalso be named or anonymous. A named inner class has a full name that is compiler\ndependent; the standard JVM uses a name like MainClass$InnerClass  for the result‐\ning file. An anonymous inner class, similarly, has a compiler-dependent name; the\nJVM uses MainClass$1 , MainClass$2 , and so on.\nThese classes cannot be instantiated in any other context; any explicit attempt to refer\nto, say, OtherMainClass$InnerClass , is caught at compile time:\nmain/src/main/java/oo/AllClasses.java\n8.2 Using Inner Classes | 247\npublic class AllClasses  {\n    public class Data {    \n        int x;\n        int y;\n    }\n    public void getResults () {\n        JButton b = new JButton(""Press me"" );\n        b.addActionListener (new ActionListener () { \n            public void actionPerformed (ActionEvent  evt) {\n                Data loc = new Data();\n                loc.x = ((Component )evt.getSource ()).getX();\n                loc.x = ((Component )evt.getSource ()).getY();\n                System.out.println(""Thanks for pressing me"" );\n            }\n        });\n    }\n}\n/** Class contained in same file as AllClasses, but can be used\n * (with a warning) in other contexts.\n */\nclass AnotherClass  {                    \n    // methods and fields here...\n    AnotherClass () {\n        // Inner class from above cannot be used here, of course\n        // Data d = new Data();    // EXPECT COMPILE ERROR\n    }\n}\nThis is an inner class, which can be used anywhere in class AllClasses .\nThis shows the anonymous inner class syntax, which uses new with a type fol‐\nlowed by (){, a class body, and }. The compiler will assign a name; the class will\nextend or implement the given type, as appropriate.\nThis is a nonpublic class; it can be used in the main class and (with warning) in\nother classes.\nOne issue is that the inner class retains a reference to the outer class. If you want to\navoid memory leaks if the inner class will be held for a longer time than the outer,\nyou can make the inner class static .\nInner classes implementing a single-method interface can be written in a much more\nconcise fashion as lambda expressions (see Chapter 9 ).\n248 | Chapter 8: Object-Oriented Techniques",3433
327-8.3 Providing Callbacks via Interfaces.pdf,327-8.3 Providing Callbacks via Interfaces,,0
328-Problem.pdf,328-Problem,,0
329-Solution.pdf,329-Solution,,0
330-Discussion.pdf,330-Discussion,"Interface Changes in Java: default and static\nJava 8 added two new capabilities to interfaces, default methods and static methods.\nDefault methods are implicitly added to any implementing class. They cannot directly\naccess fields in the class. They are useful in functional programming (see Chapter 9 ).\nThey are also useful in adding functionality to an existing, widely used interface\nwithout breaking all the implementing classes. For example, in Java 8 the List  inter‐\nface gained a forEach()  instance method for a measure of compatibility with\nStreams . It was important that all the List  implementations both in java.util  and\nin applications be able to provide this method without changing all the code, which is\nwhy the mechanism was implemented as it was.\nJava also now allows static  methods in interfaces. These allow addition of methods,\nagain without breaking existing implementations. They become static methods in\nevery implementing class. For example, the List  interface gained a static of method\nthat allows you to write code such as this:\nList<String> list = List.of(""Hello"", ""World"", ""of"", ""Java"");\nThese two additions could not have been made without the addition of these two key‐\nwords to the syntax of interfaces. A trivial subset of List , called MyList  in the struc‐\nture directory, demonstrates how these two sample methods—the instance forEach()\nand the static of() —could be implemented.\n8.3 Providing Callbacks via Interfaces\nProblem\nY ou want to provide callbacks—that is, have unrelated classes call back into your\ncode.\nSolution\nOne way is to use a Java interface.\nDiscussion\nAn interface is a class-like entity that can contain only abstract methods and final\nfields. As we’ve seen, interfaces are used a lot in Java! In the standard API, the follow‐\ning are a few of the commonly used interfaces:\n•Runnable , Comparable , and Cloneable  (in java.lang ).\n8.3 Providing Callbacks via Interfaces | 249\n•List , Set, Map, and Enumeration/Iterator  (in the Collections API; as you’ll see\nin Chapter 7 ).\n•ActionListener , WindowListener , and others in the GUI layer.\n•Driver , Connection , Statement , and ResultSet  in JDBC; see https://darwin\nsys.com/javadatabase .\n•The remote interface —the contact between the client and the server—is specified\nas an Interface  (in RMI, CORBA, and EJB).\nSubclass, Abstract Class, or Interface?\nThere is usually more than one way to solve a problem. Some problems can be solved\nby subclassing, by use of abstract classes, or by interfaces. The following general\nguidelines may help:\n•A class can only extend one other class, but it can implement any number of\ninterfaces; keep this in mind when deciding to use abstract classes or interface.\n•Use an abstract class  when you want to provide a template for a series of sub‐\nclasses, all of which may inherit some of their functionality from the parent class\nbut are required to implement some of it themselves. (Any subclass of a geomet‐\nric Shapes  class might have to provide a computeArea()  method; because the\ntop-level Shapes  class cannot do this, it would be abstract. This is implemented\nin Recipe 8.4 .)\n•Use an interface with default methods  for many of the same things you’ d have used\nan abstract class for prior to Java 8, which introduced default methods. Default\nmethods can be added to an interface without breaking existing code, such as\nforEach  and of methods being added to the Collection  interface so that every\nList  instance has a forEach  method built in.\n*Subclass  when you need to extend a class and add some functionality to it, whether\nthe parent class is abstract or not. See the standard Java APIs and the examples in\nRecipe 1.10 , Recipe 8.10 , and Recipe 10.10 .\n•Subclass  when you are required to extend a given class. Some APIs such as serv‐\nlets use subclassing to ensure base functionality in classes that are dynamically\nloaded (see Recipe 17.4 ).\n•Define  an interface  when there is no common parent class with the desired func‐\ntionality and when you want only certain unrelated classes to have that function‐\nality (see the PowerSwitchable  interface in Recipe 8.2 ). Y ou should also choose\nthis option if you know that you’ll need (or think there is a chance you might\nlater need) to be able to pass in unrelated classes for testing purposes. Using\n250 | Chapter 8: Object-Oriented Techniques\n6Of course these lights wouldn’t have remote power-off. But the computers might, for maintenance purposes.mock objects is a very common strategy in unit testing. Some say that interfaces\nshould be your first choice at least as often as subclassing.\n•Use interfaces as markers  to indicate something about a class. Marker interfaces\ncommonly have no abstract methods. The standard API, for example, uses Seri\nalizable  as a marker interface to indicate permission to serialize objects of the\nimplementing class. See “Solution” on page 394  for information on serialization.\nSuppose we are generating a building management system. To be energy efficient, we\nwant to be able to remotely turn off (at night and on weekends) such things as room\nlights and computer monitors, which use a lot of energy. Assume we have some kind\nof remote control technology. It could be a commercial version of BSR’s house-light\ncontrol technology X10, it could be Bluetooth or 802.11—it doesn’t matter. What\nmatters is that we have to be very careful what we turn off. It would cause great ire if\nwe turned off computer processors automatically—people often leave things running\novernight. It would be a matter of public safety if we ever turned off the building\nemergency lighting.6\nSo we’ve come up with the design shown in Figure 8-1 .\nFigure 8-1. Classes for a building management system\n8.3 Providing Callbacks via Interfaces | 251\nThe code for these data classes is not shown (it’s pretty trivial), but it’s in the oo/inter‐\nfaces  directory of the online source. The top-level classes (i.e., BuildingLight  and\nAsset ) are abstract classes. Y ou can’t instantiate them, because they don’t have any\nspecific functionality. To ensure—both at compile time and at runtime—that we can\nnever switch off the emergency lighting, we need only ensure that the class represent‐\ning it, EmergencyLight , does not implement the PowerSwitchable  interface.\nNote that we can’t very well use direct inheritance here. No common ancestor class\nincludes both ComputerMonitor  and RoomLights  that doesn’t also include Computer\nCPU and EmergencyLight . Use interfaces to define functionality in unrelated classes.\nHow we use these is demonstrated by the BuildingManagement  class; this class is not\npart of the hierarchy shown in Figure 8-1 , but it uses a collection of Asset  objects\nfrom that hierarchy.\nItems that can’t be switched must nonetheless be in the database, for various purposes\n(auditing, insurance, etc.). In the method that turns things off, the code is careful to\ncheck whether each object in the database is an instance of the PowerSwitchable\ninterface. If so, the object is casted to PowerSwitchable  so that its powerDown()\nmethod can be called. If not, the object is skipped, thus preventing any possibility of\nturning out the emergency lights or shutting off a machine that is busy running\nSETI@Home, downloading a big MP3 playlist, or performing system backups. The\nfollowing code shows this set of classes in action:\npublic class BuildingManagement  {\n    List<Asset> things = new ArrayList <>();\n    /** Scenario: goodNight() is called from a timer Thread at 2200, or when\n     * we get the ""shutdown"" command from the security guard.\n     */\n    public void goodNight () {\n        things.forEach(obj -> {\n            if (obj instanceof  PowerSwitchable )\n                ((PowerSwitchable )obj).powerDown ();\n            });\n    }\n    // tag::functional[]\n    public void goodNightFunctional () {\n        things.stream().filter(obj -> obj instanceof  PowerSwitchable )\n            .forEach(obj -> ((PowerSwitchable )obj).powerDown ());\n    }\n    // end::functional[]\n    // goodMorning() would be similar, but call each one's powerUp().\n    /** Add a Asset to this building */\n    public void add(Asset thing) {\n252 | Chapter 8: Object-Oriented Techniques",8335
331-8.4 PolymorphismAbstract Methods.pdf,331-8.4 PolymorphismAbstract Methods,,0
332-Problem.pdf,332-Problem,,0
333-Solution.pdf,333-Solution,,0
334-Discussion.pdf,334-Discussion,"System.out.println(""Adding ""  + thing);\n        things.add(thing);\n    }\n    /** The main program */\n    public static void main(String[] av) {\n        BuildingManagement  b1 = new BuildingManagement ();\n        b1.add(new RoomLights (101));    // control lights in room 101\n        b1.add(new EmergencyLight (101));    // and emerg. lights.\n        // add the computer on desk#4 in room 101\n        b1.add(new ComputerCPU (10104));\n        // and its monitor\n        b1.add(new ComputerMonitor (10104));\n        // time passes, and the sun sets...\n        b1.goodNight ();\n    }\n}\nWhen you run this program, it shows all the items being added but only the Power\nSwitchable  ones being switched off: \n> java oo.interfaces.BuildingManagement\nAdding RoomLights@2dc77f32\nAdding EmergencyLight@2e3b7f32\nAdding ComputerCPU@2e637f32\nAdding ComputerMonitor@2f1f7f32\nDousing lights in room 101\nDousing monitor at desk 10104\n>\n8.4 Polymorphism/Abstract Methods\nProblem\nY ou want each of a number of subclasses to provide its own version of one or more\nmethods.\nSolution\nMake the method abstract in the parent class; this makes the compiler ensure that\neach subclass implements it.\nDiscussion\nA hypothetical drawing program uses a Shape  subclass for anything that is drawn.\nShape  has an abstract method called computeArea()  that computes the exact area of\nthe given shape:\n8.4 Polymorphism/Abstract Methods | 253\npublic abstract class Shape {\n    protected int x, y;\n    public abstract double computeArea( );\n}\nA Rectangle  subclass, for example, has a computeArea()  that multiplies width times\nheight and returns the result:\npublic class Rectangle extends Shape {\n    double width, height;\n    public double computeArea( ) {\n        return width * height;\n    }\n}\nA Circle  subclass returns π r2:\npublic class Circle extends Shape {\n    double radius;\n    public double computeArea( ) {\n        return Math.PI * radius * radius;\n    }\n}\nThis system has a high degree of generality. In the main program, we can iterate over\na collection of Shape  objects and—here’s the real beauty—call computeArea()  on any\nShape  subclass object without having to worry about what kind of shape it is. Java’s\npolymorphic methods automatically call the correct computeArea()  method in the\nclass of which the object was originally constructed:\nmain/src/main/java/oo//shapes/ShapeDriver.java\n/** Part of a main program using Shape objects */\npublic class ShapeDriver  {\n    Collection <Shape> allShapes ;    // created in a Constructor, not shown\n    /** Iterate over all the Shapes, getting their areas;\n     * this cannot use the Java 8 Collection.forEach because the\n     * variable total would have to be final, which would defeat the purpose :-)\n     */\n    public double totalAreas () {\n        double total = 0.0;\n        for (Shape s : allShapes ) {\n            total += s.computeArea ();\n        }\n        return total;\n    }\nPolymorphism is a great boon for software maintenance: if a new subclass is added,\nthe code in the main program does not change. Further, all the code that is specific to,\nsay, polygon handling, is all in one place: in the source file for the Polygon  class. This\n254 | Chapter 8: Object-Oriented Techniques",3301
335-8.5 Using Typesafe Enumerations.pdf,335-8.5 Using Typesafe Enumerations,,0
336-Problem.pdf,336-Problem,,0
337-Solution.pdf,337-Solution,,0
338-Discussion.pdf,338-Discussion,"6For Java folks not that familiar with C/C++, C is the older, non-OO language; C++ is an OO derivative of C;\nand Java is in part a portable, more strongly typesafe derivative of C++.is a big improvement over older languages, where type fields in a structure were used\nwith case or switch statements scattered all across the software. Java makes software\nmore reliable and maintainable with the use of polymorphism.\n8.5 Using Typesafe Enumerations\nProblem\nY ou need to manage a small list of discrete values within a program.\nSolution\nUse the Java enum  mechanism.\nDiscussion\nTo enumerate means to list all the values. Y ou often know that a small list of possible\nvalues is all that’s wanted in a variable, such as the months of the year, the suits or\nranks in a deck of cards, or the primary and secondary colors. The C programming\nlanguage provided an enum  keyword:\nenum  { BLACK, RED, ORANGE} color;\nJava was criticized in its early years for its lack of enumerations, which many develop‐\ners have wished for. Many have had to develop custom classes to implement the type‐\nsafe enumeration pattern .\nBut C enumerations are not typesafe; they simply define constants that can be used in\nany integer context. For example, this code compiles without warning, even on gcc 3\nwith -Wall  (all warnings), whereas a C++ compiler catches the error:6\nenum { BLACK, RED, ORANGE} color;\nenum { READ, UNREAD } state;\n/*ARGSUSED*/\nint main(int argc, char *argv[]) {\n        color = RED;\n        color = READ; // In C this will compile, give bad results\n        return 0;\n}\nTo replicate this mistake in Java, one needs only to define a series of final int  val‐\nues; it will still not be typesafe. By typesafe I mean that you cannot accidentally use\nvalues other than those defined for the given enumeration. The definitive statement\n8.5 Using Typesafe Enumerations | 255\non the typesafe enumeration pattern is probably the version defined in item 21 of \nJoshua Bloch’s book Effective  Java  (Addison-Wesley). All modern Java versions\ninclude enumerations in the language; it is no longer necessary to use the code from\nBloch’s book. Bloch was one of the authors of the Typesafe Enumeration specification\n(enum  keyword), so you can be sure that Java now does a good job of implementing\nhis pattern. These enum s are implemented as classes, subclassed (transparently, by the\ncompiler) from the class java.lang.Enum . Unlike C, and unlike a series of final\nints, Java typesafe enumerations have the following qualities:\n•They are printable (they print as the name, not as an underlying int implementa‐\ntion).\n•They are almost as fast as int constants, but the code is more readable.\n•They can be easily iterated over.\n•They use a separate namespace for each enum  type, which means you don’t have\nto prefix each with some sort of constant name, like ACCOUNT_SAVINGS ,\nACCOUNT_CHECKING , etc.\nEnum constants are not compiled into clients, giving you the freedom to reorder the\nconstants within your enum  without recompiling the client classes. That does not\nmean you should, however; think about the case where objects that use them have\nbeen persisted, and the person designing the database mapping used the numeric val‐\nues of the enums. Bad idea to reorder then!\nAdditionally, an enum  type is a class, so it can, for example, implement arbitrary inter‐\nfaces; and you can add constructors, fields, and methods to an enum  class.\nCompared to Bloch’s Typesafe Enum pattern in the book:\n•Java enums  are simpler to use and more readable (those in the book require a lot\nof methods, making them cumbersome to write).\n•Enums can be used in switch statements.\nSo there are many benefits and few pitfalls.\nThe enum  keyword is at the same level as the keyword class  in declarations. That is,\nan enum  may be declared in its own file with public or default access. It may also be\ndeclared inside classes, much like nested or inner classes (see Recipe 8.2 ). Media.java ,\nshown in Example 8-1 , is a code sample showing the definition of a typesafe enum .\n256 | Chapter 8: Object-Oriented Techniques\nExample 8-1. structure/Media.java\npublic enum Media {\n    BOOK, MUSIC_CD , MUSIC_VINYL , MOVIE_VHS , MOVIE_DVD ;\n}\nNotice that an enum  class is a class; see what javap  thinks of the Media  class:\nC:> javap Media\nCompiled from ""Media.java""\npublic class Media extends java.lang.Enum{\n    public static final Media BOOK;\n    public static final Media MUSIC_CD;\n    public static final Media MUSIC_VINYL;\n    public static final Media MOVIE_VHS;\n    public static final Media MOVIE_DVD;\n    public static final Media[] values( );\n    public static Media valueOf(java.lang.String);\n    public Media(java.lang.String, int);\n    public int compareTo(java.lang.Enum);\n    public int compareTo(java.lang.Object);\n    static {};\n}\nC:>\nProduct.java , shown in Example 8-2 , is a code sample that uses the Media  enum.\nExample 8-2. main/src/main/java/structure/Product.java\npublic class Product {\n    String title;\n    String artist;\n    Media  media;\n    public Product(String artist, String title, Media media) {\n        this.title = title;\n        this.artist = artist;\n        this.media = media;\n    }\n    @Override\n    public String toString () {\n        switch (media) {\n        case BOOK:\n            return title + "" is a book"" ;\n        case MUSIC_CD:\n            return title + "" is a CD"" ;\n        case MUSIC_VINYL:\n            return title + "" is a relic of the age of vinyl"" ;\n        case MOVIE_VHS:\n            return title + "" is on old video tape"" ;\n        case MOVIE_DVD:\n8.5 Using Typesafe Enumerations | 257\n            return title + "" is on DVD"" ;\n        default:\n            return title + "": Unknown media ""  + media;\n        }\n    }\n}\nIn Example 8-3 , MediaFancy  shows how operations (methods) can be added to enu‐\nmerations; the toString()  method is overridden for the Book  value of this enum.\nExample 8-3. main/src/main/java/structure/MediaFancy.java\n/** An example of an enum with method overriding */\npublic enum MediaFancy  {\n    /** The enum constant for a book, with a method override */\n    BOOK {\n        public String toString () { return ""Book""; }\n    },\n    /** The enum constant for a Music CD */\n    MUSIC_CD ,\n    /** ... */\n    MUSIC_VINYL ,\n    MOVIE_VHS ,\n    MOVIE_DVD ;\n    /** It is generally disparaged to have a main() in an enum;\n     * please forgive this tiny demo class for doing so.\n     */\n    public static void main(String[] args) {\n        MediaFancy [] data =  { BOOK, MOVIE_DVD , MUSIC_VINYL  };\n        for (MediaFancy  mf : data) {\n            System.out.println(mf);\n        }\n    }\n}\nRunning the MediaFancy  program produces this output:\nBook\nMOVIE_DVD\nMUSIC_VINYL\nThat is, the Book  values print in a user-friendly way compared to the default way the\nother values print. In real life you’ d want to extend this to all the values in the enum .\nFinally, EnumList , in Example 8-4 , shows how to list all the possible values that a\ngiven enum  can take on; simply iterate over the array returned by the enumeration\nclass’s inherited values()  method.\n258 | Chapter 8: Object-Oriented Techniques",7285
339-8.6 Avoiding NPEs with Optional.pdf,339-8.6 Avoiding NPEs with Optional,,0
340-Problem.pdf,340-Problem,,0
341-Solution.pdf,341-Solution,,0
342-Discusssion.pdf,342-Discusssion,"Example 8-4. structure/EnumList.java\npublic class EnumList  {\n    enum State {\n        ON, OFF, UNKNOWN\n    }\n    public static void main(String[] args) {\n        for (State i : State.values()) {\n            System.out.println(i);\n        }\n    }\n}\nThe output of the EnumList  program is this, of course: \nON\nOFF\nUNKNOWN\n8.6 Avoiding NPEs with Optional\nProblem\nY ou worry about null references causing a NullPointerException  (NPE) in your\ncode.\nSolution\nUse java.util.Optional .\nDiscusssion\nThe developer who invented the notion of null pointers, and a key early contributor\nto our discipline, has described the null reference as “my billion-dollar mistake” .\nHowever, use of null  is not going away anytime soon.\nWhat we can do is make clear that we worry about null pointers in certain contexts.\nFor this purpose, Java 8 introduced the class java.util.Optional . The Optional  is\nan object wrapper around a possibly-null object reference. The Optional  wrapper has\na long history; a similar construct is found in LLVM’s ADT, where its Optional\ndescribes itself in turn as “in the spirit of OCaml’s opt variant. ”\nOptionals  can be created with one of the creational methods:\nOptional.empty()\nReturns an empty optional\n8.6 Avoiding NPEs with Optional | 259\nOptional.of(T obj)\nReturns a nonempty optional containing the given value\nOptional.ofNullable(T obj)\nReturns either an empty optional or one containing the given value\nThe basic operation of this class is to behave in one of two ways, depending on\nwhether it is full or empty. Optional objects are immutable, so they cannot transition\nfrom one state to the other.\nThe simplest use is to invoke isEmpty()  or its opposite isPresent()  and use pro‐\ngram logic to behave differently. This is not much different from using an if state‐\nment to check for null, but it puts the choice in front of you, making it less likely that\nyou’ll forget to check:\njshell> Optional <String> opt = Optional .of(""What a day!"" );\nopt ==> Optional [What a day!]\njshell> if (opt.isPresent ()) {\n   ...>     System.out.println(""Value is ""  + opt.get());\n   ...> } else {\n   ...>     System.out.println(""Value is not present."" );\n   ...> }\nValue is What a day!\nA better form would use the orElse  method:\njshell> System.out.println(""Value is ""  + opt.orElse(""not present"" ));\nValue is What a day!\nA useful use case is that of passing values into methods. The object can be wrapped in\nan Optional  either before it is passed to a method or after; the latter is useful when\nmigrating from code that didn’t use Optional  from the start. The Item  demo in\nExample 8-5  might represent part of a shipments tracking program, a lending library\nmanager, or anything else that has time-related data which might be missing.\nExample 8-5. main/src/main/java/oo/OptionalDemo.java\n        List.of(\n            new Item(""Item 1"" , LocalDate .now().plusDays (7)),\n            new Item(""Item 2"" )).\n                forEach(System.out::println);\n    static class Item {\n        String name;\n        Optional <LocalDate > dueDate;\n        Item(String name) {\n            this(name, null);\n        }\n        Item(String name, LocalDate  dueDate) {\n            this.name = name;\n260 | Chapter 8: Object-Oriented Techniques",3309
343-8.7 Enforcing the Singleton Pattern.pdf,343-8.7 Enforcing the Singleton Pattern,,0
344-Problem.pdf,344-Problem,,0
345-Solution.pdf,345-Solution,,0
346-Discussion.pdf,346-Discussion,"this.dueDate = Optional .ofNullable (dueDate);\n        }\n        public String toString () {\n            return String.format(""%s %s"", name,\n                dueDate.isPresent () ?\n                    ""Item is due on ""  + dueDate.get() :\n                    ""Sorry, do not know when item is due"" );\n        }\n    }\nThere are methods that throw exceptions, that return null, and so on. There are also\nmethods for interacting with the Streams mechanism (see Recipe 9.3 ). A full list of\nOptional ’s methods is at the start of the javadoc page .\n8.7 Enforcing the Singleton Pattern\nProblem\nY ou want to be sure there is only one instance of your class in a given Java Virtual\nMachine, or at least within your application.\nSolution\nThere are several methods of making your class enforce the Singleton pattern:\n•Enum implementation\n•Having only a private constructor (or multiple) and a getInstance()  method\n•Use a framework such as Spring or CDI ( Recipe 8.9 ) configured to give\nSingleton-style instantiation of plain classes\nDiscussion\nIt is often useful to ensure that only one instance of a class gets created, usually to\nfunnel all requests for some resource through a single point. An example of a Single‐\nton from the standard API is java.lang.Runtime : you cannot create instances of Run\ntime ; you simply ask for a reference by calling the static method Runtime.getRun\ntime() . Singleton is also an example of a design pattern that can be easily imple‐\nmented. In all forms, the point of the Singleton implementation is to provide an\ninstance in which certain methods can run, typically to control access to some\nresource.\nThe easiest implementation uses a Java enum  to provide Singleton-ness. The enum\nmechanism already guarantees that only one instance of each enum constant will\n8.7 Enforcing the Singleton Pattern | 261\nexist in a given JVM context, so this technique piggy-backs on that, as shown in\nExample 8-6 .\nExample 8-6. main/src/main/java/oo/EnumSingleton.java\npublic enum EnumSingleton  {\n    INSTANCE ;\n    // instance methods protected by singleton-ness would be here...\n    /** A simple demo method */\n    public String demoMethod () {\n        return ""demo"";\n    }\n}\nUsing it is simple:\n        // Demonstrate the enum method:\n        EnumSingleton.INSTANCE.demoMethod();\nThe next easiest implementation consists of a private constructor and a field to hold\nits result, as well as a static accessor method with a name like getInstance() .\nThe private field can be assigned from within a static initializer block or, more simply,\nby using an initializer. The getInstance()  method (which must be public) then sim‐\nply returns this instance:\npublic class Singleton  {\n    /**\n     * Static Initializer is run before class is available to code, avoiding\n     * broken anti-pattern of lazy initialization in instance method.\n     * For more complicated construction, could use static block initializer.\n     */\n    private static Singleton  instance  = new Singleton ();\n    /** A private Constructor prevents any other class from instantiating. */\n    private Singleton () {\n        // nothing to do this time\n    }\n    /** Static 'instance' method */\n    public static Singleton  getInstance () {\n        return instance ;\n    }\n    // other methods protected by singleton-ness would be here...\n    /** A simple demo method */\n262 | Chapter 8: Object-Oriented Techniques",3460
347-See Also.pdf,347-See Also,,0
348-8.8 Roll Your Own Exceptions.pdf,348-8.8 Roll Your Own Exceptions,,0
349-Problem.pdf,349-Problem,,0
350-Discussion.pdf,350-Discussion,"public String demoMethod () {\n        return ""demo"";\n    }\n}\nNote that the method of using lazy evaluation  in the getInstance()  method (as in\nDesign Patterns ) is not necessary in Java because Java already uses lazy loading . Y our\nSingleton  class will probably not get loaded until its getInstance()  is called, so\nthere is no point in trying to defer the Singleton  construction until it’s needed by\nhaving getInstance()  test the singleton  variable for null and creating the singleton\nthere.\nUsing this class is equally simple: simply get the instance reference, and invoke meth‐\nods on it:\n        // Demonstrate the codeBased method:\n        Singleton .getInstance ().demoMethod ();\nSome commentators believe that a code-based Singleton should also provide a public\nfinal clone()  method that just throws an exception, in order to avoid subclasses\nthat cheat and clone()  the Singleton. However, it is clear that a class with only a pri‐\nvate constructor cannot be subclassed, so this paranoia does not appear to be\nnecessary.\nSee Also\nThe Collections  class in java.util  has methods singletonList() , singleton\nMap() , and singletonSet() , which give out an immutable List , Map, or Set, respec‐\ntively, containing only the one object that is passed to the method. This does not, of\ncourse, convert the object into a Singleton in the sense of preventing that object from\nbeing cloned or other instances from being constructed.\nSee page 127 of the original Design Patterns  book.\n8.8 Roll Your Own Exceptions\nProblem\nY ou’ d like to use an application-specific exception class or two.\nSolution\nGo ahead and subclass Exception  or RuntimeException .\n8.8 Roll Your Own Exceptions | 263",1724
351-8.9 Using Dependency Injection.pdf,351-8.9 Using Dependency Injection,"Discussion\nIn theory, you could subclass Throwable  directly, but that’s considered rude. Y ou nor‐\nmally subclass Exception  (if you want a checked exception) or RuntimeException  (if\nyou want an unchecked exception). Checked exceptions are those that an application\ndeveloper is required to catch or throw upward by listing them in the throws  clause\nof the invoking method.\nWhen subclassing either of these, it is customary to provide at least these\nconstructors:\n•A no-argument constructor\n•A one-string argument constructor\n•A two-argument constructor—a string message and a Throwable  cause\nThe cause will appear if the code receiving the exception performs a stack trace oper‐\nation on it, with the prefix “Root Cause is” or similar. Example 8-7  shows these three\nconstructors for an application-defined exception, ChessMoveException .\nExample 8-7. main/src/main/java/oo/ChessMoveException.java\n/** A ChessMoveException is thrown  when the user makes an illegal move. */\npublic class ChessMoveException  extends Exception  {\n    private static final long serialVersionUID  = 802911736988179079L ;\n    public ChessMoveException  () {\n        super();\n    }\n    public ChessMoveException  (String msg) {\n        super(msg);\n    }\n    public ChessMoveException (String msg, Exception  cause) {\n        super(msg, cause);\n    }\n}\nSee Also\nThe javadoc documentation for Exception  lists a large number of subclasses; you\nmight look there first to see if there is one you can use.\n264 | Chapter 8: Object-Oriented Techniques",1557
352-Problem.pdf,352-Problem,,0
353-Solution.pdf,353-Solution,,0
354-Discussion.pdf,354-Discussion,"8.9 Using Dependency Injection\nProblem\nY ou want to avoid excessive coupling between classes, and you want to avoid exces‐\nsive code dedicated to object creation/lookup.\nSolution\nUse a dependency injection framework.\nDiscussion\nA dependency injection framework allows you to have objects passed in to your code\ninstead of making you either create them explicitly (which ties your code to the\nimplementing class name, since you’re calling the constructor) or looking for them\n(which requires use of a possibly cumbersome lookup API, such as JNDI, the Java\nNaming and Directory Interface).\nThree of the best-known dependency injection frameworks are the Spring Frame‐\nwork , the Java Enterprise Edition’s Context and Dependency Injection (CDI) , and\nGoogle Guice . Suppose we have three classes, a Model , a View , and a Controller ,\nimplementing the traditional MVC pattern. Given that we may want to have different\nversions of some of these, especially the View , we’ll define Java interfaces for simple\nversions of the Model (in Example 8-8 ) and View (in Example 8-9 ).\nExample 8-8. MVC Model interface\npublic interface  Model {\n String getMessage ();\n}\nExample 8-9. main/src/main/java/di/View.java (MVC View interface)\npublic interface  View {\n    void displayMessage ();\n}\nThe implementations of these are not shown, because they’re so trivial, but they are\nonline. The Controller in this example is a main program, no interface needed. First,\nlet’s see a version of the main program not using dependency injection. Obviously the\nView requires the Model, to get the data to display:\nmain/src/main/java/di/ControllerTightlyCoupled.java\n8.9 Using Dependency Injection | 265\npublic class ControllerTightlyCoupled  {\n    public static void main(String[] args) {\n        Model m = new SimpleModel ();\n        ConsoleViewer  v = new ConsoleViewer ();\n        v.setModel (m);\n        v.displayMessage ();\n    }\n}\nHere we have four tasks to undertake:\n1.Create the Model.\n2.Create the View.\n3.Tie the Model into the View.\n4.Ask the View to display some data.\nNow a version using dependency injection:\nmain/src/main/java/di/spring/MainAndController.java - Spring Controller\npublic class MainAndController  {\n    public static void main(String[] args) {\n        ApplicationContext  ctx =\n            new AnnotationConfigApplicationContext (""di.spring"" );\n        View v = ctx.getBean(""myView"" , View.class);\n        v.displayMessage ();\n        ((AbstractApplicationContext ) ctx).close();\n    }\n}\nIn this version, we have only three tasks:\n1.Set up the Spring context, which provides the dependency injection framework.\n2.Get the View from the context; it already has the Model set into it!\n3.Ask the View to display some data.\nFurthermore, we don’t depend on particular implementations of the interface.\nHow does Spring know to inject, or provide, a Model to the View? And how does it\nknow what code to use for the View? There might be multiple implementations of the\nView interface. Of course we have to tell it these things, which we’ll do here with\nannotations:\n@Named(""myView"" )\npublic class ConsoleViewer  implements  View {\n    Model messageProvider ;\n266 | Chapter 8: Object-Oriented Techniques\n    @Override\n    public void displayMessage () {\n        System.out.println(messageProvider .getMessage ());\n    }\n    @Resource (name=""myModel"" )\n    public void setModel (Model messageProvider ) {\n        this.messageProvider  = messageProvider ;\n    }\n}\nWhile Spring has provided its own annotations, it will also accept the Java standard\n@javax.annotation.Resource  annotation for injection and @java.inject.Named  to\nspecify the injectee.\nDue to the persistence of information on the web, if you do a web search for Spring\nInjection, you will probably find zillions of articles that refer to the older Spring 2.x\nway of doing things, which is to use an XML configuration file. Y ou can still use this,\nbut modern Spring practice is generally to use Java annotations to configure the\ndependencies.\nAnnotations are also used in the Java Enterprise Edition Contexts and Dependency\nInjection (CDI). Although this is most widely used in web applications, we’ll reuse\nthe same example, using the open source Weld implementation of CDI. CDI is quite a\nbit more powerful than Spring’s DI; because in CDI we don’t even need to know the\nclass from which a resource is being injected, we don’t even need the interfaces from\nthe Spring example! First, the Controller, or main program, which requires a Weld-\nspecific import or two because CDI was originally designed for use in enterprise\napplications:\npublic class MainAndController  {\n    public static void main(String[] args) {\n        final Instance <Object> weldInstance  = new Weld().initial\nize().instance ();\n        weldInstance .select(ConsoleViewer .class).get().displayMessage ();\n    }\n}\nThe View  interface is shared between both implementations. The ConsoleViewer\nimplementation is similar too, except it isn’t coupled to the Model; it just asks to have\na String  injected. In this simple example there is only one String  in the application;\nin a larger app you would need one additional annotation to specify which string to\ninject. Here is the CDI ConsoleViewer :\npublic class ConsoleViewer  implements  View {\n    @Inject @MyModel\n    private String message;\n8.9 Using Dependency Injection | 267",5466
355-See Also.pdf,355-See Also,,0
356-8.10 Program Plotter.pdf,356-8.10 Program Plotter,"@Override\n    public void displayMessage () {\n        System.out.println(message);\n    }\n}\nWhere does the injected String  come from? From the Model, as before:\nmain/src/main/java/di/cdi/ModelImpl.java\npublic class ModelImpl  {\n    public @Produces  @MyModel  String getMessage (InjectionPoint  ip)\n        throws IOException  {\n        ResourceBundle  props = ResourceBundle .getBundle (""messages"" );\n        return props.getString (\n            ip.getMember ().getDeclaringClass ().getSimpleName () + ""."" +\n            ip.getMember ().getName());\n    }\n}\nSee Also\nSpring DI, Java EE CDI, and Guice all provide powerful dependency injection . Spring’s\nis more widely used; Java EE’s has the same power and is built into every EE con‐\ntainer. All three can be used standalone or in a web application, with minor varia‐\ntions. In the EE, Spring provides special support for web apps, and in EE containers,\nCDI is already set up so that the first statement in the CDIMain  example is not needed\nin an EE app. There are many books on Spring. One book specifically treats Weld:\nJBoss Weld CDI for Java Platform  by Ken Finnegan (O’Reilly).\n8.10 Program: Plotter\nNot because it is very sophisticated, but because it is simple, this program serves as an\nexample of some of the things we’ve covered in this chapter, and also, in its subclasses,\nprovides a springboard for other discussions. This class describes a series of old-\nfashioned (i.e., common in the 1970s and 1980s) pen plotters. A pen plotter, in case\nyou’ve never seen one, is a device that moves a pen around a piece of paper and draws\nthings. It can lift the pen off the paper or lower it, and it can draw lines, letters, and so\non. Before the rise of laser printers and ink-jet printers, pen plotters were the domi‐\nnant means of preparing charts of all sorts, as well as presentation slides (this was, ah,\nwell before the rise of programs like Harvard Presents and Microsoft PowerPoint).\nToday, few, if any, companies still manufacture pen plotters, but I use them here\nbecause they are simple enough to be well understood from this brief description.\nToday’s 3D printers may be thought of as representing a resurgence of the pen plotter\nwith just one additional axis of motion. And a fancier pen.\n268 | Chapter 8: Object-Oriented Techniques\nI’ll present a high-level class that abstracts the key characteristics of a series of such\nplotters made by different vendors. It would be used, for example, in an analytical or\ndata-exploration program to draw colorful charts showing the relationships found in\ndata. But I don’t want my main program to worry about the gory details of any partic‐\nular brand of plotter, so I’ll abstract into a Plotter  class, whose source is as follows:\nmain/src/main/java/plotter/Plotter.java\n/**\n * Plotter abstract class. Must be subclassed\n * for X, DOS, Penman, HP plotter, etc.\n *\n * Coordinate space: X = 0 at left, increases to right.\n *        Y = 0 at top, increases downward (same as AWT).\n *\n * @author    Ian F. Darwin\n */\npublic abstract  class Plotter {\n    public final int MAXX = 800;\n    public final int MAXY = 600;\n    /** Current X co-ordinate (same reference frame as AWT!) */\n    protected  int curx;\n    /** Current Y co-ordinate (same reference frame as AWT!) */\n    protected  int cury;\n    /** The current state: up or down */\n    protected  boolean penUp;\n    /** The current color */\n    protected  int penColor ;\n    Plotter() {\n        penUp = true;\n        curx = 0; cury = 0;\n    }\n    abstract  void rmoveTo(int incrx, int incry);\n    abstract  void moveTo(int absx, int absy);\n    abstract  void penUp();\n    abstract  void penDown();\n    abstract  void penColor (int c);\n    abstract  void setFont(String fName, int fSize);\n    abstract  void drawString (String s);\n    /* Concrete methods */\n    /** Draw a box of width w and height h */\n    public void drawBox(int w, int h) {\n        penDown();\n        rmoveTo(w, 0);\n        rmoveTo(0, h);\n        rmoveTo(-w, 0);\n        rmoveTo(0, -h);\n        penUp();\n8.10 Program: Plotter | 269\n    }\n    /** Draw a box given an AWT Dimension for its size */\n    public void drawBox(java.awt.Dimension  d) {\n        drawBox(d.width, d.height);\n    }\n    /** Draw a box given an AWT Rectangle for its location and size */\n    public void drawBox(java.awt.Rectangle  r) {\n        moveTo(r.x, r.y);\n        drawBox(r.width, r.height);\n    }\n    /** Show the current location; useful for\n     * testing, if nothing else.\n     */\n    public Point getLocation () {\n        return new Point(curx, cury);\n    }\n}\nNote the variety of abstract methods. Those related to motion, pen control, or draw‐\ning are left abstract, due to the number of different ways of implementing motion on\nradically different devices. However, the method for drawing a rectangle ( drawBox )\nhas a default implementation, which simply puts the currently selected pen onto the\npaper at the last-moved-to location, draws the four sides, and raises the pen. Sub‐\nclasses for smarter plotters will likely override this method, but subclasses for less-\nevolved plotters will probably use the default version. This method also has two over‐\nloaded convenience methods for cases where the client has an AWT Dimension for\nthe size or an AWT Rectangle for the location and size.\nTo demonstrate one of the subclasses of this program, consider the following simple\ndriver program. This is intended to simulate a larger graphics application such as\ngnuplot. The Class.forName()  near the beginning of main  is discussed in Recipe\n17.2; for now, you can take my word that it simply creates an instance of the given\nsubclass, which we store in a Plotter  reference named r and use to draw the plot:\nmain/src/main/java/plotter/PlotDriver.java\npublic class PlotDriver  {\n    /** Construct a Plotter driver, and try it out. */\n    public static void main(String[] argv) {\n        Plotter r ;\n        if (argv.length != 1) {\n            System.err.println(""Usage: PlotDriver driverclass"" );\n            return;\n        }\n        try {\n            Class<?> c = Class.forName(argv[0]);\n270 | Chapter 8: Object-Oriented Techniques\n            Object o = c.newInstance ();\n            if (!(o instanceof  Plotter))\n                throw new ClassNotFoundException (""Not instanceof Plotter"" );\n            r = (Plotter)o;\n        } catch (ClassNotFoundException  e) {\n            System.err.println(""Sorry, class ""  + argv[0] +\n                    "" not a plotter class"" );\n            return;\n        } catch (Exception  e) {\n            e.printStackTrace ();\n            return;\n        }\n        r.penDown();\n        r.penColor (1);\n        r.moveTo(200, 200);\n        r.penColor (2);\n        r.drawBox(123, 200);\n        r.rmoveTo(10, 20);\n        r.penColor (3);\n        r.drawBox(123, 200);\n        r.penUp();\n        r.moveTo(300, 100);\n        r.penDown();\n        r.setFont(""Helvetica"" , 14);\n        r.drawString (""Hello World"" );\n        r.penColor (4);\n        r.drawBox(10, 10);\n    }\n}\nWe don’t show any actual subclasses of this Plotter  class in upcoming chapters, how‐\never there is a PlotterAWT proof-of-concept in the same source folder, and one could\nimplement this for PostScript, PDF, or other output technologies.\n8.10 Program: Plotter | 271",7435
357-Chapter 9. Functional Programming Techniques Functional Interfaces Streams and Parallel Collections.pdf,357-Chapter 9. Functional Programming Techniques Functional Interfaces Streams and Parallel Collections,,0
358-9.0 Introduction.pdf,358-9.0 Introduction,"6Haskell was used to write a fairly complete Twitter clone in a few hundred lines; see https://github.com/\nGabriel439/simple-twitter .CHAPTER 9\nFunctional Programming Techniques:\nFunctional Interfaces, Streams,\nand Parallel Collections\n9.0 Introduction\nJava is an Object-Oriented (OO) language. Y ou know what that is. Functional Pro‐\ngramming (FP) has been attracting attention lately. There may not be quite as many\ndefinitions of FP as there are FP languages, but it’s close. Wikipedia’s definition of\nfunctional programming is as follows (from https://en.wikipedia.org/wiki/Func\ntional_programming , viewed December 2013):\na programming paradigm, a style of building the structure and elements of computer\nprograms, that treats computation as the evaluation of mathematical functions and\navoids state and mutable data. Functional programming emphasizes functions that\nproduce results that depend only on their inputs and not on the program state—i.e.\npure mathematical functions. It is a declarative programming paradigm, which means\nprogramming is done with expressions. In functional code, the output value of a func‐\ntion depends only on the arguments that are input to the function, so calling a function\nf twice with the same value for an argument x will produce the same result f(x) both\ntimes. Eliminating side effects, i.e. changes in state that don’t depend on the function\ninputs, can make it much easier to understand and predict the behavior of a program,\nwhich is one of the key motivations for the development of functional programming.\nHow can we benefit from the FP paradigm? One way would be to switch to using an\nFP language; some of the leading ones are Haskell,6 Idris, Ocaml, Erlang, Julia, and\n273\nthe LISP family. But most of those would require walking away from the Java ecosys‐\ntem. Y ou could consider using Scala  or Clojure , JVM-based languages that provide\nfunctional programming support in the context of an OO language. And there is Kot‐\nlin, the latest Java-like language for the JVM.\nBut this is the Java Cookbook , so you can imagine we’re going to try to get as many\nbenefits of functional programming as we can while remaining in the Java language.\nSome features of FP include the following:\n•Pure functions having no side effects and whose results depend only on their\ninputs and not on mutable state elsewhere in the program\n•First-class functions (e.g., functions as data)\n•Immutable data\n•Extensive use of recursion and lazy evaluation\nPure functions  are completely self-contained; their operation depends only on the\ninput parameters and internal logic, not on any variable state in other parts of the\nprogram—indeed, there are no global variables, only global constants . Although this\ncan be hard to accept for those schooled in imperative languages like Java, it does\nmake it much easier to test and ensure program correctness! It means that, no matter\nwhat else is going on in the program (even with multiple threads), a method call like\ncomputeValue(27)  will always, unconditionally, return the same value every time\n(with exceptions, of course, for things like the current time, random seeds, etc., which\nare global state).\nWe’ll use the terms function  and method  interchangeably in this chapter, although it’s\nnot strictly correct. FP people use the term function  in the mathematical function\nsense, whereas in Java methods  just means some code you can call (a Java method call\nis also referred to as a message  being sent to an object, in the OO view of things).\nFunctions as data  means that you can create an object that is a function , pass it into\nanother function, write a function that returns another function, and so on—with no\nspecial syntax, because, well, functions are data.\nOne of Java’s approaches to FP is the definition of functional interfaces. A functional\ninterface  in Java is one that has only one abstract method, such as the widely used\nRunnable , whose only method is run() , or the common Swing action handler Action\nListener , whose only method is actionPerformed(ActionEvent) . Actually, also new\nin Java 8, interfaces can have methods annotated with the new-in-this-context\ndefault  keyword. A default  method in an interface becomes available for use in any\nclass that implements  the interface. Such methods cannot depend on instance state in\na particular class because they would have no way of referring to it at compile time.\n274 | Chapter 9: Functional Programming Techniques: Functional Interfaces, Streams, and Parallel Collections\nSo a functional interface is more precisely defined as one that has a single nondefault\nmethod. Y ou can do functional-style programming in Java if you use functional inter‐\nfaces and if you restrict code in your methods to not depending on any nonfinal\ninstance or class fields; using default methods is one way of achieving this. The first\nfew recipes in this chapter discuss functional interfaces.\nAnother Java approach to functional-ness is lambda expressions. A lambda is an\nexpression of a functional interface, and it can be used as data (i.e., assigned,\nreturned, etc.). Just to give a couple of short examples for now:\nActionListener  x = e -> System.out.println(""You activated ""  + e.getSource ());\npublic class RunnableLambda  {\n    public static void main(String[] args) {\n        threadPool .submit(() -> System.out.println(""Hello from a thread"" ));\nImmutable data is easy in theory: just have a class with only read accessors (“get”\nmethods). The standard String  class, for example, is immutable: methods like sub\nstring()  or toUpperCase()  don’t change the original string, but make up new string\nobjects with the requested change. Y et strings are universally used, and useful. Enums\nare also implicitly immutable. There is a proposal to add a new kind of class-like\nobject called a record  in Java 14 or 15. record s are implicitly immutable; the com‐\npiler generates “get” methods for the fields (along with a constructor and the three\ncommon Object  methods), but not “set” methods.\nAlso new in Java 8 is the notion of Stream  classes. A Stream  is like a pipeline that you\ncan feed into, fan out, collect down—like a cross between the Unix notion of pipe‐\nlines and Google’s distributed programming concept of MapReduce, as exemplified in\nHadoop , but running in a single VM, a single program. Stream s can be sequential or\nparallel; the latter are designed to take advantage of the massive parallelism that is\nhappening in hardware design (particularly servers, where 12- and 16-core process‐\nors are popular). We discuss Stream s in several recipes in this chapter.\nIf you’re familiar with Unix pipes and filters, this equivalence will make sense to you;\nif not, you can skip it for now. The Unix command is this:\ncat lines.txt | sort | uniq | wc -l\nThe Java Stream s equivalent is this:\njshell> long numberLines =\n    new BufferedReader(\n    new FileReader(""lines.txt"")).lines().sorted().distinct().count();\nnumberLines ==> 5\nThese commands are written out in more idiomatic Java in Example 9-1 . Both\napproaches give the same answer. For small inputs, the Unix pipeline is faster; but for\nlarger volumes, the Java one should be faster, especially when parallelized.\n9.0 Introduction | 275",7343
359-See Also.pdf,359-See Also,,0
360-9.1 Using LambdasClosures Instead of Inner Classes.pdf,360-9.1 Using LambdasClosures Instead of Inner Classes,,0
361-Problem.pdf,361-Problem,,0
362-Solution.pdf,362-Solution,,0
363-Discussion.pdf,363-Discussion,"Example 9-1. main/src/main/java/functional/UnixPipesFiltersReplacement.java\n        long numberLines  = Files.lines(Path.of((""lines.txt"" )))\n            .sorted()\n            .distinct ()\n            .count();\n        System.out.printf(""lines.txt contains ""  + numberLines  + "" unique lines."" );\nTied in with Stream s is the notion of a Spliterator , a derivative (logically, not by\ninheritance) of the familiar Iterator  but designed for use in parallel processing.\nMost users will not be expected to develop their own Spliterator  and will likely not\neven call its methods directly very often, so we do not discuss them in detail.\nSee Also\nFor general information on functional programming, see the book Functional Think‐\ning by Neal Ford (O’Reilly).\nThere is an entire book dedicated to lambda expressions and related tools, Richard\nWarburton’s Java 8 Lambdas  (O’Reilly).\n9.1 Using Lambdas/Closures Instead of Inner Classes\nProblem\nY ou want to avoid all the typing that even the anonymous style of inner class requires.\nSolution\nUse Java’s lambda expressions.\nDiscussion\nThe symbol lambda ( λ) is the 11th letter of the Greek alphabet and thus as old as\nWestern society. The Lambda calculus  is about as old as our notions of computing. In\nthis context, Lambda expressions are small units of calculation that can be referred to.\nThey are functions as data. In that sense, they are a lot like anonymous inner classes,\nthough it’s probably better to think of them as anonymous methods . They are essen‐\ntially used to replace inner classes for a functional interface —that is, an interface with\none abstract method (function) in it. A very common example is the AWT ActionLis\ntener  interface, widely used in GUI code, whose only method is this one:\npublic void actionPerformed (ActionEvent );\nUsing lambdas is now the preferred method of writing for GUI action listeners. Here’s\na single example:\n276 | Chapter 9: Functional Programming Techniques: Functional Interfaces, Streams, and Parallel Collections\n6If you ever have to do this kind of thing where the data is stored in a relational database using the Java Persis‐\ntence API (JPA), you should check out the Spring Data  or Apache DeltaSpike  frameworks. These allow you to\ndefine an interface  with method names like findCameraByInterchangeableTrueAndPriceLessThan(double\nprice)  and have the framework implement these methods for you.\n7If you’re just not that into cameras, the description “Interchangeable Lens Camera (ILC)” includes two cate‐\ngories of what you might find in a camera store: traditional DSLR (Digital Single Lens Reflex) cameras, and\nthe newer category of “Compact System Cameras” like the Nikon 1 and Z series, Sony ILCE (formerly known\nas NEX), and the Canon EOS-M, all of which are smaller and lighter than the older DSLRs.quitButton.addActionListener(e -> shutDownApplication(0));\nBecause not everybody writes Swing GUI applications these days, let’s start with an\nexample that doesn’t require GUI programming. Suppose we have a collection of\ncamera model descriptor objects that has already been loaded from a database into\nmemory, and we want to write a general-purpose API for searching them, for use by\nother parts of our application.\nThe first thought might be along the following lines:\npublic interface  CameraInfo  {\n    public List<Camera> findByMake ();\n    public List<Camera> findByModel ();\n    ...\n}\nPerhaps you can already see the problem. Y ou will also need to write findByPrice() ,\nfindByMakeAndModel() , findByYearIntroduced() , and so on as your application\ngrows in complexity.\nY ou could consider implementing a query by example method, where you pass in a\nCamera  object and all its nonnull fields are used in the comparison. But then how\nwould you implement finding cameras with interchangeable lenses under $500 ?6\nSo a better approach is probably to use a callback function to do the comparison.\nThen you can provide an anonymous inner class to do any kind of searching you\nneed. Y ou’ d want to be able to write callback methods like this:\npublic boolean choose(Camera c) {\n    return c.isIlc() && c.getPrice () < 500;\n}\nAccordingly, we’ll build that into an interface:7\n/** An Acceptor accepts some elements from a Collection */\npublic interface  CameraAcceptor  {\n    boolean choose(Camera c);\n}\nNow the search application provides a method:\npublic List<Camera> search(CameraAcceptor  acc);\n9.1 Using Lambdas/Closures Instead of Inner Classes | 277\nwhich we can call with code like this:\nresults = searchApp .search(new CameraAcceptor () {\n    public boolean choose(Camera c) {\n        return c.isIlc() && c.getPrice () < 500;\n    }\n}\nOr, if you were not comfortable with anonymous inner classes, you might have to\ntype this:\nclass MyIlcPriceAcceptor  implements  CameraAcceptor  {\n    public boolean choose(Camera c) {\n        return c.isIlc() && c.getPrice () < 500;\n    }\n}\nCameraAcceptor  myIlcPriceAcceptor  = nwq MyIlcPriceAcceptor ();\nresults = searchApp .search(myIlcPriceAcceptor );\nThat’s really a great deal of typing just to get one method packaged up for sending\ninto the search engine. Java’s support for lambda expressions or closures was argued\nabout for many years (literally) before the experts agreed on how to do it. And the\nresult is staggeringly simple. One way to think of Java lambda expressions is that each\none is just a method that implements a functional interface. With lambda expres‐\nsions, you can rewrite the preceding code as just:\nresults = searchApp .search(c -> c.isIlc() && c.getPrice () < 500);\nThe arrow notation -> indicates the code to execute. If it’s a simple expression as here,\nyou can just write it as shown. If there is conditional logic or other statements, you\nhave to use a block, as is usual in Java.\nHere I just rewrite the search example to show it as a block:\nresults = searchApp .search(c -> {\n    if (c.isIlc() && c.getPrice () < 500)\n        return true;\n    else\n        return false;\n});\nThe first c inside the parenthesis corresponds to Camera c  in the explicitly imple‐\nmented choose()  method: you can omit the type because the compiler knows it! If\nthere is more than one argument to the method, you must parenthesize them. Sup‐\npose we had a compare method that takes two cameras and returns a quantitative\nvalue (oh, and good luck trying to get two photographers to agree on that\nalgorithm!):\ndouble goodness  = searchApp .compare((c1, c2) -> {\n    // write some amazing code here\n});\n278 | Chapter 9: Functional Programming Techniques: Functional Interfaces, Streams, and Parallel Collections\nThis notion of lambdas  seems pretty potent, and it is! Y ou will see much more of this\nin Java as Java 8 moves into the mainstream of computing.\nUp to here, we still have to write an interface for each type of method that we want to\nbe able to lambda-ize. The next recipe shows some predefined interfaces that you can\nuse to further simplify (or at least shorten) your code.\nAnd, of course, there are many existing interfaces that are functional, such as the\nActionListener  interface from GUI applications. Interestingly, the IntelliJ IDE (see\nRecipe 1.3 ) automatically recognizes inner class definitions that are replaceable by\nlambdas and, when using code folding  (the IDE feature of representing an entire\nmethod definition with a single line), replaces the inner class with the corresponding\nlambda! Figures 9-1 and 9-2 show a before-and-after picture of this code folding.\nFigure 9-1. IntelliJ code unfolded\n9.1 Using Lambdas/Closures Instead of Inner Classes | 279",7674
364-9.2 Using Lambda Predefined Interfaces Instead of Your Own.pdf,364-9.2 Using Lambda Predefined Interfaces Instead of Your Own,,0
365-Problem.pdf,365-Problem,,0
366-Solution.pdf,366-Solution,,0
367-Roll Your Own Functional Interface.pdf,367-Roll Your Own Functional Interface,"Figure 9-2. IntelliJ code folded\n9.2 Using Lambda Predefined  Interfaces Instead\nof Your Own\nProblem\nY ou want to use existing interfaces, instead of defining your own, for use with\nLambdas.\nSolution\nUse the Java 8 lambda functional interfaces from java.util.function .\nDiscussion\nIn Recipe 9.1 , we used the interface method acceptCamera()  defined in the interface\nCameraAcceptor . Acceptor-type methods are quite common, so the package\njava.util.function  includes the Predicate<T>  interface, which we can use instead\nof CameraAcceptor . This interface has only one method— boolean test(T t) :\ninterface  Predicate <T> {\n    boolean test(T t);\n}\n280 | Chapter 9: Functional Programming Techniques: Functional Interfaces, Streams, and Parallel Collections\nThis package includes about 50 of the most commonly needed functional interfaces,\nsuch as IntUnaryOperator , which takes one int argument and returns an int value;\nLongPredicate , which takes one long  and returns boolean ; and so on.\nTo use the Predicate  interface, as with any generic type, we provide an actual type\nfor the parameter Camera , giving us (in this case) the parameterized type Predi\ncate<Camera> , which is the following (although we don’t have to write this out):\ninterface  Predicate <Camera> {\n    boolean test(Camera c);\n}\nSo now our search application will be changed to offer us the following search\nmethod:\npublic List<Camera> search(Predicate  p);\nConveniently, this has the same signature as our own CameraAcceptor  from the point\nof view of the anonymous methods that lambdas implement, so the rest of our code\ndoesn’t have to change! This is still a valid call to the search()  method:\nresults = searchApp .search(c -> c.isIlc() && c.getPrice () < 500);\nHere is the implementation of the search  method:\nmain/src/main/java/functional/CameraSearchPredicate.java\n    public List<Camera> search(Predicate <Camera> tester) {\n        List<Camera> results = new ArrayList <>();\n        privateListOfCameras .forEach(c -> {\n            if (tester.test(c))\n                results.add(c);\n        });\n        return results;\n    }\nSuppose we only need the list to do one operation on each element, and then we’ll\ndiscard it. Upon reflection, we don’t actually need to get the list back; we merely need\nto get our hooks on each element that matches our Predicate  in turn.\nRoll Your Own Functional Interface\nWhile the JDK provides a good set of functional interfaces, there may be cases where\nyou’ d want to create your own. This is a simple example of a functional interface:\ninterface  MyFunctionalInterface  {\n    int compute(int x);\n}\n9.2 Using Lambda Predefined  Interfaces Instead of Your Own | 281\nThe @FunctionalInterface  annotation tells the compiler to ensure that a given\ninterface is and remains functional. Its use is analogous to @Override  (both annota‐\ntions are in java.lang ). It is always optional.\nMyFunctionalInterface  could be used to process an array of integers, like this:\npublic class ProcessIntsUsingFunctional  {\n    static int[] integers  = {1, 2, 3};\n    public static void main(String[] args) {\n        int total = 0;\n        for (int i : integers )\n            total += process(i, x ->  x * x + 1);\n        System.out.println(""The total is ""  + total);\n    }\n    private static int process(int i, MyFunctionalInterface  o) {\n        return o.compute(i);\n    }\n}\nIf compute  were a nonfunctional interface—having multiple abstract methods—you\nwould not be able to use it in this fashion.\nSometimes, of course, you really do need an interface to have more than one method.\nIn that case, the illusion (or the effect) of functionality can sometimes be preserved by\ndenoting all but one of the methods with the default keyword—the nondefault\nmethod will still be usable in lambdas. A default method has a method body:\npublic interface  ThisIsStillFunctional  {\n    default int compute(int ix) { return ix * ix + 1 };\n    int anotherMethod (int y);\n}\nOnly default methods may contain executable statements, and there may only be one\nnondefault method per functional interface.\nBy the way, the MyFunctionalInterface  given earlier can be totally replaced by\njava.util.function.IntUnaryOperator , changing the method name apply()  to\napplyAsInt() . There is a version of the ProcessInts  program under the name Proc\nessIntsIntUnaryOperator  in the javasrc  repository.\nDefault methods in interfaces can be used to produce mixins , as described in Recipe\n9.7.\n282 | Chapter 9: Functional Programming Techniques: Functional Interfaces, Streams, and Parallel Collections",4659
368-9.3 Simplifying Processing with Streams.pdf,368-9.3 Simplifying Processing with Streams,,0
369-Problem.pdf,369-Problem,,0
370-Solution.pdf,370-Solution,,0
371-9.4 Simplifying Streams with Collectors.pdf,371-9.4 Simplifying Streams with Collectors,"9.3 Simplifying Processing with Streams\nProblem\nY ou want to process some data through a pipeline-like mechanism.\nSolution\nUse a Stream  class and its operations.\nDiscussion\nStreams  are a new mechanism introduced with Java 8 to allow a collection to send its\nvalues out one at a time through a pipeline-like mechanism where they can be pro‐\ncessed in various ways, with varying degrees of parallelism. There are three types of\nmethods involved with Stream s:\n•Stream-producing methods (see Recipe 7.3 ).\n•Stream-passing methods, which operate on a Stream and return a reference to it,\nin order to allow for fluent  programming  (chained methods calls); examples\ninclude distinct() , filter() , limit() , map() , peek() , sorted() , and unsor\nted() .\n•Stream-terminating methods, which conclude a streaming operation; examples\ninclude collect() , count() , findFirst() , max() , min() , reduce() , and sum() .\nIn Example 9-2 , we have a list of Hero  objects representing superheroes through the\nages. We use the Stream  mechanism to filter just the adult heroes and then sum their\nages. We use it again to sort the heroes’ names alphabetically.\nIn both operations we start with a stream generator ( Arrays.stream() ); we run it\nthrough several steps, one of which involves a mapping operation (don’t confuse with\njava.util.Map !) that causes a different value to be sent along the pipeline. The\nstream is wrapped up by a terminal operation. The map and filter operations almost\ninvariably are controlled by a lambda expression (inner classes would be too tedious\nto use in this style of programming!).\nExample 9-2. main/src/main/java/functional/SimpleStreamDemo.java\n    static Hero[] heroes = {\n        new Hero(""Grelber"" , 21),\n        new Hero(""Roderick"" , 12),\n        new Hero(""Francisco"" , 35),\n        new Hero(""Superman"" , 65),\n        new Hero(""Jumbletron"" , 22),\n9.3 Simplifying Processing with Streams | 283",1952
372-Problem.pdf,372-Problem,,0
373-Solution.pdf,373-Solution,,0
374-Discussion.pdf,374-Discussion,"new Hero(""Mavericks"" , 1),\n        new Hero(""Palladin"" , 50),\n        new Hero(""Athena"" , 50) };\n    public static void main(String[] args) {\n        long adultYearsExperience  = Arrays.stream(heroes)\n                .filter(b -> b.age >= 18)\n                .mapToInt (b -> b.age).sum();\n        System.out.println(""We're in good hands! The adult superheros have ""  +\n                adultYearsExperience  + "" years of experience"" );\n        List<Object> sorted = Arrays.stream(heroes)\n                .sorted((h1, h2) -> h1.name.compareTo (h2.name))\n                .map(h -> h.name)\n                .collect(Collectors .toList());\n        System.out.println(""Heroes by name: ""  + sorted);\n    }\nAnd let’s run it to be sure it works:\nWe're in good hands! The adult superheroes have 243 years of experience\nHeroes by name: [Athena, Francisco, Grelber, Jumbletron, Mavericks, Palladin,\n                 Roderick, Superman]\nSee the javadoc for the java.util.stream.Stream  interface for a complete list of the\noperations.\n9.4 Simplifying Streams with Collectors\nProblem\nY ou construct Streams but they are complicated or inefficient.\nSolution\nUse Collector s.\nDiscussion\nExample 9-2  ended the first half with a call to collect() . The argument to col\nlect()  is of type Collector , which this recipe considers in more detail. Collector s\nare a form of what classical FP languages call folds . Folds are also called reduce, accu‐\nmulate, aggregate, compress, or inject operations. A fold in functional programming\nis a terminal operation, analogous to collapsing a whole string of tickets into a flat\npile (see Figure 9-3 ). The string of tickets represents the Stream , the folding operation\nis represented by a function, and the final result is, well, the final result, all folded up.\n284 | Chapter 9: Functional Programming Techniques: Functional Interfaces, Streams, and Parallel Collections\nIt will often include a combining operation, analogous to counting the tickets as they\nare folded.\nFigure 9-3. Stream of tickets before folding, during folding, and after  folding: a terminal\noperation\nNote that in the first panel of Figure 9-3  we don’t know how long the Stream  is, but\nwe expect that it will terminate eventually.\nCollector  as used in Java refers to a terminal function that analyses/summarizes the\ncontent of a Stream . Technically, Collector  is an interface whose implementation is\nspecified by three (or four) functions that work together to accumulate entries into a\nCollection or Map or other mutable result container, and optionally a final transform\non the result. The functions are as follows:\n•Creating a new result container (the supplier() )\n•Adding a new data element into the result container (the accumulator() )\n•Combining two result containers  into one (the combiner() )\n•Performing a final transform on the container (the finisher() , which is\noptional)\nWhile you can easily compose your own Collector  implementation, it is often expe‐\ndient to use one of the many useful ones predefined in the Collectors  class. Here are\na couple of simple examples:\n9.4 Simplifying Streams with Collectors | 285\nint howMany = cameraList .stream().collect(Collectors .counting ());\ndouble howMuch = cameraList .filter(desiredFilter ).\n collect(Collectors .summingDouble (Camera::getPrice );\nIn Example 9-3  I implement the classic word frequency count  algorithm: take a text\nfile, break it into individual words, count the occurrence of each word, and list the n\nmost-used words, sorted by frequency in descending order.\nIn Unix terms this could be implemented (assuming n = 20) as:\nprep $file | sort | uniq -c | sort -nr | head -20\nwhere prep  is a script that uses the Unix tool tr to break lines into words and turn\nthe words into lowercase.\nExample 9-3. main/src/main/java/functional/WordFreq.java\npackage functional ;\nimport java.io.* ;\nimport java.nio.file.* ;\nimport java.util.* ;\nimport java.util.stream.* ;\n/**\n * Implement word frequency count, in two statements\n */\npublic class WordFreq  {\n    public static void main(String[] args) throws IOException  {\n        // 1) Collect words with a mutable reduction into Map<String,Long>.\n        Map<String,Long> map = Files.lines(Path.of(args[0]))\n            .flatMap(s -> Stream.of(s.split("" +"")))\n            .collect(Collectors .groupingBy (\n                String::toLowerCase , Collectors .counting ()));\n        // 2) Print results sorted numerically descending, limit 20\n        map.entrySet ().stream()\n            .sorted(Map.Entry.<String,Long>comparingByValue () .reversed ())\n            .limit(20)\n            .map(entry -> String.format(""%4d %s"" , entry.getValue (), entry.getKey()))\n            .forEach(System.out::println);\n    }\n}\nThere are two steps. First, create a map of the words and their frequencies. Second,\nsort these in reverse order, stop at number 20, and format them neatly and print.\nThe first part uses Files.lines()  from Chapter 10  to get a Stream  of Strings , which\nis broken into individual words using the Stream  method flatMap()  combined with\n286 | Chapter 9: Functional Programming Techniques: Functional Interfaces, Streams, and Parallel Collections",5266
375-9.5 Improving Throughput with Parallel Streams and Collections.pdf,375-9.5 Improving Throughput with Parallel Streams and Collections,,0
376-Solution.pdf,376-Solution,"the String  method split()  to break on one or more spaces. The result of that is col‐\nlected into a map using a Collector . I had initially used a homemade collector:\n.collect(HashMap: :new, (m,s)->m.put(s, m.getOrDefault (s,0)+1), HashMap: :putAll);\nThis form of collect()  takes three arguments:\n•A Supplier<R>  or factory method to create an empty container; here I’m just\nusing the HashMap  constructor.\n•An accumulator of type BiConsumer<R,? super T>  to add each element into the\nmap, adding one each time the same word is found.\n•A Combiner of type BiConsumer<R,R> combiner)  to combine all the collections\nused.\nIn the case of parallel streams (see Recipe 9.5 ), the Supplier  may be called multiple\ntimes to create multiple containers, and each part of the Stream’s content will be han‐\ndled by one Accumulator into one of the containers. The Combiner  will merge all the\ncontainers into one at the end of processing.\nHowever, Sander Mak pointed out that it’s easier to use the existing Collectors\nclass’s predefined Collector groupingBy , combining the toLowerCase()  call and the \ncollect()  call with this:\n.collect(Collectors .groupingBy (String::toLowerCase , Collectors .counting ()));\nTo further simplify the code, you could combine the two statements into one, by\ndoing the following:\n•Removing the return value and assignment Map<String,Long> =\n•Removing the semicolon from the end of the collect  call\n•Removing the .map()  from the entrySet()  call\nThen you can say you’ve implemented something useful in a single Java statement!\n9.5 Improving Throughput with Parallel Streams and\nCollections\nProblem\nY ou want to combine Stream s with parallelism and still be able to use the non-thread-\nsafe Collections API.\n9.5 Improving Throughput with Parallel Streams and Collections | 287",1829
377-9.6 Using Existing Code as Functional with Method References.pdf,377-9.6 Using Existing Code as Functional with Method References,"Solution\nUse a parallel stream.\nDiscussion\nThe standard Collections classes, such as most List , Set, and Map implementations,\nare not thread-safe for update; if you add or remove objects from one in one thread\nwhile another thread is accessing the objects stored in the collection, failure will\nresult. Multiple threads reading from the same collection with no modification is OK.\nWe discuss multithreading in Chapter 16 .\nThe Collections Framework does provide synchronized wrappers , which provide auto‐\nmatic synchronization but at the cost of adding thread contention, which reduces\nparallelism. To enable efficient operations, parallel streams  let you use the non-\nthread-safe collections safely, as long as you do not modify the collection while you\nare operating on it.\nTo use a parallel stream, you just ask the collection for it, using parallelStream()\ninstead of the stream()  method we used in Recipe 9.3 .\nFor example, suppose that our camera business takes off, and we need to find cam‐\neras by type and price range quickly  (and with less code than we used before):\n    public static void main(String[] args) {\n        System.out.println(""Search Results using For Loop"" );\n        for (Object camera : privateListOfCameras .parallelStream (). \n                filter(c -> c.isIlc() && c.getPrice () < 500).       \n                toArray()) {                                        \n            System.out.println(camera);                             \n        }\n        System.out.println(\n            ""Search Results from shorter, more functional approach"" );\n        privateListOfCameras .parallelStream ().                      \n                filter(c -> c.isIlc() && c.getPrice () < 500).\n                forEach(System.out::println);\n    }\nCreate a parallel stream from the List  of Camera  objects. The end result of the\nstream will be iterated over by the foreach loop.\nFilter the cameras on price, using the same Predicate  lambda that we used in\nRecipe 9.1 .\nTerminate the Stream  by converting it to an array.\nThe body of the foreach loop: print one Camera  from the Stream .\n288 | Chapter 9: Functional Programming Techniques: Functional Interfaces, Streams, and Parallel Collections",2248
378-Problem.pdf,378-Problem,,0
379-Solution.pdf,379-Solution,,0
380-Discussion.pdf,380-Discussion,"A more concise way of writing the search.\nThis is reliable as long as no thread is modifying the data at the\nsame time as the searching is going on. See the thread interlocking\nmechanisms in Chapter 16  to see how to ensure this.\n9.6 Using Existing Code as Functional with Method\nReferences\nProblem\nY ou have existing code that matches a functional interface and want to use it without\nrenaming methods to match the interface name.\nSolution\nUse function references such as MyClass::myFunc  or someObj::someFunc .\nDiscussion\nThe word reference  is almost as overloaded in Java as the word Session . Consider the\nfollowing:\n•Ordinary objects are usually accessed with references.\n•Reference types such as WeakReference  have defined semantics for garbage col‐\nlection.\n•And now, for something completely different, Java 8 lets you reference an indi‐\nvidual method.\n•Y ou can even reference what Oracle documentation calls “an Instance Method of\nan Arbitrary Object of a Particular Type. ”\nThe new syntax consists of an object or class name, two colons, and the name of a\nmethod that can be invoked in the context of the object or class name (as per the\nusual rules of Java, a class name can refer to static methods and an instance can refer\nto an instance method). To refer to a constructor as the method, you can use new—for\nexample, MyClass::new . The reference creates a lambda that can be invoked, stored\nin a variable of a functional interface type, and so on.\nIn Example 9-4 , we create a Runnable  reference that holds, not the usual run method,\nbut a method with the same type and arguments but with the name walk . Note the\nuse of this  as the object part of the method reference. We then pass this Runnable\n9.6 Using Existing Code as Functional with Method References | 289\ninto a Thread  constructor and start the thread, with the result that walk  is invoked\nwhere run would normally be.\nExample 9-4. main/src/main/java/functional/ReferencesDemo.java\n/** ""Walk, don't run"" */\npublic class ReferencesDemo  {\n    // Assume this is an existing method we don't want to rename\n    public void walk() {\n        System.out.println(""ReferencesDemo.walk(): Stand-in run method called"" );\n    }\n    // This is our main processing method; it runs ""walk"" in a Thread\n    public void doIt() {\n        Runnable  r = this::walk;\n        new Thread(r).start();\n    }\n    // The usual simple main method to start things off\n    public static void main(String[] args) {\n        new ReferencesDemo ().doIt();\n    }\n}\nThe output is as follows:\nReferencesDemo.walk(): Stand-in run method called\nExample 9-5  creates an AutoCloseable  for use in a try-with-resource. The normal\nAutoCloseable  method is close() , but ours is named cloz() . The AutoCloseable\nreference variable autoCloseable  is created inside the try statement, so its close-like\nmethod will be called when the body completes. In this example, we are in a static\nmain  method wherein we have a reference rnd2  to an instance of the class, so we use\nthis in referring to the AutoCloseable -compatible method.\nExample 9-5. main/src/main/java/functional/ReferencesDemo2.java\npublic class ReferencesDemo2  {\n    void cloz() {\n        System.out.println(""Stand-in close() method called"" );\n    }\n    public static void main(String[] args) throws Exception  {\n        ReferencesDemo2  rd2 = new ReferencesDemo2 ();\n        // Use a method reference to assign the AutoCloseable interface\n        // variable ""ac"" to the matching method signature ""c"" (obviously\n        // short for close, but just to show the method name isn't what matters).\n        try (AutoCloseable  autoCloseable  = rd2::cloz) {\n290 | Chapter 9: Functional Programming Techniques: Functional Interfaces, Streams, and Parallel Collections\n            System.out.println(""Some action happening here."" );\n        }\n    }\n}\nThe output is as follows:\nSome action happening here.\nStand-in close() method called\nIt is, of course, possible to use this with your own functional interfaces, defined as in\n“Roll Y our Own Functional Interface” on page 281. Y ou’re also probably at least\nvaguely aware that any normal Java object reference can be passed to Sys\ntem.out.println()  and you’ll get some description of the referenced object.\nExample 9-6  explores these two themes. We define a functional interface imagina‐\ntively known as FunInterface  with a method with a bunch of arguments (merely to\navoid it being mistaken for any existing functional interface). The method name is\nprocess , but as you now know the name is not important; our implementation\nmethod goes by the name work . The work  method is static, so we could not state that\nthe class implements FunInterface  (even if the method names were the same; a\nstatic method may not hide an inherited instance method), but we can nonetheless\ncreate a lambda reference to the work  method. We then print this out to show that it\nhas a valid structure as a Java object.\nExample 9-6. main/src/main/java/functional/ReferencesDemo3.java\npublic class ReferencesDemo3  {\n    interface  FunInterface  {\n        void process(int i, String j, char c, double d);\n    }\n    public static void work(int i, String j, char c, double d){\n        System.out.println(""Moo"");\n    }\n    public static void main(String[] args) {\n        FunInterface  sample = ReferencesDemo3: :work;\n        System.out.println(""My process method is ""  + sample);\n    }\n}\nThis generates the following output:\nMy process method is functional.ReferencesDemo3$$Lambda$1/713338599@4a574795\nThe Lambda$1  in the name is structurally similar to the “$1” used in anonymous inner\nclasses.\n9.6 Using Existing Code as Functional with Method References | 291\nThe fourth way, “an Instance Method of an Arbitrary Object of a Particular Type, ”\nmay be the most esoteric thing in all of Java 8. It allows you to declare a reference to\nan instance method but without specifying which instance. Because there is no par‐\nticular instance in mind, you again use the class name. This means you can use it with\nany instance of the given class! In Example 9-7 , we have an array of String s to sort.\nBecause the names in this array can begin with a lowercase letter, we want to sort\nthem using the String  method compareToIgnoreCase() , which nicely ignores case\ndifferences for us.\nBecause I want to show the sorting several different ways, I set up two array referen‐\ncess, the original, unsorted one, and a working one that is re-created, sorted, and\nprinted using a simple dump routine, which isn’t shown (it’s just a for loop printing\nthe strings from the passed array).\nExample 9-7. main/src/main/java/functional/ReferencesDemo4.java\nimport java.util.Arrays ;\nimport java.util.Comparator ;\npublic class ReferencesDemo4  {\n    static final String[] unsortedNames  = {\n        ""Gosling"" , ""de Raadt"" , ""Torvalds"" , ""Ritchie"" , ""Hopper""\n    };\n    public static void main(String[] args) {\n        String[] names;\n        // Sort using\n        // ""an Instance Method of an Arbitrary Object of a Particular Type""\n        names = unsortedNames .clone();\n        Arrays.sort(names, String::compareToIgnoreCase );                    \n        dump(names);\n        // Equivalent Lambda:\n        names = unsortedNames .clone();\n        Arrays.sort(names, (str1, str2) -> str1.compareToIgnoreCase (str2)); \n        dump(names);\n        // Equivalent old way:\n        names = unsortedNames .clone();\n        Arrays.sort(names, new Comparator <String>() {                       \n            @Override\n            public int compare(String str1, String str2) {\n                return str1.compareToIgnoreCase (str2);\n            }\n        });\n        dump(names);\n292 | Chapter 9: Functional Programming Techniques: Functional Interfaces, Streams, and Parallel Collections",7922
381-9.7 Java Mixins Mixing in Methods.pdf,381-9.7 Java Mixins Mixing in Methods,,0
382-Problem.pdf,382-Problem,,0
383-Solution.pdf,383-Solution,,0
384-Discussion.pdf,384-Discussion,"// Simpest way, using existing comparator\n        names = unsortedNames .clone();\n        Arrays.sort(names, String.CASE_INSENSITIVE_ORDER );                  \n        dump(names);\n    }\nUsing “an Instance Method of an Arbitrary Object of a Particular Type, ” declares\na reference to the compareToIgnoreCase  method of any String  used in the\ninvocation.\nShows the equivalent lambda expression.\nShows “Y our grandparents’ Java” way of doing things.\nUsing the exported Comparator  directly, just to show that there is always more\nthan one way to do things.\nJust to be safe, I ran the demo, and got the expected output:\nAmdahl, de Raadt, Gosling, Hopper, Ritchie, Turing\nAmdahl, de Raadt, Gosling, Hopper, Ritchie, Turing\nAmdahl, de Raadt, Gosling, Hopper, Ritchie, Turing\nAmdahl, de Raadt, Gosling, Hopper, Ritchie, Turing\n9.7 Java Mixins: Mixing in Methods\nProblem\nY ou’ve heard about mixins and want to apply them in Java.\nSolution\nUse static imports. Or, declare one or more functional interfaces with a default\nmethod containing the code to execute, and simply implement it.\nDiscussion\nDevelopers from other languages sometimes deride Java for its inability to handle\nmixins, the ability to mix in bits of code from other classes.\nOne way to implement mixins is with the static import  feature, which has been in the\nlanguage for a decade. This is often done in unit testing (see Recipe 1.10 ). A limita‐\ntion of this approach is that, as the name implies, the methods must be static meth‐\nods, not instance methods.\nA newer mechanism depends on an interesting bit of fallout from the Java 8 language\nchanges in support of lambdas: you can now mix in code from unrelated places into\n9.7 Java Mixins: Mixing in Methods | 293\none class. Has Java finally abandoned its staunch opposition to multiple inheritance?\nIt may seem that way when you first hear it, but relax: you can only pull methods\nfrom multiple interfaces, not from multiple classes. If you didn’t know that you could\nhave methods defined (rather than merely declared) in interfaces, see “Subclass,\nAbstract Class, or Interface?” on page 250 . Consider the following example:\nmain/src/main/java/lang/MixinsDemo.java\ninterface  Bar {\n    default String filter(String s) {\n        return ""Filtered ""  + s;\n    }\n}\ninterface  Foo {\n    default String convolve (String s) {\n        return ""Convolved ""  + s;\n    }\n}\npublic class MixinsDemo  implements  Foo, Bar{\n    public static void main(String[] args) {\n        String input = args.length > 0 ? args[0] : ""Hello"";\n        String output = new MixinsDemo ().process(input);\n        System.out.println(output);\n    }\n    private String process(String s) {\n        return filter(convolve (s)); // methods mixed in!\n    }\n}\nIf we run this, we see the expected results:\nC:\javasrc>javac -d build lang/MixinsDemo.java\nC:\javasrc>java -cp build lang.MixinsDemo\nFiltered Convolved Hello\nC:\javasrc>\nPresto—Java now supports mixins!\nDoes this mean you should go crazy trying to build interfaces with code in them? No.\nRemember this mechanism was designed to do the following:\n•Provide the notion of functional interfaces for use in lambda calculations.\n•Give the ability to retrofit interfaces with new methods, without having to change\nold implementations. As with many changes made in Java over the years, back‐\nward compatibility was a huge driver.\n294 | Chapter 9: Functional Programming Techniques: Functional Interfaces, Streams, and Parallel Collections\nUsed sparingly, functional interfaces can provide the ability to mix in code to build\nup applications in another way than direct inheritance, aggregation, or AOP . Over‐\nused, it can make your code heavy, drive pre–Java 8 developers crazy, and lead to\nchaos.\n9.7 Java Mixins: Mixing in Methods | 295",3840
385-Chapter 10. Input and Output Reading Writing and Directory Tricks.pdf,385-Chapter 10. Input and Output Reading Writing and Directory Tricks,,0
386-10.0 Introduction.pdf,386-10.0 Introduction,"CHAPTER 10\nInput and Output: Reading, Writing,\nand Directory Tricks\n10.0 Introduction\nMost programs need to interact with the outside world, and one common way of\ndoing so is by reading and writing files. Files are normally on some persistent\nmedium such as a disk drive; and, for the most part, we shall happily ignore the dif‐\nferences between files on a hard disk (and all the operating system–dependent filesys‐\ntem types), a USB drive or SD card, a DVD-ROM, and other memory devices. For\nnow, they’re just files. And, like most other languages and OSes, Java extends the\nreading-and-writing model to network (socket) communications, which we’ll touch\non in Chapters 12 and 13.\nJava provides many classes for input and output; they are summarized in Figure 10-1 .\nThis chapter covers all the normal input/output operations such as opening/closing\nand reading/writing files. Files are assumed to reside on some kind of file store or\npermanent storage. Distributed filesystems such as Apache Hadoop HDFS, Sun’s Net‐\nwork File System (NFS, common on Unix and available for Windows), SMB (the\nWindows network filesystem, available for Unix via the open source Samba pro‐\ngram), and FUSE (Filesystem in User SpacE, implementations for most Unix/Linux\nsystems) are assumed to work just like disk filesystems, except where noted.\nThe support for reading and writing is in two major parts:\n•The InputStream /OutputStream /Reader /Writer  classes, which are the tradi‐\ntional ways of reading/writing files, have been largely unchanged since the days\nof Java 1.0 and 1.1. In modern Java, a new class, java.nio.file.Files , is\nprovided.\n297\n•All modern operating systems provide the means to organize groups of files into\ndirectories, or folders. This chapter covers directories: how to create them, how\nto navigate them. Files  provides most of the support for processing directories,\nbut it also introduces a number of convenience routines for easily reading, writ‐\ning, and copying files that are covered in this chapter. These are generally more\nconvenient than using the traditional I/O classes. We cover both in this chapter.\nThere are two different uses of the term stream . The first is for a\nstream of bytes to be read or written, and is unrelated to the second\nuse, which is used in modern Java to refer to a connection among\ncooperating methods. I’ll try to keep these meanings straight by\nonly using InputStream  and/or OutputStream  for the former, and\nStream  for the latter.\nTo give you control over the format of data that you read and write, the Formatter\nand Scanner  classes provide formatting and scanning operations. Formatter  allows\nmany formatting tasks to be performed either into a String  or to almost any output\ndestination. Scanner  parses many kinds of objects, again either from a String  or\nfrom almost any input source. These are fairly powerful; each is given its own recipe\nin this chapter.\nThe second part of the chapter is largely devoted to the Files  and Path  classes in\njava.nio.file . These two classes provide the ability to list directories, obtain file sta‐\ntus, rename and delete files on disk, create directories, and perform other filesystem\noperations. They also provide the ability to read a file line by line into a\nStream<String> . These two classes together largely supplant the older java.io.File\nclass. They were introduced in Java 7, so very little new code should be using the\nolder File  class.\nNote that many of the methods of this class attempt to modify the permanent file\nstore, or disk filesystem, of the computer you run them on. Naturally, you might not\nhave permission to change certain files in certain ways. This can be detected by the\nJava Virtual Machine’s SecurityManager , which will throw the unchecked exception\nSecurityException  if you don’t have permission to do the attempted operation. But\nfailure can also be detected by the underlying operating system: if the security man‐\nager approves it, but the user running your program lacks permissions on the direc‐\ntory, for example, you will either get back an indication (such as false) or an instance\nof the checked exception IOException . This must be caught (or declared in the\nthrows  clause) in any code that calls any method that tries to change the filesystem.\n298 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",4422
387-10.1 About InputStreamsOutputStreams and ReadersWriters.pdf,387-10.1 About InputStreamsOutputStreams and ReadersWriters,"10.1 About InputStreams/OutputStreams and\nReaders/Writers\nJava provides two sets of classes for reading and writing. The InputStream /Output\nStream  section of package java.io  (see Figure 10-1 ) is for reading or writing bytes of\ndata. Older languages tended to assume that a byte (which is a machine-specific col‐\nlection of bits, usually eight bits on modern computers) is exactly the same thing as a\ncharacter—a letter, digit, or other linguistic element. However, Java is designed to be\nused internationally, and eight bits is simply not enough to handle the many different\ncharacter sets used around the world. Script-based languages, and pictographic lan‐\nguages like Chinese and Japanese, each have many more than 256 characters, the\nmaximum that can be represented in an eight-bit byte. The unification of these many\ncharacter code sets is called, not surprisingly, Unicode. Both Java and XML use Uni‐\ncode as their character sets, allowing you to read and write text in any of these human\nlanguages. But you should use Reader s and Writer s, not Stream s, for textual data.\nUnicode itself doesn’t solve the entire problem. Many of these human languages were\nused on computers long before Unicode was invented, and they didn’t all pick the\nsame representation as Unicode. And they all have zillions of files encoded in a par‐\nticular representation that isn’t Unicode. So routines are needed when reading and\nwriting to convert between Unicode String  objects used inside the Java machine and\nthe particular external representation in which a user’s files are written. These con‐\nverters are packaged inside a powerful set of classes called Reader s and Writer s.\nReader s and Writer s should always be used instead of InputStream s and Output\nStream s when you want to deal with characters instead of bytes. We’ll see more on\nthis conversion, and how to specify which conversion, a little later in this chapter.\n10.1 About InputStreams/OutputStreams and Readers/Writers | 299\nFigure 10-1. java.io classes\n300 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",2115
388-See Also.pdf,388-See Also,,0
389-10.2 Reading a Text File.pdf,389-10.2 Reading a Text File,,0
390-Problem.pdf,390-Problem,,0
391-Discussion.pdf,391-Discussion,"6A poor choice of name: it was new in Java SE 1.4. But newer than InputStream /OutputStream  (Java 1.0) and\nReader s/Writer s (1.1).See Also\nOne topic not addressed in depth here is the reading/writing capabilities of Channel s\nclasses in the Java “new I/O” package.6 This part of NIO is more complex to use than\neither Files  or the input/output streams, and the benefits accrue primarily in large-\nscale server-side processing. Recipe 4.5  provides one example of using NIO. The NIO\npackage is given full coverage in the book Java NIO  by Ron Hitchens (O’Reilly).\nAnother topic not covered here is that of having the read or write occur concurrently\nwith other program activity. This requires the use of threads, or multiple flows of\ncontrol within a single program. Threaded I/O is a necessity in many programs: those\nreading from slow devices such as tape drives, those reading from or writing to net‐\nwork connections, and those with a GUI. For this reason, the topic is given consider‐\nable attention, in the context of multithreaded applications, in Chapter 16 .\nFor traditional I/O topics, Elliotte Rusty Harold’s Java I/O , although somewhat dated,\nshould be considered the antepenultimate documentation. The penultimate reference\nis the javadoc documentation, while the ultimate reference is, if you really need it, the\nsource code for the Java API. Due in part to the quality of the javadoc documentation,\nI have not needed to refer to the source code in writing this chapter. \n10.2 Reading a Text File\nProblem\nThe Java documentation doesn’t have methods for opening files. How do I open and\nread a text file and then either process it a line at a time, or get a collection of all the\nlines?\nSolution\nUse the Files::lines()  method, which returns a Stream  of String s. Or, use\nFiles.newBufferedReader() , Files.newBufferedWriter() , Files.newInput\nStream() , and Files.newOutputStream() . Or, construct a FileReader  or a FileIn\nputStream . Once you have that, construct a BufferedReader , and use the older $\n$while ((line == readLine()) != null)$$  pattern.\n10.2 Reading a Text File | 301\n6Not strictly true; there is, but only in the java.nio.FileChannel  class, which we’re not covering.Discussion\nThere is no explicit open operation,6 perhaps as a kind of rhetorical flourish of the\nJava API’s object-oriented design.\nThe quickest way to process a text file a line at a time is to use Files.lines() , which\ntakes a Path  argument and returns a functional Stream<String>  into which it feeds\nthe lines from the file:\nFiles.lines(Path.of(""myFile.txt"" )).forEach(System.out::println);\nThe Files  class has several other static methods which open a file and read some or\nall of it:\nList<String> Files.readAllLines(Path)\nReads the whole file into a List<String> .\nbyte[] Files.readAllBytes\nReads the whole file into an array of bytes.\nThere is a series of methods with names like newReader() , newBufferedWriter() ,\netc., each of which takes a Path  argument and return the appropriate Reader/Writer\nor InputStream/OutputStream . A Path  is a descriptor for an abstract path (filename)\nthat may or may not exist. The explicit constructors for a FileReader , FileWriter ,\nFileInputStream , or FileOutputStream  take a filename or an instance of the older\nFile  class containing the path. These operations correspond to the “open” operation\nin most other languages’ I/O packages.\nHistorically, Java used to require use of the code pattern while ((line == read\nLine()) != null  to read lines from a BufferedReader . This still works, of course,\nand will continue to work until the last JavaBean sets in the west, in the far future.\nExample 10-1  shows the code for each of these ways of reading lines from a file.\nExample 10-1. main/src/main/java/io/ReadLines.java (reading lines from a file)\n        System.out.println(""Using Path.lines()"" );\n        Files.lines(Path.of(fileName )).forEach(System.out::println);\n        System.out.println(""Using Path.readAllLines()"" );\n        List<String> lines = Files.readAllLines (Path.of(fileName ));\n        lines.forEach(System.out::println);\n        System.out.println(""Using BufferedReader.lines().forEach()"" );\n        new BufferedReader (new FileReader (fileName )).lines().forEach(s -> {\n302 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\n            System.out.println(s);\n        });\n        System.out.println(""The old-fashioned way"" );\n        BufferedReader  is = new BufferedReader (new FileReader (fileName ));\n        String line;\n        while ((line = is.readLine ()) != null) {\n            System.out.println(line);\n        }\nMost of these methods can throw the checked exception IOException , so you must\nhave a throws  clause or a try/catch  around these invocations.\nIf you create an InputStream , OutputStream , Reader , or Writer , you should close it\nwhen finished. This avoids memory leaks and, in the case of writing, ensures that all\nbuffered data is actually written to disk. One way to ensure this is not forgotten is to\nuse the try-with-resources syntax. This puts the declaration and definition of a Close\nable  resource into the try statement:\n    static void oldWayShorter() throws IOException {\n        try (BufferedReader is =\n            new BufferedReader(new FileReader(INPUT_FILE_NAME));\n            BufferedOutputStream bytesOut = new BufferedOutputStream(\n              new FileOutputStream(OUTPUT_FILE_NAME.replace(""\\."", ""-1."")));) {\n            // Read from is, write to bytesOut\n            String line;\n            while ((line = is.readLine()) != null) {\n                line = doSomeProcessingOn(line);\n                bytesOut.write(line.getBytes(""UTF-8""));\n                bytesOut.write('\n');\n            }\n        }\n    }\nThe lines()  and read-related methods in Files  obviate the need for closing the\nresource, but not the need for handling IOException ; the compiler or IDE will\nremind you if you forget those.\nThere are options that can be passed to the Files  methods that open a file; these are\ndiscussed in the sidebar “Understanding I/O Options: StandardOpenOptions, FileAt‐\ntribute, PosixFileAttribute, and More” on page 321 .\nTo read the entire contents of a file into single string, in Java 8+, use Files.read\nString() :\nString input = Files.readString(Path.of(INPUT_FILE_NAME)));\n10.2 Reading a Text File | 303",6450
392-See Also.pdf,392-See Also,,0
393-10.3 Reading from the Standard Input or from the ConsoleControlling Terminal.pdf,393-10.3 Reading from the Standard Input or from the ConsoleControlling Terminal,,0
394-Problem.pdf,394-Problem,,0
395-Solution.pdf,395-Solution,,0
396-Discussion.pdf,396-Discussion,"In older Java versions, use my FileIO.readerToString()  method. This will read the\nentire named file into one long string, with embedded newline ( \n) characters\nbetween each line. To read a binary file, use Files.readAllBytes()  instead.\nSee Also\nThere is formal documentation online for File s and Path .\n10.3 Reading from the Standard Input or from the\nConsole/Controlling Terminal\nProblem\nY ou want to read from the program’s standard input or directly from the program’s\ncontrolling terminal or console terminal.\nSolution\nFor the standard input, read bytes by wrapping a BufferedInputStream()  around\nSystem.in . For reading text, use an InputStreamReader  and a BufferedReader . For\nthe console or controlling terminal, use Java’s System.console()  method to obtain a\nConsole  object, and use its methods.\nDiscussion\nSometimes you really do need to read from the standard input, or console. One rea‐\nson is that simple test programs are often console-driven. Another is that some pro‐\ngrams naturally require a lot of interaction with the user and you want something\nfaster than a GUI (consider an interactive mathematics or statistical exploration pro‐\ngram). Y et another is piping the output of one program directly to the input of\nanother, a very common operation among Unix users and quite valuable on other\nplatforms, such as Windows, that support this operation.\nStandard input\nMost desktop platforms support the notion of standard input  (a keyboard, a file, or\nthe output from another program) and standard output  (a terminal window, a printer,\na file on disk, or the input to yet another program). Most such systems also support a\nstandard error output so that error messages can be seen by the user even if the stan‐\ndard output is being redirected. When programs on these platforms start up, the\nthree streams are preassigned to particular platform-dependent handles, or file\ndescriptors . The net result is that ordinary programs on these operating systems can\n304 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\nread the standard input or write to the standard output or standard error stream\nwithout having to open any files or make any other special arrangements.\nJava continues this tradition and enshrines it in the System  class. The static variables\nSystem.in , System.out , and System.err  are connected to the three operating system\nstreams before your program begins execution (an application is free to reassign\nthese; see Recipe 10.10 ). So, to read the standard input, you need only refer to the\nvariable System.in  and call its methods. For example, to read one byte from the stan‐\ndard input, you call the read method of System.in , which returns the byte in an int\nvariable:\nint b = System.in.read( );\nBut is that enough? No, because the read()  method can throw an IOException . So\nyou must either declare that your program throws an IOException :\npublic static void main(String args[]) throws IOException  {\n...\n}\nOr you can put a try/catch  block around the read()  method:\n        int b = 0;\n        try {\n            b = System.in.read();\n            System.out.println(""Read this data: ""  + (char)b);\n        } catch (Exception  e) {\n            System.out.println(""Caught ""  + e);\n        }\nIn this case, it makes sense to print the results inside the try block because there’s no\npoint in trying to print the value you read, if the read()  threw an IOException .\nThat code works and gives you the ability to read a byte at a time from the standard\ninput. But most applications are designed in terms of larger units, such as integers, or\na line of text. To read a value of a known type, such as int, from the standard input,\nyou can use the Scanner  class (covered in more detail in Recipe 10.6 ):\nScanner sc = Scanner.create(System.in);\nint i = sc.nextInt();\nFor reading characters of text with an input character converter so that your program\nwill work with multiple input encodings around the world, use a Reader  class. The\nparticular subclass that allows you to read lines of characters is a BufferedReader .\nBut there’s a hitch. Remember I mentioned those two categories of input classes,\nStream s and Reader s? But I also said that System.in  is a Stream , and you want a\nReader . How do you get from a Stream  to a Reader ? A crossover class called Input\nStreamReader  is tailor-made for this purpose. Just pass your Stream  (like System.in )\nto the InputStreamReader  constructor and you get back a Reader , which you in turn\n10.3 Reading from the Standard Input or from the Console/Controlling Terminal | 305\npass to the BufferedReader  constructor. The usual idiom for writing this in Java is to\nnest the constructor calls:\nBufferedReader  is = new BufferedReader (new InputStreamReader (System.in));\nY ou can then read lines of text using the readLine()  method. This method takes no\nargument and returns a String  that is made up for you by readLine()  containing the\ncharacters (converted to Unicode) from the next line of text in the file. When there\nare no more lines of text, the literal value null  is returned:\npublic class CatStdin  {\n    public static void main(String[] av) {\n        try (BufferedReader  is =\n                new BufferedReader (new InputStreamReader (System.in))) {\n            String inputLine ;\n            while ((inputLine  = is.readLine ()) != null) {\n                System.out.println(inputLine );\n            }\n        } catch (IOException  e) {\n            System.out.println(""IOException: ""  + e);\n        }\n    }\n}\nTo read a single Integer  from the standard input, read a line and parse it using Inte\nger.parseInt() . To read a series of integers, one per line, you could combine these\nwith a functional style, since the BufferedReader  has a lines()  method that pro‐\nduces a Stream<String> :\npublic class ReadStdinIntsFunctional  {\n    private static Stream<Integer> parseIntSafe (String s) {\n        try {\n            return Stream.of(Integer.parseInt (s));\n        } catch (NumberFormatException  e) {\n            return Stream.empty();\n        }\n    }\n    public static void main(String[] args) throws IOException  {\n        try (BufferedReader  is =\n                new BufferedReader (new InputStreamReader (System.in));) {\n            is.lines()\n                .flatMap(ReadStdinIntsFunctional: :parseIntSafe )\n                .forEach(System.out::println);\n        }\n    }\n}\n306 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",6591
397-10.4 Printing with Formatter and printf.pdf,397-10.4 Printing with Formatter and printf,"The Console (Controlling Terminal)\nThe Console  class is intended for reading directly from a program’s controlling termi‐\nnal. When you run an application from a terminal window  or command prompt win‐\ndow on most systems, its console and its standard input are both connected to the\nterminal, by default. However, the standard input can be changed by piping or redi‐\nrection on most OSes. If you really want to read from wherever the user is sitting,\nbypassing any indirections, then the Console  class is usually your friend.\nY ou cannot instantiate Console  yourself; you must get an instance from the System\nclass’s console()  method. Y ou can then call methods such as readLine() , which\nbehaves largely like the method of the same name in the BufferedReader  class used\nin the previous recipe.\nThe following code shows an example of prompting for a name and reading it from\nthe console:\nmain/src/main/java/io/ConsoleRead.java\npublic class ConsoleRead  {\n    public static void main(String[] args) {\n        String name = System.console().readLine (""What is your name?"" );\n        System.out.println(""Hello, ""  + name.toUpperCase ());\n    }\n}\nOne complication is that the System.console()  method can return null  if the con‐\nsole isn’t connected. Annoyingly, some IDEs, including Eclipse, don’t manage to set\nup a controlling terminal when you use the Run As→Java Application mechanism. So\nproduction-quality code should always check for null  before trying to use the Con\nsole . If it fails, use a logger or just plain System.out .\nOne facility the Console  class is quite useful for is reading a password without having\nit echo. This has been a standard facility of command-line applications for decades, as\nthe most obvious way of preventing shoulder surfing —somebody looking over your\nshoulder to see your password. Nonecho password reading is now supported in Java:\nthe Console  class has a readPassword()  method that takes a prompt  argument,\nintended to be used like: cons.readPassword(""Password:"") . This method returns an\narray of bytes, which can be used directly in some encryption and security APIs, or\ncan easily be converted into a String . It is generally advised to overwrite the byte\narray after use to prevent security leaks when other code can access the stack,\nalthough the benefits of this are probably reduced when you’ve constructed a String .\nThere’s an example of this in the online code in io/ReadPassword.java .\n10.3 Reading from the Standard Input or from the Console/Controlling Terminal | 307",2567
398-Problem.pdf,398-Problem,,0
399-Solution.pdf,399-Solution,,0
400-Discussion.pdf,400-Discussion,"6The central character in Y ann Martel’s novel Life of Pi  would have been born in 1956, according to informa‐\ntion in Wikipedia .10.4 Printing with Formatter and printf\nProblem\nY ou want an easy way to use  java.util.Formatter  class’s capability for simple print‐\ning tasks.\nSolution\nUse Formatter  for printing values with fine-grained control over the formatting. Use\nString.format()  or PrintWriter.printf()  / PrintStream.printf() .\nDiscussion\nThe Formatter  class is patterned after C’s printf  routines. In fact, PrintStream  and\nPrintWriter  have convenience routines named printf()  that simply delegate to the\nstream or writer’s format()  method, which uses a default Formatter  instance. Unlike\nin C, however, Java is a strongly typed language, so invalid arguments will throw an\nexception rather than generating gibberish. There are also convenience routines\nstatic String.format()  and printf()  in PrintWRiter/PrintStream  for use when\nyou want to format a String  without the bother of creating the Formatter  explicitly.\nThe underlying Formatter  class in java.util  works on a String  containing format\ncodes. For each item that you want to format, you put a format code. The format code\nconsists of a percent sign, optionally an argument number followed by a dollar sign,\noptionally a field width or precision, and a format type (e.g., d for decimal integer,\nthat is, an integer with no decimal point, and f for floating point). A simple use might\nlook like the following:\nSystem.out.printf(""%1$04d - the year of %2$f%n"" , 1956, Math.PI);\nSystem.out.printf(""%04d - the year of %f%n"" , 1956, Math.PI);\nAs shown in Figure 10-2 , the “%1$04d” controls formatting of the year, and the\n“%2$f ” controls formatting of the value of PI.6\n308 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\nFigure 10-2. Format codes examined\nMany format codes are available; Table 10-1  lists some of the more common ones.\nFor a complete description, refer to the javadoc for java.util.Formatter .\nTable 10-1. Formatter format codes\nCode Meaning\nc Character (argument must be char  or integral type containing valid character value).\nd “decimal int”—integer to be printed as a decimal (radix 10) with no decimal point (argument must be integral type).\nf Floating-point value with decimal fraction (must be numeric); field  width may be followed by decimal point and\nfractional digit field  width; e.g., 7.2f.\ne Floating-point value in scientific  notation.\ng Floating-point value, as per f or e, depending on magnitude.\ns Generic format; if value is null, prints “null”; else if arg implements Formattable , format as per arg.for\nmatTo() ; else format as per arg.toString() .\nt Date codes; follow with secondary code. Common date codes are shown in Table 10-2 . Argument must be long ,\nLong , Calendar , or Date .\nn Newline; insert the platform-dependent line ending character.\n% Insert a literal % character.\nNote also that you may, but are not required to, put a parameter order  number\nbetween the % and the format code. For example, in “%2$04d” , the “2$” means to for‐\nmat the second  parameter, regardless of the order of the parameters. This is primarily\nuseful with dates (see the following example, where you need to format several differ‐\nent portions of the same Date  or Calendar , or any time you want to format the same\nobject more than once) and in internationalization, where different languages may\nrequire words to be in a different order within a sentence.\nSome examples of using a Formatter  are shown in Example 10-2 .\n10.4 Printing with Formatter and printf | 309\nExample 10-2. main/src/main/java/io/FormatterDemo.java\npublic class FormatterDemo  {\n    public static void main(String[] args) {\n        // The arguments to all these format methods consist of\n        // a format code String and 1 or more arguments.\n        // Each format code consists of the following:\n        // % - code lead-in\n        // N$ - OPTIONAL parameter number (1-based) after the format code\n        // N - field width\n        // L - format letter (d: decimal(int); f: float; s: general; many more)\n        // For the full(!) story, see javadoc for java.util.Formatter.\n        // Most general (cumbersome) way of proceding.\n        Formatter  fmtr = new Formatter ();\n        Object result = fmtr.format(""%1$04d - the year of %2$f"" , 1956, Math.PI);\n        System.out.println(result);\n        fmtr.close();\n        // Shorter way using static String.format(), default parameter numbering.\n        Object stringResult  = String.format(""%04d - the year of %f"" , 1956, Math.PI);\n        System.out.println(stringResult );\n        // A shorter way using PrintStream/PrintWriter.format, more in line with\n        // other languages. But this way you should provide the newline delimiter\n        // using %n (rather than \n as that is platform-dependent!).\n        System.out.printf(""%04d - the year of %f%n"" , 1956, Math.PI);\n        // Format doubles with more control\n        System.out.printf(""PI is approximately %4.2f%n"" , Math.PI);\n    }\n}\nRunning FormatterDemo  produces this:\nC:> javac FormatterDates.java\nC:> java io.FormatterDates \n1956 - The year of 3.141593\n1956 - The year of 3.141593\n1956 - The year of 3.141593\nPI is about 3.14\nFor formatting date and time objects, a large variety of format codes are available—\nabout 40 in all. Date and time objects are discussed in Chapter 6 . Table 10-3  shows\nthe more common date/time format codes. Each must be preceded by a t, so to for‐\nmat the first argument as a year, you would use %1$tY .\n310 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\nTable 10-2. Formatting codes for dates and times\nFormat code Meaning\nY Year (at least four digits)\nm Month as two-digit (leading zeros) number\nB Locale-specific  month name (b for abbreviated)\nd Day of month (two digits, leading zeros)\ne Day of month (one or two digits)\nA Locale-specific  day of week ( a for abbreviated)\nH or I Hour in 24-hour (H) or 12-hour (I) format (two digits, leading zeros)\nM Minute (two digits)\nS Second (two digits)\nP/p Locale-specific  AM or PM in uppercase (if P) or lowercase (if p)\nR or T 24-hour time combination: %tH:%tM (if R) or %tH:%tM:%tS (if T)\nD Date formatted as %tm/%td/%ty\nIn my opinion, embedding these codes directly in applications that you distribute\nor make available as web applications is often a bad idea, because any direct use of\nthem assumes that you know the correct order to print these fields in all locales\naround the world. Trust me, you don’t. Instead of these, I recommend the use of Date\nTimeFormatter , covered in Recipe 6.2 , to control the order of arguments. However,\nfor quick-and-dirty work, as well as for writing log or data files that must be in a\ngiven format because some other program reads them, these are OK.\nSome date examples are shown in Example 10-3 .\nExample 10-3. main/src/main/java/io/FormatterDates.java\npublic class FormatterDates  {\n    public static void main(String[] args) {\n        // Format number as dates e.g., 2020-06-28\n        System.out.printf(""%4d-%02d-%2d%n"" , 2020, 6, 28);\n        // Format fields directly from a Date object: multiple fields from ""1$""\n        // (hard-coded formatting for Date not advisable; see I/O chapter)\n        LocalDate  today = LocalDate .now();\n        // Print in a form like e.g., ""July 4, 2020""\n        System.out.printf(""Today is %1$tB %1$td, %1$tY%n"" , today);\n    }\n}\nRunning this FormatterDates  class produces the following output:\n10.4 Printing with Formatter and printf | 311",7683
401-10.5 Scanning Input with StreamTokenizer.pdf,401-10.5 Scanning Input with StreamTokenizer,,0
402-Problem.pdf,402-Problem,,0
403-Solution.pdf,403-Solution,,0
404-Discussion.pdf,404-Discussion,"C:> java io.FormatterDates\n2020-06-28\nToday is January 01, 2020\n10.5 Scanning Input with StreamTokenizer\nProblem\nY ou need to scan a file with more fine-grained resolution than the readLine()\nmethod of the BufferedReader  class and its subclasses.\nSolution\nUse a StreamTokenizer , readLine()  and a StringTokenizer , the Scanner  class (see\nRecipe 10.6 ), regular expressions ( Chapter 4 ), or one of several third-party parser\ngenerators.\nDiscussion\nThough you could, in theory, read a file one character at a time and analyze each\ncharacter, that is a pretty low-level approach. The read()  method in the Reader  class\nis defined to return int so that it can use the time-honored value -1 (defined as EOF\nin Unix <stdio.h>  for years) to indicate that you have read to the end of the file:\nmain/src/main/java/io/ReadCharsOneAtATime.java\npublic class ReadCharsOneAtATime  {\n    void doFile(Reader is) throws IOException  {\n        int c;\n        while ((c=is.read( )) != -1) {\n            System.out.print((char)c);\n        }\n    }\n}\nNotice the cast to char ; the program compiles fine without it, but it does not print\ncorrectly because c is declared as int. Variable c must be declared int to be able to\ncompare against the end-of-file value -1. For example, the integer value correspond‐\ning to capital A treated as an int prints as 65, whereas with (char)  prints the\ncharacter A.\nWe discussed the StringTokenizer  class extensively in Recipe 3.1 . The combination\nof readLine()  and StringTokenizer  provides a simple means of scanning a file. Sup‐\npose you need to read a file in which each line consists of a name like\nuser@host.domain , and you want to split the lines into users and host addresses. Y ou\ncould use this:\n312 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\npublic class ScanStringTok  {\n    public static void main(String[] av) throws IOException  {\n        if (av.length == 0)\n            System.err.printf(""Usage: %s filename [...]%n"" ,\n                ScanStringTok .class.getSimpleName ());\n        else\n            for (int i=0; i<av.length; i++)\n                process(av[i]);\n    }\n    static void process(String fileName ) {\n        String s = null;\n        try (BufferedReader  is =\n                new BufferedReader (new FileReader (fileName ));) {\n            while ((s = is.readLine ()) != null) {\n                StringTokenizer  st = new StringTokenizer (s, ""@"", true);\n                String user = (String)st.nextElement ();\n                st.nextElement ();\n                String host = (String)st.nextElement ();\n                System.out.println(""User name: ""  + user +\n                    ""; host part: ""  + host);\n                // Do something useful with the user and host parts...\n            }\n        } catch (NoSuchElementException  ix) {\n            System.err.println(""Malformed input ""  + s);\n        } catch (IOException  e) {\n            System.err.println(e);\n        }\n    }\n}\nThe StreamTokenizer  class in java.util  provides slightly more capabilities for scan‐\nning a file. It reads characters and assembles them into words, or tokens. It returns\nthese tokens to you along with a type code describing the kind of token it found. This\ntype code is one of four predefined types ( StringTokenizer.TT_WORD , TT_NUMBER ,\nTT_EOF , or TT_EOL  for the end-of-line) or the char  value of an ordinary character\n(such as 32 for the space character). Methods such as ordinaryCharacter()  allow\nyou to specify how to categorize characters, while others such as slashSlashCom\nment()  allow you to enable or disable features.\nExample 10-4  shows a StreamTokenizer  used to implement a simple immediate-\nmode stack-based calculator:\n2 2 + =\n4\n22 7 / =\n3.141592857\n10.5 Scanning Input with StreamTokenizer | 313\nI read tokens as they arrive from the StreamTokenizer . Numbers are put on the\nstack. The four operators ( +, -, \*, and /) are immediately performed on the two ele‐\nments at the top of the stack, and the result is put back on the top of the stack. The =\noperator causes the top element to be printed, but is left on the stack so that you can\nsay this:\n4 5 * = 2 / =\n20.0\n10.0\nExample 10-4. main/src/main/java/io/SimpleCalcStreamTok.java (simple calculator\nusing StreamTokenizer)\npublic class SimpleCalcStreamTok  {\n    /** The StreamTokenizer input */\n    protected   StreamTokenizer  tf;\n    /** The output file */\n    protected  PrintWriter  out = new PrintWriter (System.out, true);\n    /** The variable name (not used in this version) */\n    protected  String variable ;\n    /** The operand stack */\n    protected  Stack<Double> s = new Stack<>();\n    /* Driver - main program */\n    public static void main(String[] av) throws IOException  {\n        if (av.length == 0)\n            new SimpleCalcStreamTok (\n                new InputStreamReader (System.in)).doCalc();\n        else\n            for (int i=0; i<av.length; i++)\n                new SimpleCalcStreamTok (av[i]).doCalc();\n    }\n    /** Construct by filename */\n    public SimpleCalcStreamTok (String fileName ) throws IOException  {\n        this(new FileReader (fileName ));\n    }\n    /** Construct from an existing Reader */\n    public SimpleCalcStreamTok (Reader rdr) throws IOException  {\n        tf = new StreamTokenizer (rdr);\n        // Control the input character set:\n        tf.slashSlashComments (true);    // treat ""//"" as comments\n        tf.ordinaryChar ('-');        // used for subtraction\n        tf.ordinaryChar ('/');    // used for division\n    }\n    /** Construct from a Reader and a PrintWriter\n     */\n    public SimpleCalcStreamTok (Reader in, PrintWriter  out) throws IOException  {\n        this(in);\n314 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\n        setOutput (out);\n    }\n    /**\n     * Change the output destination.\n     */\n    public void setOutput (PrintWriter  out) {\n        this.out = out;\n    }\n    protected  void doCalc() throws IOException  {\n        int iType;\n        double tmp;\n        while ((iType = tf.nextToken ()) != StreamTokenizer .TT_EOF) {\n            switch(iType) {\n            case StreamTokenizer .TT_NUMBER : // Found a number, push value to stack\n                push(tf.nval);\n                break;\n            case StreamTokenizer .TT_WORD:\n                // Found a variable, save its name. Not used here.\n                variable  = tf.sval;\n                break;\n            case '+':\n                // + operator is commutative.\n                push(pop() + pop());\n                break;\n            case '-':\n                // - operator: order matters.\n                tmp = pop();\n                push(pop() - tmp);\n                break;\n            case '*':\n                // Multiply is commutative.\n                push(pop() * pop());\n                break;\n            case '/':\n                // Handle division carefully: order matters!\n                tmp = pop();\n                push(pop() / tmp);\n                break;\n            case '=':\n                out.println(peek());\n                break;\n            default:\n                out.println(""What's this? iType = ""  + iType);\n            }\n        }\n    }\n    void push(double val) {\n        s.push(Double.valueOf(val));\n    }\n10.5 Scanning Input with StreamTokenizer | 315",7480
405-10.6 Scanning Input with the Scanner Class.pdf,405-10.6 Scanning Input with the Scanner Class,,0
406-Problem.pdf,406-Problem,,0
407-Solution.pdf,407-Solution,,0
408-Discussion.pdf,408-Discussion,"double pop() {\n        return ((Double)s.pop()).doubleValue ();\n    }\n    double peek() {\n        return ((Double)s.peek()).doubleValue ();\n    }\n    void clearStack () {\n        s.removeAllElements ();\n    }\n}\n10.6 Scanning Input with the Scanner Class\nProblem\nY ou want to scan a simple input file consisting of various numbers and strings in a\nknown format.\nSolution\nRead with Scanner ’s next()  methods.\nDiscussion\nThe Scanner  class lets you read an input source by tokens, somewhat analogous to\nthe StreamTokenizer  described in Recipe 10.5 . The Scanner  is more flexible in some\nways (it lets you break tokens based on spaces or regular expressions) but less in oth‐\ners (you need to know the kind of token you are reading). This class bears some\nresemblance to the C-language scanf()  function, but in the Scanner  you specify the\ninput token types by calling methods like nextInt() , nextDouble() , and so on. Here\nis a simple example of scanning:\n        String sampleDate  = ""25 Dec 1988"" ;\n        try (Scanner sDate = new Scanner(sampleDate )) {\n            int dayOfMonth  = sDate.nextInt();\n            String month = sDate.next();\n            int year = sDate.nextInt();\n            System.out.printf(""%d-%s-%02d%n"" , year, month, dayOfMonth );\n        }\nThe Scanner  recognizes Java’s eight built-in types, in addition to BigInteger  and Big\nDecimal . It can also return input tokens as String s or by matching regular expres‐\nsions (see Chapter 4 ). Table 10-3  lists the “next” methods and corresponding “has”\nmethods; the “has” method returns true if the corresponding “next” method would\nsucceed. There is no nextString()  method; just use next()  to get the next token as a\nString .\n316 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\n6If this were code in a maintained project, I might factor out some of the common code among these two cal‐\nculators, as well as the one in Recipe 5.12 , and divide the code better using interfaces. However, this would\ndetract from the simplicity of self-contained examples.Table 10-3. Scanner methods\nReturned\ntype“has” method “next” method Comment\nString hasNext() next() The next complete token from this scanner\nString hasNext(Pattern) next(Pattern) The next string that matches the given regular\nexpression (regex)\nString hasNext(String) next(String) The next token that matches the regex pattern\nconstructed from the specified  string\nBigDeci\nmalhasNextBigDeci\nmal()nextBigDeci\nmal()The next token of the input as a BigDecimal\nBigIn\ntegerhasNextBigIn\nteger()nextBigIn\nteger()The next token of the input as a BigInteger\nboolean hasNextBoolean() nextBoolean() The next token of the input as a boolean\nbyte hasNextByte() nextByte() The next token of the input as a byte\ndouble hasNextDouble() nextDouble() The next token of the input as a double\nfloat hasNextFloat() nextFloat() The next token of the input as a float\nint hasNextInt() nextInt() The next token of the input as an int\nString N/A nextLine() Reads up to the end-of-line, including the line ending\nlong hasNextLong() nextLong() The next token of the input as a long\nshort hasNextShort() nextShort() The next token of the input as a short\nThe Scanner  class is constructed with an input source, which can be an InputStream ,\na String , or Readable  (Readable  is an interface that Reader  and all its subclasses\nimplement).\nOne way to use the Scanner  class is based on the Iterator pattern, using while (scan\nner.hasNext())  to control the iteration. Example 10-5  shows the simple calculator\nfrom Recipe 10.5  rewritten6 to use the Scanner  class.\nExample 10-5. main/src/main/java/io/simpleCalcScanner.java (simple calculator using\njava.util.Scanner)\npublic class SimpleCalcScanner  {\n    /** The Scanner */\n    protected  Scanner scan;\n    /** The output */\n    protected  PrintWriter  out = new PrintWriter (System.out, true);\n10.6 Scanning Input with the Scanner Class | 317\n    /** The variable name (not used in this version) */\n    protected  String variable ;\n    /** The operand stack; no operators are pushed,\n     * so it can be a stack of Double\n     */\n    protected  Stack<Double> s = new Stack<>();\n    /* Driver - main program */\n    public static void main(String[] args) throws IOException  {\n        if (args.length == 0)\n            new SimpleCalcScanner (\n                new InputStreamReader (System.in)).doCalc();\n        else\n            for (String arg : args) {\n                new SimpleCalcScanner (arg).doCalc();\n            }\n    }\n    /** Construct a SimpleCalcScanner by name */\n    public SimpleCalcScanner (String fileName ) throws IOException  {\n        this(new FileReader (fileName ));\n    }\n    /** Construct a SimpleCalcScanner from an open Reader */\n    public SimpleCalcScanner (Reader rdr) throws IOException  {\n        scan = new Scanner(rdr);\n    }\n    /** Construct a SimpleCalcScanner from a Reader and a PrintWriter */\n    public SimpleCalcScanner (Reader rdr, PrintWriter  pw) throws IOException  {\n        this(rdr);\n        setWriter (pw);\n    }\n    /** Change the output to go to a new PrintWriter */\n    public void setWriter (PrintWriter  pw) {\n        out = pw;\n    }\n    protected  void doCalc() throws IOException  {\n        double tmp;\n        while (scan.hasNext()) {\n            if (scan.hasNextDouble ()) {\n                push(scan.nextDouble ());\n            } else {\n                String token;\n                switch(token = scan.next()) {\n                case ""+"":\n                    // Found + operator, perform it immediately.\n318 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",5739
409-10.7 Scanning Input with Grammatical Structure.pdf,409-10.7 Scanning Input with Grammatical Structure,,0
410-Solution.pdf,410-Solution,"push(pop() + pop());\n                    break;\n                case ""-"":\n                    // Found - operator, perform it (order matters).\n                    tmp = pop();\n                    push(pop() - tmp);\n                    break;\n                case ""*"":\n                    // Multiply is commutative.\n                    push(pop() * pop());\n                    break;\n                case ""/"":\n                    // Handle division carefully: order matters!\n                    tmp = pop();\n                    push(pop() / tmp);\n                    break;\n                case ""="":\n                    out.println(peek());\n                    break;\n                default:\n                    out.println(""What's this? ""  + token);\n                    break;\n                }\n            }\n        }\n    }\n    void push(double val) {\n        s.push(Double.valueOf(val));\n    }\n    double pop() {\n        return ((Double)s.pop()).doubleValue ();\n    }\n    double peek() {\n        return ((Double)s.peek()).doubleValue ();\n    }\n    void clearStack () {\n        s.removeAllElements ();\n    }\n}\n10.7 Scanning Input with Grammatical Structure\nProblem\nY ou need to parse a file whose structure can be described as grammatical (in the sense\nof computer languages, not natural languages).\n10.7 Scanning Input with Grammatical Structure | 319",1398
411-Discussion.pdf,411-Discussion,"Solution\nUse one of many parser generators.\nDiscussion\nAlthough the StreamTokenizer  class (see Recipe 10.5 ) and Scanner  (see Recipe 10.6 )\nare useful, they know only a limited number of tokens and have no way of specifying\nthat the tokens must appear in a particular order. To do more advanced scanning, you\nneed some special-purpose scanning tools. Parser generators have a long history in\ncomputer science. The best-known examples are the C-language yacc  (Y et Another\nCompiler Compiler) and lex, released with Seventh Edition Unix in the 1970s and\ndiscussed in lex & yacc  by Doug Brown et al. (O’Reilly), and their open source clones \nbison  and flex. These tools let you specify the lexical structure of your input using\nsome pattern language such as regular expressions (see Chapter 4 ). For example, you\nmight say that an email address consists of a series of alphanumerics, followed by an\nat sign (@), followed by a series of alphanumerics with periods embedded, like this:\nname:  [A-Za-z0-9]+@[A-Za-z0-0.]\nor\nname: \w+#[\w.]\nThe tool then writes code that recognizes the characters you have described. These\ntools also have a grammatical specification, which says, for example, that the keyword\nEMAIL  must appear, followed by a colon, followed by a name  token, as previously\ndefined.\nThere are several good third-party parser generator tools for Java. They vary widely\nbased on complexity, power, and ease of use:\n•One of the best known and most elaborate is ANTLR .\n•JavaCC is an open source project at https://javacc.org .\n•JParsec lets you write the parser in straight Java, so it’s all built at compile time\n(most of the others require a separate parse generation step, with the build and\ndebugging issues that raises). JParsec is on GitHub . * JFlex  and CUP  work\ntogether like the original yacc and lex, as grammar parser and lexical scanner,\nrespectively.\n•Parboiled uses Parsing Expression Grammar  (PEG) to also build the parser at\ncompile time. See GitHub  for more information. * The Rats!  parser generator is\npart of the eXTensible Compiler Project  at New Y ork University.\n•There are others; a more complete list is maintained at Java Source .\nThese parser generators can be used to write grammars for a wide variety of pro‐\ngrams, from simple calculators—such as the one in Recipe 10.6 —through HTML and\n320 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\nCORBA/IDL, up to full Java and C/C++ parsers. Examples of these are included with\nthe downloads. Unfortunately, the learning curve for parsers in general precludes\nproviding a simple and comprehensive example here, let alone comparing them intel‐\nligently. Refer to the documentation and the numerous examples provided with each\ndistribution.\nAs an alternative to using one of these, you could simply roll your own recursive\ndescent parser; and once you learn how to do so, you may find it’s not really that diffi‐\ncult, quite possibly even less hassle than dealing with the extra parser generator soft‐\nware (depending on the complexity of the grammar involved, obviously).\nJava developers have a range of choices, including simple line-at-a-time scanners\nusing StringTokenizer , fancier token-based scanners using StreamTokenizer , a\nScanner  class to scan simple tokens (see Recipe 10.6 ), regular expressions (see Chap‐\nter 4 ), and third-party solutions including grammar-based scanners based on the\nparsing tools listed here.\nUnderstanding I/O Options: StandardOpenOptions, FileAttribute,\nPosixFileAttribute, and More\nThere are several sets of options that can be applied when creating or opening a file.\nThe main option sets that can be applied include those listed in Table 10-4 :\nTable 10-4. Sets of options\nName Examples Usage/notes\nCopyOption StandardCopyOp\ntion.REPLACE_EXISTINGFiles  methods that copy\nLinkOption LinkOption.NOFOL\nLOW_LINKSFiles  methods that write data or read\nattributes\nFileAttribute Name-value pair, used in Files.cre\nate*()  methods\nOpenOption StandardOpenOp\ntion.READ,APPENDFiles.new{In,Out}put\nStream()\nPosixFilePermis\nsionOWNER_READ,OTHER_WRITE FileAttribute\nPosixFilePermis\nsionsSet<PosixFilePermission> Conversions to/from rwx strings\nA list of the standard OpenOption  values is in Table 10-5 . These control how a file is to\nbe accessed.\n10.7 Scanning Input with Grammatical Structure | 321\nTable 10-5. OpenOption StandardOpenOption values\nName Meaning\nAPPEND Write at the end of an existing file instead of overwriting it.\nCREATE Create the file if it does not exist.\nCREATE_NEW Create the file only if it is new; fails with FileAlreadyExistsExcep\ntion  if file already exists.\nDELETE_ON_CLOSE Delete the file when the stream is closed. Useful for temporary files.\nDSYNC Write data synchronously, i.e., every write is to be synchronized to disk\nimmediately.\nREAD Open the file for reading.\nSPARSE Create as a sparse file,  e.g., for random-access writing.\nSYNC Write data and metadata synchronously, i.e., every write or attribute\nchange is to be synchronized to disk immediately.\nTRUNCATE_EXISTING If the file exists, open for writing at the beginning, removing all contents\nat open time.\nWRITE Open for write access.\nPOSIX is the IEEE’s Portable Operating System Specification for Unix-like operating\nsystems. Java’s PosixPermission  and its wrapper PosixPermissions  are used to con‐\ntrol who can do what to a file on disk. These are based on the Unix/POSIX permis‐\nsions laid down in early Unix systems in the early 1970s. There are three actors:\nowner (which Unix calls user), group, and other (everyone else). Groups is a Unix/\nPOSIX mechanism: a user can be in one or many groups and has permissions based\non all the groups they are in; this is an early form of privilege separation. There are\nthree permissions: read, write, and execute. The latter grants permission to execute a\nfile, but is also used to grant permission to search (list) a directory. For decades these\nhave been expressed as a nine-character permissions string. For example, rwxr—r--\nmeans the user has read, write, and execute permissions on a given file; other mem‐\nbers of the file owner’s group have read-only access, and everyone else also has read-\nonly access. The PosixPermissions  wrapper class has methods for converting\nbetween these concise strings and a Set of individual PosixPermission  enum con‐\nstants. The enum constants are the nine combinations of OWNER , GROUP , and OTHERS\nwith READ , WRITE , and EXECUTE . Here is a JShell example showing these file permission\nconversion routines:\njshell> Set<PosixFilePermission > perms =\n  PosixFilePermissions .fromString (""rwxr-xr--"" );\nperms ==> [OWNER_READ , OWNER_WRITE , OWNER_EXECUTE , GROUP_READ ,\n  GROUP_EXECUTE , OTHERS_READ ]\njshell> Set<PosixFilePermission > nPerms =\n  Set.of(PosixFilePermission .OWNER_READ , PosixFilePermission .GROUP_READ );\nnPerms ==> [GROUP_READ , OWNER_READ ]\n322 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\njshell> PosixFilePermissions .toString (nPerms)\n$7 ==> ""r--r-----""\nY ou can further convert the Set<PosixFilePermission>  into a FileAttribute  to be\nused with the Files  class createFile()  or createDirectory()  operations:\njshell> PosixFilePermissions .asFileAttribute (nPerms)\n$8 ==> java.nio.file.attribute .PosixFilePermissions $1@ed17bee\njshell> $8.name()\n$9 ==> ""posix:permissions""\njshell> $8.value()\n$10 ==> [OWNER_READ , GROUP_READ ]\njshell> Files.createFile (Path.of(""/tmp/xx"" ), $8);\n$41 ==> /tmp/xx\njshell> /exit\n$ ls -l /tmp/xx\n-r--r-----  1 ian  wheel  0 Dec 23 11:14 /tmp/xx\n$\nWe see the file was created with only owner-read and group-read permissions, as\nrequested. Note that on *nix systems there is a user setting umask  that may remove or\nmask out permissions, so what you ask for may not be exactly what you get.\nY ou can examine the attributes of a file using the FileAttribute  interface or its\nfilesystem-specific subtypes. Here we’ll use the PosixFileAttributeView  to show the\nowner and permissions of the file we created:\n        PosixFileAttributes  attrs =\n            Files.getFileAttributeView (filePath ,\n                PosixFileAttributeView .class)\n            .readAttributes ();\n        System.out.format(""File %s Owned by %s has perms %s%n"" ,\n            filePath ,\n            attrs.owner().getName(),\n            PosixFilePermissions .toString (attrs.permissions ()));\nThere are other filesystem-specific views, such as DosFilewAttributeView  for use on\nFAT filesystems. FAT was copied from CPM-86 into the earliest releases of MS-DOS,\nand expanded versions of it are still in use on USB memory cards and in consumer\ndevices.\n10.7 Scanning Input with Grammatical Structure | 323",8828
412-10.8 Copying a File.pdf,412-10.8 Copying a File,,0
413-Problem.pdf,413-Problem,,0
414-Solution.pdf,414-Solution,,0
415-10.9 Reassigning the Standard Streams.pdf,415-10.9 Reassigning the Standard Streams,"10.8 Copying a File\nProblem\nY ou need to copy a file in its entirety.\nSolution\nUse one of the Java 11 Files.copy()  methods. If on an older release, use the explicit\nread and write methods in the Readers/Writer s or InputStream/OutputStream s.\nDiscussion\nThe Files  class has several overloads of a copy  method that makes quick work of this\nrequirement:\nPath copy(Path, Path, CopyOption ...) throws java.io.IOException ;\nlong copy(InputStream , Path, CopyOption ...) throws IOException ;\nlong copy(Path, OutputStream ) throws IOException ;\nFor example:\nPath p = Paths.get(""my_new_file"");\nInputStream is = // open some file for reading\nlong newFileSize = Files.copy(is, p);\nLong ago, Java’s I/O facilities did not package a lot of the common operations like\ncopying one file to another or reading a file into a String . So back then I wrote my\nown package of helper methods. Users of older JDK versions may want to use FileIO\nfrom my utilities package com.darwinsys.util . Here’s a simple demo program that\nuses FileIO  to copy a source file to a backup file:\nmain/src/demo/java/io/FileIoDemo.java\npackage com.darwinsys .io;\nimport java.io.IOException ;\npublic class FileIoDemo  {\n    public static void main(String[] av) {\n        try {\n            FileIO.copyFile (""FileIO.java"" , ""FileIO.bak"" );\n            FileIO.copyFile (""FileIO.class"" , ""FileIO-class.bak"" );\n        } catch (IOException  e) {\n            System.err.println(e);\n        }\n    }\n}\n324 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",1563
416-Problem.pdf,416-Problem,,0
417-Solution.pdf,417-Solution,,0
418-10.10 Duplicating a Stream as It Is Written Reassigning Standard Streams.pdf,418-10.10 Duplicating a Stream as It Is Written Reassigning Standard Streams,"My copyFile  method takes several forms, depending on whether you have two file‐\nnames, a filename and a PrintWriter , and so on. The code for FileIO  itself is not\nshown here but is online, in the darwinsys API download.\n10.9 Reassigning the Standard Streams\nProblem\nY ou need to reassign one or more of the standard streams System.in , System.out , or\nSystem.err .\nSolution\nConstruct an InputStream  or PrintStream  as appropriate, and pass it to the appro‐\npriate set method in the System  class.\nDiscussion\nThe ability to reassign these streams corresponds to what Unix (or DOS command\nline) users think of as redirection , or piping . This mechanism is commonly used to\nmake a program read from or write to a file without having to explicitly open it and\ngo through every line of code changing the read, write, print, etc. calls to refer to a\ndifferent stream object. The open operation is performed by the command-line inter‐\npreter in Unix or DOS or by the calling class in Java.\nAlthough you could just assign a new PrintStream  to the variable System.out , best\npractice is to use the defined method to replace it:\n        String LOGFILENAME  = ""error.log"" ;\n        System.setErr(new PrintStream (new FileOutputStream (LOGFILENAME )));\n        System.out.println(""Please look for errors in ""  + LOGFILENAME );\n        // Now assume this is somebody else's code; you'll see it\n        //   writing to stderr...\n        int[] a = new int[5];\n        a[10] = 0;    // here comes an ArrayIndexOutOfBoundsException\nThe stream you use can be one that you’ve opened, as here, or one you inherited:\nSystem.setErr(System.out);    // merge stderr and stdout to same output file.\nIt could also be a stream connected to or from another Process  you’ve started (see\nRecipe 18.1 ), a network socket, or a URL. Anything that gives you a stream can be\nused.\n10.9 Reassigning the Standard Streams | 325",1926
419-Problem.pdf,419-Problem,,0
420-Solution.pdf,420-Solution,,0
421-Discussion.pdf,421-Discussion,"10.10 Duplicating a Stream as It Is Written; Reassigning\nStandard Streams\nProblem\nY ou want anything written to a stream, such as the standard output System.out  or\nthe standard error System.err , to appear there but also be logged in to a file.\nSolution\nSubclass PrintStream  and have its write()  methods write to two streams. Then use\nsystem.setErr()  or setOut()  to replace the existing standard stream with a Print\nStream  subclass.\nDiscussion\nSome classes are meant to be subclassed. Here we’re just subclassing PrintStream  and\nadding a bit of functionality: a second PrintStream ! I wrote a class called TeePrint\nStream , named after the ancient Unix command tee. That command allowed you to\nduplicate, or tee off (from plumber’s pipe tee, not the game of golf or the local pest) a\ncopy of the data being written on a pipeline between two programs.\nThe original Unix tee command is used like this: the | character creates a pipeline in\nwhich the standard output of one program becomes the standard input to the next.\nThis often-used example of pipes shows how many users are logged into a Unix\nserver:\nwho | wc -l\nThis runs the  who program (which lists who is logged in to the system, one name per\nline, along with the terminal port and login time) and sends its output, not to the ter‐\nminal, but rather into the standard input of the word count ( wc) program. Here, wc is\nbeing asked to count lines, not words, hence the -l option. To tee a copy of the inter‐\nmediate data into a file, you might say:\nwho | tee wholist | wc -l\nwhich creates a file  wholist  containing the data. For the curious, the file wholist  might\nlook something like this:\nian      ttyC0    Mar 14 09:59\nben      ttyC3    Mar 14 10:23\nian      ttyp4    Mar 14 13:46  (laptop.darwinsys.com)\nSo both the previous command sequences would print 3 as their output.\n326 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\nTeePrintStream  is an attempt to capture the spirit of the tee command. It can be used\nlike this:\nSystem.setErr(new TeePrintStream(System.err, ""err.log""));\n// ...lots of code that occasionally writes to System.err... Or might.\nSystem.setErr()  is a means of specifying the destination of text printed to\nSystem.err  (there are also System.setOut()  and System.setIn() ). This code results\nin any messages that printed to System.err  to print to wherever System.err  was pre‐\nviously directed (normally the terminal, but possibly a text window in an IDE) and to\nthe file err.log .\nThis technique is not limited to the three standard streams. A TeePrintStream  can be\npassed to any method that wants a PrintStream . Or, for that matter, an Output\nStream . And you can adapt the technique for BufferedInputStreams , PrintWriters ,\nBufferedReaders , and so on.\nExample 10-6  shows the source code for TeePrintStream .\nExample 10-6. main/src/main/java/io/TeePrintStream.java\npublic class TeePrintStream  extends PrintStream  {\n    /** The original/direct print stream */\n    protected  PrintStream  parent;\n    /** The filename we are tee-ing too, if known;\n     * intended for use in future error reporting.\n     */\n    protected  String fileName ;\n    /** The name for when the input filename is not known */\n    private static final String UNKNOWN_NAME  = ""(opened Stream)"" ;\n    /** Construct a TeePrintStream given an existing PrintStream,\n     * an opened OutputStream, and a boolean to control auto-flush.\n     * This is the main constructor, to which others delegate via ""this"".\n     */\n    public TeePrintStream (PrintStream  orig, OutputStream  os, boolean flush)\n    throws IOException  {\n        super(os, true);\n        fileName  = UNKNOWN_NAME ;\n        parent = orig;\n    }\n    /** Construct a TeePrintStream given an existing PrintStream and\n     * an opened OutputStream.\n     */\n    public TeePrintStream (PrintStream  orig, OutputStream  os)\n    throws IOException  {\n        this(orig, os, true);\n10.10 Duplicating a Stream as It Is Written; Reassigning Standard Streams | 327\n    }\n    /* Construct a TeePrintStream given an existing Stream and a filename.\n     */\n    public TeePrintStream (PrintStream  os, String fn) throws IOException  {\n        this(os, fn, true);\n    }\n    /* Construct a TeePrintStream given an existing Stream, a filename,\n     * and a boolean to control the flush operation.\n     */\n    public TeePrintStream (PrintStream  orig, String fn, boolean flush)\n    throws IOException  {\n        this(orig, new FileOutputStream (fn), flush);\n        fileName  = fn;\n    }\n    /** Return true if either stream has an error. */\n    public boolean checkError () {\n        return parent.checkError () || super.checkError ();\n    }\n    /** override write(). This is the actual ""tee"" operation. */\n    public void write(int x) {\n        parent.write(x);    // ""write once;\n        super.write(x);        // write somewhere else.""\n    }\n    /** override write(). This is the actual ""tee"" operation. */\n    public void write(byte[] x, int o, int l) {\n        parent.write(x, o, l);    // ""write once;\n        super.write(x, o, l);    // write somewhere else.""\n    }\n    /** Close both streams. */\n    public void close() {\n        parent.close();\n        super.close();\n    }\n    /** Flush both streams. */\n    public void flush() {\n        parent.flush();\n        super.flush();\n    }\n}\nIt’s worth mentioning that I do not need to override all the polymorphic forms of \nprint()  and println() . Because these all ultimately use one of the forms of write() ,\nif you override the print  and println  methods to do the tee-ing as well, you can get\nseveral additional copies of the data written out.\n328 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",5835
422-10.11 ReadingWriting a Different Character Set.pdf,422-10.11 ReadingWriting a Different Character Set,,0
423-Problem.pdf,423-Problem,,0
424-Solution.pdf,424-Solution,,0
425-10.12 Those Pesky End-of-Line Characters.pdf,425-10.12 Those Pesky End-of-Line Characters,"10.11 Reading/Writing a Different  Character Set\nProblem\nY ou need to read or write a text file using a particular encoding.\nSolution\nConvert the text to or from internal Unicode by specifying a converter when you con‐\nstruct an InputStreamReader  or PrintWriter .\nDiscussion\nClasses InputStreamReader  and OutputStreamWriter  are the bridge from byte-\noriented Stream s to character-based Reader s. These classes read or write bytes and\ntranslate them to or from characters according to a specified character encoding. The\nUTF-16 character set used inside Java ( char  and String  types) is a 16-bit character\nset. But most character sets—such as ASCII, Swedish, Spanish, Greek, Turkish, and\nmany others—use only a small subset of that. In fact, many European language char‐\nacter sets fit nicely into 8-bit characters. Even the larger character sets (script-based\nand pictographic languages) don’t all use the same bit values for each particular char‐\nacter. The encoding, then, is a mapping between Java characters and an external stor‐\nage format for characters drawn from a particular national or linguistic character set.\nTo simplify matters, the InputStreamReader  and OutputStreamWriter  constructors\nare the only places where you can specify the name of an encoding to be used in this\ntranslation. If you do not specify an encoding, the platform’s (or user’s) default\nencoding is used. PrintWriters , BufferedReaders , and the like all use whatever\nencoding the InputStreamReader  or OutputStreamWriter  class uses. Because these\nbridge classes only accept Stream  arguments in their constructors, the implication is\nthat if you want to specify a nondefault converter to read or write a file on disk, you\nmust start by constructing not a FileReader  or FileWriter , but a FileInputStream\nor FileOutputStream !\n// io/UseConverters.java\nBufferedReader fromKanji = new BufferedReader(\n    new InputStreamReader(new FileInputStream(""kanji.txt""), ""EUC_JP""));\nPrintWriter toSwedish = new PrinterWriter(\n    new OutputStreamWriter(new FileOutputStream(""sverige.txt""), ""Cp278""));\nNot that it would necessarily make sense to read a single file from Kanji and output it\nin a Swedish encoding. For one thing, most fonts would not have all the characters of\nboth character sets; and, at any rate, the Swedish encoding certainly has far fewer\ncharacters in it than the Kanji encoding. Besides, if that were all you wanted, you\ncould use a JDK tool with the ill-fitting name native2ascii  (see its documentation for\n10.11 Reading/Writing a Different  Character Set | 329",2601
426-Problem.pdf,426-Problem,,0
427-Solution.pdf,427-Solution,,0
428-Discussion.pdf,428-Discussion,,0
429-10.13 Beware Platform-Dependent File Code.pdf,429-10.13 Beware Platform-Dependent File Code,,0
430-Problem.pdf,430-Problem,,0
431-Discussion.pdf,431-Discussion,"details). A list of the supported encodings is also in the JDK documentation, in the\nfile docs/guide/internat/encoding.doc.html . A more detailed description is found in\nAppendix B of Java I/O .\n10.12 Those Pesky End-of-Line Characters\nProblem\nY ou really want to know about end-of-line characters.\nSolution\nUse \r and \n in whatever combination makes sense.\nDiscussion\nIf you are reading text (or bytes containing ASCII characters) in line mode using the \nreadLine()  method, you’ll never see the end-of-line characters, and if you’re using a\nPrintWriter  with its println()  method, the same applies. Thus you won’t be cursed\nwith having to figure out whether \n, \r, or \r\n  appears at the end of each line.\nIf you want that level of detail, you have to read the characters or bytes one at a time,\nusing the read()  methods. The only time I’ve found this necessary is in networking\ncode, where some of the line-mode protocols assume that the line ending is \r\n .\nEven here, though, you can still work in line mode. When writing, pass \r\n  into the \nprint()  (not +deal with the characters:\noutputSocket.print(""HELO "" + myName + ""\r\n"");\nString response = inputSocket.readLine();\nFor the curious, the strange spelling of “hello” is used in SMTP , the mail sending pro‐\ntocol, where commands are four letters.\n10.13 Beware Platform-Dependent File Code\nProblem\nChastened by the previous recipe, you now wish to write only platform-independent\ncode.\nSolution\nUse readLine()  and println() . Avoid use of \n by itself; use File.separator  if you\nmust.\n330 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",1656
432-10.14 ReadingWriting Binary Data.pdf,432-10.14 ReadingWriting Binary Data,,0
433-Solution.pdf,433-Solution,"Discussion\nAs mentioned in Recipe 10.12 , if you just use readLine()  and println() , you won’t\nhave to think about the line endings. But a particular problem, especially for former\nprogrammers of C and related languages, is using the \n character in text strings to\nmean a newline. What is particularly distressing about this code is that it works—\nsometimes—usually on the developer’s own platform. But it will probably fail some‐\nday, on some other system:\n    String myName;\n    public static void main(String[] argv) {\n        BadNewline  jack = new BadNewline (""Jack Adolphus Schmidt, III"" );\n        System.out.println(jack);\n    }\n    /**\n     * DON'T DO THIS. THIS IS BAD CODE.\n     */\n    public String toString () {\n        return ""BadNewlineDemo@""  + hashCode () + ""\n"" + myName;\n    }\n    // The obvious Constructor is not shown for brevity; it's in the code\nThe real problem is not that it fails on some platforms, though. What’s really wrong is\nthat it mixes formatting and I/O, or tries to. Don’t mix line-based display with \ntoString() ; avoid multiline strings —output from toString()  or any other string-\nreturning method. If you need to write multiple strings, then say what you mean:\n    String myName;\n    public static void main(String[] argv) {\n        GoodNewline  jack = new GoodNewline (""Jack Adolphus Schmidt, III"" );\n        jack.print(System.out);\n    }\n    protected  void print(PrintStream  out) {\n        out.println(toString ());    // classname and hashcode\n        out.println(myName);        // print name  on next line\n    }\nAlternatively, if you need multiple lines, you could return an array or List  of strings.\n10.14 Reading/Writing Binary Data\nProblem\nY ou need to read or write binary data, as opposed to text.\n10.14 Reading/Writing Binary Data | 331",1831
434-Discussion.pdf,434-Discussion,,0
435-10.15 Reading and Writing JAR or ZIP Archives.pdf,435-10.15 Reading and Writing JAR or ZIP Archives,,0
436-Problem.pdf,436-Problem,,0
437-Discussion.pdf,437-Discussion,"Solution\nUse a DataInputStream  or DataOutputStream .\nDiscussion\nThe Stream  classes have been in Java since the beginning of time and are optimal for\nreading and writing bytes rather than characters. The data layer over them, compris‐\ning DataInputStream  and DataOutputStream , is configured for reading and writing\nbinary values, including all of Java’s built-in types. Suppose that you want to write a\nbinary integer plus a binary floating-point value into a file and read it back later. This\ncode shows the writing part:\npublic class WriteBinary  {\n    public static void main(String[] argv) throws IOException  {\n        int i = 42;\n        double d = Math.PI;\n        String FILENAME  = ""binary.dat"" ;\n        DataOutputStream  os = new DataOutputStream (\n            new FileOutputStream (FILENAME ));\n        os.writeInt (i);\n        os.writeDouble (d);\n        os.close();\n        System.out.println(""Wrote ""  + i + "", "" + d + "" to file ""  + FILENAME );\n    }\n}\nShould you need to write all the fields from an object, you should probably use one of\nthe methods described in Recipe 12.6 .\n10.15 Reading and Writing JAR or ZIP Archives\nProblem\nY ou need to create and/or extract from a JAR archive or a file in the well-known ZIP\narchive format, as established by PkZip and used by Unix zip/unzip and WinZip.\nSolution\nY ou could use the jar program in the Java Development Kit because its file format is\nidentical to the ZIP format with the addition of the META-INF  directory to contain\nadditional structural information. But because this is a book about programming,\nyou are probably more interested in the ZipFile  and ZipEntry  classes and the stream\nclasses to which they provide access.\n332 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\n6There is no support for adding files to an existing archive, so make sure you put all the files in at once or be\nprepared to re-create the archive from scratch.Discussion\nThe class java.util.zip.ZipFile  is not an I/O class per se , but a utility class that\nallows you to read or write the contents of a JAR or ZIP-format file.6 When construc‐\nted, it creates a series of ZipEntry  objects, one to represent each entry in the archive.\nIn other words, the ZipFile  represents the entire archive, and the ZipEntry  repre‐\nsents one entry, or one file that has been stored (and compressed) in the archive. The\nZipEntry  has methods like getName() , which returns the name that the file had\nbefore it was put into the archive, and getInputStream() , which gives you an Input\nStream  that will transparently uncompress the archive entry by filtering it as you read\nit. To create a ZipFile  object, you need either the name of the archive file or a File\nobject representing it:\nZipFile zippy = new ZipFile(fileName);\nTo see whether a given file is present in the archive, you can call the getEntry()\nmethod with a filename. More commonly, you’ll want to process all the entries; for\nthis, use the ZipFile  object to get a list of the entries in the archive, in the form of an\nEnumeration  (see Recipe 7.6 ), as is done here:\nEnumeration all = zippy.entries( );\nwhile (all.hasMoreElements( )) {\n    ZipEntry entry = (ZipEntry)all.nextElement( );\n    ...\n}\nWe can then process each entry as we wish. A simple listing program could be this:\nif (entry.isDirectory( ))\n    println(""Directory: "" + e.getName( ));\nelse\n    println(""File: "" + e.getName( ));\nA fancier version would extract the files. The program in Example 10-7  does both: it\nlists by default, but with the -x (extract) switch, it actually extracts the files from the\narchive.\nExample 10-7. main/src/main/java/io/UnZip.java\npublic class UnZip {\n    /** Constants for mode listing or mode extracting. */\n    public static enum Mode {\n        LIST,\n        EXTRACT;\n    }\n10.15 Reading and Writing JAR or ZIP Archives | 333\n    /** Whether we are extracting or just printing TOC */\n    protected  Mode mode = Mode.LIST;\n    /** The ZipFile that is used to read an archive */\n    protected  ZipFile zippy;\n    /** The buffer for reading/writing the ZipFile data */\n    protected  byte[] b = new byte[8092];\n    /** Simple main program, construct an UnZipper, process each\n     * .ZIP file from argv[] through that object.\n     */\n    public static void main(String[] argv) {\n        UnZip u = new UnZip();\n        for (int i=0; i<argv.length; i++) {\n            if (""-x"".equals(argv[i])) {\n                u.setMode(Mode.EXTRACT);\n                continue ;\n            }\n            String candidate  = argv[i];\n            // System.err.println(""Trying path "" + candidate);\n            if (candidate .endsWith ("".zip"") ||\n                candidate .endsWith ("".jar""))\n                    u.unZip(candidate );\n            else System.err.println(""Not a zip file? ""  + candidate );\n        }\n        System.err.println(""All done!"" );\n    }\n    /** Set the Mode (list, extract). */\n    protected  void setMode(Mode m) {\n        mode = m;\n    }\n    /** Cache of paths we've mkdir()ed. */\n    protected  SortedSet <String> dirsMade ;\n    /** For a given Zip file, process each entry. */\n    public void unZip(String fileName ) {\n        dirsMade  = new TreeSet<String>();\n        try {\n            zippy = new ZipFile(fileName );\n            @SuppressWarnings (""unchecked"" )\n            Enumeration <ZipEntry > all = (Enumeration <ZipEntry >) zippy.entries();\n            while (all.hasMoreElements ()) {\n                getFile((ZipEntry )all.nextElement ());\n            }\n        } catch (IOException  err) {\n            System.err.println(""IO Error: ""  + err);\n            return;\n        }\n334 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\n    }\n    protected  boolean warnedMkDir  = false;\n    /** Process one file from the zip, given its name.\n     * Either print the name, or create the file on disk.\n     */\n    protected  void getFile(ZipEntry  e) throws IOException  {\n        String zipName = e.getName();\n        switch (mode) {\n        case EXTRACT:\n            if (zipName.startsWith (""/"")) {\n                if (!warnedMkDir )\n                    System.out.println(""Ignoring absolute paths"" );\n                warnedMkDir  = true;\n                zipName = zipName.substring (1);\n            }\n            // if a directory, just return. We mkdir for every file,\n            // since some widely used Zip creators don't put out\n            // any directory entries, or put them in the wrong place.\n            if (zipName.endsWith (""/"")) {\n                return;\n            }\n            // Else must be a file; open the file for output\n            // Get the directory part.\n            int ix = zipName.lastIndexOf ('/');\n            if (ix > 0) {\n                String dirName = zipName.substring (0, ix);\n                if (!dirsMade .contains (dirName)) {\n                    File d = new File(dirName);\n                    // If it already exists as a dir, don't do anything\n                    if (!(d.exists() && d.isDirectory ())) {\n                        // Try to create the directory, warn if it fails\n                        System.out.println(""Creating Directory: ""  + dirName);\n                        if (!d.mkdirs()) {\n                            System.err.println(\n                            ""Warning: unable to mkdir ""  + dirName);\n                        }\n                        dirsMade .add(dirName);\n                    }\n                }\n            }\n            System.err.println(""Creating ""  + zipName);\n            FileOutputStream  os = new FileOutputStream (zipName);\n            InputStream   is = zippy.getInputStream (e);\n            int n = 0;\n            while ((n = is.read(b)) >0)\n                os.write(b, 0, n);\n            is.close();\n            os.close();\n            break;\n        case LIST:\n10.15 Reading and Writing JAR or ZIP Archives | 335",8037
438-See Also.pdf,438-See Also,,0
439-10.16 Finding Files in a Filesystem-Neutral Way with getResource and getResourceAsStream.pdf,439-10.16 Finding Files in a Filesystem-Neutral Way with getResource and getResourceAsStream,,0
440-Problem.pdf,440-Problem,,0
441-Solution.pdf,441-Solution,,0
442-Discussion.pdf,442-Discussion,"// Not extracting, just list\n            if (e.isDirectory ()) {\n                System.out.println(""Directory ""  + zipName);\n            } else {\n                System.out.println(""File "" + zipName);\n            }\n            break;\n        default:\n            throw new IllegalStateException (""mode value (""  + mode + "") bad"");\n        }\n    }\n}\nSee Also\nPeople sometimes confuse the ZIP archive file format with the similarly named gzip\ncompression format. Gzip-compressed files can be read or written with the GZipIn\nputStream  and GZipOutputStream  classes from java.io .\n10.16 Finding Files in a Filesystem-Neutral Way with\ngetResource() and getResourceAsStream()\nProblem\nY ou want to load objects or files without referring to their absolute location in the\nfilesystem. Y ou might want to do this for one of the following reasons:\n•Y ou are in a server (Java EE) environment.\n•Y ou want to be independent of file paths.\n•Y ou want to read a file in a unit test.\n•Y ou expect users to deploy the resource “somewhere” on the LASSPATH  (possibly\neven inside a JAR file).\nSolution\nUse getClass()  or getClassLoader()  and either getResource()  or getResourceAs\nStream() .\nDiscussion\nThere are three varieties of getResource()  methods, some of which exist (with the\nexact same signature) both in the Class  class (see Chapter 17 ) and in the Class\n336 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\nLoader  class (see Recipe 17.5 ). The methods in Class  delegate to the ClassLoader , so\nthere is little difference between them. The methods are summarized in Table 10-6 .\nTable 10-6. The getResource* methods\nMethod signature In Class In ClassLoader\npublic InputStream getResourceAsStream(String); Y Y\npublic URL getResource(String); Y Y\npublic Enumeration<URL> getResources(String) throws IOException; N Y\nThe first method is designed to quickly and easily locate a resource, or file, on your\nCLASSPATH . Using the Class  version, or the other one with a standard ClassLoader\nimplementation, the resource can be a physical file or a file inside a JAR file. If you\ndefine your own classloader, your imagination is the limit, as long as it can be repre‐\nsented as an InputStream . This is commonly used as shown here:\nInputStream  is = getClass ().getResourceAsStream (""foo.properties"" );\n// then do something with the InputStream...\nThe second form returns a URL, which can be interpreted in various ways (see the dis‐\ncussion of reading from a URL in Recipe 12.1 ).\nThe third form, only usable with a ClassLoader  instance, returns an Enumeration  of\nURL objects. This is intended to return all the resources that match a given string;\nremember that a CLASSPATH  can consist of pretty much any number of directories\nand/or JAR files, so this will search all of them. This is useful for finding a series of\nconfiguration files and merging them, perhaps. Or for finding out whether there is\nmore than one resource/file of a given name on your CLASSPATH .\nNote that the resource name can be given as either a relative path or as an absolute\npath. Assuming you are using Maven (see Recipe 1.7 ), then for the absolute path,\nplace the file relative to src/main/resources/  directory. For the relative path, place the\nfile in the same directory as your source code. The same rules apply in an IDE,\nassuming you have made src/main/java  and src/main/resources  be treated as source\nfolders in your IDE configuration. The idea is that resource files get copied to your\nCLASSPATH  folder. For example, if you have two resource files, src/main/resources/\none.txt  and src/main/java/MyPackage/two.txt , and your project is configured as\ndescribed, these two lines would work, if accessed from a program in MyPackage :\nClass<?> c = getClass();\nInputStream isOne = getResourceAsStream(""/one.txt""); // note leading slash\nInputStream isTwo = getResourceAsStream(""two.txt""); // without leading slash\n10.16 Finding Files in a Filesystem-Neutral Way with getResource() and getResourceAsStream() | 337",4079
443-10.17 Getting File Information Files and Path.pdf,443-10.17 Getting File Information Files and Path,,0
444-Problem.pdf,444-Problem,,0
445-Solution.pdf,445-Solution,,0
446-Discussion.pdf,446-Discussion,"In either case, getResource()  and getResourceAsStream()  will\nreturn null  if they don’t find the resource; you should always check\nfor null  to guard against faulty deployment. If it doesn’t find\nanything matching, getResources()  will return an empty\nEnumeration .\nIf the file path has slashes between components (as in package/subpackage ), the name\nyou path into any of the getResource  methods should have a period in place of the\nslash.\n10.17 Getting File Information: Files and Path\nProblem\nY ou need to know all you can about a given file on disk.\nSolution\nUse java.nio.file.Files  methods.\nDiscussion\nThe java.nio.file.Files  class has a plural name both to differentiate it from the\nlegacy File  class that it replaces and to remind us that it sometimes works on multi‐\nple files. There are two types of static methods in the Files  class, information and\noperational. The informational ones (see Table 10-7 ) simply give you information\nabout one file, such as boolean exists()  or long size() . The operational ones (see\nTable 10-8 ) either make changes to the filesystem or open a file for reading or writing.\nEach of the operational ones can throw the checked exception IOException ; only a\nfew of the informational ones can.\nThe vast majority of these methods have argument(s) of type java.nio.file.Path . A\nPath  represents a path into the filesystem, that is, a set of directories and possibly a\nfile, like “C:\Users\user\Downloads” or “/home/ian/Downloads” . The path may or\nmay not exist as a file on disk at the time you create a Path  representing it. The Files\nclass can tell you whether the file represented by a given Path  exists, can bring that\nPath  into being as a file or as a directory, and can either change the corresponding\nfile’s attributes or even destroy it if it does exist. Path  objects are easily created with\nPath.of(String name) , which has several overloads.\nFiles  in conjunction with Path  offers pretty well everything you’ d need to write a\nfull-blown file manager application, let alone the needs of a more typical application\n338 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\nneeding file information and/or directory access. The Files  class has a series of static\nboolean  methods that give basic information.\nTable 10-7. Public static informational methods in java.nio.file.Files\nReturn type Method Notes\nboolean exists(Path, LinkOption…);\nObject getAttribute(Path, String, LinkOption…);\n<V extends FileAttributeView> V getFileAttributeView(Path, Class<V>,\nLinkOption…);\nFileTime getLastModifiedTime(Path,  LinkOption…);\nUserPrincipal getOwner(Path, LinkOption…);\nSet<PosixFilePermission> getPosixFilePermissions(Path, LinkOption…);\nboolean isDirectory(Path, LinkOption…);\nboolean isExecutable(Path); If Executable by current user\nboolean isHidden(Path); If a “dot file” on Unix, or “hidden”\nattribute set on some OSes\nboolean isReadable(Path); If Readable by current user\nboolean isRegularFile(Path, LinkOption…);\nboolean isSameFile(Path, Path) throws IOException; Has to unwind filesys  complexities like\n“..”, symlinks, …\nboolean isSymbolicLink(Path);\nboolean isWritable(Path); If Writable by current user\nlong mismatch(Path, Path);\nboolean notExists(Path, LinkOption…);\nString probeContentType(Path) throws IOException; Tries to return MIME type of data\nPath readSymbolicLink(Path) throws IOException;\nlong size(Path);\nBy “current user” we mean the account under which the current JVM instance is\nbeing run.\nMost of these methods are demonstrated in Example 10-8 .\nExample 10-8. main/src/main/java/io/FilesInfos.java\n        println(""exists"" , Files.exists(Path.of(""/"")));\n        println(""isDirectory"" , Files.isDirectory (Path.of(""/"")));\n        println(""isExecutable"" , Files.isExecutable (Path.of(""/bin/cat"" )));\n        println(""isHidden"" , Files.isHidden (Path.of(""~/.profile"" )));\n        println(""isReadable"" , Files.isReadable (Path.of(""lines.txt"" )));\n        println(""isRegularFile"" , Files.isRegularFile (Path.of(""lines.txt"" )));\n        println(""isSameFile"" , Files.isSameFile (Path.of(""lines.txt"" ),\n            Path.of(""../main/lines.txt"" )));\n10.17 Getting File Information: Files and Path | 339\n        println(""isSymbolicLink"" , Files.isSymbolicLink (Path.of(""/var"")));\n        println(""isWritable"" , Files.isWritable (Path.of(""/tmp"")));\n        println(""isDirectory"" , Files.isDirectory (Path.of(""/"")));\n        println(""notexists"" ,\n            Files.notExists (Path.of(""no_such_file_as_skjfsjljwerjwj"" )));\n        println(""probeContentType"" , Files.probeContentType (Path.of(""lines.txt"" )));\n        println(""readSymbolicLink"" , Files.readSymbolicLink (Path.of(""/var"")));\n        println(""size"", Files.size(Path.of(""lines.txt"" )));\nObviously the paths chosen are somewhat system-specific, but when run on my Unix\nsystem, the boolean  methods all returned true , and the last three returned this:\nprobeContentType returned text/plain\nreadSymbolicLink returned private/var\nsize returned 78\nTable 10-8  shows the methods that make changes to filesystem entities.\nTable 10-8. Public static operational methods in java.nio.file.Files\nReturn type Method\nlong copy(InputStream, Path, CopyOption…);\nlong copy(Path, OutputStream);\nPath copy(Path, Path, CopyOption…);\nPath createDirectories(Path, FileAttribute<?>…);\nPath createDirectory(Path, FileAttribute<?>…);\nPath createFile(Path, FileAttribute<?>…);\nPath createLink(Path, Path);\nPath createSymbolicLink(Path, Path, FileAttribute<?>…);\nPath createTempDirectory(Path, String, FileAttribute<?>…);\nPath createTempDirectory(String, FileAttribute<?>…);\nPath createTempFile(Path, String, String, FileAttribute<?>…);\nPath createTempFile(String, String, FileAttribute<?>…);\nvoid delete(Path);\nboolean deleteIfExists(Path);\nStream<Path> find(Path,  int, BiPredicate<Path, BasicFileAttributes>, FileVisitOption…);\nStream<String> lines(Path);\nStream<String> lines(Path, Charset);\nStream<Path> list(Path);\nPath move(Path, Path, CopyOption…);\nBufferedReader newBufferedReader(Path);\nBufferedReader newBufferedReader(Path,  Charset);\nBufferedWriter newBufferedWriter(Path,  Charset, OpenOption…);\nBufferedWriter newBufferedWriter(Path,  OpenOption…);\n340 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\nReturn type Method\nSeekableByteChannel newByteChannel(Path, OpenOption…);\nSeekableByteChannel newByteChannel(Path, Set<? extends OpenOption>, FileAttribute<?>…);\nDirectoryStream<Path> newDirectoryStream(Path);\nDirectoryStream<Path> newDirectoryStream(Path, String);\nInputStream newInputStream(Path, OpenOption…);\nOutputStream newOutputStream(Path, OpenOption…);\nbyte[] readAllBytes(Path);\nList<String> readAllLines(Path);\nList<String> readAllLines(Path, Charset);\n<A extends BasicFileAttributes> A readAttributes(Path, Class<A>, LinkOption…);\nMap<String, Object> readAttributes(Path, String, LinkOption…);\nString readString(Path);\nString readString(Path, Charset);\nPath setAttribute(Path, String, Object, LinkOption…);\nPath setLastModifiedTime(Path,  FileTime);\nPath setOwner(Path, UserPrincipal);\nPath setPosixFilePermissions(Path, Set<PosixFilePermission>);\nPath write(Path, Iterable<? extends CharSequence>, Charset, OpenOption…);\nPath write(Path, Iterable<? extends CharSequence>, OpenOption…);\nPath write(Path, byte[], OpenOption…);\nPath writeString(Path, CharSequence, Charset, OpenOption…);\nPath writeString(Path, CharSequence, OpenOption…);\nPath  is an interface whose implementation is provided by a provider class called File\nsystem . Path  has many methods, listed in Table 10-9 .\nTable 10-9. Public static operational methods in java.nio.file.Path\nAccess Return type Method\nstatic Path of(String, String…);\nstatic Path of(URI);\nabstract FileSystem getFileSystem();\nabstract boolean isAbsolute();\nabstract Path getRoot();\nabstract Path getFileName();\nabstract Path getParent();\nabstract int getNameCount();\nabstract Path getName(int);\nabstract Path subpath(int, int);\n10.17 Getting File Information: Files and Path | 341\nAccess Return type Method\nabstract boolean startsWith(Path);\ndefault boolean startsWith(String);\nabstract boolean endsWith(Path);\ndefault boolean endsWith(String);\nabstract Path normalize();\nabstract Path resolve(Path);\ndefault Path resolve(String);\ndefault Path resolveSibling(Path);\ndefault Path resolveSibling(String);\nabstract Path relativize(Path);\nabstract URI toUri();\nabstract Path toAbsolutePath();\nabstract Path toRealPath(LinkOption…) throws IOException;\ndefault File toFile();\nabstract WatchKey register(WatchService, WatchEvent$Kind<?>[], WatchEvent$Modifier…)\nthrows IOException;\ndefault WatchKey register(WatchService, WatchEvent$Kind<?>…) throws IOException;\ndefault Iterator<Path> iterator();\nabstract int compareTo(Path);\nabstract boolean equals(Object);\nabstract int hashCode();\nabstract String toString();\ndefault int compareTo(Object);\nTo find the information about one file, you can use the informational methods in\nFiles  and Path , as shown in Example 10-9 .\nExample 10-9. main/src/main/java/dir_file/FileStatus.java  (getting file information)\npublic class FileStatus  {\n    public static void main(String[] argv) throws IOException  {\n        // Ensure that a filename (or something) was given in argv[0]\n        if (argv.length == 0) {\n            System.err.println(""Usage: FileStatus filename"" );\n            System.exit(1);\n        }\n        for (String a : argv) {\n            status(a);\n        }\n    }\n342 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\n    public static void status(String fileName ) throws IOException  {\n        System.out.println(""---"" + fileName  + ""---"");\n        // Construct a Path object for the given file.\n        Path p = Path.of(fileName );\n        // See if it actually exists\n        if (!Files.exists(p)) {\n            System.out.println(""file not found"" );\n            System.out.println();    // Blank line\n            return;\n        }\n        // Print full name\n        System.out.println(""Canonical name ""  + p.normalize ());\n        // Print parent directory if possible\n        Path parent = p.getParent ();\n        if (parent != null) {\n            System.out.println(""Parent directory: ""  + parent);\n        }\n        // Check if the file is readable\n        if (Files.isReadable (p)) {\n            System.out.println(fileName  + "" is readable."" );\n        }\n        // Check if the file is writable\n        if (Files.isWritable (p)) {\n            System.out.println(fileName  + "" is writable."" );\n        }\n        // See if file, directory, or other. If file, print size.\n        if (Files.isRegularFile (p)) {\n            // Report on the file's size and possibly its type\n            System.out.printf(""File size is %d bytes, content type %s\n"" ,\n                    Files.size(p),\n                    Files.probeContentType (p));\n        } else if (Files.isDirectory (p)) {\n            System.out.println(""It's a directory"" );\n        } else {\n            System.out.println(""I dunno! Neither a file nor a directory!"" );\n        }\n        // Report on the modification time.\n        final FileTime  d = Files.getLastModifiedTime (p);\n        System.out.println(""Last modified ""  + d);\n        System.out.println();    // blank line between entries\n    }\nWhen run on MS Windows with the three arguments shown, it produces this output:\nC:\javasrc\dir_file> java dir_file.FileStatus   / /tmp/id /autoexec.bat\n---/---\nCanonical name C:\\nFile is readable.\n10.17 Getting File Information: Files and Path | 343\nFile is writable.\nLast modified 1970-01-01T00:00:00.00000Z\nIt's a directory\n---/tmp/id---\nfile not found\n---/autoexec.bat---\nCanonical name C:\AUTOEXEC.BAT\nParent directory: \\nFile is readable.\nFile is writable.\nLast modified 2019-10-13T12:43:05.123918Z\nFile size is 308 bytes.\nAs you can see, the so-called canonical name  not only includes a leading directory\nroot of C:\, but also has had the name converted to uppercase. Y ou can tell I ran that\non Windows. That version of Windows did not maintain timestamps on directories;\nthe value 0L gets interpreted as January 1, 1970 (not accidentally the same time base\nas used on Unix since that time). On Unix, it behaves differently:\n$ java dir_file.FileStatus / /tmp/id /autoexec.bat\n---/---\nCanonical name /\nFile is readable.\nIt's a directory\nLast modified 2019-12-16T01:14:05.226108Z\n---/tmp/id---\nCanonical name /tmp/id\nParent directory: /tmp\nFile is readable.\nFile is writable.\nFile size is 36768 bytes, content type null\nLast modified 2019-12-21T18:46:27.402108Z\n---/autoexec.bat---\nfile not found\n$\nA typical Unix system has no autoexec.bat  file. And Unix filenames (like those on a\nMac) can consist of upper- and lowercase characters: what you type is what you get.\nLegacy compatibility\nTo use a Path  with legacy code that needs the older java.io.File , simply use File\noldType = Path.toFile() :\njshell> Path p = Path.of(""/"");\np ==> /\n344 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",13244
447-10.18 Creating a New File or Directory.pdf,447-10.18 Creating a New File or Directory,,0
448-Problem.pdf,448-Problem,,0
449-Solution.pdf,449-Solution,,0
450-10.19 Changing a Files Name or Other Attributes.pdf,450-10.19 Changing a Files Name or Other Attributes,"jshell> File f = p.toFile();\nf ==> /\nTo go the other way, the File  class has been retrofitted with a toPath()  method:\njshell> File f = new File(""/"");\nf ==> /\njshell> Path p = f.toPath();\np ==> /\n10.18 Creating a New File or Directory\nProblem\nY ou need to create a new file on disk but not write any data into it; you need to create\na directory before you can create files in it.\nSolution\nFor an empty file, use a java.nio.file.Files  object’s createFile(Path)  method.\nUse the Files  class’s createDirectory()  or createDirectories()  method to create\na directory.\nDiscussion\nFiles\nY ou could easily create a new file by constructing a FileOutputStream  or FileWriter\n(see Recipe 12.6 ). But then you’ d have to remember to close it as well. Sometimes you\nwant a file to exist, but you don’t want to bother putting anything into it. This might\nbe used, for example, as a simple form of interprogram communication: one program\ncould test for the presence of a file and interpret that to mean that the other program\nhas reached a certain state. Example 10-10  is code that simply creates an empty file\nfor each name you give.\nExample 10-10. main/src/main/java/dir_file/Creat.java  (creation of a file on disk)\n/** Create file(s) by name. Final ""e"" omitted in homage to UNIX system call. */\npublic class Creat {\n    public static void main(String[] argv) throws IOException  {\n        // Ensure that a filename (or something) was given in argv[0]\n        if (argv.length == 0) {\n            throw new IllegalArgumentException (""Usage: Creat filename [...]"" );\n        }\n10.18 Creating a New File or Directory | 345",1645
451-Solution.pdf,451-Solution,"for (String arg : argv) {\n            // Constructing a Path object doesn't affect the disk, but\n            // the Files.createFile() method does.\n            final Path p = Path.of(arg);\n            final Path created = Files.createFile (p);\n            System.out.println(created);\n        }\n    }\n}\njava.nio.file.createFile()  has an overload that takes a second argument of type\nOpenOption . This is an empty interface that is implemented by the StandardOpenOp\ntion  enumeration. These options are listed in Table 10-5 .\nDirectories\nOf the two methods used for creating directories, createDirectory()  creates just\none directory, whereas createDirectories()  creates any intermediate directories\nthat are needed. For example, if /home/ian  exists and is a directory, the call\nshell> Files.createDirectory (Path.of(""/Users/ian/abc"" ))\n$11 ==> /Users/ian/abc\nwill succeed (unless the directory is already there), but the call\njshell> Files.createDirectory (Path.of(""/Users/ian/once/twice/again"" ))\nwill fail with a java.nio.file.NoSuchFileException  because the directory named\nonce  does not exist. To create this path of directories, as you might expect by now, use\ncreateDirectories()  (plural):\njshell> Files.createDirectories(Path.of(""/Users/ian/once/twice/again""))\n$14 ==> /Users/ian/once/twice/again\nBoth variants return a Path  object referring to the new directory if they succeed and\nthrow an exception if they fail. Notice that it is possible (but not likely) for createDir\nectories()  to create some of the directories and then fail; in this case, the newly cre‐\nated directories are left in the filesystem.\n10.19 Changing a File’s Name or Other Attributes\nProblem\nY ou need to change a file’s name on disk or some of its other attributes, such as set‐\nting the file to read-only or changing its modification time.\n346 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",1937
452-Discussion.pdf,452-Discussion,"Solution\nTo change the name (or location), use a java.nio.file.Files  static move()  method.\nFor other attributes, use setLastModifiedTime()  to change the timestamp, or one of\nseveral other setters for mode or permission attributes.\nDiscussion\nSimilar to the Unix command line, there is no separate rename operation; the move\nmethods provide all functions for putting a file somewhere else, whether that is to the\nsame name in a different directory, a different name in the same directory, or a differ‐\nent name on a different disk or filesystem. Accordingly, the Files.move()  method\nrequires two Path  objects, one referring to the existing file and another referring to\nthe new name. Then call the Files.move()  method, passing both path objects, first\nthe existing and then the desired name. This is easier to see than to explain, so here\ngoes:\npublic class Rename {\n    public static void main(String[] argv) throws IOException  {\n        // Construct the Path object. Does NOT create a file on disk!\n        final Path p = Path.of(""MyCoolDocument"" ); // The file we will rename\n        // Setup for the demo: create a new ""old"" file\n        final Path oldName = Files.exists(p) ? p : Files.createFile (p);\n        // Rename the backup file to ""mydoc.bak""\n        // Renaming requires a Path object for the target.\n        final Path newName = Path.of(""mydoc.bak"" );\n        Files.deleteIfExists (newName); // In case previous run left it there\n        Path p2 = Files.move(oldName, newName);\n        System.out.println(p + "" renamed to ""  + p2);\n    }\n}\nFor changing the attributes, there are several methods available, listed in Table 10-10 .\nEach of these has a return value of type boolean , with true  meaning success.\nTable 10-10. Files attribute setters\nMethod signature Description\nsetExecutable(boolean executable) Convenience method to set owner’s execute permission for\nthis file\nsetExecutable(boolean executable, \nboolean ownerOnly)Sets the owner’s or everybody’s execute permission for this\nfile\nsetLastModified(long time) Sets the last-modified  time of the file or directory that this file\nnames\n10.19 Changing a File’s Name or Other Attributes | 347\nMethod signature Description\nsetReadable(boolean readable) Convenience method to set owner’s read permission for this\nfile\nsetReadable(boolean readable, boolean \nownerOnly)Sets the owner’s or everybody’s read permission for this file\nsetReadOnly() Convenience for setReadable(false)\nsetWritable(boolean writable) A convenience method to set the owner’s write permission for\nthis file\nsetWritable(boolean writable, boolean \nownerOnly)Set owner’s or everybody’s write permission for this file\nFor the methods that take two arguments, the first enables or disables the feature on\nthe given file that matches the method name, and the second controls whether the\noperation applies to the owner only or to everyone. The second argument is ignored\nif the file lives on a filesystem that doesn’t support multiuser permissions or if the\noperating system doesn’t support that. All the methods described in this recipe return\ntrue  if they succeed and false  otherwise.\nFor example, boolean setReadable(boolean readable, boolean ownerOnly)  lets\nyou specify who can read the given file. The readable  argument is true or false\ndepending on whether you want it readable or not. The ownerOnly  argument tries to\nextend the readability choice to all users on a multiuser operating system, and is\nignored if not applicable.\nsetLastModified()  allows you to play games with the modification time of a file.\nThis is normally not a good game to play, but it is useful in some types of backup/\nrestore programs. This method takes an argument that is the number of milliseconds\n(not seconds) since the beginning of Unix time (January 1, 1970). Y ou can get the\noriginal value for the file by calling getLastModified()  (see Recipe 10.17 ), or you\ncan get the value for a given date by calling the ZonedDateTime ’s toInstant().getE\npochSecond()  method (see Recipe 6.3 ) and multiplying by 1,000 to convert seconds\nto milliseconds.\nI encourage you to explore the operation of these methods using JShell (see Recipe\n1.4). I’ d suggest having a second window in which you can run ls -l  or dir com‐\nmands to see how the file is affected. Example 10-11  shows some of these methods\nbeing explored in JShell.\nExample 10-11. Exploring Files\njshell> var f = File.createTempFile (""foo"", ""bar"");\nf ==> /tmp/foo9391300789087780984bar\njshell> f.createNewFile ();\n$4 ==> false\n348 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",4668
453-10.20 Deleting a File.pdf,453-10.20 Deleting a File,,0
454-Problem.pdf,454-Problem,,0
455-Solution.pdf,455-Solution,,0
456-Discussion.pdf,456-Discussion,"jshell> f.setReadOnly ();\n$5 ==> true\njshell> f.canRead();\n$6 ==> true\njshell> f.canWrite ();\n$7 ==> false\njshell> f.setReadable (true);\n$8 ==> true\njshell> f.canWrite ();\n$9 ==> false\njshell> f.setReadable (false, false);\n$10 ==> true\njshell> f.canWrite ();\n$11 ==> false\n10.20 Deleting a File\nProblem\nY ou need to delete one or more files from the disk.\nSolution\nUse java.nio.file.Files  object’s delete(Path)  or deleteIfExists(Path)  method.\nThese delete the files referred to by the Path  argument (subject of course to permis‐\nsions) and directories (subject to permissions and to the directory being empty).\nDiscussion\nThis is not complicated. Simply construct a Path  object for the file you wish to delete,\nand call the static Files.delete()  method:\npublic class Delete {\n    public static void main(String[] argv) throws IOException  {\n        // Construct a File object for the backup created by editing\n        // this source file. The file probably already exists.\n        // Some text editors create backups by putting ~ at end of filename.\n        File bkup = new File(""Delete.java~"" );\n        // Now, delete it:\n        bkup.delete();\n10.20 Deleting a File | 349\n    }\n}\nRecall the caveat about permissions in the introduction to this chapter: if you don’t\nhave permission, you can get a return value of false or, possibly, a SecurityExcep\ntion . Note also that there are some differences between platforms. Some versions of\nWindows allow Java to remove a read-only file, but Unix does not allow you to\nremove a file unless you have write permission on the directory it’s in. Nor does Unix\nallow you to remove a directory that isn’t empty (there is even an exception, Director\nyNotEmptyException , for the latter case). Here is a version of Delete  with reporting\nof success or failure:\npublic class Delete2 {\n    static boolean hard = false; // True for delete, false for deleteIfExists\n    public static void main(String[] argv) {\n        for (String arg : argv) {\n            if (""-h"".equals(arg)) {\n                hard = true;\n                continue ;\n            }\n            delete(arg);\n        }\n    }\n    public static void delete(String fileName ) {\n        // Construct a File object for the file to be deleted.\n        final Path target = Path.of(fileName );\n        // Now, delete it:\n        if (hard) {\n            try {\n                System.out.print(""Using Files.delete(): "" );\n                Files.delete(target);\n                System.err.println(""** Deleted ""  + fileName  + "" **"");\n            } catch (IOException  e) {\n                System.out.println(""Deleting ""  + fileName  + "" threw ""  + e);\n            }\n        } else {\n            try {\n                System.out.print(""Using deleteIfExists(): "" );\n                if (Files.deleteIfExists (target)) {\n                    System.out.println(""** Deleted ""  + fileName  + "" **"");\n                } else {\n                    System.out.println(\n                        ""Deleting ""  + fileName  + "" returned false."" );\n                }\n            } catch (IOException  e) {\n                System.out.println(""Deleting ""  + fileName  + "" threw ""  + e);\n            }\n350 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",3328
457-10.21 Creating a TransientTemporary File.pdf,457-10.21 Creating a TransientTemporary File,,0
458-Problem.pdf,458-Problem,,0
459-10.22 Listing a Directory.pdf,459-10.22 Listing a Directory,"}\n    }\n}\nThe -h option allows this program to switch between delete()  and deleteIfEx\nists() ; you can see the difference by running it on things that exist, don’t exist, and\nare not empty, using both methods. The output looks something like this on my Unix\nbox:\n$ ls -ld ?\n-rw-r--r--  1 ian  512   0 Dec 21 16:35 a\ndrwxr-xr-x  2 ian  512  64 Dec 21 16:35 b\ndrwxr-xr-x  3 ian  512  96 Dec 21 16:22 c\n$ java -cp target/classes dir_file.Delete2 a b c d \nUsing deleteIfExists(): ** Deleted a **\nUsing deleteIfExists(): ** Deleted b **\nUsing deleteIfExists(): Deleting c threw\n  java.nio.file.DirectoryNotEmptyException: c\nUsing deleteIfExists(): Deleting d returned false.\n# Here I put the files back the way they were, then run again with -h\n$ java -cp target/classes dir_file.Delete2 -h a b c d\nUsing Files.delete(): ** Deleted a **\nUsing Files.delete(): ** Deleted b **\nUsing Files.delete(): Deleting c threw\n  java.nio.file.DirectoryNotEmptyException: c\nUsing Files.delete(): Deleting d threw java.nio.file.NoSuchFileException: d\n$ ls -l c\ntotal 2\ndrwxr-xr-x  2 ian  ian  512 Oct  8 16:50 d\n$ java dir_file.Delete2 c/d c\nUsing deleteIfExists(): ** Deleted c/d **\nUsing deleteIfExists(): ** Deleted c **\n$ \n10.21 Creating a Transient/Temporary File\nProblem\nY ou need to create a file with a unique temporary filename and/or or arrange for a file\nto be deleted when your program is finished.\nSolution\nUse the java.nio.file.Files  createTempFile()  or createTempDirectory()\nmethod. Use one of several methods to ensure your file is deleted on exit.\n10.21 Creating a Transient/Temporary File | 351\nDiscussion\nThe Files  class has static methods for creating temporary files and directories. Note\nthat a temporary file in this context is not deleted automatically; it is simply created in\na directory that is set aside for temporary files on that operating system (e.g., /tmp on\nUnix). Here are the methods for creating tempory files and directories:\nPath createTempFile(Path dir, String prefix,  String suffix,  FileAttribute<?>… attrs)\nCreates a new empty file in the specified directory, using the given prefix and suf‐\nfix strings to generate its name\nPath createTempFile(String prefix,  String suffix,  FileAttribute<?>… attrs)\nCreates an empty file in the default temporary-file directory, using the given pre‐\nfix and suffix to generate its name\nPath createTempDirectory(Path dir, String prefix,  FileAttribute<?>… attrs)\nCreates a new directory in the specified directory, using the given prefix to gener‐\nate its name\nPath createTempDirectory(String prefix,  FileAttribute<?>… attrs)\nCreates a new directory in the default temporary-file directory, using the given\nprefix to generate its name\nThe file attributes are discussed in the sidebar “Understanding I/O Options: Standar‐\ndOpenOptions, FileAttribute, PosixFileAttribute, and More” on page 321 .\nThere are various ways to arrange for a file to be deleted automatically. One is to use\nthe legacy java.io.File  class, which has a explicit deleteOnExit()  method. This\narranges for any file (no matter how it was created) to be deleted if it still exists when\nthe program exits. Here we arrange for a backup copy of a program to be deleted on\nexit, and we also create a temporary file and arrange for it to be removed on exit.\nBoth files are gone after the program runs:\npublic class TempFiles  {\n    public static void main(String[] argv) throws IOException  {\n        // 1. Making an existing file temporary\n        // Construct a File object for the backup created by editing\n        // this source file. The file probably already exists.\n        // My editor creates backups by putting ~ at the end of the name.\n        File bkup = new File(""Rename.java~"" );\n        // Arrange to have it deleted when the program ends.\n        bkup.deleteOnExit ();\n        // 2. Create a new temporary file.\n        // Make a file object for foo.tmp, in the default temp directory\n        Path tmp = Files.createTempFile (""foo"", ""tmp"");\n        // Report on the filename that it made up for us.\n352 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",4194
460-Solution.pdf,460-Solution,"System.out.println(""Your temp file is ""  + tmp.normalize ());\n        // Arrange for it to be deleted at exit.\n        tmp.toFile().deleteOnExit ();\n        // Now do something with the temporary file, without having to\n        // worry about deleting it later.\n        writeDataInTemp (tmp);\n    }\n    public static void writeDataInTemp (Path tempFile ) throws IOException  {\n        // This version is dummy. Use your imagination.\n        Files.writeString (tempFile , ""This is a temp file"" );\n    }\n}\nWhen run on a Unix system, this program looked like this, proving that the file was\ncreated but removed when the JVM exited:\n$ java TempFiles .java\nYour temp file is /tmp/foo8423321910215054689tmp\n$ ls -l /tmp/foo8423321910215054689tmp\nls: /tmp/foo8423321910215054689tmp:  No such file or directory\n$\nThe createTempFile()  method is like createNewFile()  (see Recipe 10.18 ) in that it\ndoes create the file. Also be aware that, should the Java Virtual Machine terminate\nabnormally, the deletion probably will not occur. There is no way to undo the setting\nof deleteOnExit()  short of renaming the file or something drastic like powering off\nthe computer before the program exits.\nAnother way to arrange for any file to be deleted when you are finished with it is to\ncreate it with the DELETE_ON_CLOSE  option (see Table 10-5 ) so it will be deleted when\nyou close the file.\nA third, less likely method is to instead use a JVM shutdown hook . DELETE_ON_CLOSE\nis probably the best option, particularly in a long-running application, like most\nserver-side apps. In these situations, the server could be running for weeks, months,\nor even years. In the meantime all the temp files would accumulate and the JVM\nwould accumulate a large list of deferred work that it needs to perform upon shut‐\ndown. Y ou’ d probably run out of disk space or server memory or some other\nresource. For most long-running apps of this kind, it’s better to use DELETE_ON_CLOSE\nor even the explicit delete()  operation. Another alternative is to use a scheduler ser‐\nvice to periodically trigger removal of old temporary files.\n10.22 Listing a Directory\nProblem\nY ou need to list the filesystem entries named in a directory.\n10.22 Listing a Directory | 353",2272
461-Discussion.pdf,461-Discussion,,0
462-10.23 Getting the Directory Roots.pdf,462-10.23 Getting the Directory Roots,,0
463-Solution.pdf,463-Solution,"Solution\nUse the java.nio.file.Files  static method Stream<Path> list(Path dir) , pass‐\ning the Path  representing the directory.\nDiscussion\nThe java.nio.file.Files  class contains several methods for working with directo‐\nries. If you just want to list the contents of a directory, use its list(Path)  method.\nFor example, to list the filesystem entities named in the current directory, just write\nthe following:\nFiles.list(Path.of(""."")).forEach(System.out::println);\nThis can become a complete program with as little as the following code. Note that on\nmany systems the Path  objects are returned in the order they occur in the directory,\nwhich isn’t sorted. In this simple example we use the Stream.sorted()  method to\norder the entries alphabetically:\npublic class Ls {\n    public static void main(String args[]) throws IOException  {\n        Files.list(Path.of("".""))\n            .sorted()\n            .forEach(dir -> {\n                System.out.println(dir);\n            });\n    }\n}\nOf course, there’s lots of room for elaboration. Y ou could print the names in multiple\ncolumns across the page. Or even down the page because you know the number of\nitems in the list before you print. Y ou could omit filenames with leading periods, as\ndoes the Unix ls program. Or print the directory names first; I once used a directory\nlister called lc that did this, and I found it quite useful.\nIf you want to process the directory recursively, you should not check each entry to\nsee if it’s a file or directory and recurse on directories. Instead, you should use one of\nthe walk()  or walkFileTree()  methods discussed in Recipe 10.26 ; these handle\nrecursion for you. There is also a set of Files.newDirectoryStream()  methods, with\nand without filter callbacks and other arguments, that return a Directory\nStream<Path> .\n10.23 Getting the Directory Roots\nProblem\nY ou want to know about the top-level directories, such as C:\ and D:\ on Windows.\n354 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",2053
464-10.24 Using the FileWatcher Service to Get Notified About File Changes.pdf,464-10.24 Using the FileWatcher Service to Get Notified About File Changes,"Solution\nUse the static method FileSystems.getDefault().getRootDirectories() , which\nreturns an Iterable  of Path  objects, one for each root directory. Y ou can print them\nor do other operations on them.\nDiscussion\nOperating systems differ in how they organize filesystems out of multiple disk drives\nor partitions. Microsoft Windows has a low-level device-oriented approach in which\neach disk drive has a root directory named A:\ for the first floppy (if you still have\none!), C:\ for the first hard drive, and other letters for CD-ROM and network drives.\nThis approach requires you to know the physical device that a file is on. Unix, Linux,\nand macOS have a high-level approach with a single root directory /; and different\ndisks or partitions are mounted, or connected, into a single unified tree. This\napproach sometimes requires you to figure out where a device file is mounted. Per‐\nhaps neither is easier, though the Unix approach is a bit more consistent. Either way,\nJava makes it easy for you to get a list of the roots.\nThe static method FileSystems.getDefault().getRootDirectories()  returns an\nIterable<Path>  containing the available filesystem roots for whatever platform you\nare running on. Here is a short program to list these:\nFileSystems .getDefault ().getRootDirectories ().forEach(System.out::println);\nC:> java dir_file.DirRoots\nA:\\nC:\\nD:\\nC:>\nAs you can see, the program listed my floppy drive (even though the floppy drive was\nnot only empty, but left at home while I wrote this recipe on my notebook computer\nin my car in a parking lot), the hard disk drive, and the CD-ROM drive.\nOn Unix there is only one root directory:\n$ java dir_file.DirRoots\n/\n$\nOne thing that is left out of the list of roots is the so-called UNC filename . UNC file‐\nnames are used on some Microsoft platforms to refer to a network-available resource\nthat hasn’t been mounted locally on a particular drive letter. If your system still uses\nthese, be aware they will not show up in the listDirectoryRoots()  output.\n10.23 Getting the Directory Roots | 355",2093
465-Problem.pdf,465-Problem,,0
466-Solution.pdf,466-Solution,,0
467-Discussion.pdf,467-Discussion,"10.24 Using the FileWatcher Service to Get Notified  About\nFile Changes\nProblem\nY ou want to be notified when some other application updates one or more of the files\nin which you are interested.\nSolution\nUse the java.nio.file.FileWatchService  to get notified of changes to files auto‐\nmatically, instead of having to examine the files periodically.\nDiscussion\nIt is fairly common for a large application to want to be notified of changes to files,\nwithout having to go and look at them periodically. For example, a Java Enterprise\nweb server wants to know when Servlets and other components get updated. An IDE\nwants to know when files were modified by an external editor or a build script. Many\nmodern operating systems have had this capability for some time, and now it is avail‐\nable in Java.\nThese are the basic steps to using the FileWatchService :\n1.Create a Path  object representing the directory you want to watch.\n2.Get a WatchService  by calling, for example, FileSystems.getDefault().new\nWatchService() .\n3.Create an array of Kind  enumerations for the things you want to watch (in our\nexample we watch for files being created or modified).\n4.Register the WatchService  and the Kind  array onto the Path  object.\n5.From then on, you wait for the watcher to notify you. A typical implementation\nis to enter a while (true)  loop calling the WatchService ’s take()  method to get\nan event and interpret the events to figure out what just happened.\nExample 10-12  is a program that does just that. In addition, it starts another thread to\nactually do some filesystem operations so that you can see the WatchService\noperating.\nExample 10-12. main/src/main/java/nio/FileWatchServiceDemo.java\npublic class FileWatchServiceDemo  {\n    final static String TEMP_DIR_PATH  = ""/tmp"";\n356 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\n    static final String FILE_SEMA_FOR  = ""MyFileSema.for"" ;\n    final static Path SEMAPHORE_PATH  = Path.of(TEMP_DIR_PATH  ,FILE_SEMA_FOR );\n    static volatile  boolean done = false;\n    final static ExecutorService  threadPool  = Executors .newSingleThreadExecutor ();\n    public static void main(String[] args) throws Throwable  {\n        String tempDirPath  = ""/tmp"";\n        System.out.println(""Starting watcher for ""  + tempDirPath );\n        System.out.println(""Semaphore file is ""  + SEMAPHORE_PATH );\n        Path p = Paths.get(tempDirPath );\n        WatchService  watcher =\n            FileSystems .getDefault ().newWatchService ();\n        Kind<?>[] watchKinds  = { ENTRY_CREATE , ENTRY_MODIFY  };\n        p.register (watcher, watchKinds );\n        threadPool .submit(new DemoService ());\n        while (!done) {\n            WatchKey  key = watcher.take();\n            for (WatchEvent <?> e : key.pollEvents ()) {\n                System.out.println(\n                    ""Saw event ""  + e.kind() + "" on "" +\n                    e.context());\n                if (e.context().toString ().equals(FILE_SEMA_FOR )) {\n                    System.out.println(""Semaphore found, shutting down watcher"" );\n                    done = true;\n                }\n            }\n            if (!key.reset()) {\n                System.err.println(""WatchKey failed to reset!"" );\n            }\n        }\n    }\n    /**\n     * Nested class whose only job is to wait a while, create a file in\n     * the monitored directory, and then go away.\n     */\n    private final static class DemoService  implements  Runnable  {\n        public void run() {\n            try {\n                Thread.sleep(1000);\n                System.out.println(""DemoService: Creating file"" );\n                Files.deleteIfExists (SEMAPHORE_PATH ); // clean up from previous run\n                Files.createFile (SEMAPHORE_PATH );\n                Thread.sleep(1000);\n                System.out.println(""DemoService: Shutting down"" );\n            } catch (Exception  e) {\n                System.out.println(""Caught UNEXPECTED ""  + e);\n            }\n        }\n    }\n}\n10.24 Using the FileWatcher Service to Get Notified  About File Changes | 357",4143
468-10.25 Program Save User Data to Disk.pdf,468-10.25 Program Save User Data to Disk,,0
469-Problem.pdf,469-Problem,,0
470-Solution.pdf,470-Solution,,0
471-Discussion.pdf,471-Discussion,"10.25 Program: Save User Data to Disk\nProblem\nY ou need to save user data to disk in a Java application. This may be in response to\nFile→Save in a GUI application, saving the file in a text editor, or saving configura‐\ntion data in a non-GUI application. Y ou have heard (correctly) that a well-behaved\napplication should never lose data.\nSolution\nUse this five-step plan, with appropriate variations:\n1.Create a temporary file; arrange for it to be removed automatically with deleteO\nnExit(true) .\n2.Write the user data to this file. Data format translation errors, if any, will be\nthrown during this process, leaving the previous version of the user’s data file\nintact.\n3.Delete the backup file if it exists.\n4.Rename the user’s previous file to *.bak .\n5.Rename the temporary file to the saved file.\nDiscussion\nAs developers, we have to deal with the fact that saving a file to disk is full of risk.\nThere are many things that can go wrong in saving data, yet it is one of the most criti‐\ncal parts of most applications. If you lose data that a person has spent hours input‐\nting, or even lose a setting that a user feels strongly about, she will despise your whole\napplication. The disk might fill up while we’re writing it, or it might be full before we\nstart. This is a user’s error, but we have to face it. So here’s a more detailed discussion\nof the little five-step dance we should go through:\n1.Create a temporary file that we will write to. Set this file to deleteOnExit(true)\nso that if we fail in a later step we don’t clutter the disk. Because we are later going\nto rename this file to become the user’s real file, and we don’t want to run out of\ndisk space during the rename, it is important that we create the file on the same\ndisk drive partition (drive letter  or mount point ) as the user’s real file; otherwise\nthe rename will silently morph into a copy-and-delete, which could fail due to\nlack of disk space. See Recipe 10.21  for methods of deleting a file on exit.\n2.Write the user data to this new temporary file. If we are transforming data—say,\ngetting it from a JDBC ResultSet or writing objects using a XML transformer—an\n358 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\nexception could be thrown. If we’re not careful, these exceptions can cause the\nuser’s data to be lost.\n3.Delete the backup file if it exists. First time we do this it won’t exist; after that it\nprobably will. Be prepared either way.\n4.Rename the user’s previous file to *.bak _.\n5.Rename the temporary file to the save file.\nThis may seem like overkill, but it prevents career kill. I’ve done pretty much this in\nnumerous apps with various save file formats. This plan is the only really safe way\naround all the problems that can occur. For example, the final step has to be a rename\nnot a copy, regardless of size considerations, to avoid the problem of the disk filling\nup. So, to be correct, you have to ensure that the temp file gets created on the same\ndisk partition (drive letter or mount point) as the user’s file.\nThis is the basic plan to use the FileSaver :\n•Instantiate it by calling the constructor.\n•Call the getWriter()  or getOutputStream()  method.\n•Use the output file to write the data.\n•Call finish()  on the FileSaver  object.\nmain/src/main/java/com/darwinsys/io/FileSaver.java\n// package com.darwinsys.io;\npublic class FileSaver  {\n    private enum State {\n        /** The state before and after use */\n        AVAILABLE ,\n        /** The state while in use */\n        INUSE\n    }\n    private State state;\n    private final Path inputFile ;\n    private final Path tmpFile;\n    private final Path backupFile ;\n    private OutputStream  mOutputStream ;\n    private Writer mWriter;\n    public FileSaver (Path inputFile ) throws IOException  {\n        // Step 1: Create temp file in right place; must be on same disk\n        // as the original file, to avoid disk-full troubles later.\n        this.inputFile  = inputFile ;\n        tmpFile = Path.of(inputFile .normalize () + "".tmp"");\n10.25 Program: Save User Data to Disk | 359\n        Files.createFile (tmpFile);\n        tmpFile.toFile().deleteOnExit ();\n        backupFile  = Path.of(inputFile .normalize () + "".bak"");\n        state = State.AVAILABLE ;\n    }\n    /**\n     * Return a reference to the contained File object, to\n     * promote reuse (File objects are immutable so this\n     * is at least moderately safe). Typical use would be:\n     * <pre>\n     * if (fileSaver == null ||\n     *   !(fileSaver.getFile().equals(file))) {\n     *        fileSaver = new FileSaver(file);\n     * }\n     * </pre>\n     * @return the File object for the file to be saved\n     */\n    public Path getFile() {\n        return inputFile ;\n    }\n    /** Return an output file that the client should use to\n     * write the client's data to.\n     * @return An OutputStream, which should be wrapped in a\n     *     buffered OutputStream to ensure reasonable performance.\n     * @throws IOException if the temporary file cannot be written\n     */\n    public OutputStream  getOutputStream () throws IOException  {\n        if (state != State.AVAILABLE ) {\n            throw new IllegalStateException (""FileSaver not opened"" );\n        }\n        mOutputStream  = Files.newOutputStream (tmpFile);\n        state = State.INUSE;\n        return mOutputStream ;\n    }\n    /** Return an output file that the client should use to\n     * write the client's data to.\n     * @return A BufferedWriter to write on the new file.\n     * @throws IOException if the temporary file cannot be written\n     */\n    public Writer getWriter () throws IOException  {\n        if (state != State.AVAILABLE ) {\n            throw new IllegalStateException (""FileSaver not opened"" );\n        }\n        mWriter = Files.newBufferedWriter (tmpFile);\n        state = State.INUSE;\n        return mWriter;\n    }\n360 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",6044
472-Acknowledgments.pdf,472-Acknowledgments,,0
473-10.26 Program FindWalking a File Tree.pdf,473-10.26 Program FindWalking a File Tree,"/** Close the output file and rename the temp file to the original name.\n     * @throws IOException If anything goes wrong\n     */\n    public void finish() throws IOException  {\n        if (state != State.INUSE) {\n            throw new IllegalStateException (""FileSaver not in use"" );\n        }\n        // Ensure both are closed before we try to rename.\n        if (mOutputStream  != null) {\n            mOutputStream .close();\n        }\n        if (mWriter != null) {\n            mWriter.close();\n        }\n        // Delete the previous backup file if it exists.\n        Files.deleteIfExists (backupFile );\n        // Rename the user's previous file to itsName.bak,\n        // UNLESS this is a new file.\n        if (Files.exists(inputFile ) &&\n            Files.move(inputFile , backupFile ) == null) {\n            throw new IOException (\n                ""Could not rename file to backup file ""  + backupFile );\n        }\n        // Rename the temporary file to the save file.\n        if (Files.move(tmpFile, inputFile ) == null) {\n            throw new IOException (""Could not rename temp file to save file"" );\n        }\n        state = State.AVAILABLE ;\n    }\n}\nAcknowledgments\nThe code in this program is my own, based on my experience in various applications.\nI was prompted to package it up this way, and write it up, by a post by Brendon\nMcLean to the mailing list for the now-defunct Java Application Framework JSR-296 .\n10.26 Program: Find—Walking a File Tree\nThe program shown in Example 10-13  implements a subset of the Windows Find\nFiles  dialog or the Unix find command. It has most of the structure needed to build a\nmore complete version of either of these. It accepts the following options from stan‐\ndard Unix find  (with limits):\n10.26 Program: Find—Walking a File Tree | 361\n-n name\nName to look for. Can include shell wildcards if quoted from the shell.\n-s size\nSize of file to look for. Can prefix with a plus sign to indicate greater than or a\nminus sign to indicate less than.\n-a, -o\nAnd or or, but only one of these, between a -n and a -s.\nThe Files  class has four methods for walking a file tree. Two return a lazily popula‐\nted Stream<Path> , and the other two invoke a callback FileVisitor  for each file or\ndirectory found. My find  implementation uses the first one; the four are summarized\nin Table 10-11 .\nTable 10-11. Files tree walk methods\nReturn Signature\nStream<Path> walk(Path start, FileVisitOption… options)\nStream<Path> walk(Path start, int maxDepth, FileVisitOption… options)\nPath walkFileTree(Path start, FileVisitor<? super Path> visitor)\nPath walkFileTree(Path start, Set<FileVisitOption> options, int maxDepth, FileVisitor<? super\nPath> visitor)\nUsing the walk()  methods is as simple as this:\nFiles.walk(startingPath ).forEach(path -> {\n // Do something with Path path; might be file, directory or other...\n}\nThat code is near the start of the startWalkingAt()  method in Example 10-13 .\nExample 10-13. main/src/main/java/dir_file/Find.java\n/**\n * Find - find files by name, size, or other criteria. Non-GUI version.\n */\npublic class Find {\n    public enum Conjunction  { AND, OR };\n    private static Logger logger = Logger.getLogger (Find.class.getSimpleName ());\n    static boolean started;\n    /** Main program\n     * @throws IOException If the Files.walkTree does so\n     */\n    public static void main(String[] args) throws IOException  {\n362 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\n        Find finder = new Find();\n        if (args.length == 0) {\n            finder.startWalkingAt (""."");\n        } else {\n            for (int i = 0; i < args.length; i++) {\n                if (args[i].charAt(0) == '-') {\n                    switch(args[i].substring (1)) {\n                    case ""name"":\n                        finder.filter.setNameFilter (args[++i]);\n                        continue ;\n                    case ""size"":\n                        finder.filter.setSizeFilter (args[++i]);\n                        continue ;\n//                    Not implemented by back-end yet\n//                    case ""a"":\n//                        finder.filter.addConjunction(Conjunction.AND);\n//                        continue;\n//                    case ""o"":\n//                        finder.filter.addConjunction(Conjunction.OR);\n//                        continue;\n                    default: throw new IllegalArgumentException (\n                        ""Unknown argument ""  + args[i]);\n                    }\n                }\n                finder.startWalkingAt (args[i]);\n            }\n            if (!started) {\n                finder.startWalkingAt (""."");\n            }\n        }\n    }\n    protected  FindFilter  filter = new FindFilter ();\n    public static void usage() {\n        System.err.println(\n            ""Usage: Find [-n namefilter][-s sizefilter][dir...]"" );\n        System.exit(1);\n    }\n    /** doName - handle one filesystem object by name */\n    private void startWalkingAt (String s) throws IOException  {\n        logger.info(""doName(""  + s + "")"");\n        started = true;\n        Path f = Path.of(s);\n        if (!Files.exists(f)) {\n            System.out.println(s + "" does not exist"" );\n            return;\n        }\n        Files.walk(f).forEach(fp -> {\n            try {\n10.26 Program: Find—Walking a File Tree | 363\n                if (Files.isRegularFile (fp))\n                    doFile(fp);\n                else if (Files.isDirectory (fp)) {\n                    doDir(fp);\n                } else {\n                    System.err.println(""Unknown type: ""  + s);\n                }\n            } catch (IOException  e) {\n                throw new RuntimeException (""IO Exception: ""  + e);\n            }\n        });\n    }\n    /** doFile - process one regular file.\n     * @throws IOException */\n    private void doFile(Path f) throws IOException  {\n        if (filter.accept(f)) {\n            System.out.println(""f "" + f);\n        }\n    }\n    /** doDir - process a directory */\n    private void doDir(Path d) {\n        System.out.println(""d "" + d.normalize ());\n    }\n}\nExample 10-14  shows a class called FindFilter , the backend implementation of Find .\nExample 10-14. main/src/main/java/dir_file/FindFilter.java\n/** Class to encapsulate the filtration for Find.\n * For now just set*Filter() methods. Really needs to be a real\n * data structure (maybe LinkedList<FilterOp> or a Tree) for complex\n * requests like:\n *    -n ""*.html"" -a \( -size < 0 -o mtime < 5 \).\n */\npublic class FindFilter  {\n    private enum SizeMode  {GT, EQ, LT};\n    SizeMode  sizeMode ;\n    Find.Conjunction  conj;\n    long size;\n    String name;\n    Pattern nameRE;\n    boolean debug = false;\n    void setSizeFilter (String sizeFilter ) {\n        System.out.println(""FindFilter.setSizeFilter()"" );\n        sizeMode  = SizeMode .EQ;\n        char c = sizeFilter .charAt(0);\n        if (c == '+') {\n            sizeMode  = SizeMode .GT;\n364 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks\n            sizeFilter  = sizeFilter .substring (1);\n        } else {\n            if (c == '-') {\n                sizeMode  = SizeMode .LT;\n                sizeFilter  = sizeFilter .substring (1);\n            }\n        }\n        size = Long.parseLong (sizeFilter );\n    }\n    /** Add a conjunction */\n    public void addConjunction (Find.Conjunction  conj) {\n        System.out.println(""FindFilter.addConjunction()"" );\n        if (this.conj != null) {\n            throw new IllegalArgumentException (\n                ""Only one conjucntion allowed in this version"" );\n        }\n        this.conj = conj;\n    }\n    /** Convert the given shell wildcard pattern into internal form (an RE) */\n    void setNameFilter (String nameToFilter ) {\n        nameRE = makeNameFilter (nameToFilter );\n    }\n    Pattern makeNameFilter (String name) {\n        StringBuilder  sb = new StringBuilder ('^');\n        for (char c : name.toCharArray ()) {\n            switch(c) {\n                case '.':    sb.append(""\\.""); break;\n                case '*':    sb.append("".*""); break;\n                case '?':    sb.append('.'); break;\n                // Some chars are special to RE and have to be escaped\n                case '[':    sb.append(""\\[""); break;\n                case ']':    sb.append(""\\]""); break;\n                case '(':    sb.append(""\\(""); break;\n                case ')':    sb.append(""\\)""); break;\n                default:    sb.append(c); break;\n            }\n        }\n        sb.append('$');\n        if (debug) {\n            System.out.println(""RE=\"""" + sb + ""\""."");\n        }\n        // Should catch PatternException and rethrow for better diagnostics\n        return Pattern.compile(sb.toString ());\n    }\n    /** Do the filtering. For now, only filter on name, size or name+size */\n    public boolean accept(Path p) throws IOException  {\n        if (debug) {\n            System.out.println(""FindFilter.accept(""  + p + "")"");\n10.26 Program: Find—Walking a File Tree | 365\n        }\n        if (nameRE != null) {\n            return nameRE.matcher(p.getFileName ().toString ()).matches();\n        }\n        // size handling\n        if (sizeMode  != null) {\n            long sz = Files.size(p);\n            switch (sizeMode ) {\n            case EQ:\n                return (sz == size);\n            case GT:\n                return (sz > size);\n            case LT:\n                return (sz < size);\n            }\n        }\n        // Catchall\n        return false;\n    }\n    public String getName() {\n        return name;\n    }\n}\n366 | Chapter 10: Input and Output: Reading, Writing, and Directory Tricks",9850
474-11.1 Machine Learning with Java.pdf,474-11.1 Machine Learning with Java,"6Map/Reduce  is a famous algorithm pioneered by Google to handle large data problems. An unspecified num‐\nber of generators process map  data—such as words on a web page or the page’s URL—and a single (usually)\nreduce process reduces the maps to a manageable form, such as a list of all the pages that contain the given\nwords. Early on, data science went overboard on trying to do everything with Map/Reduce; now the pendu‐\nlum has swung back to using compute engines like Spark.CHAPTER 11\nData Science and R\nData science is a relatively new discipline that first came to the attention of many with\nthis article by O’Reilly’s Mike Loukides . While there are many definitions in the field,\nLoukides distills his detailed observation of and participation in the field into this\ndefinition:\nA data application acquires its value from the data itself, and creates more data as a\nresult. It’s not just an application with data; it’s a data product. Data science enables the\ncreation of data products.\nOne of the main open source ecosystems for data science software is at Apache and\nincludes  Hadoop  (which includes the HDFS distributed filesystem, Hadoop Map/\nReduce,6 Ozone object store, and Y arn scheduler), the Cassandra distributed data‐\nbase , and the Spark compute engine . Read the “Modules and Related Tools” section of\nthe Hadoop page for a current list.\nWhat’s interesting here is that a great deal of this infrastructure, which is taken for\ngranted by data scientists, is written in Java and Scala (a JVM language). Much of the\nrest is written in Python, a language that complements Java.\nData science problems may involve a lot of setup, so we’ll only give one example from\ntraditional DS, using the Spark framework. Spark is written in Scala so it can be used\ndirectly by Java code.\n367",1821
475-Problem.pdf,475-Problem,,0
476-Solution.pdf,476-Solution,,0
477-See Also.pdf,477-See Also,"In the rest of the chapter I’ll focus on a language called R, which is widely used both\nin statistics and in data science (well, also in many other sciences; many of the graphs\nyou see in refereed journal articles are prepared with R). R is widely used and is use‐\nful to know. Its primary implementation was not written in Java, but in a mixture of\nC, Fortran, and R itself. But R can be used within Java, and Java can be used within R.\nI’ll talk about several implementations of R and how to select one, and then I’ll show\ntechniques for using Java from R and R from Java, as well as using R in a web\napplication.\n11.1 Machine Learning with Java\nProblem\nY ou want to use Java for machine learning and data science, but everyone tells you to\nuse Python.\nSolution\nUse one of the many powerful Java toolkits available for free download.\nDiscussion\nIt’s sometimes said that machine learning (ML) and deep learning have to be done in\nC++ for efficiency or in Python for the wide availability of software. While these lan‐\nguages have their advantages and their advocates, it is certainly possible to use Java\nfor these purposes. However, setting up these packages and presenting a short demo\ntends to be longer than would fit in this book’s typical recipe format.\nWith industry giant Amazon having released its Java-based Deep Java Learning (DJL)\nlibrary as this book was going to press, and many other good libraries available (with\nquite a few supporting CUDA  for faster GPU-based processing) (see Table 11-1 ),\nthere is no reason to avoid using Java for ML. With the exception of DJL, I’ve tried to\nlist packages that are still being maintained and have a decent reputation among\nusers.\nTable 11-1. Some Java machine learning packages\nLibrary name Description Info URL Source URL\nADAMS Workflow  engine for\nbuilding/maintaining\ndata-driven, reactive\nworkflows;  integration\nwith business processeshttps://adams.cms.waikato.ac.nz/ https://github.com/waikato-datamini\nng/adams-base\nDeep Java\nLibraryAmazon’s ML library https://djl.ai https://github.com/awslabs/djl\n368 | Chapter 11: Data Science and R",2136
478-11.2 Using Data In Apache Spark.pdf,478-11.2 Using Data In Apache Spark,,0
479-Problem.pdf,479-Problem,,0
480-Solution.pdf,480-Solution,,0
481-Discussion.pdf,481-Discussion,"6DataBricks offers several free ebooks on Spark from their website; it also offers commercial Spark add-ons.Library name Description Info URL Source URL\nDeeplearning4j DL4J, Eclipse’s\ndistributed deep-\nlearning library;\nintegrates w/ Hadoop\nand Apache Sparkhttps://deeplearning4j.org/ https://github.com/eclipse/deeplearni\nng4j\nELKI Data mining toolkit https://elki-project.github.io/ https://github.com/elki-project/elki\nMallet ML for text processing mallet.cs.umass.edu https://github.com/mimno/Mallet.git\nWeka ML algorithms for data\nmining; tools for data\npreparation,\nclassification,  regression,\nclustering, association\nrules mining, and\nvisualizationhttps://www.cs.waikato.ac.nz/ml/weka\n/index.htmlhttps://svn.cms.waikato.ac.nz/svn/we\nka/trunk/weka\nSee Also\nThe book Data Mining: Practical Machine Learning and Techniques  by Ian Witten et\nal. (Morgan Kaufmann) was written by the team behind Weka.\nSee also Eugen Parschiv’s list of Java AI software packages .\n11.2 Using Data In Apache Spark\nProblem\nY ou want to process data using Spark.\nSolution\nCreate a SparkSession , use its read()  function to read a DataSet , apply operations,\nand summarize results.\nDiscussion\nSpark is a massive subject! Entire books have been written on using it.  Quoting Data‐\nbricks , home of much of the original Spark team:6\nApache Spark™ has seen immense growth over the past several years, becoming the de-\nfacto data processing and AI engine in enterprises today due to its speed, ease of use,\nand sophisticated analytics. Spark unifies data and AI by simplifying data preparation\nat massive scale across various sources, providing a consistent set of APIs for both data\n11.2 Using Data In Apache Spark | 369\nengineering and data science workloads, as well as seamless integration with popular\nAI frameworks and libraries such as TensorFlow, PyTorch, R and SciKit-Learn.\nI cannot convey the whole subject matter in this book. However, one thing Spark is\ngood for is dealing with lots of data. In Example 11-1 , we read an Apache-format log‐\nfile and find (and count) the lines with 200, 404, and 500 responses.\nExample 11-1. spark/src/main/java/sparkdemo/LogReader.java\nimport org.apache.spark.sql.SparkSession ;\nimport org.apache.spark.sql.Dataset ;\nimport org.apache.spark.api.java.function.FilterFunction ;\n/**\n * Read an Apache Logfile and summarize it.\n */\npublic class LogReader  {\n    public static void main(String[] args) {\n        final String logFile = ""/var/wildfly/standalone/log/access_log.log"" ;    \n        SparkSession  spark =\n            SparkSession .builder().appName(""Log Analyzer"" ).getOrCreate ();       \n        Dataset<String> logData = spark.read().textFile (logFile).cache();       \n        long good = logData.filter(                                             \n        new FilterFunction <>() {public boolean call(String s) {\n                    return s.contains (""200"");\n                }\n            }).count();\n        long bad = logData.filter(new FilterFunction <>() {\n                public boolean call(String s) {\n                    return s.contains (""404"");\n                }\n            }).count();\n        long ugly = logData.filter(new FilterFunction <>() {\n                public boolean call(String s) {\n                    return s.contains (""500"");\n                }\n            }).count();\n        System.out.printf(                                                      \n            ""Successful transfers %d, 404 tries %d, 500 errors %d\n"" ,\n            good, bad, ugly);\n        spark.stop();\n    }\n}\n370 | Chapter 11: Data Science and R\nSet up the filename for the logfile. It probably should come from args .\nStart up the Spark SparkSession  object—the runtime.\nTell Spark to read the logfile and keep it in memory (cache).\nDefine the filters for 200, 404, and 500 errors. They should be able to use lambdas\nto make the code shorter, but there’s an ambiguity between the Java and Scala\nversions of FilterFunction .\nPrint the results.\nTo make this compile , you need to add the following to a Maven POM file:\n<dependency >\n    <groupId>org.apache.spark</groupId>\n    <artifactId >spark-sql_2.12</artifactId >\n    <version>2.4.4</version>\n    <scope>provided </scope>\n</dependency >\nThen you should be able to do mvn package  to get a JAR file packaged.\nThe use of the provided  scope is because we will also download the Apache Spark\nruntime package from the Spark Download page  in order to run the application.\nUnpack the distribution and set the SPARK_HOME  environment to the root of it:\nSPARK_HOME=~/spark-3.0.0-bin-hadoop3.2/\nThen you can use the run script that I’ve provided in the source download ( javasrc/\nspark ).\nSpark is designed for larger-scale computing than what’s in this simple example, so its\nvoluminous output simply dwarfs the output from my simple sample program.\nNonetheless, for an approximately 42,000-line file, I did get this result, buried among\nthe logging:\nSuccessful transfers 32555, 404 tries 6539, 500 errors 183\nAs mentioned, Spark is a massive subject but a necessary tool for most data scientists.\nY ou can program Spark in Java (obviously), or in Scala. Scala is a JVM language that\npromotes functional programming (see this Scala tutorial for Java devs ) in Python\nand probably other languages. Y ou can learn more at https://spark.apache.org  or from\nthe many books, videos, and tutorials online.\n11.2 Using Data In Apache Spark | 371",5527
482-11.3 Using R Interactively.pdf,482-11.3 Using R Interactively,,0
483-Problem.pdf,483-Problem,,0
484-Solution.pdf,484-Solution,,0
485-Discussion.pdf,485-Discussion,"11.3 Using R Interactively\nProblem\nY ou don’t know the first thing about R, and you want to.\nSolution\nR has been around for ages, and its predecessor S for a decade before that. There are\nmany books and online resources devoted to this language. The official home page is\nat https://www.r-project.org . There are many online tutorials; the R Project hosts one .\nR itself is available in most systems’ package managers, and it can be downloaded\nfrom the official download site . The name CRAN  in these URLs stands for Compre‐\nhensive R Archive Network, named in a similar fashion to TeX’s CTAN and the Perl\nlanguage’s CPAN.\nIn this example we’ll write some data from a Java program and then analyze and\ngraph it using R interactively.\nDiscussion\nThis is merely a brief intro to using R interactively. Suffice to say that R is a valuable\ninteractive environment for exploring data. Here are some simple calculations to\nshow the flavor of the language: a chatty startup (so long I had to cut part of it), sim‐\nple arithmetic, automatic printing of results if not saved, half-decent errors when you\nmake a mistake, and arithmetic on vectors. Y ou may see some similarities to Java’s\nJShell (see Recipe 1.4 ); both are REPL (Read-Evaluate-Print Loop) interfaces. R adds\nthe ability to save your interactive session ( workspace ) when exiting the program, so\nall your data and function definitions are restored next time you start R. A simple\ninteractive session showing a bit of the syntax of R might look like this:\n$ R\nR version 3.6.0 (2019-04-26) -- ""Planting of a Tree""\nCopyright (C) 2019 The R Foundation for Statistical Computing\nPlatform: x86_64-apple-darwin15.6.0 (64-bit)\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\n...\n> 2 + 2\n[1] 4\n> x = 2 + 2\n> x\n372 | Chapter 11: Data Science and R\n[1] 4\n> r = 10 20 30 40 50\nError: unexpected numeric constant in ""r = 10 20""\n> r = c(10,20,30,45,55,67)\n> r\n[1] 10 20 30 45 55 67\n> r+3\n[1] 13 23 33 48 58 70\n> r / 3\n[1]  3.333333  6.666667 10.000000 15.000000 18.333333 22.333333\n>quit()\nSave workspace image? [y/n/c]: n\n$\nR purists will usually use the  assignment arrow  ← in lieu of the = sign when assigning.\nIf you like that, go for it.\nThis short session barely scratches the surface: R offers hundreds of built-in func‐\ntions, sample datasets, over a thousand add-on packages, built-in help, and much\nmore. For interactive exploration of data, R is really the one to beat.\nSome people prefer a GUI frontend to R. RStudio  is the most widely used GUI front‐\nend.\nNow we want to write some data from Java and process it in R (we’ll use Java and R\ntogether in later recipes in this chapter). In Recipe 5.9  we discussed the\njava.util.Random  class and its nextDouble()  and nextGaussian()  methods. The\nnextDouble()  and related methods try to give a flat distribution between 0 and 1.0, in\nwhich each value has an equal chance of being selected. A Gaussian or normal distri‐\nbution is a bell curve of values from negative infinity to positive infinity, with the\nmajority of the values clustered around zero (0.0). We’ll use R’s histogramming and\ngraphics functions to examine visually how well they do so:\nRandom r = new Random();\nfor (int i = 0; i < 10_000; i++) {\n    System.out.println(""A normal random double is ""  + r.nextDouble ());\n    System.out.println(""A gaussian random double is ""  + r.nextGaussian ());\nTo illustrate the different distributions, I generated 10,000 numbers each using nex\ntRandom()  and nextGaussian() . The code for this is in Random4.java  (not shown\nhere) and is a combination of the preceding sample code with code to print just the\nnumbers into two files. I then plotted histograms using R; the R script used to gener‐\nate the graph is in javasrc  under src/main/resources , but its core is shown in\nExample 11-2 . The results are shown in Figure 11-1 .\nExample 11-2. R commands to generate histograms\npng(""randomness.png"" )\nus <- read.table (""normal.txt"" )[[1]]\n11.3 Using R Interactively | 373",4186
486-11.4 ComparingChoosing an R Implementation.pdf,486-11.4 ComparingChoosing an R Implementation,,0
487-Problem.pdf,487-Problem,,0
488-Solution.pdf,488-Solution,,0
489-11.5 Using R from Within a Java App Renjin.pdf,489-11.5 Using R from Within a Java App Renjin,"ns <- read.table (""gaussian.txt"" )[[1]]\nlayout(t(c(1,2)), respect=TRUE)\nhist(us, main = ""Using nextRandom()"" , nclass = 10,\n       xlab = NULL, col = ""lightgray"" , las = 1, font.lab  = 3)\nhist(ns, main = ""Using nextGaussian()"" , nclass = 16,\n       xlab = NULL, col = ""lightgray"" , las = 1, font.lab  = 3)\ndev.off()\nThe png()  call tells R which graphics device to use. Others include X11()  and Post\nscript() . read.table()  reads data from a text file into a table; the [1] gives us just\nthe data column, ignoring some metadata. The layout()  call says we want two\ngraphics objects displayed side by side. Each hist()  call draws one of the two histo‐\ngrams. And dev.off()  closes the output and flushes any writing buffers to the PNG\nfile. The result is shown in Figure 11-1 .\nFigure 11-1. Flat (left)  and Gaussian (right) distributions\n11.4 Comparing/Choosing an R Implementation\nProblem\nY ou’re not sure which implementation of R to use.\nSolution\nLook at original R, Renjin, and FastR.\nDiscussion\nThe original for R was S, an environment for interactive programming developed by\nJohn Chambers and others at AT&T Bell Labs starting in 1976. I ran into S when sup‐\nporting the University of Toronto Statistics Department, and again when reviewing a\n374 | Chapter 11: Data Science and R",1312
490-Problem.pdf,490-Problem,,0
491-Solution.pdf,491-Solution,,0
492-Discussion.pdf,492-Discussion,"commercial implementation of it, SPlus, for a long-ago glossy magazine called Sun\nExpert . AT&T was only making S source available to universities and to commercial\nlicensees who could not further distribute the source. Two developers at the Univer‐\nsity of Auckland, Ross Ihaka and Robert Gentleman, developed a clone of S, starting\nin 1995. They named it R after their own first initials and as a play on the name S.\n(There is precedent for this: the awk language popular on Unix/Linux was named for\nthe initials of its designers Aho, Weinberger, and Kernighan). R grew quickly because\nit was very largely compatible with S and was more readily available. This implemen‐\ntation of original R is actively managed by the R Foundation for Statistical Comput‐\ning, which also manages the Comprehensive R Archive Network .\nRenjin  is a fairly complete implementation of R in Java. This project provides built\nJAR files via their own Maven repository.\nFastR  is another implementation in Java, designed to run in the faster GraalVM and\nsupporting direct invocation of JVM code from almost any other programming lan‐\nguage. The technical lead of the FastR descibes the implementation in this blog post .\nBesides these implementations, R’s popularity has led to development of many access\nlibraries for invoking R from many popular programming languages.  Rserve  is a\nTCP/IP networked access mode for R, for which Java wrappers exist.\n11.5 Using R from Within a Java App: Renjin\nProblem\nY ou want to access R from within a Java application using Renjin.\nSolution\nAdd Renjin to your Maven or Gradle build, and call it via the Script Engines mecha‐\nnism described in Recipe 18.3 .\nDiscussion\nRenjin is a pure-Java, open source reimplementation of R and provides a script\nengines interface. Add the following dependency to your build tool:\norg.renjin:renjin-script-engine:3.5-beta76\nOf course there is probably a later version of Renjin than the one shown above by the\ntime you read this; use the latest unless there’s a reason not to.\nNote that you will also need a <repository>  entry since the maintainers put their\nartifacts in the repo at nexus.betadriven.com  instead of the usual Maven Central.\nHere’s what I used (obtained from https://www.renjin.org/downloads.html ):\n11.5 Using R from Within a Java App: Renjin | 375\n<repositories>\n    <repository>\n        <id>bedatadriven</id>\n        <name>bedatadriven public repo</name>\n        <url>https://nexus.bedatadriven.com/content/groups/public/</url>\n    </repository>\n</repositories>\nOnce that’s done, you should be able to access Renjin via the Script Engines frame‐\nwork, as in Example 11-3 .\nExample 11-3. main/src/main/java/otherlang/RenjinScripting.java\n    /**\n     * Demonstrate interacting with the ""R"" implementation called ""Renjin""\n     */\n    public static void main(String[] args) throws ScriptException  {\n        ScriptEngineManager  manager = new ScriptEngineManager ();\n        ScriptEngine  engine = manager.getEngineByName (""Renjin"" );\n        engine.put(""a"", 42);\n        Object ret = engine.eval(""b <- 2; a*b"" );\n        System.out.println(ret);\n    }\nBecause R treats all numbers as floating point, like many interpreters, the value\nprinted is 84.0 .\nOne can also get Renjin to invoke a script file; Example 11-4  invokes the same script\nused in Recipe 11.3  to generate and plot a batch of pseudorandom numbers.\nExample 11-4. Renjin with a script file\n    private static final String R_SCRIPT_FILE  = ""/randomnesshistograms.r"" ;\n    private static final int N = 10000;\n    public static void main(String[] argv) throws Exception  {\n        // java.util.Random methods are non-static, do need to construct\n        Random r = new Random();\n        double[] us = new double[N], ns = new double[N];\n        for (int i=0; i<N; i++) {\n            us[i] = r.nextDouble ();\n            ns[i] =r.nextGaussian ();\n        }\n        try (InputStream  is =\n            Random5.class.getResourceAsStream (R_SCRIPT_FILE )) {\n            if (is == null) {\n                throw new IllegalStateException (""Can't open R file "" );\n            }\n            ScriptEngineManager  manager = new ScriptEngineManager ();\n            ScriptEngine  engine = manager.getEngineByName (""Renjin"" );\n            engine.put(""us"", us);\n376 | Chapter 11: Data Science and R",4390
493-11.6 Using Java from Within an R Session.pdf,493-11.6 Using Java from Within an R Session,,0
494-Problem.pdf,494-Problem,,0
495-Solution.pdf,495-Solution,,0
496-11.7 Using FastR the GraalVM Implementation of R.pdf,496-11.7 Using FastR the GraalVM Implementation of R,"engine.put(""ns"", ns);\n            engine.eval(FileIO.readerToString (new InputStreamReader (is)));\n        }\n    }\nRenjin can also be used as a standalone R implementation if you download an all-\ndependencies JAR file from https://renjin.org/downloads.html .\n11.6 Using Java from Within an R Session\nProblem\nY ou are partway through a computation in R and realize that there’s a Java library to\ndo the next step. Or for any other reason, you need to call Java code from within an R\nsession.\nSolution\nInstall rJava, call .jinit() , and use J() to load classes or invoke methods.\nDiscussion\nHere is the part of an interactive R session in which we install rJava, initialize it by\ncalling .jinit() , and invoke java.time.LocalDate.now()  to get the current date:\n> install.packages ('rJava')                            \ntrying URL 'http://.../rJava_0.9-11.tgz'\nContent type 'application /x-gzip' length 745354 bytes (727 KB)\n==================================================\ndownloaded  727 KB\nThe downloaded  binary packages  are in\n    /tmp//Rtmp6XYZ9t/downloaded_packages\n> library('rJava')                                    \n> .jinit()\n> J('java.time.LocalDate ', 'now')                    \n[1] ""Java-Object{2019-11-22}""\n> d=J('java.time.LocalDate ', 'now')$toString ()        \n> d\n[1] ""2019-11-22""\nInstall the rJava  package; only needs to be done once.\nload rJava , and initialize it with .jinit() ; both needed in every R session.\nThe J function takes one argument of a full class name. If only that argument is\ngiven, a class descriptor (like a java.lang.Class  object) is returned. If more\n11.6 Using Java from Within an R Session | 377",1678
497-Problem.pdf,497-Problem,,0
498-11.8 Using R in a Web App.pdf,498-11.8 Using R in a Web App,"than one argument is given, the second is a static method name, and any subse‐\nquent arguments are passed to that method.\nReturned objects can have Java methods invoked with the standard R \$ notation;\nhere the toString()  method is invoked to return just a character string instead\nof a LocalDate  object.\nThe .jcall  function gives you more control over calling method and return types:\n> d=J('java.time.LocalDate ', 'now')                    \n> .jcall(d, ""I"", 'getYear')                            \n[1] 2019\n>\n> .jcall(""java/lang/System"" ,""S"",""getProperty"" ,""user.dir"" ) \n[1] ""/home/ian""\n> c=J('java/lang/System')                            \n> .jcall(c, ""S"", 'getProperty ', 'user.dir')\n[1] ""/home/ian""\n>\nInvoke Java LocalDate.now()  method and save result in R variable d.\nInvoke Java getYear()  method on the LocalDate  object; the “I” tells jcall  to\nexpect an integer result.\nCall System.getProperty(""user.dir"")  and print the result; the “S” tells .jcall\nto expect a string return.\nIf you will be using a class several times, save the Class  object, and pass it as the\nfirst argument of .jcall() .\nThere are more capabilities here; consult the documentation  and a developer.com\narticle .\n11.7 Using FastR, the GraalVM Implementation of R\nProblem\nY ou use the R language but feel a need for speed.\nSolution\nUse FastR, Oracle’s GraalVM reimplementation of the R language.\n378 | Chapter 11: Data Science and R\nDiscussion\nAssuming you have installed GraalVM as described in Recipe 1.2 , you can just type\nthe following command:\n$ gu install R\nDownloading: Component catalog from www.graalvm.org\nProcessing component archive: FastR\nDownloading: Component R: FastR  from github.com\nInstalling new component: FastR (org.graalvm.R, version 19.2.0.1)\nNOTES:\n---------------\nThe user specific library directory was not created automatically.\nYou can either create the directory manually or edit file\n/Library/Java/JavaVirtualMachines/graalvm-ce-19.2.0.1/Contents/\n  Home/jre/languages/R/etc/Renviron\nto change it to any desired location. Without user specific library\ndirectory, users will need write permission for the GraalVM home\ndirectory in order to install R packages.\n...\n[more install notes]\nIf you have set your PATH  to have GraalVM before other directories, the command R\nwill now give you the GraalVM version of R. To access the standard R, you will have\nto either set your PATH  or give a full path to the R installation. On all Unix and Unix-\nlike systems, the command which R  will reveal all R commands on your PATH :\n$ which R\n/Library/Java/JavaVirtualMachines/graalvm-ce-19.2.0.1/Contents/Home/bin/R\n/usr/local/bin/R\nLet’s just run it:\n$ R\nR version 3.5.1 (FastR)\nCopyright (c) 2013-19, Oracle and/or its affiliates\nCopyright (c) 1995-2018, The R Core Team\nCopyright (c) 2018 The R Foundation for Statistical Computing\nCopyright (c) 2012-4 Purdue University\nCopyright (c) 1997-2002, Makoto Matsumoto and Takuji Nishimura\nAll rights reserved.\nFastR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\nR is a collaborative project with many contributors.\nType 'contributors()' for more information.\nType 'q()' to quit R.\n[Previously saved workspace restored]\n> 2 + 2\n11.7 Using FastR, the GraalVM Implementation of R | 379",3434
499-Problem.pdf,499-Problem,,0
500-Solution.pdf,500-Solution,,0
501-Discussion.pdf,501-Discussion,"[1] 4\n> ^D\nSave workspace image? [y/n/c]: n\n$\nFrom that point on, you should be able to do practically anything that you would do\nin standard R, since this R’s source code is largely derived from the R Foundation’s\nsource.\n11.8 Using R in a Web App\nProblem\nY ou want to display R’s data and graphics in a web page on a web server.\nSolution\nThere are several approaches that would achieve this effect:\n•Prepare the data, generate graphics as we did in Recipe 11.3 , and then incorpo‐\nrate both into a static web page.\n•Use one of several R add-on web frameworks , such as shiny  or Rook .\n•Invoke a JVM implementation of R from within a Servlet, JSF, Spring Bean, or\nother web-tier component.\nDiscussion\nThe first approach is trivial, and doesn’t need discussion here.\nFor the second, I’ll actually use timevis , which in turn uses shiny . This isn’t built in\nto the R library, so we first have to install it, using R’s install.packages() :\n$ R\n> install.packages ('timevis')\n> quit()\n$\nThis may take a while as it downloads and builds multiple dependencies.\nFor this demo I have a small dataset with some basic information on medieval litera‐\nture, which I load and display using shiny :\n# Draw the timeline for the epics.\nepics = read.table (""epics.txt"" , header=TRUE, fill=TRUE)\n# epics\n380 | Chapter 11: Data Science and R\nlibrary(""timevis"" )\ntimevis(epics)\nWhen run, this creates a temporary file containing HTML and JavaScript to allow\ninteractive exploration of the data. The library also opens this in a browser, shown in\nFigure 11-2 . One can explore the data by expanding or contracting the timeline and\nscrolling sideways.\nFigure 11-2. TimeVis (shiny) in action\nWhere there are two boxes (Cid, Sagas), the first is when the life or stories took place,\nand the second is when they were written down.\nTo expose this on the public web, copy the file (whose full path is revealed in the\nbrowser titlebar) and the lib folder in that same directory into a directory served by\nthe web server. Or just use File→Save As→Complete Web Page within the browser.\nEither way, you must do this while the R session is running, as the temporary files are\ndeleted when the session ends. Or, if you are familiar with the shiny  framework, you\ncan insert the timevis  visualization into a shiny  application.\n11.8 Using R in a Web App | 381",2376
502-Chapter 12. Network Clients.pdf,502-Chapter 12. Network Clients,,0
503-12.0 Introduction.pdf,503-12.0 Introduction,"CHAPTER 12\nNetwork Clients\n12.0 Introduction\nJava can be used to write many types of networked programs. In traditional socket-\nbased code, the programmer is responsible for structuring the interaction between\nthe client and server; the TCP socket code  simply ensures that whatever data you send\ngets to the other end. In higher-level types, such as HTTP , RMI, CORBA, and EJB, the\nsoftware takes over more control. Sockets are often used for connecting to legacy\nservers; if you were writing a new application from scratch, you’ d be better off using a\nhigher-level service.\nIt may be helpful to compare sockets with the telephone system. Telephones were\noriginally used for analog voice traffic, which is pretty unstructured. Then it began to\nbe used for some layered applications; the first widely popular one was facsimile\ntransmission, or fax. Where would fax be without the widespread availability of voice\ntelephony? The second wildly popular layered application historically was dial-up\nTCP/IP . This coexisted with the web to become popular as a mass-market service.\nWhere would dial-up IP be without widely deployed voice lines? And where would\nthe internet be without dial-up IP? Fax and dial-up are mostly gone now, but they\npaved the way for your smartphone’s networked ability, which is what makes it useful\n(and even seductive as a time sink).\nSockets are layered like that too. The web, RMI, JDBC, CORBA, and EJB are all lay‐\nered on top of sockets. HTTP is now the most common protocol and should gener‐\nally be used for new applications when all you want is to get data from point b to\npoint a.\nEver since the alpha release of Java (originally as a sideline to the HotJava browser) in\nMay 1995, Java has been popular as a programming language for building network\napplications. It’s easy to see why, particularly if you’ve ever built a networked\n383\napplication in C. First, C programmers have to worry about the platform they are on.\nUnix uses synchronous sockets, which work rather like normal disk files vis-à-vis\nreading and writing, whereas Microsoft OSes use asynchronous sockets, which use\ncallbacks to notify when a read or write has completed. Java glosses over this distinc‐\ntion. Further, the amount of code needed to set up a socket in C is intimidating. Just\nfor fun, Example 12-1  shows the typical C code for setting up a client socket. And\nremember, this is only the Unix part. And only the part that makes and closes the\nconnection. To be portable to Windows, it would need some additional conditional\ncode (using C’s #ifdef  mechanism). C’s #include  mechanism requires that exactly\nthe right files be included, and some files have to be listed in particular orders (Java’s\nimport  mechanism is much more flexible).\nExample 12-1. main/src/main/java/network/Connect.c (C client setup)\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\nint\nmain(int argc, char *argv[])\n{\n    char* server_name = ""localhost"";\n    struct hostent *host_info;\n    int sock;\n    struct sockaddr_in server;\n    /* Look up the remote host's IP address */\n    host_info = gethostbyname(server_name);\n    if (host_info == NULL) {\n        fprintf(stderr, ""%s: unknown host: %s\n"", argv[0], server_name);\n        exit(1);\n    }\n    /* Create the socket */\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        perror(""creating client socket"");\n        exit(2);\n    }\n    /* Set up the server's socket address */\n    server.sin_family = AF_INET;\n    memcpy((char *)&server.sin_addr, host_info->h_addr,\n                     host_info->h_length);\n    server.sin_port = htons(80);\n384 | Chapter 12: Network Clients",3795
504-12.1 HTTPREST Web Client.pdf,504-12.1 HTTPREST Web Client,,0
505-Solution.pdf,505-Solution,"/* Connect to the server */\n    if (connect(sock,(struct sockaddr *)&server,sizeof server) < 0) {\n        perror(""connecting to server"");\n        exit(4);\n    }\n    /* Finally, we can read and write on the socket. */\n    /* ... */\n    (void) close(sock);\n}\nIn the first recipe, we’ll see how to do the connect in essentially one line of Java (plus\na bit of error handling). We’ll then cover error handling and transferring data over a\nsocket. Next, we’ll take a quick look at a datagram  or UDP client that implements\nmost of the TFTP (Trivial File Transfer Protocol) that has been used for two decades\nto boot diskless workstations. We’ll end with a program that connects interactively to\na chat server.\nA common theme through most of these client examples is to use existing servers so\nthat we don’t have to generate both the client and the server at the same time. Most of\nthese are services that exist on any standard Unix platform. If you can’t find a Unix\nserver near you to try them on, let me suggest that you take an old PC, maybe one\nthat’s underpowered for running the latest Microsoft software, and put up a free,\nopen source Unix system on it. My personal favorite is OpenBSD , and the market’s\noverall favorite is Linux. Both are readily available and can be installed for free over\nthe internet, and they offer all the standard services used in the client examples,\nincluding the time servers and TFTP . Both have free Java implementations available.\nI also provide basic coverage of web services clients. The term “web services” has\ncome to mean program-to-program communication using HTTP . The two general\ncategories are SOAP-based and REST-based. REST services are very simple—you\nsend an HTTP request and get back a response in plain text, or JSON ( Chapter 14 ) or\nXML. SOAP is more complicated and not covered in this book. There is more infor‐\nmation on the client-side connections in Java Network Programming  by Elliotte Har‐\nold (O’Reilly). I don’t cover the server-side APIs for building web services—JAX-RS\nand JAX-WS—because these are covered in several O’Reilly books .\n12.1 HTTP/REST Web Client\nProblem\nY ou need to read from a URL, for example, to connect to a RESTful web service or to\ndownload a web page or other resource over HTTP/HTTPS.\n12.1 HTTP/REST Web Client | 385",2341
506-12.2 Contacting a Socket Server.pdf,506-12.2 Contacting a Socket Server,"Solution\nUse the standard Java 11 HttpClient  or the URLConnection  class.\nThis technique applies anytime you need to read from a URL, not just a RESTful web\nservice.\nDiscussion\nPrior to Java 11, you had to either use the URLConnection  class or download and use\nthe older Apache HTTP Client Library. With Java 11, there is a fairly easy-to-use and\nflexible API in standard Java. It also supports HTTP/2.0; which the Apache\nHttpClient  does not as of early 2020, and the legacy URLConnection , which is\nunlikely ever to support HTTP/2.0.\nAs our simple example, we’ll use Google’s Suggest service, that is, what you see when\nyou type the first few characters of a search into the Google web search engine.\nThis Google service supports various output formats. The base URL is just the\nfollowing:\nhttps://suggestqueries.google.com/complete/search?client=firefox&q=\nAppend to it the word you want suggestions on. The client=firefox  tells it we want\na simple JSON format; with client=chrome  it contains more fields.\nTo use the Java HTTP Client API, you need a HttpClient  object, which you get using\nthe Builder pattern, then create a Request  object:\n        // This object would be kept for the life of an application\n        HttpClient  client = HttpClient .newBuilder ()\n            .followRedirects (Redirect .NORMAL)\n            .version(Version.HTTP_1_1 )\n            .build();\n        // Build the HttpRequest object to ""GET"" the urlString\n        HttpRequest  req =\n            HttpRequest .newBuilder (URI.create(urlString  +\n                URLEncoder .encode(keyword)))\n            .header(""User-Agent"" , ""Dept of Silly Walks"" )\n            .GET()\n            .build();\nThe HttpRequest  object can be sent using the client to get a HttpResponse  object,\nfrom which you can get the status and/or the body. Sending can be done either syn‐\nchronously (if you need the results right away) or asynchronously (if you can usefully\ndo something else in the meantime). This example shows sending it both synchro‐\nnously and asynchronously:\n386 | Chapter 12: Network Clients\n        // Send the request - synchronously\n        HttpResponse <String> resp =\n            client.send(req, BodyHandlers .ofString ());\n        // Collect the results\n        if (resp.statusCode () == 200) {\n            String response  = resp.body();\n            System.out.println(response );\n        } else {\n            System.out.printf(""ERROR: Status %d on request %s\n"" ,\n                resp.statusCode (), urlString );\n        }\n        // Send the request - asynchronously\n        client.sendAsync (req, BodyHandlers .ofString ())\n            .thenApply (HttpResponse: :body)\n            .thenAccept (System.out::println)\n            .join();\nHere is the output; the line has been broken at commas to make it fit on the page:\n$ java HttpClientDemo.java\n[""darwin"",[""darwin thompson"",""darwin"",""darwin awards"",""darwinism"",\n ""darwin australia"",""darwin thompson fantasy"",""darwin barney"",\n ""darwin theory"",""darwinai"",""darwin dormitorio""]]\nShould you not wish to use the HttpClient  library, you could  use the legacy code in\njava.net , since all we usually need here is the ability to open and read from a URL.\nHere is the code using a URLConnection :\npublic class RestClientURLDemo  {\n    public static void main(String[] args) throws Exception  {\n        URLConnection  conn = new URL(\n            HttpClientDemo .urlString  + HttpClientDemo .keyword)\n            .openConnection ();\n        try (BufferedReader  is =\n            new BufferedReader (new InputStreamReader (conn.getInputStream ()))) {\n            String line;\n            while ((line = is.readLine ()) != null) {\n                System.out.println(line);\n            }\n        }\n    }\n}\nThe output should be identical to what the HttpClient  version produced.\nSee Also\nDon’t confuse this HttpClient  with the older Apache HttpClient Library .\n12.1 HTTP/REST Web Client | 387",4001
507-Problem.pdf,507-Problem,,0
508-Solution.pdf,508-Solution,,0
509-See Also.pdf,509-See Also,"Y ou can find more information on REST services (including implementing the\nserver-side components for them) in Bill Burke’s RESTful Java with JAX-RS 2.0, 2nd\nEdition  (O’Reilly).\n12.2 Contacting a Socket Server\nProblem\nY ou need to contact a server using TCP/IP .\nSolution\nJust create a java.net.Socket , passing the hostname and port number into the\nconstructor.\nDiscussion\nThere isn’t much to this in Java. When creating a socket, you pass in the hostname\nand the port number. The java.net.Socket  constructor does the gethostbyname()\nand the socket()  system call, sets up the server’s sockaddr_in  structure, and exe‐\ncutes the connect()  call. All you have to do is catch the errors, which are subclassed\nfrom the familiar IOException . Example 12-2  sets up a Java network client but\ndoesn’t actually do any I/O yet. It uses try-with-resources to ensure that the socket is\nclosed automatically when we are done with it.\nExample 12-2. main/src/main/java/network/ConnectSimple.java (simple client\nconnection)\nimport java.net.Socket ;\n/* Client with NO error handling */\npublic class ConnectSimple  {\n    public static void main(String[] argv) throws Exception  {\n        try (Socket sock = new Socket(""localhost"" , 8080)) {\n            /* If we get here, we can read and write on the socket ""sock"" */\n            System.out.println("" *** Connected OK ***"" );\n            /* Do some I/O here... */\n        }\n    }\n}\n388 | Chapter 12: Network Clients",1483
510-12.3 Finding and Reporting Network Addresses.pdf,510-12.3 Finding and Reporting Network Addresses,,0
511-Problem.pdf,511-Problem,,0
512-Solution.pdf,512-Solution,,0
513-12.4 Handling Network Errors.pdf,513-12.4 Handling Network Errors,"This version does no real error reporting, but a version called ConnectFriendly  does;\nwe’ll see this version in Recipe 12.4 .\nSee Also\nJava supports other ways of using network applications. Y ou can also open a URL and\nread from it (see Recipe 12.8 ). Y ou can write code so that it will run from a URL,\nwhen opened in a web browser, or from an application.\n12.3 Finding and Reporting Network Addresses\nProblem\nY ou want to look up a host’s address name or number or get the address at the other\nend of a network connection.\nSolution\nGet an InetAddress  object.\nDiscussion\nThe InetAddress  object represents the internet address of a given computer or host.\nIt has no public constructors; you obtain an InetAddress  by calling the static getBy\nName()  method, passing in either a hostname like darwinsys.com  or a network\naddress as a string, like 1.23.45.67. All the “lookup” methods in this class can throw\nthe checked UnknownHostException  (a subclass of java.io.IOException ), which\nmust be caught or declared on the calling method’s header. None of these methods\nactually contact the remote host, so they do not throw the other exceptions related to\nnetwork connections.\nThe method getHostAddress()  gives you the numeric IP address (as a string) corre‐\nsponding to the InetAddress . The inverse is getHostName() , which reports the name\nof the InetAddress . This can be used to print the address of a host given its name, or\nvice versa:\npublic class InetAddrDemo  {\n    public static void main(String[] args) throws IOException  {\n        String hostName  = ""darwinsys.com"" ;\n        String ipNumber  = ""8.8.8.8"" ; // currently a well-known Google DNS server\n        // Show getting the InetAddress (looking up a host) by host name\n        System.out.println(hostName  + ""'s address is ""  +\n            InetAddress .getByName (hostName ).getHostAddress ());\n        // Look up a host by address\n12.3 Finding and Reporting Network Addresses | 389\n6The location where it is looked up varies. It might be in a file named /etc/services  on Unix; in the services  file in\na subdirectory of \ or _\winnt  in Windows; in a centralized registry such as Sun’s Network Information Serv‐\nices (NIS, formerly YP); or in some other platform- or network-dependent location.        System.out.println(ipNumber  + ""'s name is ""  +\n            InetAddress .getByName (ipNumber ).getHostName ());\n        // Look up my localhost addresss\n        final InetAddress  localHost  = InetAddress .getLocalHost ();\n        System.out.println(""My localhost address is ""  + localHost );\n        // Show getting the InetAddress from an open Socket\n        String someServerName  = ""google.com"" ;\n        // assuming there's a web server on the named server:\n        try (Socket theSocket  = new Socket(someServerName , 80)) {\n            InetAddress  remote = theSocket .getInetAddress ();\n            System.out.printf(""The InetAddress for %s is %s%n"" ,\n                someServerName , remote);\n        }\n    }\n}\nY ou can also get an InetAddress  from a Socket  by calling its getInetAddress()\nmethod. Y ou can construct a Socket  using an InetAddress  instead of a hostname\nstring. So, to connect to port number myPortNumber  on the same host as an existing\nsocket, you’ d use this:\nInetAddress remote = theSocket.getInetAddress( );\nSocket anotherSocket = new Socket(remote, myPortNumber);\nFinally, to look up all the addresses associated with a host—a server may be on more\nthan one network—use the static method getAllByName(host) , which returns an\narray of InetAddress  objects, one for each IP address associated with the given name.\nA static method  getLocalHost()  returns an InetAddress  equivalent to localhost  or\n127.0.0.1. This can be used to connect to a server program running on the same\nmachine as the client.\nIf you are using IPv6, you can use Inet6Address  instead.\nSee Also\nSee NetworkInterface  in Recipe 13.2 , which lets you find out more about the net‐\nworking of the machine you are running on. There is no way to look up services in\nthe standard API yet—that is, to find out that the HTTP service is on port 80. Full\nimplementations of TCP/IP have always included an additional set of resolvers; in C,\nthe call getservbyname(""http"" , ""tcp"");  would look up the given service6 and return\na servent  (service entry) structure whose s_port  member would contain the value\n390 | Chapter 12: Network Clients",4481
514-Problem.pdf,514-Problem,,0
515-12.5 Reading and Writing Textual Data.pdf,515-12.5 Reading and Writing Textual Data,"80. The numbers of established services do not change, but when services are new or\ninstalled in nonroutine ways, it is convenient to be able to change the service number\nfor all programs on a machine or network (regardless of programming language) just\nby changing the services definitions. Java should provide this capability in a future\nrelease.\n12.4 Handling Network Errors\nProblem\nY ou want more detailed reporting than just IOException  if something goes wrong.\nSolution\nCatch a greater variety of exception classes. SocketException  has several subclasses;\nthe most notable are ConnectException  and NoRouteToHostException . The names\nare self-explanatory: the first means that the connection was refused by the machine\nat the other end (the server machine), and the second completely explains the failure.\nExample 12-3  is an excerpt from the Connect  program, enhanced to handle these\nconditions.\nExample 12-3. ConnectFriendly.java\npublic class ConnectFriendly  {\n    public static void main(String[] argv) {\n        String server_name  = argv.length == 1 ? argv[0] : ""localhost"" ;\n        int tcp_port  = 80;\n        try (Socket sock = new Socket(server_name , tcp_port )) {\n            /* If we get here, we can read and write on the socket. */\n            System.out.println("" *** Connected to ""  + server_name   + "" ***"");\n            /* Do some I/O here... */\n        } catch (UnknownHostException  e) {\n            System.err.println(server_name  + "" Unknown host"" );\n            return;\n        } catch (NoRouteToHostException  e) {\n            System.err.println(server_name  + "" Unreachable""  );\n            return;\n        } catch (ConnectException  e) {\n            System.err.println(server_name  + "" connect refused"" );\n            return;\n        } catch (java.io.IOException  e) {\n            System.err.println(server_name  + ' ' + e.getMessage ());\n            return;\n        }\n12.4 Handling Network Errors | 391",1976
516-Problem.pdf,516-Problem,,0
517-Solution.pdf,517-Solution,,0
518-Discussion.pdf,518-Discussion,"}\n}\n12.5 Reading and Writing Textual Data\nProblem\nHaving connected, you wish to transfer textual data.\nSolution\nConstruct a BufferedReader  or PrintWriter  from the socket’s getInputStream()  or\ngetOutputStream() .\nDiscussion\nThe Socket  class has methods that allow you to get an InputStream  or OutputStream\nto read from or write to the socket. It has no method to fetch a Reader  or Writer ,\npartly because some network services are limited to ASCII, but mainly because the\nSocket  class was decided on before there were Reader  and Writer  classes. Y ou can\nalways create a Reader  from an InputStream  or a Writer  from an OutputStream\nusing the conversion classes. This is the paradigm for the two most common forms:\nBufferedReader is = new BufferedReader(\n    new InputStreamReader(sock.getInputStream( )));\nPrintWriter os = new PrintWriter(sock.getOutputStream( ), true);\nExample 12-4  reads a line of text from the daytime service, which is offered by full-\nfledged TCP/IP suites (such as those included with most Unixes). Y ou don’t have to\nsend anything to the Daytime  server; you simply connect and read one line. The\nserver writes one line containing the date and time and then closes the connection.\nRunning it looks like the following code. I started by getting the current date and\ntime on the local host, then ran the DaytimeText  program to see the date and time on\nthe server (machine darian  is one of my Unix servers):\nC:\javasrc\network> date \nCurrent date is Sun 01-23-2000\nEnter new date (mm-dd-yy):\nC:\javasrc\network> time\nCurrent time is  1:13:18.70p\nEnter new time:\nC:\javasrc\network> java network.DaytimeText darian\nTime on darian is Sun Jan 23 13:14:34 2000\nThe code is in class DaytimeText , shown in Example 12-4 .\n392 | Chapter 12: Network Clients\n6It used to be universal, when most networked systems were administered by full-time systems people who had\nbeen trained or served an apprenticeship. Today many machines on the internet don’t have localhost  config‐\nured properly.Example 12-4. DaytimeText.java\npublic class DaytimeText  {\n    public static final short TIME_PORT  = 13;\n    public static void main(String[] argv) {\n        String server_name  = argv.length == 1 ? argv[0] : ""localhost"" ;\n        try (Socket sock = new Socket(server_name ,TIME_PORT );\n            BufferedReader  is = new BufferedReader (new\n                InputStreamReader (sock.getInputStream ()));) {\n            String remoteTime  = is.readLine ();\n            System.out.println(""Time on ""  + server_name  + "" is "" + remoteTime );\n        } catch (IOException  e) {\n            System.err.println(e);\n        }\n    }\n}\nThe second example, shown in Example 12-5 , shows both reading and writing on the\nsame socket. The Echo  server simply echoes back whatever lines of text you send it.\nIt’s not a very clever server, but it is a useful one. It helps in network testing and also\nin testing clients of this type!\nThe converse()  method holds a short conversation with the Echo  server on the\nnamed host; if no host is named, it tries to contact localhost , a universal alias6 for\nthe machine the program is running on.\nExample 12-5. main/src/main/java/network/EchoClientOneLine.java\npublic class EchoClientOneLine  {\n    /** What we send across the net */\n    String mesg = ""Hello across the net"" ;\n    public static void main(String[] argv) {\n        if (argv.length == 0)\n            new EchoClientOneLine ().converse (""localhost"" );\n        else\n            new EchoClientOneLine ().converse (argv[0]);\n    }\n    /** Hold one conversation across the net */\n    protected  void converse (String hostName ) {\n        try (Socket sock = new Socket(hostName , 7);) { // echo server.\n            BufferedReader  is = new BufferedReader (new\n12.5 Reading and Writing Textual Data | 393",3876
519-12.6 Reading and Writing Binary or Serialized Data.pdf,519-12.6 Reading and Writing Binary or Serialized Data,,0
520-Problem.pdf,520-Problem,,0
521-Solution.pdf,521-Solution,,0
522-Discussion.pdf,522-Discussion,"InputStreamReader (sock.getInputStream ()));\n            PrintWriter  os = new PrintWriter (sock.getOutputStream (), true);\n            // Do the CRLF ourself since println appends only a \r on\n            // platforms where that is the native line ending.\n            os.print(mesg + ""\r\n""); os.flush();\n            String reply = is.readLine ();\n            System.out.println(""Sent \""""  + mesg  + ""\"""");\n            System.out.println(""Got  \""""  + reply + ""\"""");\n        } catch (IOException  e) {\n            System.err.println(e);\n        }\n    }\n}\nIt might be a good exercise to isolate the reading and writing code from this method\ninto a NetWriter  class, possibly subclassing PrintWriter  and adding the \r\n  and\nthe flushing.\n12.6 Reading and Writing Binary or Serialized Data\nProblem\nHaving connected, you wish to transfer binary data, either raw binary data or serial‐\nized Java objects.\nSolution\nFor plain binary date, construct a DataInputStream  or DataOutputStream  from the\nsocket’s getInputStream()  or getOutputStream() . For serialized Java object data,\nconstruct an ObjectInputStream  or ObjectOutputStream .\nDiscussion\nThe simplest paradigm for reading/writing on a socket is this:\nDataInputStream is = new DataInputStream(sock.getInputStream());\nDataOutputStream is = new DataOutputStream(sock.getOutputStream( ));\nIf the volume of data might be large, insert a buffered stream for efficiency. The para‐\ndigm is this:\nDataInputStream is = new DataInputStream(\n    new BufferedInputStream(sock.getInputStream( )));\nDataOutputStream is = new DataOutputStream(\n    new BufferedOutputStream(sock.getOutputStream( )));\nThe program example in Example 12-6  uses another standard service that gives out\nthe time as a binary integer representing the number of seconds since 1900. Because\nthe Java Date  class base is 1970, we convert the time base by subtracting the difference\n394 | Chapter 12: Network Clients\nbetween 1970 and 1900. When I used this exercise in a course, most of the students\nwanted to add this time difference, reasoning that 1970 is later. But if you think\nclearly, you’ll see that there are fewer seconds between 1999 and 1970 than there are\nbetween 1999 and 1900, so subtraction gives the correct number of seconds. And\nbecause the Date  constructor needs milliseconds, we multiply the number of seconds\nby 1,000.\nThe time difference is the number of years multiplied by 365, plus the number of leap\ndays between the two dates (in the years 1904, 1908, . . . , 1968)—19 days.\nThe integer that we read from the server is a C-language unsigned int . But Java\ndoesn’t provide an unsigned integer type; normally when you need an unsigned num‐\nber, you use the next-larger integer type, which would be long . But Java also doesn’t\ngive us a method to read an unsigned integer from a data stream. The DataInput\nStream  method readInt()  reads Java-style signed integers. There are readUnsigned\nByte()  methods and readUnsignedShort()  methods, but no readUnsignedInt()\nmethod. Accordingly, we synthesize the ability to read an unsigned int (which must\nbe stored in a long , or else you’ d lose the signed bit and be back where you started\nfrom) by reading unsigned bytes and reassembling them using Java’s bit-shifting\noperators:\nAt the end of the code, we use the new date/time API (see Chapter 6 ) to construct and\nprint a LocalDateTime  object to show the current date and time on the local (client)\nmachine:\n$ date\nThu Dec 26 09:48:36 EST 2019\njava network.RDateClient aragorn\nRemote time is 3786360519\nBASE_DIFF is 2208988800\nTime diff == 1577371719\nTime on aragorn is 2019-12-26T09:48:39\nLocal date/time = 2019-12-26T09:48:41.208180\n$\nThe name aragorn  is the hostname of one of my OpenBSD Unix computers. Looking\nat the output, you can see that the server agrees within a second or two. That con‐\nfirms the date calculation code in Example 12-6 . This protocol is commonly known\nas rdate , so the client code is called RDateClient .\nExample 12-6. main/src/main/java/network/RDateClient.java\npublic class RDateClient  {\n    /** The TCP port for the binary time service. */\n    public static final short TIME_PORT  = 37;\n    /** Seconds between 1970, the time base for dates and times\n     * Factors in leap years (up to 2100), hours, minutes, and seconds.\n12.6 Reading and Writing Binary or Serialized Data | 395\n     * Subtract 1 day for 1900, add in 1/2 day for 1969/1970.\n     */\n    protected  static final long BASE_DAYS  =\n        (long)((1970-1900)*365 + (1970-1900-1)/4);\n    /* Seconds since 1970 */\n    public static final long BASE_DIFF  = (BASE_DAYS  * 24 * 60 * 60);\n    public static void main(String[] argv) {\n        String hostName ;\n        if (argv.length == 0)\n            hostName  = ""localhost"" ;\n        else\n            hostName  = argv[0];\n        try (Socket sock = new Socket(hostName ,TIME_PORT );) {\n            DataInputStream  is = new DataInputStream (new\n                BufferedInputStream (sock.getInputStream ()));\n            // Read 4 bytes from the network, unsigned.\n            // Do it yourself; there is no readUnsignedInt().\n            // Long is 8 bytes on Java, but we are using the\n            // existing time protocol, which uses 4-byte ints.\n            long remoteTime  = (\n                ((long)(is.readUnsignedByte ()) << 24) |\n                ((long)(is.readUnsignedByte ()) << 16) |\n                ((long)(is.readUnsignedByte ()) <<  8) |\n                ((long)(is.readUnsignedByte ()) <<  0));\n            System.out.println(""Remote time is ""  + remoteTime );\n            System.out.println(""BASE_DIFF is ""  + BASE_DIFF );\n            System.out.println(""Time diff == ""  + (remoteTime  - BASE_DIFF ));\n            Instant time = Instant.ofEpochSecond (remoteTime  - BASE_DIFF );\n            LocalDateTime  d = LocalDateTime .ofInstant (time, ZoneId.systemDefault ());\n            System.out.println(""Time on ""  + hostName  + "" is "" + d.toString ());\n            System.out.println(""Local date/time = ""  + LocalDateTime .now());\n        } catch (IOException  e) {\n            System.err.println(e);\n        }\n    }\n}\nObject serialization  is the ability to convert in-memory objects to an external form\nthat can be sent serially (a byte at a time). To read or write Java objects via serializa‐\ntion, you need only construct an ObjectInputStream  or ObjectOutputStream  from\nan InputStream  or OutputStream ; in this case, the socket’s getInputStream()  or\ngetOutputStream() .\nThis program (and its server) provide a service that isn’t a standard part of the\nTCP/IP stack; it’s a service I made up as a demo. The server for this service is intro‐\nduced in Recipe 13.3 . The client code in Example 12-7  is quite similar to the Daytime\nBinary  program in the previous recipe, but the server sends us a LocalDateTime\n396 | Chapter 12: Network Clients",6970
523-12.7 UDP Datagrams.pdf,523-12.7 UDP Datagrams,,0
524-Problem.pdf,524-Problem,,0
525-Solution.pdf,525-Solution,,0
526-Discussion.pdf,526-Discussion,"object already constructed. Example 12-7  shows the portion of the client code that\ndiffers from Example 12-6 .\nExample 12-7. main/src/main/java/network/DaytimeObject.java\n        try (Socket sock = new Socket(hostName , TIME_PORT );) {\n            ObjectInputStream  is = new ObjectInputStream (new\n                BufferedInputStream (sock.getInputStream ()));\n            // Read and validate the Object\n            Object o = is.readObject ();\n            if (o == null) {\n                System.err.println(""Read null from server!"" );\n            } else if ((o instanceof  LocalDateTime )) {\n                // Valid, so cast to LocalDateTime, and print\n                LocalDateTime  d = (LocalDateTime ) o;\n                System.out.println(""Time on ""  + hostName  + "" is "" + d);\n            } else {\n                throw new IllegalArgumentException (\n                    String.format(""Wanted LocalDateTime, got %s, a %s"" ,\n                        o, o.getClass ()));\n            }\nI ask the operating system for the date and time, and then I run the program, which\nprints the date and time on a remote machine:\n$ date\nThu Dec 26 09:29:02 EST 2019\nC:\javasrc\network> java network.DaytimeObject aragorn\nTime on aragorn is 2019-12-26T09:29:05.227397\nC:\javasrc\network>\nAgain, the results agree within a few seconds.\n12.7 UDP Datagrams\nProblem\nY ou need to use a datagram connection (UDP) instead of a stream connection (TCP).\nSolution\nUse DatagramSocket  and DatagramPacket .\nDiscussion\nDatagram network traffic is a kindred spirit to the underlying packet-based Ethernet\nand IP (Internet Protocol) layers. Unlike a stream-based connection such as TCP ,\n12.7 UDP Datagrams | 397\n6The UDP packet may need to be fragmented by some networks, but this is not germane to us at the UDP\nlevel, because it will reassemble the network packets into our single-entity UDP packet at the other end.datagram  transports like UDP transmit each packet , or chunk of data, as a single\nentity with no necessary relation to any other.6 A common analogy is that TCP is like\ntalking on the telephone, whereas UDP is like sending postcards or maybe fax\nmessages.\nThe differences show up most in error handling. Packets can, like postcards, go\nastray. When was the last time the postman rang your bell to tell you that the post\noffice had lost one of several postcards it was supposed to deliver to you? That’s not\ngoing to happen, because the post office doesn’t keep track of postcards. On the other\nhand, when you’re talking on the phone and there’s a noise burst—like somebody\nyelling in the room, or even a bad connection—you notice the failure in real time,\nand you can ask the person at the other end to repeat what they just said.\nWith a stream-based connection like a TCP socket, the network transport layer han‐\ndles errors for you: it asks the other end to retransmit. With a datagram transport\nsuch as UDP , you have to handle retransmission yourself. It’s kind of like numbering\nthe postcards you send so that you can go back and resend any that don’t arrive—a\ngood excuse to return to your vacation spot, perhaps.\nAnother difference is that datagram transmission preserves message boundaries. That\nis, if you write 20 bytes and then write 10 bytes when using TCP , the program reading\nfrom the other end will not know if you wrote one chunk of 30 bytes, two chunks of\n15, or even 30 individual characters. With a DatagramSocket , you construct a Data\ngramPacket  object for each buffer, and its contents are sent as a single  entity over the\nnetwork; its contents will not be mixed together with the contents of any other buffer.\nThe DatagramPacket  object has methods like getLength()  and setPort() .\nIan’s Basic Steps: UDP Client\nUDP is a bit more involved, so I’ll list the basic steps for generating a UDP client:\n1.Create a DatagramSocket  with no arguments (the form that takes two arguments\nis used on the server).\n2.Optionally connect()  the socket to an InetAddress  (see Recipe 12.3 ) and port\nnumber.\n3.Create one or more DatagramPacket  objects; these are wrappers around a byte\narray that contains data you want to send and is filled in with data you receive.\n4.If you did not connect()  the socket, provide the InetAddress  and port when\nconstructing the DatagramPacket .\n398 | Chapter 12: Network Clients\n5.Set the packet’s length and use sock.send(packet)  to send data to the server.\n6.Use sock.receive()  to retrieve data.\nSo why would we even use UDP? UDP has a lot less overhead than TCP , which can be\nparticularly valuable when sending huge amounts of data over a reliable local net‐\nwork or a few hops on the internet. Over long-haul networks, TCP is probably prefer‐\nred because TCP handles retransmission of lost packets for you. And obviously, if\npreserving record boundaries makes your life easier, that may be a reason for consid‐\nering UDP . UDP is also the way to perform Multicast (broadcast to many receivers\nsimultaneously), though Multicast is out of scope for this discussion.\nExample 12-8  is a short program that connects via UDP to the Daytime  date and time\nserver used in Recipe 12.5 . Because UDP has no real notion of connection, the client\ntypically initiates the conversation, which sometimes means sending an empty\npacket; the UDP server uses the address information it gets from that to return its\nresponse.\nExample 12-8. main/src/main/java/network/DaytimeUDP .java\npublic class DaytimeUDP  {\n    /** The UDP port number */\n    public final static int DAYTIME_PORT  = 13;\n    /** A buffer plenty big enough for the date string */\n    protected  final static int PACKET_SIZE  = 100;\n    /** The main program that drives this network client.\n     * @param argv[0] hostname, running daytime/udp server\n     */\n    public static void main(String[] argv) throws IOException  {\n        if (argv.length < 1) {\n            System.err.println(""usage: java DayTimeUDP host"" );\n            System.exit(1);\n        }\n        String host = argv[0];\n        InetAddress  servAddr  = InetAddress .getByName (host);\n        DatagramSocket  sock = new DatagramSocket ();\n        //sock.connect(servAddr, DAYTIME_PORT);\n        byte[] buffer = new byte[PACKET_SIZE ];\n        // The udp packet we will send and receive\n        DatagramPacket  packet = new DatagramPacket (\n            buffer, PACKET_SIZE , servAddr , DAYTIME_PORT );\n        /* Send empty max-length (-1 for null byte) packet to server */\n        packet.setLength (PACKET_SIZE -1);\n        sock.send(packet);\n12.7 UDP Datagrams | 399",6641
527-12.8 URI URL or URN.pdf,527-12.8 URI URL or URN,,0
528-Problem.pdf,528-Problem,,0
529-Solution.pdf,529-Solution,,0
530-12.9 Program TFTP UDP Client.pdf,530-12.9 Program TFTP UDP Client,"System.out.println(""Sent request"" );\n        // Receive a packet and print it.\n        sock.receive(packet);\n        System.out.println(""Got packet of size ""  + packet.getLength ());\n        System.out.print(""Date on ""  + host + "" is "" +\n            new String(buffer, 0, packet.getLength ()));\n        sock.close();\n    }\n}\nI’ll run it to my Unix box just to be sure that it works:\n$\n$ java network.DaytimeUDP aragorn\nSent request\nGot packet of size 26\nDate on aragorn is Sat Feb  8 20:22:12 2014\n$\n12.8 URI, URL, or URN?\nProblem\nHaving heard these terms, you want to know the difference between a URI, URL, and\nURN.\nSolution\nRead on. Or see the javadoc for java.net.uri .\nDiscussion\nA URL is the traditional name for a network address consisting of a scheme (like\nHTTP) and an address (site name) and resource or pathname. But there are three dis‐\ntinct terms in all:\n•URI (Uniform Resource Identifier)\n•URL (Uniform Resource Locator)\n•URN (Uniform Resource Name)\nA discussion near the end of the Java documentation for the new class explains the\nrelationship among URI, URL, and URN. URIs form the set of all identifiers. URLs\nand URNs are subsets.\n400 | Chapter 12: Network Clients\nURIs are the most general; a URI is parsed for basic syntax without regard to the\nscheme, if any, that it specifies, and it need not refer to a particular server. A URL\nincludes a hostname, scheme, and other components; the string is parsed according\nto rules for its scheme. When you construct a URL, an InputStream  is created auto‐\nmatically. URNs name resources but do not explain how to locate them; typical exam‐\nples of URNs that you will have seen include mailto:  and news:  references.\nThe main operations provided by the URI class are normalization (removing extrane‐\nous path segments including “.. ”) and relativization (this should be called “making rel‐\native, ” but somebody wanted a single word to make a method name). A URI object\ndoes not have any methods for opening the URI; for that, you would normally use a\nstring representation of the URI to construct a URL object, like so:\nURL x = new URL(theURI.toString( ));\nThe program in Example 12-9  shows examples of normalizating, making relative, and\nconstructing a URL from a URI.\nExample 12-9. main/src/main/java/network/URIDemo.java\npublic class URIDemo {\n    public static void main(String[] args)\n    throws URISyntaxException , MalformedURLException  {\n        URI u = new URI(""https://darwinsys.com/java/../openbsd/../index.jsp"" );\n        System.out.println(""Raw: "" + u);\n        URI normalized  = u.normalize ();\n        System.out.println(""Normalized: ""  + normalized );\n        final URI BASE = new URI(""https://darwinsys.com"" );\n        System.out.println(""Relativized to ""  + BASE + "": "" + BASE.relativize (u));\n        // A URL is a type of URI\n        URL url = new URL(normalized .toString ());\n        System.out.println(""URL: "" + url);\n        // Demo of non-URL but valid URI\n        URI uri = new URI(""bean:WonderBean"" );\n        System.out.println(uri);\n    }\n}\n12.9 Program: TFTP UDP Client\nThis program implements the client half of the TFTP application protocol, a once-\nwell-known service that has been used in the Unix world for network booting of\nworkstations since before Windows 3.1, now primarily used for network bootstrap‐\nping of computers. I chose this protocol because it’s widely implemented on the\nserver side, so it’s easy to find a test server for it.\n12.9 Program: TFTP UDP Client | 401\n6When the application doesn’t care, these port numbers are usually made up by the operating system. For\nexample, when you call a company from a pay phone or cell phone, the company doesn’t usually care what\nnumber you are calling from, and if it does, there are ways to find out. Generated port numbers generally\nrange from 1024 (the first nonprivileged port; see Chapter 13 ) to 65535 (the largest value that can be held in a\n16-bit port number).The TFTP protocol is a bit odd. The client contacts the server on the well-known\nUDP port number 69, from a generated port number,6 and the server responds to the\nclient from a generated port number. Further communication is on the two generated\nport numbers.\nGetting into more detail, as shown in Figure 12-1 , the client initially sends a read\nrequest with the filename and reads the first packet of data. The read request consists\nof two bytes (a short ) with the read request code (short integer with a value of 1,\ndefined as OP_RRQ ), two bytes for the sequence number, then the ASCII filename, null\nterminated, and the mode string, also null terminated. The server reads the read\nrequest from the client, verifies that it can open the file and, if so, sends the first data\npacket (OP_DATA ), and then reads again. The client reads from its end and, if the read\nis OK, turns the packet into an acknowledgement packet, and sends it. This read-\nacknowledge cycle is repeated until all the data is read. Note that each packet is 516\nbytes (512 bytes of data, plus 2 bytes for the packet type and 2 more for the packet\nnumber) except the last, which can be any length from 4 (zero bytes of data) to 515\n(511 bytes of data). If a network I/O error occurs, the packet is resent. If a given\npacket goes astray, both client and server are supposed to perform a timeout cycle.\nThis client does not, but the server does. Y ou could add timeouts either using a\nthread (see Recipe 16.4 ) or by invoking setSoTimeout()  on the socket and, if packets\ndo get lost, catching the SocketTimeoutException , retransmitting the ACK (or\nRRQ), perhaps up to some max number of attempts. This is left as an exercise for the\nreader. The current version of the client code is shown in Example 12-10 .\n402 | Chapter 12: Network Clients\nFigure 12-1. The TFTP protocol packet formats\nExample 12-10. main/src/main/java/network/RemCat.java\npublic class RemCat {\n    /** The UDP port number */\n    public final static int TFTP_PORT  = 69;\n    /** The mode we will use - octet for everything. */\n    protected  final String MODE = ""octet"";\n    /** The offset for the code/response as a byte */\n    protected  final int OFFSET_REQUEST  = 1;\n    /** The offset for the packet number as a byte */\n    protected  final int OFFSET_PACKETNUM  = 3;\n    /** Debugging flag */\n    protected  static boolean debug = false;\n    /** TFTP op-code for a read request */\n    public final int OP_RRQ = 1;\n    /** TFTP op-code for a read request */\n    public final int OP_WRQ = 2;\n    /** TFTP op-code for a read request */\n    public final int OP_DATA = 3;\n    /** TFTP op-code for a read request */\n    public final int OP_ACK    = 4;\n    /** TFTP op-code for a read request */\n12.9 Program: TFTP UDP Client | 403\n    public final int OP_ERROR  = 5;\n    protected  final static int PACKET_SIZE  = 516;    // == 2 + 2 + 512\n    protected  String host;\n    protected  InetAddress  servAddr ;\n    protected  DatagramSocket  sock;\n    protected  byte buffer[];\n    protected  DatagramPacket  inp, outp;\n    /** The main program that drives this network client.\n     * @param argv[0] hostname, running TFTP server\n     * @param argv[1..n] filename(s), must be at least one\n     */\n    public static void main(String[] argv) throws IOException  {\n        if (argv.length < 2) {\n            System.err.println(""usage: rcat host filename[...]"" );\n            System.exit(1);\n        }\n        if (debug)\n            System.err.println(""Java RemCat starting"" );\n        RemCat rc = new RemCat(argv[0]);\n        for (int i = 1; i<argv.length; i++) {\n            if (debug)\n                System.err.println(""-- Starting file ""  +\n                    argv[0] + "":"" + argv[i] + ""---"");\n            rc.readFile (argv[i]);\n        }\n    }\n    RemCat(String host) throws IOException  {\n        super();\n        this.host = host;\n        servAddr  = InetAddress .getByName (host);\n        sock = new DatagramSocket ();\n        buffer = new byte[PACKET_SIZE ];\n        outp = new DatagramPacket (buffer, PACKET_SIZE , servAddr , TFTP_PORT );\n        inp = new DatagramPacket (buffer, PACKET_SIZE );\n    }\n    /* Build a TFTP Read Request packet. This is messy because the\n     * fields have variable length. Numbers must be in\n     * network order, too; fortunately Java just seems\n     * naturally smart enough :-) to use network byte order.\n     */\n    void readFile (String path) throws IOException  {\n        buffer[0] = 0;\n        buffer[OFFSET_REQUEST ] = OP_RRQ;        // read request\n        int p = 2;            // number of chars into buffer\n        // Convert filename String to bytes in buffer , using ""p"" as an\n        // offset indicator to get all the bits of this request\n        // in exactly the right spot.\n404 | Chapter 12: Network Clients\n        byte[] bTemp = path.getBytes ();    // i.e., ASCII\n        System.arraycopy (bTemp, 0, buffer, p, path.length());\n        p += path.length();\n        buffer[p++] = 0;        // null byte terminates string\n        // Similarly, convert MODE (""stream"" or ""octet"") to bytes in buffer\n        bTemp = MODE.getBytes ();    // i.e., ASCII\n        System.arraycopy (bTemp, 0, buffer, p, MODE.length());\n        p += MODE.length();\n        buffer[p++] = 0;        // null terminate\n        /* Send Read Request to tftp server */\n        outp.setLength (p);\n        sock.send(outp);\n        /* Loop reading data packets from the server until a short\n         * packet arrives; this indicates the end of the file.\n         */\n        do {\n            sock.receive(inp);\n            if (debug)\n                System.err.println(\n                    ""Packet # ""  + Byte.toString (buffer[OFFSET_PACKETNUM ])+\n                    ""RESPONSE CODE ""  + Byte.toString (buffer[OFFSET_REQUEST ]));\n            if (buffer[OFFSET_REQUEST ] == OP_ERROR ) {\n                System.err.println(""rcat ERROR: ""  +\n                    new String(buffer, 4, inp.getLength ()-4));\n                return;\n            }\n            if (debug)\n                System.err.println(""Got packet of size ""  +\n                    inp.getLength ());\n            /* Print the data from the packet */\n            System.out.write(buffer, 4, inp.getLength ()-4);\n            /* Ack the packet. The block number we\n             * want to ack is already in buffer so\n             * we just change the opcode. The ACK is\n             * sent to the port number which the server\n             * just sent the data from, NOT to port\n             * TFTP_PORT.\n             */\n            buffer[OFFSET_REQUEST ] = OP_ACK;\n            outp.setLength (4);\n            outp.setPort(inp.getPort());\n            sock.send(outp);\n        } while (inp.getLength () == PACKET_SIZE );\n        if (debug)\n            System.err.println(""** ALL DONE** Leaving loop, last size ""  +\n                inp.getLength ());\n12.9 Program: TFTP UDP Client | 405",11048
531-12.10 Program Sockets-Based Chat Client.pdf,531-12.10 Program Sockets-Based Chat Client,"6Beware of security holes; don’t turn a TFTP server loose on the internet without first reading a good security\nbook, such as Building Internet Firewalls  by D. Chapman et al. (O’Reilly).\n7For an open source program that provides an IM service to let you talk to both from the same program, check\nout Jabber at http://www.jabber.org .    }\n}\nTo test this client, you need a TFTP server. If you are on a Unix system that you\nadminister, you can enable the TFTP server to test this client just by editing the\nfile /etc/inetd.conf  and restarting or reloading the inetd  server (Linux uses a different\nmechanism, which may vary depending on which distribution you are on). inetd  is a\nprogram that listens for a wide range of connections and starts the servers only when\na connection from a client comes along (a kind of lazy evaluation).6 I set up the tradi‐\ntional /tftpboot  directory, put this line in my inetd.conf , and reloaded inetd :\ntftp dgram udp wait root /usr/libexec/tftpd tftpd -s /tftpboot\nThen I put a few test files, one named foo, into the /tftpboot  directory. Running\n$ java network.RemCat localhost foo\nproduced what looked like the file. But just to be safe, I tested the output of RemCat\nagainst the original file, using the Unix diff comparison program. No news is good\nnews:\n$ java network.RemCat localhost foo | diff - /tftpboot/foo\nSo far so good. Let’s not slip this program on an unsuspecting network without exer‐\ncising the error handling at least briefly:\n$ java network.RemCat localhost nosuchfile \nremcat ERROR: File not found\n$\n12.10 Program: Sockets-Based Chat Client\nThis program is a simple chat program. Y ou can’t break in on ICQ or AIM with it,\nbecause they each use their own protocol.7 Rather, this program simply writes to and\nreads from a server. The server for this will be presented in Chapter 13 . How does it\nlook when you run it? Figure 12-2  shows me chatting all by myself one day.\nThe code is reasonably self-explanatory. We read from the remote server in a thread\nto make the input and the output run without blocking each other; this is discussed\nin Chapter 16 . The reading and writing are discussed in this chapter. The program is\nshown in Example 12-11 .\n406 | Chapter 12: Network Clients\nFigure 12-2. Chat client in action\nExample 12-11. main/src/main/java/chat/ChatClient.java\npublic class ChatClient  extends JFrame {\n    private static final long serialVersionUID  = -3686334002367908392L ;\n    private static final String userName  =\n        System.getProperty (""user.name"" , ""User With No Name"" );\n    /** The state of logged-in-ness */\n    protected  boolean loggedIn ;\n    /* The main Frame. */\n    protected  JFrame cp;\n    /** The default port number */\n    protected  static final int PORTNUM = ChatProtocol .PORTNUM;\n    /** The actual port number */\n    protected  int port;\n    /** The network socket */\n    protected  Socket sock;\n    /** PrintWriter for sending lines on socket */\n    protected  PrintWriter  pw;\n    /** TextField for input */\n    protected  JTextField  tf;\n    /** TextArea to display conversations */\n    protected  JTextArea  ta;\n    /** The Login Button */\n    protected  JButton loginButton ;\n    /** The LogOUT button */\n    protected  JButton logoutButton ;\n    /** The TitleBar title */\n    final static String TITLE = ""ChatClient: Ian Darwin's Chat Room Client"" ;\n    final Executor  threadPool  = Executors .newSingleThreadExecutor ();\n    /** set up the GUI */\n    public ChatClient () {\n        cp = this;\n        cp.setTitle (TITLE);\n12.10 Program: Sockets-Based Chat Client | 407\n        cp.setLayout (new BorderLayout ());\n        port = PORTNUM;\n        // The GUI\n        ta = new JTextArea (14, 80);\n        ta.setEditable (false);        // readonly\n        ta.setFont(new Font(""Monospaced"" , Font.PLAIN, 11));\n        cp.add(BorderLayout .NORTH, ta);\n        JPanel p = new JPanel();\n        // The login button\n        p.add(loginButton  = new JButton(""Login""));\n        loginButton .setEnabled (true);\n        loginButton .requestFocus ();\n        loginButton .addActionListener (e -> {\n                login();\n                loginButton .setEnabled (false);\n                logoutButton .setEnabled (true);\n                tf.requestFocus ();    // set keyboard focus in right place!\n        });\n        // The logout button\n        p.add(logoutButton  = new JButton(""Logout"" ));\n        logoutButton .setEnabled (false);\n        logoutButton .addActionListener (e -> {\n                logout();\n                loginButton .setEnabled (true);\n                logoutButton .setEnabled (false);\n                loginButton .requestFocus ();\n        });\n        p.add(new JLabel(""Message here:"" ));\n        tf = new JTextField (40);\n        tf.addActionListener (e -> {\n                if (loggedIn ) {\n                    pw.println(ChatProtocol .CMD_BCAST +tf.getText());\n                    tf.setText("""");\n                }\n        });\n        p.add(tf);\n        cp.add(BorderLayout .SOUTH, p);\n        cp.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE );\n        cp.pack();\n    }\n    protected  String serverHost  = ""localhost"" ;\n    /** LOG ME IN TO THE CHAT */\n    public void login() {\n408 | Chapter 12: Network Clients\n        /** BufferedReader for reading from socket */\n        BufferedReader  is;\n        showStatus (""In login!"" );\n        if (loggedIn )\n            return;\n        try {\n            sock = new Socket(serverHost , port);\n            is = new BufferedReader (new InputStreamReader (sock.getInputStream ()));\n            pw = new PrintWriter (sock.getOutputStream (), true);\n            showStatus (""Got socket"" );\n            // FAKE LOGIN FOR NOW - no password needed\n            pw.println(ChatProtocol .CMD_LOGIN  + userName );\n            loggedIn  = true;\n        } catch(IOException  e) {\n            warn(""Can't get socket to ""  +\n                serverHost  + ""/"" + port + "": "" + e);\n            cp.add(new JLabel(""Can't get socket: ""  + e));\n            return;\n        }\n        // Construct and start the reader: from server to textarea.\n        // Make a Thread to avoid lockups.\n        Runnable  readerThread  = new Runnable () {\n            public void run() {\n                String line;\n                try {\n                    while (loggedIn  && ((line = is.readLine ()) != null))\n                        ta.append(line + ""\n"");\n                } catch(IOException  e) {\n                    showStatus (""Lost another client!\n""  + e);\n                    return;\n                }\n            }\n        };\n        threadPool .execute(readerThread );\n    }\n    /** Log me out, Scotty, there's no intelligent life here! */\n    public void logout() {\n        if (!loggedIn )\n            return;\n        loggedIn  = false;\n        try {\n            if (sock != null)\n                sock.close();\n        } catch (IOException  ign) {\n            // so what?\n        }\n12.10 Program: Sockets-Based Chat Client | 409",7131
532-See Also.pdf,532-See Also,,0
533-12.11 Program Simple HTTP Link Checker.pdf,533-12.11 Program Simple HTTP Link Checker,"}\n    public void showStatus (String message) {\n        System.out.println(message);\n    }\n    private void warn(String message) {\n        JOptionPane .showMessageDialog (this, message);\n    }\n    /** A main method to allow the client to be run as an Application */\n    public static void main(String[] args) {\n        ChatClient  room101 = new ChatClient ();\n        room101.pack();\n        room101.setVisible (true);\n    }\n}\nSee Also\nThere are many better-structured ways to write a chat client, including WebSockets,\nRMI, and JMS. RMI is Java’s RPC interface and is included both in Java SE and Java\nEE; it is not described in this edition of this book, but you can find the RMI chapter\nfrom previous editions on the my website . The other technologies are part of the Java\nEnterprise so, again, I refer you to Arun Gupta’s Java EE 7 Essentials .\nIf your communication goes over the public internet, you do need to encrypt your\nsocket connection, so check out Sun’s JSSE (Java Secure Socket Extension). If you\ntook my earlier advice and used the standard HTTP protocol, you can encrypt the\nconversation just by changing the URL to https.\nFor a good overview of network programming from the C programmer’s point of\nview, see the late W . Richard Stevens’ Unix Network Programming  (Prentice Hall).\nDespite the book’s name, it’s really about socket and TCP/IP/UDP programming and\ncovers all parts of the (Unix) networking API and protocols such as TFTP in amazing\ndetail.\n12.11 Program: Simple HTTP Link Checker\nChecking links is an ongoing problem for website owners as well as those who write\ntechnical documentation that links to external sources (e.g., people like the author of\nthe book you are now reading). Link checkers  are the tool they inevitably use to vali‐\ndate the links in their pages, be they web pages or book pages. Implementing a link\nchecker is basically a matter of (a) extracting links and (b) opening them. Thus, we\nhave the program in Example 12-12 . I call it KwikLinkChecker  as it is a bit on the\nquick-and-dirty side—it doesn’t validate the content of the link to be sure it still con‐\ntains what it once did; so if, say, an open source project forgets to renew its domain\n410 | Chapter 12: Network Clients\nregistration, and it gets taken over by a porn site, well, KwikLinkChecker  will never\nknow. But that said, it does its job reasonably well, and reasonably quickly.\nExample 12-12. darwinsys-api/src/main/java/com/darwinsys/tools/\nKwikLinkChecker.java\n    /**\n     * Check one HTTP link; not recursive. Returns a LinkStatus with\n     * boolean success, and the filename or an error message in the\n     * message part of the LinkStatus.  The end of this method is one of\n     * the few places where a whole raft of different ""catch"" clauses is\n     * actually needed for the intent of the program.\n     * @param urlString the link to check\n     * @return the link's status\n     */\n    @SuppressWarnings (""exports"" )\n    public LinkStatus  check(String urlString ) {\n        try {\n            HttpResponse <String> resp = client.send(\n                HttpRequest .newBuilder (URI.create(urlString ))\n                .header(""User-Agent"" , getClass ().getName())\n                .GET()\n                .build(),\n                BodyHandlers .ofString ());\n            // Collect the results\n            if (resp.statusCode () == 200) {\n                System.out.println(resp.body());\n            } else {\n                System.out.printf(""ERROR: Status %d on request %s\n"" ,\n                    resp.statusCode (), urlString );\n            }\n            switch (resp.statusCode ()) {\n            case 200:\n                return new LinkStatus (true, urlString );\n            case 403:\n                return new LinkStatus (false,""403: "" + urlString  );\n            case 404:\n                return new LinkStatus (false,""404: "" + urlString  );\n            }\n            return new LinkStatus (true, urlString );\n        } catch (IllegalArgumentException  | MalformedURLException  e) {\n            // JDK throws IAE if host can't be determined from URL string\n            return new LinkStatus (false, ""Malformed URL: ""  + urlString );\n        } catch (UnknownHostException  e) {\n            return new LinkStatus (false, ""Host invalid/dead: ""  + urlString );\n        } catch (FileNotFoundException  e) {\n            return new LinkStatus (false,""NOT FOUND (404) ""  + urlString );\n        } catch (ConnectException  e) {\n            return new LinkStatus (false, ""Server not listening: ""  + urlString );\n12.11 Program: Simple HTTP Link Checker | 411\n        } catch (SocketException  e) {\n            return new LinkStatus (false, e + "": "" + urlString );\n        } catch (IOException  e) {\n            return new LinkStatus (false, e.toString ()); // includes failing URL\n        } catch (Exception  e) {\n            return new LinkStatus (false, urlString  + "": "" + e);\n        }\n    }\nFancier link checkers are surely available, but this one works for me.\n412 | Chapter 12: Network Clients",5122
534-Chapter 13. Server-Side Java.pdf,534-Chapter 13. Server-Side Java,,0
535-13.1 Opening a Server Socket for Business.pdf,535-13.1 Opening a Server Socket for Business,"CHAPTER 13\nServer-Side Java\n13.0 Introduction\nSockets form the underpinnings of almost all networking protocols. JDBC, RMI,\nCORBA, EJB, and the non-Java RPC (Remote Procedure Call) and NFS (Network\nFile System) are all implemented by connecting various types of sockets together.\nSocket connections can be implemented in most any language, not just Java: C, C++,\nPerl, and Python are also popular, and many others are possible. A client or server\nwritten in any one of these languages can communicate with its opposite written in\nany of the other languages. Therefore, it’s worth taking a quick look at how the Serv\nerSocket  behaves, even if you wind up utilizing the higher-level services such as\nRMI, JDBC, CORBA, or EJB.\nThe discussion looks first at the ServerSocket  itself, then at writing data over a\nsocket in various ways. Finally, I show a complete implementation of a usable net‐\nwork server written in Java: the chat server from the client in the previous chapter.\n413",996
536-Problem.pdf,536-Problem,,0
537-Solution.pdf,537-Solution,,0
538-Discussion.pdf,538-Discussion,"6Y ou may not be able to pick just any port number for your own service, of course. Certain well-known port\nnumbers are reserved for specific services and listed in your services  file, such as 22 for Secure Shell and 25 for\nSMTP . Also, on server-based operating systems, ports below 1024 are considered privileged ports and require\nroot or administrator privilege to create. This was an early security mechanism; today, with zillions of single-\nuser desktops connected to the internet, it provides little real security, but the restriction remains.\nMost production work in server-side Java uses the Java Enterprise\nEdition (Java EE), recently transferred from Oracle to the Eclipse\nSoftware Foundation and renamed to Jakarta but widely referred to\nby the previous name (and occasionally by its very old name,\n“J2EE, ” which was retired in 2005). Java EE provides scalability and\nsupport for building well-structured, multitiered distributed appli‐\ncations. EE provides the servlet framework; a servlet is a strategy\nobject that can be installed into any standard Java EE web server.\nEE also provides two web view technologies: the original JSP (Java‐\nServer Pages) and the newer, component-based JSF (JavaServer\nFaces). Finally, EE provides a number of other network-based serv‐\nices, including EJB3 remote access and Java Messaging Service\n(JMS). These are outside the scope of this book; they are covered in\nother books, such as Arun Gupta’s Java EE 7 Essentials: Enterprise\nDeveloper Handbook . This chapter is only for those who need or\nwant to build their own server from the ground up.\n13.1 Opening a Server Socket for Business\nProblem\nY ou need to write a socket-based server.\nSolution\nCreate a ServerSocket  for the given port number.\nDiscussion\nThe ServerSocket  represents the other end of a connection, the server that waits\npatiently for clients to come along and connect to it. Y ou construct a ServerSocket\nwith just the port number.6 Because it doesn’t need to connect to another host, it\ndoesn’t need a particular host’s address as the client socket constructor does.\nAssuming the ServerSocket  constructor doesn’t throw an exception, you’re in busi‐\nness. Y our next step is to await client activity, which you do by calling accept() . This\ncall blocks until a client connects to your server; at that point, the accept()  returns to\nyou a Socket  object (not a ServerSocket ) that is connected in both directions to the\n414 | Chapter 13: Server-Side Java\nServerSocket  object on the client (or its equivalent, if written in another language).\nExample 13-1  shows the code for a socket-based server.\nExample 13-1. main/src/main/java/network/Listen.java\npublic class Listen {\n    /** The TCP port for the service. */\n    public static final short PORT = 9999;\n    public static void main(String[] argv) throws IOException  {\n        ServerSocket  sock;\n        Socket  clientSock ;\n        try {\n            sock = new ServerSocket (PORT);\n            while ((clientSock  = sock.accept()) != null) {\n                // Process it, usually on a separate thread\n                // to avoid blocking the accept() call.\n                process(clientSock );\n            }\n        } catch (IOException  e) {\n            System.err.println(e);\n        }\n    }\n    /** This would do something with one client. */\n    static void process(Socket s) throws IOException  {\n        System.out.println(""Accept from client ""  + s.getInetAddress ());\n        // The conversation would be here.\n        s.close();\n    }\n}\nY ou would normally use the same socket for both reading and writing, as shown in\nthe next few recipes.\nY ou may want to listen only on a particular network interface. Though we tend to\nthink of network addresses as computer addresses, the two are not the same. A net‐\nwork address is actually the address of a particular network card, or network interface\nconnection, on a given computing device. A desktop computer, laptop, tablet, or\nmobile phone might have only a single interface, hence a single network address. But\na large server machine might have two or more interfaces, usually when it is connec‐\nted to several networks. A network router is a box, either special purpose (e.g., a\nCisco router), or general purpose (e.g., a Unix host), that has interfaces on multiple\nnetworks and has both the capability and the administrative permission to forward\npackets from one network to another. A program running on such a server machine\nmight want to provide services only to its inside network or its outside network. One\n13.1 Opening a Server Socket for Business | 415\nway to accomplish this is by specifying the network interface to be listened on. Sup‐\npose you want to provide a different view of web pages for your intranet than you\nprovide to outside customers. For security reasons, you probably wouldn’t run both\nthese services on the same machine. But if you wanted to, you could do this by pro‐\nviding the network interface addresses as arguments to the ServerSocket\nconstructor.\nHowever, to use this form of the constructor, you don’t have the option of using a\nstring for the network address’s name, as you did with the client socket; you must\nconvert it to an InetAddress  object. Y ou also have to provide a backlog argument,\nwhich is the number of connections that can queue up to be accepted before clients\nare told that your server is too busy. The complete setup is shown in Example 13-2 .\nExample 13-2. main/src/main/java/network/ListenInside.java\npublic class ListenInside  {\n    /** The TCP port for the service. */\n    public static final short PORT = 9999;\n    /** The name of the network interface. */\n    public static final String INSIDE_HOST  = ""acmewidgets-inside"" ;\n    /** The number of clients allowed to queue */\n    public static final int BACKLOG = 10;\n    public static void main(String[] argv) throws IOException  {\n        ServerSocket  sock;\n        Socket  clientSock ;\n        try {\n            sock = new ServerSocket (PORT, BACKLOG,\n                InetAddress .getByName (INSIDE_HOST ));\n            while ((clientSock  = sock.accept()) != null) {\n                // Process it.\n                process(clientSock );\n            }\n        } catch (IOException  e) {\n            System.err.println(e);\n        }\n    }\n    /** Hold server's conversation with one client. */\n    static void process(Socket s) throws IOException  {\n        System.out.println(""Connected from  ""  + INSIDE_HOST  +\n            "": "" + s.getInetAddress (  ));\n        // The conversation would be here.\n        s.close();\n    }\n}\n416 | Chapter 13: Server-Side Java",6727
539-13.2 Finding Network Interfaces.pdf,539-13.2 Finding Network Interfaces,,0
540-Problem.pdf,540-Problem,,0
541-Solution.pdf,541-Solution,,0
542-13.3 Returning a Response String or Binary.pdf,542-13.3 Returning a Response String or Binary,"6Digital Equipment was absorbed by Compaq, which was then absorbed by HP , but the name remains de\nbecause the engineers who name such things don’t care for corporate mergers anyway.InetAddress.getByName()  looks up the given hostname in a system-dependent way,\nreferring to a configuration file in the /etc or \windows  directory, or to some kind of\nresolver such as the Domain Name System. Consult a good book on networking and\nsystem administration if you need to modify this data. \n13.2 Finding Network Interfaces\nProblem\nY ou wish to find out about the computer’s networking arrangements.\nSolution\nUse the NetworkInterface  class.\nDiscussion\nEvery computer on a network has one or more “network interfaces. ” On typical desk‐\ntop machines, a network interface represents a network card or network port or some\nsoftware network interface, such as the loopback interface. Each interface has an\noperating system–defined name. On most versions of Unix, these devices have a two-\nor three-character device driver name plus a digit (starting from 0), for example, eth0\nor en0 for the first Ethernet on systems that hide the details of the card manufacturer,\nor de0 and de1 for the first and second Digital Equipment6 DC21x4x-based Ethernet\ncard, xl0 for a 3Com EtherLink XL, and so on. The loopback interface is almost\ninvariably lo0 on all Unix-like platforms.\nSo what? Most of the time this is of no consequence to you. If you have only one net‐\nwork connection, like a cable link to your ISP , you really don’t care. Where this mat‐\nters is on a server, where you might need to find the address for a given network, for\nexample. The NetworkInterface  class lets you find out. It has static methods for list‐\ning the interfaces and other methods for finding the addresses associated with a given\ninterface. The program in Example 13-3  shows some examples of using this class.\nRunning it prints the names of all the local interfaces. If you happen to be on a com‐\nputer named laptop , it prints the machine’s network address; if not, you probably\nwant to change it to accept the local computer’s name from the command line; this is\nleft as an exercise for the reader.\n13.2 Finding Network Interfaces | 417",2236
543-Problem.pdf,543-Problem,,0
544-Solution.pdf,544-Solution,,0
545-Discussion.pdf,545-Discussion,"Example 13-3. main/src/main/java/network/NetworkInterfaceDemo.java\npublic class NetworkInterfaceDemo  {\n    public static void main(String[] a) throws IOException  {\n        Enumeration <NetworkInterface > list =\n            NetworkInterface .getNetworkInterfaces ();\n        while (list.hasMoreElements ()) {\n            // Get one NetworkInterface\n            NetworkInterface  iface = list.nextElement ();\n            // Print its name\n            System.out.println(iface.getDisplayName ());\n            Enumeration <InetAddress > addrs = iface.getInetAddresses ();\n            // And its address(es)\n            while (addrs.hasMoreElements ()) {\n                InetAddress  addr = addrs.nextElement ();\n                System.out.println(addr);\n            }\n        }\n        // Try to get the Interface for a given local (this machine's) address\n        InetAddress  destAddr  = InetAddress .getByName (""laptop"" );\n        try {\n            NetworkInterface  dest = NetworkInterface .getByInetAddress (destAddr );\n            System.out.println(""Address for ""  + destAddr  + "" is "" + dest);\n        } catch (SocketException  ex) {\n            System.err.println(""Couldn't get address for ""  + destAddr );\n        }\n    }\n}\n13.3 Returning a Response (String or Binary)\nProblem\nY ou need to write a string or binary data to the client.\nSolution\nThe socket gives you an InputStream  and an OutputStream . Use them.\nDiscussion\nThe client socket examples in the previous chapter called the getInputStream()  and\ngetOutputStream()  methods. These examples do the same. The main difference is\nthat these ones get the socket from a ServerSocket ’s accept()  method. Another dis‐\ntinction is, by definition, that normally the server creates or modifies the data and\nsends it to the client. Example 13-4  is a simple Echo  server, which the Echo  client of\n418 | Chapter 13: Server-Side Java\nRecipe 12.5  can connect to. This server handles one complete connection with a cli‐\nent, then goes back and does the accept()  to wait for the next client.\nExample 13-4. main/src/main/java/network/EchoServer.java\npublic class EchoServer  {\n    /** Our server-side rendezvous socket */\n    protected  ServerSocket  sock;\n    /** The port number to use by default */\n    public final static int ECHOPORT  = 7;\n    /** Flag to control debugging */\n    protected  boolean debug = true;\n    /** main: construct and run */\n    public static void main(String[] args) {\n        int p = ECHOPORT ;\n        if (args.length == 1) {\n            try {\n                p = Integer.parseInt (args[0]);\n            } catch (NumberFormatException  e) {\n                System.err.println(""Usage: EchoServer [port#]"" );\n                System.exit(1);\n            }\n        }\n        new EchoServer (p).handle();\n    }\n    /** Construct an EchoServer on the given port number */\n    public EchoServer (int port) {\n        try {\n            sock = new ServerSocket (port);\n        } catch (IOException  e) {\n            System.err.println(""I/O error in setup"" );\n            System.err.println(e);\n            System.exit(1);\n        }\n    }\n    /** This handles the connections */\n    protected  void handle() {\n        Socket ios = null;\n        while (true) {\n            try {\n                System.out.println(""Waiting for client..."" );\n                ios = sock.accept();\n                System.err.println(""Accepted from ""  +\n                    ios.getInetAddress ().getHostName ());\n                try (BufferedReader  is = new BufferedReader (\n                            new InputStreamReader (ios.getInputStream (), ""8859_1"" ));\n                        PrintWriter  os = new PrintWriter (\n                            new OutputStreamWriter (ios.getOutputStream (), ""8859_1"" ),\n13.3 Returning a Response (String or Binary) | 419\n                            true);) {\n                    String echoLine ;\n                    while ((echoLine  = is.readLine ()) != null) {\n                        System.err.println(""Read "" + echoLine );\n                        os.print(echoLine  + ""\r\n"");\n                        os.flush();\n                        System.err.println(""Wrote ""  + echoLine );\n                    }\n                    System.err.println(""All done!"" );\n                }\n            } catch (IOException  e) {\n                System.err.println(e);\n            }\n        }\n        /* NOTREACHED */\n    }\n}\nTo send a string across an arbitrary network connection, some authorities recom‐\nmend sending both the carriage return and the newline character; many protocol\nspecifications require that you do so. This explains the \r\n  in the code. If the other\nend is a DOS program or a Telnet-like program, it may be expecting both characters.\nOn the other hand, if you are writing both ends, you can simply use println() —fol‐\nlowed always by an explicit flush()  before you read—to prevent the deadlock of hav‐\ning both ends trying to read with one end’s data still in the PrintWriter ’s buffer!\nIf you need to process binary data, use the data streams from java.io  instead of the\nreaders/writers. I need a server for the DaytimeBinary  program of Recipe 12.6 . In\noperation, it should look like the following:\nC:\javasrc\network> java network.DaytimeBinary\nRemote time is 3161316799\nBASE_DIFF is 2208988800\nTime diff == 952284799\nTime on localhost is Sun Mar 08 19:33:19 GMT 2014\nC:\javasrc\network> time/t\nCurrent time is  7:33:23.84p\nC:\javasrc\network> date/t\nCurrent date is Sun 03-08-2014\nC:\javasrc\network>\nWell, it happens that I have such a program in my arsenal, so I present it in\nExample 13-5 . Note that it directly uses certain public constants defined in the client\nclass. Normally these are defined in the server class and used by the client, but I\nwanted to present the client code first.\n420 | Chapter 13: Server-Side Java\nExample 13-5. main/src/main/java/network/DaytimeServer.java\npublic class DaytimeServer  {\n    /** Our server-side rendezvous socket */\n    ServerSocket  sock;\n    /** The port number to use by default */\n    public final static int PORT = 37;\n    /** main: construct and run */\n    public static void main(String[] argv) {\n        new DaytimeServer (PORT).runService ();\n    }\n    /** Construct a DaytimeServer on the given port number */\n    public DaytimeServer (int port) {\n        try {\n            sock = new ServerSocket (port);\n        } catch (IOException  e) {\n            System.err.println(""I/O error in setup\n""  + e);\n            System.exit(1);\n        }\n    }\n    /** This handles the connections */\n    protected  void runService () {\n        Socket ios = null;\n        DataOutputStream  os = null;\n        while (true) {\n            try {\n                System.out.println(""Waiting for connection on port ""  + PORT);\n                ios = sock.accept();\n                System.err.println(""Accepted from ""  +\n                    ios.getInetAddress ().getHostName ());\n                os = new DataOutputStream (ios.getOutputStream ());\n                long time = System.currentTimeMillis ();\n                time /= 1000;    // Daytime Protocol is in seconds\n                // Convert to Java time base.\n                time += RDateClient .BASE_DIFF ;\n                // Write it, truncating cast to int since it is using\n                // the Internet Daytime protocol which uses 4 bytes.\n                // This will fail in the year 2038, along with all\n                // 32-bit timekeeping systems based from 1970.\n                // Remember, you read about the Y2038 crisis here first!\n                os.writeInt ((int)time);\n                os.close();\n            } catch (IOException  e) {\n                System.err.println(e);\n            }\n        }\n13.3 Returning a Response (String or Binary) | 421",7953
546-13.4 Returning Object Information Across a Network Connection.pdf,546-13.4 Returning Object Information Across a Network Connection,,0
547-Problem.pdf,547-Problem,,0
548-Solution.pdf,548-Solution,,0
549-13.5 Handling Multiple Clients.pdf,549-13.5 Handling Multiple Clients,"}\n}\n13.4 Returning Object Information Across a Network\nConnection\nProblem\nY ou need to return an object across a network connection.\nSolution\nCreate the object you need, and write it using an ObjectOutputStream  created on top\nof the socket’s output stream.\nDiscussion\nThe program in Example 12-7  in the previous chapter reads a Date  object over an\nObjectInputStream . Example 13-6 , the DaytimeObjectServer  (the other end of that\nprocess), is a program that constructs a Date  object each time it’s connected to and\nreturns it to the client.\nExample 13-6. main/src/main/java/network/DaytimeObjectServer.java\npublic class DaytimeObjectServer  {\n    /** The TCP port for the object time service. */\n    public static final short TIME_PORT  = 1951;\n    public static void main(String[] argv) {\n        ServerSocket  sock;\n        Socket  clientSock ;\n        try {\n            sock = new ServerSocket (TIME_PORT );\n            while ((clientSock  = sock.accept()) != null) {\n                System.out.println(""Accept from ""  +\n                    clientSock .getInetAddress ());\n                ObjectOutputStream  os = new ObjectOutputStream (\n                    clientSock .getOutputStream ());\n                // Construct and write the Object\n                os.writeObject (LocalDateTime .now());\n                os.close();\n            }\n        } catch (IOException  e) {\n            System.err.println(e);\n        }\n422 | Chapter 13: Server-Side Java",1496
550-Problem.pdf,550-Problem,,0
551-Solution.pdf,551-Solution,,0
552-Discussion.pdf,552-Discussion,"6There are some limits to how many threads you can have, which affect only very large, enterprise-scale\nservers. Y ou can’t expect to have thousands of threads running in the standard Java runtime. For large, high-\nperformance servers, you may wish to resort to native code (see Recipe 18.6 ) using select()  or poll() .    }\n}\n13.5 Handling Multiple Clients\nProblem\nY our server needs to handle multiple clients.\nSolution\nUse a thread for each.\nDiscussion\nIn the C world, several mechanisms allow a server to handle multiple clients. One is\nto use a special system call  select()  or poll() , which notifies the server when any of\na set of file/socket descriptors is ready to read, ready to write, or has an error. By\nincluding its rendezvous socket (equivalent to our ServerSocket ) in this list, the C-\nbased server can read from any of a number of clients in any order. Java does not pro‐\nvide this call, because it is not readily implementable on some Java platforms. Instead,\nJava uses the general-purpose Thread  mechanism, as described in Chapter 16\n(threads are now commonplace in many programming languages, though not always\nunder that name). Each time the code accepts a new connection from the Server\nSocket , it immediately constructs and starts a new thread object to process that\nclient.6\nThe Java code to implement accepting on a socket is pretty simple, apart from having\nto catch IOException s:\n/** Run the main loop of the Server. */\nvoid runServer( ) {\n    while (true) {\n        try {\n            Socket clntSock = sock.accept( );\n            new Handler(clntSock).start( );\n        } catch(IOException e) {\n            System.err.println(e);\n        }\n    }\n}\n13.5 Handling Multiple Clients | 423\nTo use a thread, you must either subclass Thread  or implement Runnable . The Han\ndler  class must be a subclass of Thread  for this code to work as written; if Handler\ninstead implemented the Runnable  interface, the code would pass an instance of the\nRunnable  into the constructor for Thread , as in:\nThread t = new Thread(new Handler(clntSock));\nt.start( );\nBut as written, Handler  is constructed using the normal socket returned by accept()\nand normally calls the socket’s getInputStream()  and getOutputStream()  methods\nand holds its conversation in the usual way. I’ll present a full implementation, a threa‐\nded echo client. First, a session showing it in use:\n$ java network.EchoServerThreaded\nEchoServerThreaded ready for connections.\nSocket starting: Socket[addr=localhost/127.0.0.1,port=2117,localport=7]\nSocket starting: Socket[addr=darian/192.168.1.50,port=13386,localport=7]\nSocket starting: Socket[addr=darian/192.168.1.50,port=22162,localport=7]\nSocket ENDED: Socket[addr=darian/192.168.1.50,port=22162,localport=7]\nSocket ENDED: Socket[addr=darian/192.168.1.50,port=13386,localport=7]\nSocket ENDED: Socket[addr=localhost/127.0.0.1,port=2117,localport=7]\nHere I connected to the server once with my EchoClient  program and, while still\nconnected, called it up again (and again) with an operating system–provided Telnet\nclient. The server communicated with all the clients concurrently, sending the\nanswers from the first client back to the first client, and the data from the second cli‐\nent back to the second client. In short, it works. I ended the sessions with the end-of-\nfile character in the program and used the normal disconnect mechanism from the\nTelnet client. Example 13-7  is the code for the server.\nExample 13-7. main/src/main/java/network/EchoServerThreaded.java\npublic class EchoServerThreaded  {\n    public static final int ECHOPORT  = 7;\n    public static void main(String[] av) {\n        new EchoServerThreaded ().runServer ();\n    }\n    public void runServer () {\n        ServerSocket  sock;\n        Socket clientSocket ;\n        try {\n            sock = new ServerSocket (ECHOPORT );\n            System.out.println(""EchoServerThreaded ready for connections."" );\n            /* Wait for a connection */\n424 | Chapter 13: Server-Side Java\n            while (true) {\n                clientSocket  = sock.accept();\n                /* Create a thread to do the communication, and start it */\n                new Handler(clientSocket ).start();\n            }\n        } catch (IOException  e) {\n            /* Crash the server if IO fails. Something bad has happened */\n            System.err.println(""Could not accept ""  + e);\n            System.exit(1);\n        }\n    }\n    /** A Thread subclass to handle one client conversation. */\n    class Handler extends Thread {\n        Socket sock;\n        Handler(Socket s) {\n            sock = s;\n        }\n        public void run() {\n            System.out.println(""Socket starting: ""  + sock);\n            try (BufferedReader  is = new BufferedReader (\n                        new InputStreamReader (sock.getInputStream ()));\n                    PrintStream  os = new PrintStream (\n                        sock.getOutputStream (), true);) {\n                String line;\n                while ((line = is.readLine ()) != null) {\n                    os.print(line + ""\r\n"");\n                    os.flush();\n                }\n                sock.close();\n            } catch (IOException  e) {\n                System.out.println(""IO Error on socket ""  + e);\n                return;\n            }\n            System.out.println(""Socket ENDED: ""  + sock);\n        }\n    }\n}\nA lot of short transactions can degrade performance, because each client causes the\ncreation of a new threaded object. If you know or can reliably predict the degree of\nconcurrency that is needed, an alternative paradigm involves the precreation of a\nfixed number of threads. But then how do you control their access to the Server\nSocket ? A look at the ServerSocket  class documentation reveals that the accept()\nmethod is not synchronized, meaning that any number of threads can call the\nmethod concurrently. This could cause bad things to happen. So I use the synchron\nized  keyword around this call to ensure that only one client runs in it at a time,\nbecause it updates global data. When no clients are connected, you will have one\n13.5 Handling Multiple Clients | 425\n(randomly selected) thread running in the ServerSocket  object’s accept()  method,\nwaiting for a connection, plus n-1 threads waiting for the first thread to return from\nthe method. As soon as the first thread manages to accept a connection, it goes off\nand holds its conversation, releasing its lock in the process so that another randomly\nchosen thread is allowed into the accept()  method. Each thread’s run()  method has\nan infinite loop beginning with an accept()  and then holding the conversation. The\nresult is that client connections can get started more quickly, at a cost of slightly\ngreater server startup time. Doing it this way also avoids the overhead of constructing\na new Handler  or Thread  object each time a request comes along. This general\napproach is similar to what the popular Apache web server does, although it normally\ncreates a number or pool of identical processes (instead of threads) to handle client\nconnections. Accordingly, I have modified the EchoServerThreaded  class shown in\nExample 13-7  to work this way, as you can see in Example 13-8 .\nExample 13-8. main/src/main/java/network/EchoServerThreaded2.java\npublic class EchoServerThreaded2  {\n    public static final int ECHOPORT  = 7;\n    public static final int NUM_THREADS  = 4;\n    /** Main method, to start the servers. */\n    public static void main(String[] av) {\n        new EchoServerThreaded2 (ECHOPORT , NUM_THREADS );\n    }\n    /** Constructor */\n    public EchoServerThreaded2 (int port, int numThreads ) {\n        ServerSocket  servSock ;\n        try {\n            servSock  = new ServerSocket (port);\n        } catch (IOException  e) {\n            /* Crash the server if IO fails. Something bad has happened */\n            throw new RuntimeException (""Could not create ServerSocket "" , e);\n        }\n        // Create a series of threads and start them.\n        for (int i = 0; i < numThreads ; i++) {\n            new Handler(servSock , i).start();\n        }\n    }\n    /** A Thread subclass to handle one client conversation. */\n    class Handler extends Thread {\n        ServerSocket  servSock ;\n426 | Chapter 13: Server-Side Java\n        int threadNumber ;\n        /** Construct a Handler. */\n        Handler(ServerSocket  s, int i) {\n            servSock  = s;\n            threadNumber  = i;\n            setName(""Thread ""  + threadNumber );\n        }\n        public void run() {\n            /*\n             * Wait for a connection. Synchronized on the ServerSocket while\n             * calling its accept() method.\n             */\n            while (true) {\n                try {\n                    System.out.println(getName() + "" waiting"" );\n                    Socket clientSocket ;\n                    // Wait here for the next connection.\n                    synchronized  (servSock ) {\n                        clientSocket  = servSock .accept();\n                    }\n                    System.out.println(\n                        getName() + "" starting, IP=""  +\n                        clientSocket .getInetAddress ());\n                    try (BufferedReader  is = new BufferedReader (\n                            new InputStreamReader (clientSocket .getInputStream ()));\n                            PrintStream  os = new PrintStream (\n                                clientSocket .getOutputStream (), true);) {\n                        String line;\n                        while ((line = is.readLine ()) != null) {\n                            os.print(line + ""\r\n"");\n                            os.flush();\n                        }\n                        System.out.println(getName() + "" ENDED "" );\n                        clientSocket .close();\n                    }\n                } catch (IOException  ex) {\n                    System.out.println(getName() + "": IO Error on socket ""  + ex);\n                    return;\n                }\n            }\n        }\n    }\n}\nIt is quite possible to implement a server of this sort with NIO, the “new” (back in\nJ2SE 1.4) I/O package. However, the code to do so outweighs anything in this chapter,\nand it is fraught with issues. There are several good tutorials on the internet for the\n13.5 Handling Multiple Clients | 427",10538
553-13.6 Serving the HTTP Protocol.pdf,553-13.6 Serving the HTTP Protocol,,0
554-Problem.pdf,554-Problem,,0
555-Solution.pdf,555-Solution,,0
556-Discussion.pdf,556-Discussion,"person who truly needs the performance gain of using NIO to manage server\nconnections.\n13.6 Serving the HTTP Protocol\nProblem\nY ou want to serve up a protocol such as HTTP .\nSolution\nCreate a ServerSocket  and write some code that speaks the particular protocol. Or,\nbetter, use a Java-powered web server such as Apache Tomcat or a Java Enterprise\nEdition (Java EE) server such as JBoss WildFly.\nDiscussion\nY ou can implement your own HTTP protocol server for very simple applications,\nwhich we’ll do here. For any serious development, you want to use the Java Enterprise\nEdition; see the note at the beginning of this chapter.\nThis example just constructs a ServerSocket  and listens on it. When connections\ncome in, they are replied to using the HTTP protocol. So it is somewhat more\ninvolved than the simple Echo  server presented in Recipe 13.3 . However, it’s not a\ncomplete web server; the filename in the request is ignored, and a standard message\nis always returned. This is thus a very simple web server; it follows only the bare min‐\nimum of the HTTP protocol needed to send its response back. For a real web server\nwritten in Java, get Tomcat from the Apache Tomcat website  or any of the Jakarta/\nJavaEE Application Servers. The code shown in Example 13-9 , however, is enough to\nunderstand how to build a simple server that responds to requests using a protocol.\nExample 13-9. main/src/main/java/network/WebServer0.java\npublic class WebServer0  {\n    public static final int HTTP = 80;\n    public static final String CRLF = ""\r\n"";\n    ServerSocket  s;\n    /** A link to the source of this program, used in error message */\n    static final String VIEW_SOURCE_URL  =\n    ""https://github.com/IanDarwin/javasrc/tree/master/main/src/main/\n      java/network"" ;\n    /**\n     * Main method, just creates a server and call its runServer().\n     */\n    public static void main(String[] args) throws Exception  {\n428 | Chapter 13: Server-Side Java\n        System.out.println(""DarwinSys JavaWeb Server 0.0 starting..."" );\n        WebServer0  w = new WebServer0 ();\n        int port = HTTP;\n        if (args.length == 1) {\n            port = Integer.parseInt (args[0]);\n            }\n        w.runServer (port);        // never returns!!\n    }\n    /** Get the actual ServerSocket; deferred until after Constructor\n     * so subclass can mess with ServerSocketFactory (e.g., to do SSL).\n     * @param port The port number to listen on\n     */\n    protected  ServerSocket  getServerSocket (int port) throws Exception  {\n        return new ServerSocket (port);\n    }\n    /** RunServer accepts connections and passes each one to handler. */\n    public void runServer (int port) throws Exception  {\n        s = getServerSocket (port);\n        while (true) {\n            try {\n                Socket us = s.accept();\n                Handler(us);\n            } catch(IOException  e) {\n                System.err.println(e);\n                return;\n            }\n        }\n    }\n    /** Handler() handles one conversation with a Web client.\n     * This is the only part of the program that ""knows"" HTTP.\n     */\n    public void Handler(Socket s) {\n        BufferedReader  is;    // inputStream, from Viewer\n        PrintWriter  os;        // outputStream, to Viewer\n        String request;        // what Viewer sends us.\n        try {\n            String from = s.getInetAddress ().toString ();\n            System.out.println(""Accepted connection from ""  + from);\n            is = new BufferedReader (new InputStreamReader (s.getInputStream ()));\n            request = is.readLine ();\n            System.out.println(""Request: ""  + request);\n            os = new PrintWriter (s.getOutputStream (), true);\n            os.print(""HTTP/1.0 200 Here is your data""  + CRLF);\n            os.print(""Content-type: text/html""  + CRLF);\n            os.print(""Server-name: DarwinSys NULL Java WebServer 0""  + CRLF);\n            String reply1 = ""<html><head>""  +\n                ""<title>Wrong System Reached</title></head>\n""  +\n13.6 Serving the HTTP Protocol | 429",4129
557-13.7 Securing a Web Server with SSL and JSSE.pdf,557-13.7 Securing a Web Server with SSL and JSSE,,0
558-Problem.pdf,558-Problem,,0
559-Solution.pdf,559-Solution,,0
560-Discussion.pdf,560-Discussion,"""<h1>Welcome, "" ;\n            String reply2 = "", but...</h1>\n""  +\n                ""<p>You have reached a desktop machine ""  +\n                ""that does not run a real Web service.\n""  +\n                ""<p>Please pick another system!</p>\n""  +\n                ""<p>Or view <a href=\""""  + VIEW_SOURCE_URL  + ""\"">"" +\n                ""the WebServer0 source on github</a>.</p>\n""  +\n                ""<hr/><em>Java-based WebServer0</em><hr/>\n""  +\n                ""</html>\n"" ;\n            os.print(""Content-length: ""  +\n                (reply1.length() + from.length() + reply2.length()) + CRLF);\n            os.print(CRLF);\n            os.print(reply1 + from + reply2 + CRLF);\n            os.flush();\n            s.close();\n        } catch (IOException  e) {\n            System.out.println(""IOException ""  + e);\n        }\n        return;\n    }\n}\n13.7 Securing a Web Server with SSL and JSSE\nProblem\nY ou want to protect your network traffic from prying eyes or malicious modification\nwhile the data is in transit.\nSolution\nUse the Java Secure Socket Extension, JSSE, to encrypt your traffic.\nDiscussion\nJSSE provides services at a number of levels, but the simplest way to use it is simply to\nget your ServerSocket  from an SSLServerSocketFactory  instead of using the Serv\nerSocket  constructor directly. SSL is the Secure Sockets Layer; a revised version is\nknown as TLS. It is specifically for use on the web. To secure other protocols, you’ d\nhave to use a different form of the SocketFactory .\nThe SSLServerSocketFactory  returns a ServerSocket  that is set up to do SSL\nencryption. Example 13-10  uses this technique to override the getServerSocket()\nmethod in Recipe 13.6 . If you’re thinking this is too easy, you’re wrong!\n430 | Chapter 13: Server-Side Java\nExample 13-10. main/src/main/java/network/JSSEWebServer0\n/**\n * JSSEWebServer - subclass trivial WebServer0 to make it use SSL.\n * N.B. You MUST have set up a server certificate (see the\n * accompanying book text), or you will get the dreaded\n * javax.net.ssl.SSLHandshakeException: no cipher suites in common\n * (because without it JSSE can't use any of its built-in ciphers!).\n */\npublic class JSSEWebServer0  extends WebServer0  {\n    public static final int HTTPS = 8443;\n    public static void main(String[] args) throws Exception  {\n        if (System.getProperty (""javax.net.ssl.keyStore"" ) == null) {\n            System.err.println(\n                ""You must pass in a keystore via -D; see the documentation!"" );\n            System.exit(1);\n        }\n        System.out.println(""DarwinSys JSSE Server 0.0 starting..."" );\n        JSSEWebServer0  w = new JSSEWebServer0 ();\n        w.runServer (HTTPS);        // never returns!!\n    }\n    /** Get an HTTPS ServerSocket using JSSE.\n     * @see WebServer0#getServerSocket(int)\n     * @throws ClassNotFoundException the SecurityProvider can't be instantiated.\n     */\n    protected  ServerSocket  getServerSocket (int port) throws Exception  {\n        SSLServerSocketFactory  ssf =\n            (SSLServerSocketFactory )SSLServerSocketFactory .getDefault ();\n        return ssf.createServerSocket (port);\n    }\n}\nThat is, indeed, all the Java code one needs to write. Y ou do have to set up an SSL\nCertificate. For demonstration purposes, this can be a self-signed certificate; the steps\nin https://darwinsys.com/java/selfsigncert.html  (steps 1–4) will suffice. Y ou have to tell\nthe JSSE layer where to find your keystore:\njava -Djavax.net.ssl.keyStore=/home/ian/.keystore -Djavax.net.ssl.\nkeyStorePassword=secrit JSSEWebServer0\nThe typical client browser raises its eyebrows at a self-signed certificate (see\nFigure 13-1 ), but, if the user okays it, will accept the certificate.\nFigure 13-2  shows the output of the simple WebServer0  being displayed over the\nHTTPS protocol (notice the padlock in the lower-right corner).\n13.7 Securing a Web Server with SSL and JSSE | 431\nFigure 13-1. Browser caution\n432 | Chapter 13: Server-Side Java",4037
561-See Also.pdf,561-See Also,,0
562-13.8 Creating a REST Service with JAX-RS.pdf,562-13.8 Creating a REST Service with JAX-RS,,0
563-Problem.pdf,563-Problem,,0
564-Solution.pdf,564-Solution,,0
565-Discussion.pdf,565-Discussion,"Figure 13-2. With encryption\nSee Also\nJSSE can do much more than encrypt web server traffic; this is, however, sometimes\nseen as its most exciting application. For more information on JSSE, see the Sun web‐\nsite or Java Security  by Scott Oaks (O’Reilly).\n13.8 Creating a REST Service with JAX-RS\nProblem\nY ou want to implement a RESTful server by using the provided Java EE/Jakarta EE\nAPIs.\nSolution\nUse JAX-RS annotations on a class that provides a service; install it in an enterprise\napplication server.\nDiscussion\nThis operation consists of both coding and configuration.\nThe coding steps consist of creating a class that extends the JAX-RS Application\nclass and adding annotations to a class that provides a service.\nHere is a minimal Application  class:\n13.8 Creating a REST Service with JAX-RS | 433\nimport javax.ws.rs.ApplicationPath;\nimport javax.ws.rs.core.Application;\n@ApplicationPath("""")\npublic class RestApplication extends Application {\n // Empty\n}\nExample 13-11  is a “Hello, World""–type service class with the annotations needed to\nmake it a service class and to have three sample methods.\nExample 13-11. restdemo/src/main/java/rest/RestService.java\n@Path("""")\n@ApplicationScoped\npublic class RestService  {\n    public RestService () {\n        System.out.println(""RestService.init()"" );\n    }\n    @GET @Path(""/timestamp"" )\n    @Produces (MediaType .TEXT_PLAIN )\n    public String getDate() {\n        return LocalDateTime .now().toString ();\n    }\n    /** A Hello message method\n     */\n    @GET @Path(""/greeting/{userName}"" )\n    @Produces (""text/html"" )\n    public String doGreeting (@PathParam (""userName"" )String userName ) {\n        System.out.println(""RestService.greeting()"" );\n        if (userName  == null || userName .trim().length() <= 3) {\n            return ""Missing or too-short username"" ;\n        }\n        return String.format(\n            ""<h1>Welcome %s</h1><p>%s, We are glad to see you back!"" ,\n            userName , userName );\n    }\n    /** Used to download all items */\n    @GET @Path(""/names"" )\n    @Produces (MediaType .APPLICATION_JSON )\n    public List<String> findTasksForUser () {\n        return List.of(""Robin"", ""Jedunkat"" , ""Lyn"", ""Glen"");\n    }\n}\nNow the class must be deployed. If we have created a proper Maven project structure\n(see Recipe 1.7 ) and have provided an application-server-specific Maven plug-in, and\n434 | Chapter 13: Server-Side Java\nour development server is running, we can use some variation on mvn deploy . In the\npresent case I have set this up, in the rest subdirectory, for deployment to WildFly, a\nJava Enterprise server from the JBoss open source community (though somewhat\ndated), funded by RedHat Inc. I need only say mvn wildfly:deploy  to have the appli‐\ncation compiled, packaged, and deployed to my server.\nFor deploying REST services as a microservice based on Eclipse MicroProfile, you\nmay wish to investigate the Quarkus Framework .\nOnce the service is deployed, you can explore it interactively with a browser or, for\nsimple GET requests, a Telnet client:\n$ telnet localhost 8080 # output cleaned up\nEscape character is '^]'.\nGET /rest/timestamp HTTP/1.0\nConnection: keep-alive\nHTTP/1.1 200 OK\nContent-Type: text/plain;charset=UTF-8\n2019-10-16T19:54:31.42\nGET /rest/greeting/Ian%20Darwin HTTP/1.0\nHTTP/1.1 200 OK\nContent-Type: text/html;charset=UTF-8\n<h1>Welcome Ian Darwin</h1><p>Ian Darwin, We are glad to see you back!\nget /rest/names HTTP/1.0\nAccept: Application/JSON\nHTTP/1.1 200 OK\nContent-Type: application/json\n[""Robin"",""Jedunkat"",""Lyn"",""Glen""]\n^] (CTRL/C)\n$\nAn issue with REST is that there is not an official standard for documenting the API\nor protocol offered by a server (there are several competing specifications). So people\nwriting clients must either rely on plain documentation offered by the server’s devel‐\nopers, or use trial and error to discover the protocol. Our example here is simple\nenough that we don’t have this problem, but imagine a class with 20 or 30 methods in\nit.\nThe Spring Framework offers an API that is very similar to the JAX-RS API used\nhere; if you are already using Spring, it may be simpler to use their annotations.\n13.8 Creating a REST Service with JAX-RS | 435",4290
566-13.9 Network Logging.pdf,566-13.9 Network Logging,,0
567-Problem.pdf,567-Problem,,0
568-Solution.pdf,568-Solution,,0
569-13.10 Setting Up SLF4J.pdf,569-13.10 Setting Up SLF4J,"13.9 Network Logging\nProblem\nY our class is running inside a server container, and its debugging output is hard to\nobtain.\nSolution\nUse a network-based logger like the Java Logging API (JUL), the Apache Logging\nServices Project’s Log4j , or the simple one shown here.\nDiscussion\nGetting the debug output from a desktop client is fairly easy on most operating sys‐\ntems. But if the program you want to debug is running in a container like a servlet\nengine or an EJB server, it can be difficult to obtain debugging output, particularly if\nthe container is running on a remote computer. It would be convenient if you could\nhave your program send messages back to a program on your desktop machine for\nimmediate display. Needless to say, it’s not that hard to do this with Java’s socket\nmechanism.\nMany logging APIs can handle this:\n•Java has had for years a standard logging API JUL (discussed in Recipe 13.12 )\nthat talks to various logging mechanisms, including Unix syslog .\n•The Apache Logging Services Project produces Log4j , which is used in many\nopen source projects that require logging (see Recipe 13.11 ).\n•The Apache Jakart Commons Logging (JCL) . Not discussed here; similar to the\nothers.\n•SLF4J (Simple Logging Facade For Java, see Recipe 13.10 ) is the newest and, as\nthe name implies, a facade that can use the others.\n•And, before these became widely used, I wrote a small, simple API to handle this\ntype of logging function. My netlog  is not discussed here because it is preferable\nto use one of the standard logging mechanisms; its code is in the logging  subdir‐\nectory of the javasrc  repo if you want to exhume it.\nThe JDK logging API, Log4j , and SFL4J  are more fully fleshed out and can write to\nsuch destinations as a file; an OutputStream  or Writer ; or a remote Log4j , Unix\nsyslog , or Windows Event Log server.\nThe program being debugged is the client from the logging API’s point of view—even\nthough it may be running in a server-side container such as a web server or\n436 | Chapter 13: Server-Side Java",2067
570-Problem.pdf,570-Problem,,0
571-Solution.pdf,571-Solution,,0
572-Discussion.pdf,572-Discussion,"application  server—because the network client is the program that initiates the con‐\nnection. The program that runs on your desktop machine is the “server” program for\nsockets because it waits for a connection to come along.\nIf you want to run any network-based logger reachable from any public network, you\nneed to be more aware of security issues. One common form of attack is a simple\ndenial-of-service (DoS), during which the attacker makes a lot of connections to your\nserver in order to slow it down. If you are writing the log to disk, for example, the\nattacker could fill up your disk by sending lots of garbage. In common use, your log\nlistener would be behind a firewall and not reachable from outside; but if this is not\nthe case, beware of the DoS attack.\n13.10 Setting Up SLF4J\nProblem\nY ou want to use a logging API that lets you use any of the other logging APIs, for\nexample, so that your code can be used in other projects without requiring them to\nswitch logging APIs.\nSolution\nUse SLF4J: get a Logger  from the LoggerFactory , and use its various methods for\nlogging.\nDiscussion\nUsing SLF4J requires only one JAR file to compile, slf4j-api-1.x.y.jar  (where x and y\nwill change over time). To actually get logging output, you need to add one of several\nimplementation JARs to your runtime CLASSPATH , the simplest of which is slf4j-\nsimple-1.x.y.jar  (where x and y should match between the two files).\nOnce you’ve added those JAR files to your build script or on your CLASSPATH , you can\nget a Logger  by calling LoggerFactory.getLogger() , passing either the string name\nof a class or package or just the current Class  reference. Then call the logger’s logging\nmethods. A simple example is in Example 13-12 .\nExample 13-12. main/src/main/java/logging/Slf4jDemo.java\npublic class Slf4jDemo  {\n    final static Logger theLogger  =\n            LoggerFactory .getLogger (Slf4jDemo .class);\n    public static void main(String[] args) {\n13.10 Setting Up SLF4J | 437\n        Object o = new Object();\n        theLogger .info(""I created this object: ""  + o);\n    }\n}\nThere are various methods used to log information at different levels of severity,\nwhich are shown in Table 13-1 .\nTable 13-1. SLF4j logging methods\nName Meaning\ntrace Verbose debugging (disabled by default)\ndebug Verbose debugging\ninfo Low-level informational message\nwarn Possible error\nerror Serious error\nOne of the advantages of SLF4j over most of the other logging APIs is the avoidance\nof the dead string anti-pattern. In the use of many other logger APIs you may find\ncode like the following:\nlogger.log(""The value is ""  + object + ""; this is not good"" );\nThis can lead to a performance problem, in that the object’s toString()  is implicitly\ncalled, and two string concatenations are performed, before we even know if the log‐\nger is going to use them! If this is in code that is called repeatedly, a lot of overhead\ncan be wasted.\nThis led the other logging packages to offer code guards, based on logger methods\nthat can find out very quickly if a logger is enabled, leading to code like the following:\nif (logger.isEnabled ()) {\n logger.log(""The value is ""  + object + ""; this is not good"" );\n}\nThis solves the performance problem but clutters the code! SLF4J’s solution is to use a\nmechanism similar to (but not quite compatible with) Java’s MessageFormat  mecha‐\nnism, as shown in Example 13-13 .\nExample 13-13. main/src/main/java/logging/Slf4jDemo2.java\npublic class Slf4jDemo2  {\n    final static Logger theLogger  = LoggerFactory .getLogger (Slf4jDemo2 .class);\n    public static void main(String[] args) {\n438 | Chapter 13: Server-Side Java",3705
573-See Also.pdf,573-See Also,,0
574-13.11 Network Logging with Log4j.pdf,574-13.11 Network Logging with Log4j,,0
575-Problem.pdf,575-Problem,,0
576-Discussion.pdf,576-Discussion,"try {\n            Person p = new Person();\n            // populate person's fields here...\n            theLogger .info(""I created an object {}"" , p);\n            if (p != null) {    // bogus, just to show logging\n                throw new IllegalArgumentException (""Just testing"" );\n            }\n        } catch (Exception  ex) {\n            theLogger .error(""Caught Exception: ""  + ex, ex);\n        }\n    }\n}\nAlthough this doesn’t demonstrate network logging, it is easy to accomplish that in\nconjunction with a logging implementation like Log4j or JUL (Java Util Logging, a\nstandard part of the JDK), which allow you to provide configurable logging. Log4j  is\ndescribed in the next recipe.\nSee Also\nThe SLF4J website contains a manual  that discusses the various CLASSPATH  options.\nThere are also some Maven artifacts  for the various options.\n13.11 Network Logging with Log4j\nProblem\nY ou wish to write log file messages using Log4j.\nSolution\nGet a Logger  and use its log()  method or the convenience methods. Control logging\nby changing a properties file. Use the org.apache.logging.log4j.net  package to\nmake it network based.\n13.11 Network Logging with Log4j | 439\nDiscussion\nThis recipe describes Version 2 of the Log4j API. Between Version\n1 and Version 2, there are changes to the package names, filenames,\nand the method used to obtain a logger. If you see code using, for\nexample, Logger.getLogger(""class name"") , that code is written\nto the older API, which is no longer maintained (the Log4j website\nrefers to Log4j 1.2, and versions up to 2.12, as “legacy”; we are\nusing 2.13 in this recipe). A good degree of compatibility is offered\nfor code written to the 1.x API; see https://logging.apache.org/\nlog4j/2.x/manual/compatibility.html .\nLogging using Log4j is simple, convenient, and flexible. Y ou need to get a Logger\nobject from the static method LogManager.getLogger() , The Logger  has public void\nmethods  (debug() , info() , warn() , error() , and fatal() ), each of which takes one\nObject  to be logged (and an optional Throwable ). As with System.out.println() , if\nyou pass in anything that is not a String , its toString()  method is called. A generic\nlogging method is also included:\npublic void log(Level level, Object message);\nThe Level  class is defined in the Log4j 2 API. The standard levels are, in order, DEBUG\n< INFO  < WARN  < ERROR  < FATAL . That is, debug messages are considered the least\nimportant, and fatal the most important. Each Logger  has a level associated with it;\nmessages whose level is less than the Logger ’s level are silently discarded.\nA simple application can log messages using these few statements:\npublic class Log4JDemo  {\n    private static Logger myLogger  = LogManager .getLogger ();\n    public static void main(String[] args) {\n        Object o = new Object();\n        myLogger .info(""I created an object: ""  + o);\n    }\n}\nIf you compile and run this program with no log4j2.properties  file, it does not pro‐\nduce any logging output (see the log4j2demos  script in the source folder). We need to\ncreate a configuration file whose default name is log4j2.properties . Y ou can also pro‐\nvide the logfile name via System Properties: -Dlog4j.configurationFile=URL .\n440 | Chapter 13: Server-Side Java\nLog4j configuration is very flexible, and therefore very complex.\nEven their own documentation admits that “Trying to configure\nLog4j without understanding [the logging architecture] will lead to\nfrustration. ” See this Apache website for full details on the logging\nconfiguration file location and format .\nEvery Logger  has a Level  to specify what level of messages to write. It will also have\nan Appender , which is the code that writes the messages out. A ConsoleAppender\nwrites to System.out , of course; other loggers write to files, operating system–level\nloggers, and so on. A simple configuration file looks something like this:\n# Log4J2 properties file for the logger demo programs.\n# tag::generic[] # Ensure file gets copied for Java Cookbook\n# WARNING - log4j2.properties must be on your CLASSPATH,\n# not necessarily in your source directory.\n# The configuration file for Version 2 is different from V1!\nrootLogger.level = info\nrootLogger.appenderRef.stdout.ref = STDOUT\nappender.console.type = Console\nappender.console.name = STDOUT\nappender.console.layout.type = PatternLayout\nappender.console.layout.pattern = %m%n\nappender.console.filter.threshold.type = ThresholdFilter\nappender.console.filter.threshold.level = debug\nThis file gives the root logger a level of DEBUG , which causes it to write all messages.\nThe config file also sets up an appender of APPENDER1 , which is configured on the\nnext few lines. Note that I didn’t have to refer to the com.darwinsys Logger . Because\nevery Logger  inherits from the root logger, a simple application needs to configure\nonly the root logger. The properties file can also be an XML document, or you can\nwrite your own configuration parser (almost nobody does this).\nIf the logging configuration file is not found, the default root logger\ndefaults the root logger to Level.ERROR , so you will not see any\noutput below the ERROR  level.\nWith the configuration file in place, the demonstration works better. Running this\nprogram (with the appropriate CLASSPATH  as done in the scripts) produces this\noutput:\n13.11 Network Logging with Log4j | 441\n$ java Log4j2Demo\nI created an object: java.lang.Object@477b4cdf\n$\nA common use of logging is to log a caught Exception , as shown in Example 13-14 .\nExample 13-14. main/src/main/java/Log4JDemo2.java (Log4j—catching and logging)\npublic class Log4JDemo2  {\n    private static Logger myLogger  = LogManager .getLogger ();\n    public static void main(String[] args) {\n        try {\n            Object o = new Object();\n            myLogger .info(""I created an object: ""  + o);\n            if (o != null) {    // bogus, just to show logging\n                throw new IllegalArgumentException (""Just testing"" );\n            }\n        } catch (Exception  ex) {\n            myLogger .error(""Caught Exception: ""  + ex, ex);\n        }\n    }\n}\nWhen run, Log4JDemo2  produces the expected output:\n$ java Log4JDemo2\nI created an object: java.lang.Object@477b4cdf\nCaught Exception: java.lang.IllegalArgumentException: Just testing\njava.lang.IllegalArgumentException: Just testing\n at logging.Log4JDemo2.main(Log4JDemo2.java:17) [classes/:?]\n$\nMuch of the flexibility of Log4j 2 stems from its use of external configuration files;\nyou can enable or disable logging without recompiling the application. A properties\nfile that eliminates most logging might have this entry:\nrootLogger.level = fatal\nOnly fatal error messages print; all levels less than that are ignored.\nTo log from a client to a server on a remote machine, the SocketAppender  can be\nused. There is also an SmtpAppender  to send urgent notices via email. See https://\nlogging.apache.org/log4j/2.x/manual/appenders.html  for details on all the supported\nAppenders. Here is log4j2-network.properties , the socket-based networking version of\nthe configuration file:\n# Log4J2 properties file for the NETWORKED logger demo programs.\n# tag::generic[] # Ensure file gets copied for Java Cookbook\n442 | Chapter 13: Server-Side Java\n# WARNING - log4j2.properties must be on your CLASSPATH,\n# not necessarily in your source directory.\n# The configuration file for Version 2 is different from V1!\nrootLogger.level = info\nrootLogger.appenderRef.stdout.ref = STDOUT\nappender.console.type = Socket\nappender.console.name = STDOUT\nappender.console.host = localhost\nappender.console.port = 6666\nappender.console.layout.type = PatternLayout\nappender.console.layout.pattern = %m%n\nappender.console.filter.threshold.type = ThresholdFilter\nappender.console.filter.threshold.level = debug\nThis file gets passed to the demo programs via a Java System Property in the netde\nmos script:\nbuild=../../../../target/classes\nlog4j2_jar=\\n${HOME}/.m2/repository/org/apache/logging/log4j/log4j-api/2.13.0/log4j-\napi-2.13.0.jar:\\n${HOME}/.m2/repository/org/apache/logging/log4j/log4j-core/2.13.0/log4j-\ncore-2.13.0.jar\necho ""==> Log4JDemo""\njava -Dlog4j.configurationFile=log4j2-network.properties \\n -classpath "".:${build}:${log4j2_jar}"" logging.Log4JDemo\necho ""==> Log4JDemo2""\njava -Dlog4j.configurationFile=log4j2-network.properties \\n -classpath "".:${build}:${log4j2_jar}"" logging.Log4JDemo2\nWhen run with the log4j2-network.properties  file, you have to arrange for a listener on\nthe other end. On Unix systems the nc (or netcat ) program will work fine:\n$ nc -kl 6666\nI created an object: java.lang.Object@37ceb1df\nI created an object: java.lang.Object@37ceb1df\nCaught Exception: java.lang.IllegalArgumentException: Just testing\njava.lang.IllegalArgumentException: Just testing\n at logging.Log4JDemo2.main(Log4JDemo2.java:17) [classes/:?]\n^C\n$\nNetcat  option -l says to listen on the numbered port; -k tells it to keep listening, that\nis, to reopen the connection when the client closes it, as happens when each demo\nprogram exits.\n13.11 Network Logging with Log4j | 443",9240
577-13.12 Network Logging with java.util.logging.pdf,577-13.12 Network Logging with java.util.logging,,0
578-Problem.pdf,578-Problem,,0
579-Discussion.pdf,579-Discussion,"There is a performance issue with some logging calls. Consider some expensive oper‐\nation, like a toString()  or two along with several string concatenations passed to a\nLog.info()  call in an often-used piece of code. If this is placed into production with\na higher logging level, all the work will be done but the resultant string will never be\nused. In older APIs we used to use “code guards, ” methods like “isLoggerEna‐\nbled(Level), ” to determine whether to bother creating the string. Nowadays, the pre‐\nferred method is to create the string inside a lambda expression (see Chapter 9 ). All\nthe log methods have an overload that accepts a Supplier  argument\n(Example 13-15 ).\nExample 13-15. main/src/main/java/logging/Log4J2Lambda.java\npublic class Log4JLambda  {\n    private static Logger myLogger  = LogManager .getLogger ();\n    public static void main(String[] args) {\n        Person customer  = getPerson ();\n        myLogger .info( () -> String.format(\n            ""Value %d from Customer %s"" , customer .value, customer ) );\n    }\nThis way the string operations will only be performed if needed: if the logger is oper‐\nating at the INFO  level it will call the Supplier  and if not, it won’t do the expensive\noperation.\nWhen run as part of the log4j2demos  script, this prints:\nValue 42 from Customer Customer[Robin]\nFor more information on Log4j, visit its main website . Log4j 2 is free software, dis‐\ntributed under the Apache Software Foundation license. \n13.12 Network Logging with java.util.logging\nProblem\nY ou wish to write logging messages using the Java logging mechanism.\nSolution\nGet a Logger , and use it to log your messages and/or exceptions.\n444 | Chapter 13: Server-Side Java\nDiscussion\nThe Java Logging API (package java.util.logging ) is similar to, and was obviously\ninspired by, the Log4j package. Y ou acquire a Logger  object by calling the static\nLogger.getLogger()  with a descriptive String . Y ou then use instance methods to\nwrite to the log; these methods include the following:\npublic void log(java.util.logging.LogRecord );\npublic void log(java.util.logging.Level,String);\n// and a variety of overloaded log(  ) methods\npublic void logp(java.util.logging.Level,String,String,String);\npublic void logrb(java.util.logging.Level,String,String,String,String);\n// Convenience routines for tracing program flow\npublic void entering (String,String);\npublic void entering (String,String,Object);\npublic void entering (String,String,Object[]);\npublic void exiting(String,String);\npublic void exiting(String,String,Object);\npublic void throwing (String,String,Throwable );\n// Convenience routines for log(  ) with a given level\npublic void severe(String);\npublic void warning(String);\npublic void info(String);\npublic void config(String);\npublic void fine(String);\npublic void finer(String);\npublic void finest(String);\nAs with Log4j, every Logger  object has a given logging level, and messages below that\nlevel are silently discarded:\npublic void setLevel (java.util.logging.Level);\npublic java.util.logging.Level getLevel (  );\npublic boolean isLoggable (java.util.logging.Level);\nAs with Log4j, objects handle the writing of the log. Each logger has a Handler :\npublic synchronized  void addHandler (java.util.logging.Handler);\npublic synchronized  void removeHandler (java.util.logging.Handler);\npublic synchronized  java.util.logging.Handler[] getHandlers (  );\nEach Handler  has a Formatter , which formats a LogRecord  for display. By providing\nyour own Formatter , you have more control over how the information being passed\ninto the log gets formatted.\nUnlike Log4j, the Java SE logging mechanism has a default configuration, so\nExample 13-16  is a minimal logging example program.\n13.12 Network Logging with java.util.logging | 445\nExample 13-16. main/src/main/java/logging/JulLogDemo.java\npublic class JulLogDemo  {\n    public static void main(String[] args) {\n        Logger myLogger  = Logger.getLogger (""com.darwinsys"" );\n        Object o = new Object();\n        myLogger .info(""I created an object: ""  + o);\n    }\n}\nRunning it prints the following:\n$ juldemos\nJan 31, 2020 1:03:27 PM logging.JulLogDemo main\nINFO: I created an object: java.lang.Object@5ca881b5\n$ \nAs with Log4j, one common use is in logging caught exceptions; the code for this is in\nExample 13-17 .\nExample 13-17. main/src/main/java/logging/JulLogDemo2.java (catching and logging\nan exception)\npublic class JulLogDemo2  {\n    public static void main(String[] args) {\n        System.setProperty (""java.util.logging.config.file"" ,\n            ""logging/logging.properties"" );\n        Logger logger = Logger.getLogger (""com.darwinsys"" );\n        try {\n            Object o = new Object();\n            logger.info(""I created an object: ""  + o);\n            if (o != null) {    // bogus, just to show logging\n                throw new IllegalArgumentException (""Just testing"" );\n            }\n        } catch (Exception  t) {\n            // All-in-one call:\n            logger.log(Level.SEVERE, ""Caught Exception"" , t);\n            // Alternate: Long form, more control.\n            // LogRecord msg = new LogRecord(Level.SEVERE, ""Caught exception"");\n            // msg.setThrown(t);\n            // logger.log(msg);\n        }\n    }\n}\nAs with Log4j, java.util.logging  accepts a lambda expression (and has since Java\n8); see Example 13-18 .\n446 | Chapter 13: Server-Side Java",5497
580-See Also.pdf,580-See Also,"Example 13-18. main/src/main/java/logging/JulLambdaDemo.java\n/** Demonstrate how Java 8 Lambdas avoid extraneous object creation\n * @author Ian Darwin\n */\npublic class JulLambdaDemo  {\n    public static void main(String[] args) {\n        Logger myLogger  = Logger.getLogger (""com.darwinsys.jullambda"" );\n        Object o = new Helper();\n        // If you change the log call from finest to info,\n        // you see both the systrace from the toString,\n        // and the logging output. As it is here,\n        // you don't see either, so the toString() is not called!\n        myLogger .finest(() -> ""I created this object: ""  + o);\n    }\n    static class Helper {\n        public String toString () {\n            System.out.println(""JulLambdaDemo.Helper.toString()"" );\n            return ""failure!"" ;\n        }\n    }\n}\nSee Also\nA good general reference on this chapter’s topic is Java Network Programming  by\nElliotte Harold.\nThe server side of any network mechanism is extremely sensitive to security issues. It\nis easy for one misconfigured or poorly written server program to compromise the\nsecurity of an entire network! Of the many books on network security, two stand out:\nFirewalls and Internet Security  by William R. Cheswick et al. (Addison-Wesley) and a\nseries of books with Hacking Exposed  in the title, the first in the series by Stuart\nMcClure et al. (McGraw-Hill).\nThis completes my discussion of server-side Java using sockets. A chat server could\nbe implemented using several technologies, such as RMI (Remote Methods Invoca‐\ntion), an HTTP web service, JMS (Java Message Service), and a Java Enterprise API\nthat handles store-and-forward message processing. This is beyond the scope of this\nbook, but there’s an example of an RMI chat server in the chat folder of the source\ndistribution, and there’s an example of a JMS chat server in Java Message Service  by\nMark Richards et al. (O’Reilly).\n13.12 Network Logging with java.util.logging | 447",1999
581-Chapter 14. Processing JSON Data.pdf,581-Chapter 14. Processing JSON Data,,0
582-14.0 Introduction.pdf,582-14.0 Introduction,"CHAPTER 14\nProcessing JSON Data\n14.0 Introduction\nJSON, or JavaScript Object Notation, is all of the following:\n•A simple, lightweight data interchange format.\n•A simpler, lighter alternative to XML.\n•Easy to generate with println()  or with one of several APIs.\n•Recognized directly by the JavaScript parser in all web browsers.\n•Supported with add-on frameworks for all common languages (Java, C/C++,\nPerl, Ruby, Python, Lua, Erlang, Haskell, to name a few); a ridiculously long list\nof supported languages (including two dozen parsers for Java alone) is right on\nthe home page .\nA simple JSON message might look like this:\njson/src/main/resources/json/softwareinfo.json/\n{\n  ""name"": ""robinparse"" ,\n  ""version"" : ""1.2.3"",\n  ""description"" : ""Another Parser for JSON"" ,\n  ""className"" : ""RobinParse"" ,\n  ""contributors"" : [\n        ""Robin Smythe"" ,\n        ""Jon Jenz"" ,\n        ""Jan Ardann""\n    ]\n}\nAs you can see, the syntax is simple, nestable, and amenable to human inspection.\n449\nThe JSON home page  provides a concise summary of JSON syntax. There are two\nkinds of structure: JSON objects (maps) and JSON arrays (lists). JSON objects are sets\nof name and value pairs, which can be represented either as a java.util.Map  or as\nthe properties of a Java object. For example, the fields of a LocalDate  (see Recipe 6.1 )\nobject for April 1, 2019, might be represented like this:\n{\n ""year"": 2019,\n ""month"": 4,\n ""day"" : 1\n}\nJSON arrays are ordered lists, represented in Java either as arrays or as\njava.util.List s. A list of two dates might look like this:\n{\n [{\n  ""year"": 2019,\n  ""month"": 4,\n  ""day"" : 1\n },{\n  ""year"": 2019,\n  ""month"": 5,\n  ""day"" : 15\n }]\n}\nJSON is free-format, so the preceding could also be written, with some loss of human\nreadability but no loss of information or functionality, as this:\n{[{""year"":2019,""month"":4,""day"":1},{""year"":2019,""month"":5,""day"":15}]}\nHundreds of parsers have, I’m sure, been written for JSON. A few that come to mind\nin the Java world include the following:\nstringtree.org\nVery small and lightweight\njson.org parser\nWidely used because it’s free and has a good domain name\njackson.org parser\nWidely used because it’s very powerful and used with Spring Framework and\nwith JBoss RESTEasy and Wildfly\njavax.json\nOracle’s official but currently EE-only standard\nThis chapter shows several ways of processing JSON data using some of the various\nAPIs just listed. The official javax.json  API is only included in the Java EE, not the\nJava SE, so it is unlikely to see very much use on the client side. This API uses some\n450 | Chapter 14: Processing JSON Data",2664
583-14.1 Generating JSON Directly.pdf,583-14.1 Generating JSON Directly,,0
584-Problem.pdf,584-Problem,,0
585-Solution.pdf,585-Solution,,0
586-14.2 Parsing and Writing JSON with Jackson.pdf,586-14.2 Parsing and Writing JSON with Jackson,"names in common with the org.json  API, but not enough to be considered\ncompatible.\nBecause this is a book for client-side Java developers, nothing will be made of the\nability to process JSON directly in server-generated, browser-based JavaScript,\nthough this can be very useful in building enterprise applications.\n14.1 Generating JSON Directly\nProblem\nY ou want to generate JSON without bothering to use an API.\nSolution\nGet the data you want, and use println()  or String.format()  as appropriate.\nDiscussion\nIf you are careful, you can generate JSON data yourself. For the utterly trivial cases,\nyou can just use PrintWriter.println()  or String.format() . For significant vol‐\numes, however, it’s usually better to use one of the APIs.\nThis code prints the year, month, and date from a LocalTime  object (see Recipe 6.1 ).\nSome of the JSON formatting is delegated to the toJson()  method:\n/**\n * Convert an object to JSON, not using any JSON API.\n * BAD IDEA - should use an API!\n */\npublic class LocalDateToJsonManually  {\n    private static final String OPEN = ""{"";\n    private static final String CLOSE = ""}"";\n    public static void main(String[] args) {\n        LocalDate  dNow = LocalDate .now();\n        System.out.println(toJson(dNow));\n    }\n    public static String toJson(LocalDate  dNow) {\n        StringBuilder  sb = new StringBuilder ();\n        sb.append(OPEN).append(""\n"");\n        sb.append(jsonize(""year"", dNow.getYear()));\n        sb.append(jsonize(""month"", dNow.getMonth ()));\n        sb.append(jsonize(""day"", dNow.getDayOfMonth ()));\n        sb.append(CLOSE).append(""\n"");\n        return sb.toString ();\n    }\n14.1 Generating JSON Directly | 451",1706
587-Problem.pdf,587-Problem,,0
588-Solution.pdf,588-Solution,,0
589-14.3 Parsing and Writing JSON with org.json.pdf,589-14.3 Parsing and Writing JSON with org.json,"public static String jsonize(String key, Object value) {\n        return String.format(""\""%s\"": \""%s\"",\n"" , key, value);\n    }\n}\nOf course, this is an extremely trivial example. For anything more involved, or for the\ncommon case of having to parse JSON objects, using one of the frameworks will be\neasier on your nerves.\n14.2 Parsing and Writing JSON with Jackson\nProblem\nY ou want to read and/or write JSON using a full-function JSON API.\nSolution\nUse Jackson, the full-blown JSON API.\nDiscussion\nJackson provides many ways of working. For simple cases, you can have POJO (Plain\nOld Java Objects) converted to/from JSON more or less automatically, as is illustrated\nin Example 14-1 .\nExample 14-1. json/src/main/java/json/ReadWriteJackson.java (reading and writing\nPOJOs with Jackson)\npublic class ReadWriteJackson  {\n    public static void main(String[] args) throws IOException  {\n        ObjectMapper  mapper = new ObjectMapper ();                \n        String jsonInput  =                                       \n                ""{\""id\"":0,\""firstName\"":\""Robin\"",\""lastName\"":\""Wilson\""}"" ;\n        Person q = mapper.readValue (jsonInput , Person.class);\n        System.out.println(""Read and parsed Person from JSON: ""  + q);\n        Person p = new Person(""Roger"", ""Rabbit"" );                \n        System.out.print(""Person object ""  + p +"" as JSON = "" );\n        mapper.writeValue (System.out, p);\n    }\n}\nCreate a Jackson ObjectMapper  that can map POJOs to/from JSON.\nMap the string jsonInput  into a Person  object with one call to readValue() .\n452 | Chapter 14: Processing JSON Data",1629
590-Solution.pdf,590-Solution,"Convert the Person  object p into JSON with one call to writeValue() .\nRunning this example produces the following output:\nRead and parsed Person from JSON: Robin Wilson\nPerson object Roger Rabbit as JSON = {""id"":0,""firstName"":""Roger"",\n ""lastName"":""Rabbit"",""name"":""Roger Rabbit""}\nAs another example, this code reads the example file that opened this chapter (which\nhappens to have been a description of a JSON parser). Notice the declaration\nList<String>  for the array of contributors:\npublic class SoftwareParseJackson  {\n    final static String FILE_NAME  = ""/json/softwareinfo.json"" ;\n    public static void main(String[] args) throws Exception  {\n        ObjectMapper  mapper = new ObjectMapper (); \n        InputStream  jsonInput  =\n            SoftwareParseJackson .class.getResourceAsStream (FILE_NAME );\n        if (jsonInput  == null) {\n            throw new NullPointerException (""can't find ""  + FILE_NAME );\n        }\n        SoftwareInfo  sware = mapper.readValue (jsonInput , SoftwareInfo .class);\n        System.out.println(sware);\n    }\n}\nThe ObjectMapper  does the actual parsing of the JSON input.\nRunning this example produces the following output:\nSoftware: robinparse (1.2.3) by [Robin Smythe, Jon Jenz, Jan Ardann]\nOf course there are cases where the mapping gets more involved; for this purpose,\nJackson provides a set of annotations to control the mapping. But the default map‐\nping is pretty good!\nThere is also a streaming API for Jackson; refer to the website for details.\n14.3 Parsing and Writing JSON with org.json\nProblem\nY ou want to read/write JSON using a midsized, widely used JSON API.\n14.3 Parsing and Writing JSON with org.json | 453",1702
591-See Also.pdf,591-See Also,"Solution\nConsider using the org.json API , also known as JSON-Java; it’s widely used and is\nalso used in Android.\nDiscussion\nThe org.json  package is not as advanced as Jackson, nor as high level; it makes you\nthink and work in terms of the underlying JSON abstractions instead of at the Java\ncode level. For example, here is the org.json  version of reading the software descrip‐\ntion from the opening of this chapter:\npublic class SoftwareParseOrgJson  {\n    final static String FILE_NAME  = ""/json/softwareinfo.json"" ;\n    public static void main(String[] args) throws Exception  {\n        InputStream  jsonInput  =\n            SoftwareParseOrgJson .class.getResourceAsStream (FILE_NAME );\n        if (jsonInput  == null) {\n            throw new NullPointerException (""can't find""  + FILE_NAME );\n        }\n        JSONObject  obj = new JSONObject (new JSONTokener (jsonInput ));      \n        System.out.println(""Software Name: ""  + obj.getString (""name""));    \n        System.out.println(""Version: ""  + obj.getString (""version"" ));\n        System.out.println(""Description: ""  + obj.getString (""description"" ));\n        System.out.println(""Class: ""  + obj.getString (""className"" ));\n        JSONArray  contribs  = obj.getJSONArray (""contributors"" );            \n        for (int i = 0; i < contribs .length(); i++) {                     \n            System.out.println(""Contributor Name: ""  + contribs .get(i));\n        }\n    }\n}\nCreate the JSONObject  from the input.\nRetrieve individual String  fields.\nRetrieve the JSONArray  of contributor names.\norg.json.JSONArray  doesn’t implement Iterable , so you can’t use a forEach\nloop.\nRunning it produces the expected output:\nSoftware Name: robinparse\nVersion: 1.2.3\nDescription: Another Parser for JSON\nClass: RobinParse\n454 | Chapter 14: Processing JSON Data",1849
592-14.4 Parsing and Writing JSON with JSON-B.pdf,592-14.4 Parsing and Writing JSON with JSON-B,,0
593-Problem.pdf,593-Problem,,0
594-Solution.pdf,594-Solution,,0
595-14.5 Finding JSON Elements with JSON Pointer.pdf,595-14.5 Finding JSON Elements with JSON Pointer,"Contributor Name: Robin Smythe\nContributor Name: Jon Jenz\nContributor Name: Jan Ardann\nJSONObject  and JSONArray  use their toString()  method to produce (correctly for‐\nmatted) JSON strings, like this:\npublic class WriteOrgJson  {\n    public static void main(String[] args) {\n        JSONObject  jsonObject  = new JSONObject ();\n        jsonObject .put(""Name"", ""robinParse"" ).        \n            put(""Version"" , ""1.2.3"").\n            put(""Class"", ""RobinParse"" );\n        String printable  = jsonObject .toString ();    \n        System.out.println(printable );\n    }\n}\nNice that it offers a fluent API to allow chaining of method calls.\ntoString()  converts to textual JSON representation.\nRunning this produces the following:\n{""Name"":""robinParse"" ,""Class"":""RobinParse"" ,""Version"" :""1.2.3""}\nSee Also\nThe org.json library code including its javadoc documentation is online at https://\ngithub.com/stleary/JSON-java . (under the name JSON-java to differentiate it from the\nother packages).\n14.4 Parsing and Writing JSON with JSON-B\nProblem\nY ou want to read/write JSON using a midsized, standards-conforming JSON API.\nSolution\nConsider using JSON-B, the new Java standard (JSR-367).\nDiscussion\nThe JSON-B (JSON Binding) API is designed to make it simple to read/write Java\nPOJOs. This is neatly illustrated by the code in Example 14-2 .\n14.4 Parsing and Writing JSON with JSON-B | 455\nExample 14-2. json/src/main/java/json/ReadWriteJsonB.java (reading/writing JSON\nwith JSON-B)\npublic class ReadWriteJsonB  {\n    public static void main(String[] args) throws IOException  {\n        Jsonb jsonb = JsonbBuilder .create();            \n        // Read\n        String jsonInput  =                              \n                ""{\""id\"":0,\""firstName\"":\""Robin\"",\""lastName\"":\""Williams\""}"" ;\n        Person rw = jsonb.fromJson (jsonInput , Person.class);\n        System.out.println(rw);\n        String result = jsonb.toJson(rw);                \n        System.out.println(result);\n    }\n}\nCreate a Jsonb  object, your gateway to JSON-B services.\nObtain a JSON string, and convert it to a Java object using jsonb.fromJson() .\nConvert a Person  object back to a JSON string using the inverse jsonb.toJ\nson() .\nNote that the methods are sensibly named and that no annotations are needed on the\nJava entity class to make this work. However, there is an API that allows us to cus‐\ntomize it. For example, the fullName  property is really just a convenience for concat‐\nenating the first name and last name with a space between. As such, it’s completely\nredundant and does not need to be transmitted over a JSON network stream. How‐\never, running the program produces this output:\n{""firstName"" :""Robin"",""fullName"" :""Robin Williams"" ,""id"":0,""lastName"" :""Williams"" }\nWe need only add the @JsonbTransient  annotation to the getFullName()  accessor in\nthe Person  class to eliminate the redundancy; running the program now produces\nthis smaller output:\n{""firstName"" :""Robin"",""id"":0,""lastName"" :""Williams"" }\nSee Also\nAs with most other JSON APIs, there is full support for customization, ranging from\nthe simple annotation shown here up to writing complete custom serializer/deserial‐\nizer helpers. See the JSON-B spec page , the JSON-B home page , and this longer tuto‐\nrial online .\n456 | Chapter 14: Processing JSON Data",3371
596-Problem.pdf,596-Problem,,0
597-Solution.pdf,597-Solution,,0
598-Discussion.pdf,598-Discussion,"14.5 Finding JSON Elements with JSON Pointer\nProblem\nY ou have a JSON document and want to extract only selected values from it.\nSolution\nUse javax.json ’s implementation of JSON Pointer , the standard API for extracting\nselected elements from JSON.\nDiscussion\nThe Internet Standard RFC 6901  spells out in detail the syntax for JSON Pointer, a\nlanguage-independent syntax for matching elements in JSON documents. Obviously\ninspired by the XML syntax XPath, JSON Pointer is a bit simpler than XPath because\nof JSON’s inherent simpllicity. Basically a JSON Pointer is a string that identifies an\nelement (either simple or array) within a JSON document. The javax.json  package\nprovides an object model API somewhat similar to the XML DOM API for Java, let‐\nting you create immutable objects to represent objects (via JsonObjectBuilder  and\nJsonArrayBuilder ) or to read them from JSON string format via a Reader  or Input\nStream .\nJSON Pointers begin with a “/” (inherited from XPath), followed by the name of the\nelement or subelement we want to look for. Suppose we extend our Person  example\nfrom Example 14-2  to add an array of roles the comedian played, looking like this:\n{""firstName"" :""Robin"",""lastName"" :""Williams"" ,\n ""age"": 63,""id"":0,\n ""roles"":[""Mork"", ""Mrs. Doubtfire"" , ""Patch Adams"" ]}\nThen the following JSON Pointers should generate the given matches:\n/firstName => Robin\n/age => 63\n/roles => [""Mork"",""Mrs. Doubtfire"",""Patch Adams""]\n/roles/1 => ""Mrs. Doubtfire""\nThe program in Example 14-3  demonstrates this.\nExample 14-3. json/src/main/java/json/JsonPointerDemo.java\npublic class JsonPointerDemo  {\n    public static void main(String[] args) {\n        String jsonPerson  =\n            ""{\""firstName\"":\""Robin\"",\""lastName\"":\""Williams\"",""  +\n                ""\""age\"": 63,""  +\n14.5 Finding JSON Elements with JSON Pointer | 457\n                ""\""id\"":0,""  +\n                ""\""roles\"":[\""Mork\"", \""Mrs. Doubtfire\"", \""Patch Adams\""]}"" ;\n        System.out.println(""Input: ""  + jsonPerson );\n        JsonReader  rdr =\n                Json.createReader (new StringReader (jsonPerson ));       \n        JsonStructure  jsonStr = rdr.read();\n        rdr.close();\n        JsonPointer  jsonPointer ;\n        JsonString  jsonString ;\n        jsonPointer  = Json.createPointer (""/firstName"" );                \n        jsonString  = (JsonString )jsonPointer .getValue (jsonStr);\n        String firstName  = jsonString .getString ();\n        System.out.println(""/firstName => ""  + firstName );\n        JsonNumber  num =                                               \n                (JsonNumber ) Json.createPointer (""/age"").getValue (jsonStr);\n        System.out.println(""/age => ""  + num + ""; a "" + num.getClass ().getName());\n        jsonPointer  = Json.createPointer (""/roles"" );                    \n        JsonArray  roles = (JsonArray ) jsonPointer .getValue (jsonStr);\n        System.out.println(""/roles => ""  + roles);\n        System.out.println(""JsonArray roles.get(1) => ""  + roles.get(1));\n        jsonPointer  = Json.createPointer (""/roles/1"" );                  \n        jsonString  = (JsonString )jsonPointer .getValue (jsonStr);\n        System.out.println(""/roles/1 => ""  + jsonString );\n    }\n}\nCreate the JsonStructure , the gateway into this API, from a JsonReader , using a\nStringReader .\nCreate a JSON Pointer for the firstName  element, and get the JsonString  from\nthe element’s value. Since getValue()  will throw an exception if the element is\nnot found, use jsonPointer.containsValue(jsonStr)  to check first, if not sure\nif the element will be found.\nSame for age, but using more fluent syntax. If you print the class name for the\nmatch in /age , it will report an implementation-specific implementation class,\nsuch as org.glassfish.json.JsonNumberImpl$JsonIntNumber . Change the age\nin the XML from 63 to 63.5 and it will print a class with BigDecimal  in its name.\nEither way, toString()  on this object will return just the numeric value.\n458 | Chapter 14: Processing JSON Data",4083
599-See Also.pdf,599-See Also,,0
600-Summary.pdf,600-Summary,"In the JSON file, roles  is an array. Thus, getting it using a JSON Pointer should\nreturn a JsonArray  object, so we cast it to a reference of that type. This behaves\nsomewhat like an immutable List  implementation, so we call get() . JSON array\nindices start at zero, as in Java.\nRetrieve the same array element directly, using a pattern with “/1” to mean the\nnumbered element in the array.\nIt is possible (but fortunately not common) for a JSON element name to contain spe‐\ncial characters such as a slash. Most characters are not special to JSON Pointer, but to\nmatch a name containing a slash ( /), the slash must be entered as ~1, and since that\nmakes the tilde ( ~) special, tilde characters must be entered as ~0. Thus if the Person\nJSON file had an element like ""ft/pt/~"" , you would look for it with Json.create\nPointer(""/ft~1pt~1~0""); .\nSee Also\nThe JSON Pointer API has additional methods that let you modify values and add/\nremove elements. The offical home page for javax.json , which includes JSON\nPointer, is at jakarta.ee . The javadoc for javax.json  is linked to from that page.\nSummary\nMany APIs exist for Java. Jackson is the biggest and most powerful; org.json,\njavax.json, and JSON-B are in the middle and StringTree (which I didn’t give an\nexample of because it doesn’t have a Maven Artifact available) is the smallest. For a\nlist of these and other JSON APIs, consult https://www.json.org/json-en.html  and\nscroll past the syntax summary.\n14.5 Finding JSON Elements with JSON Pointer | 459",1535
601-Chapter 15. Packages and Packaging.pdf,601-Chapter 15. Packages and Packaging,,0
602-15.1 Creating a Package.pdf,602-15.1 Creating a Package,"6This is not strictly true. On Unix in C, at least, there is a distinction between normal include files and those in\nthe sys subdirectory, and many structures have names beginning with one or two letters and an underscore in\nthe password structure, like pw_name , pw_passwd , and pw_home . But this is nowhere near as consistent as Java’s\njava.*  naming conventions.CHAPTER 15\nPackages and Packaging\n15.0 Introduction\nOne of the better aspects of the Java language is that it has defined a very clear pack‐\naging mechanism for categorizing and managing its large API. Contrast this with\nmost other languages, where symbols may be found in the C library itself or in any of\ndozens of other libraries, with no clearly defined naming conventions.6 APIs consist\nof one or more package, packages consist of classes, and classes consist of methods\nand fields. Anybody can create a package, with one important restriction: you or I\ncannot create a package whose name begins with the four letters java . Packages\nnamed java . or javax . are reserved for use by Oracle’s Java developers, under the\nmanagement of the Java Community Process (JCP). When Java was new, there were\nabout a dozen packages in a structure that is very much still with us, though it has\nquadrupled in size; some of these packages are shown in Table 15-1 .\nTable 15-1. Java packages basic structure\nName Function\njava.awt Graphical user interface\njava.io Reading and writing\njava.lang Intrinsic classes ( String , etc.)\njava.lang.annotation Library support for annotation processing\njava.math Math library\n461",1597
603-Problem.pdf,603-Problem,,0
604-Solution.pdf,604-Solution,,0
605-Discussion.pdf,605-Discussion,"Name Function\njava.net Networking (sockets)\njava.nio “New” I/O (not new anymore): channel-based I/O\njava.sql Java database connectivity\njava.text Handling and formatting/parsing dates, numbers, messages\njava.time Java 8: modern date/time API (JSR-311)\njava.util Utilities (collections, date)\njava.util.regex Regular expressions\njavax.naming JNDI\njavax.print Support for printing\njavax.script Java 6: scripting engines support\njavax.swing Modern graphical user interface\nMany packages have been added over the years, but the initial structure has stood the\ntest of time fairly well. In this chapter, I’ll show you how to create and document your\nown packages, and then I’ll discuss a number of issues related to deploying your\npackage in various ways on various platforms.\nThis chapter also covers the more traditional meaning of packaging, as in, creating a\npackage of your program for others to use. This covers the Java Platform Modules\nSystem (JPMS) introduced in Java 9. We also cover jlink , a tool for creating a mini-\nJava distribution containing your application and only the parts of the JDK that you\nactually use. We do not yet cover the jpackage  tool for packaging applications,\nbecause it’s not yet in the JDK; it may arrive with Java 14 or 15.\n15.1 Creating a Package\nProblem\nY ou want to be able to import classes and/or organize your classes, so you want to\ncreate your own package.\nSolution\nPut a package  statement at the front of each file, and recompile with -d or a build tool\nor IDE.\nDiscussion\nThe package  statement must be the very first noncomment statement in your Java\nsource file—preceding even import  statements—and it must give the full name of the\npackage. Package names are expected to start with your domain name backward; for\n462 | Chapter 15: Packages and Packaging\nexample, my internet domain is darwinsys.com , so most of my packages begin with\ncom.darwinsys  and a project name. The utility classes used in this book and meant\nfor reuse are in one of the com.darwinsys  packages listed in Recipe 1.6 , and each\nsource file begins with a statement, such as this:\npackage com.darwinsys.util;\nThe demonstration classes in the JavaSrc  repository do not follow this pattern; they\nare in packages with names related to the chapter they are in or the java.*  package\nthey relate to; for example, lang  for basic Java stuff, structure  for examples from the\ndata structuring chapter ( Chapter 7 ), threads  for the threading chapter ( Chapter 16 ),\nand so on. It is hoped that you will put them in a “real” package if you reuse them in\nyour application!\nOnce you have package statements in place, be aware that the Java runtime, and even\nthe compiler, will expect the compiled .class  files to be found in their rightful place\n(i.e., in the subdirectory corresponding to the full name somewhere in your CLASS\nPATH  settings). For example, the class file for com.darwinsys.util.FileIO  must not\nbe in the file FileIO.class  in my CLASSPATH  but must be in com/darwinsys/util/\nFileIO.class  relative to one of the directories or archives in my CLASSPATH . Accord‐\ningly, if you are compiling with the command-line compiler, it is customary (almost\nmandatory) to use the -d command-line argument when compiling. This argument\nmust be followed by the name of an existing directory (often . is used to signify the\ncurrent directory) to specify where to build the directory tree. For example, to com‐\npile all the .java  files in the current directory, and create the directory path under it\n(e.g., create ./com/darwinsys/util  in the example), use this:\njavac -d . *.java\nThis creates the path (e.g., com/darwinsys/util/ ) relative to the current directory and\nputs the class files into that subdirectory. This makes life easy for subsequent compi‐\nlations and also for creating archives, which is covered in Recipe 15.5 .\nOf course, if you use a build tool such as Maven (see Recipe 1.7 ), this will be done\ncorrectly by default (Maven), so you won’t have to remember to keep doing it!\nNote that in all modern Java environments, classes that do not belong to a package \n(the anonymous package ) cannot be listed in an import  statement, although they can\nbe referred to by other classes in that package. They also cannot become part of a\nJPMS module.\n15.1 Creating a Package | 463",4376
606-15.2 Documenting Classes with Javadoc.pdf,606-15.2 Documenting Classes with Javadoc,,0
607-Problem.pdf,607-Problem,,0
608-Solution.pdf,608-Solution,,0
609-Discussion.pdf,609-Discussion,"15.2 Documenting Classes with Javadoc\nProblem\nY ou have heard about this thing called code reuse  and would like to promote it by\nallowing other developers to use your classes.\nSolution\nUse javadoc. Write the comments when you write the code.\nDiscussion\nJavadoc is one of the great inventions of the early Java years. Like so many good\nthings, it was not wholly invented by the Java folks; earlier projects such as Knuth’s\nLiterate Programming had combined source code and documentation in a single\nsource file. But the Java folks did a good job on it and came along at the right time.\nJavadoc is to Java classes what man pages  are to Unix, or what Windows Help is to\nWindows applications: it is a standard format that everybody expects to find and\nknows how to use. Learn it. Use it. Write it. Live long and prosper (well, perhaps that’s\nnot guaranteed). But all that HTML documentation that you learned from writing\nJava code, the complete reference for the JDK—did you think they hired dozens of\ntech writers to produce it? Nay, that’s not the Java way. Java’s developers wrote the\ndocumentation comments as they went along, and when the release was made, they\nran javadoc on all the zillions of public classes and generated the documentation bun‐\ndle at the same time as the JDK. Y ou can, should, and really must do the same when\nyou are preparing classes for other developers to use.\nAll you have to do to use javadoc is to put special javadoc comments  into your Java\nsource files. These are similar to multiline Java comments, but they begin with a slash\nand two stars and end with the normal star-slash. Javadoc comments must appear\nimmediately before the definition of the class, method, or field that they document; if\nplaced elsewhere, they are ignored.\nA series of keywords, prefixed by the at sign, can appear inside doc comments in cer‐\ntain contexts. Some are contained in braces. The keywords as of Java 8 are listed in\nTable 15-2 .\n464 | Chapter 15: Packages and Packaging\nTable 15-2. Javadoc keywords\nKeyword Use\n@author Author name(s)\n{@code text} Displays text in code font without HTML interpretation\n@deprecated Causes deprecation warning\n{@docroot} Refers to the root of the generated documentation tree\n@exception Alias for @throws\n{@inheritDoc} Inherits documentation from nearest superclass/superinterface\n@link Generates inline link to another class or member\n@linkplain As @link  but displays in plain text\n{@literal text} Displays text without interpretation\n@param name description Argument name and meaning (methods only)\n@return Return value\n@see Generate cross-reference link to another class or member\n@serial Describes serializable field\n@serialData Describes order and types of data in serialized form\n@serialField Describes serializable field\n@since JDK version in which introduced (primarily for Sun use)\n@throws Exception class and conditions under which thrown\n{@value [ ref]} Displays values of this or another constant field\n@version Version identifier\nExample 15-1  is a somewhat contrived example that shows some common javadoc\nkeywords in use. The output of running this through javadoc is shown in a browser\nin Figure 15-1 .\nExample 15-1. main/src/main/java/javadoc/JavadocDemo.java\npublic class JavadocDemo  extends JPanel {\n    private static final long serialVersionUID  = 1L;\n    /**\n     * Construct the GUI\n     * @throws java.lang.IllegalArgumentException if constructed on a Sunday.\n     */\n    public JavadocDemo () {\n        // We create and add a pushbutton here,\n        // but it doesn't do anything yet.\n        Button b = new Button(""Hello"");\n        add(b);                        // connect Button into component\n        // Totally capricious example of what you should not do\n15.2 Documenting Classes with Javadoc | 465\n        if (Calendar .getInstance ().get(Calendar .DAY_OF_WEEK ) == Calendar .SUNDAY) {\n            throw new IllegalArgumentException (""Never On A Sunday"" );\n        }\n    }\n    /** paint() is an AWT Component method, called when the\n     * component needs to be painted. This one just draws colored\n     * boxes in the window.\n     *\n     * @param g A java.awt.Graphics that we use for all our\n     * drawing methods.\n     */\n    public void paint(Graphics  g) {\n        int w = getSize().width, h = getSize().height;\n        g.setColor (Color.YELLOW);\n        g.fillRect (0, 0, w/2, h);\n        g.setColor (Color.GREEN);\n        g.fillRect (w/2, 0, w, h);\n        g.setColor (Color.BLACK);\n        g.drawString (""Welcome to Java"" , 50, 50);\n    }\n}\nThe javadoc tool works fine for one class but really comes into its own when dealing\nwith a package or collection of packages. Y ou can provide a package summary file for\neach package, which will be incorporated into the generated files. Javadoc generates\nthoroughly interlinked and crosslinked documentation, just like that which accompa‐\nnies the standard JDK. There are several command-line options; I normally use\n-author  and -version  to get it to include these items, and often -link  to tell it where\nto find the standard JDK to link to.\nRun javadoc -help  for a complete list of options, or see the full documentation\nonline at Oracle’s website . Figure 15-1  shows one view of the documentation that the\nclass shown in Example 15-1  generates when run as the following:\n$ javadoc -author -version JavadocDemo.java\nIf you run this with Java 9+, it will also include a fully functional search box, shown in\nthe upper right of Figure 15-1 . This is implemented in JavaScript, so it should work in\nany modern browser.\nBe aware that quite a few files are generated, and one of the generated files will have\nthe same name as each class, with the extension .html . If you happened to have an\nHTML file documenting the class, and you generate javadoc in the source directory,\nthe .html  file is silently overwritten with the javadoc output. If you wish to avoid clut‐\ntering up your source directories with the generated files, the -d __directorypath\noption to javadoc allows you to place the generated files into the specified directory.\n466 | Chapter 15: Packages and Packaging",6228
610-See Also.pdf,610-See Also,,0
611-15.3 Beyond Javadoc AnnotationsMetadata.pdf,611-15.3 Beyond Javadoc AnnotationsMetadata,"Figure 15-1. Javadoc opened in a browser\nSee Also\nJavadoc has numerous other command-line arguments. If documentation is for your\nown use only and will not be distributed, you can use the -link  option to tell it where\nyour standard JDK documentation is installed so that links can be generated to stan‐\ndard Java classes (like String , Object , and so on). If documentation is to be dis‐\ntributed, you can omit -link  or use -link  with a URL to the appropriate Java API\npage on Oracle’s website. See the online tools documentation for all the command-\nline options.\nThe output that javadoc generates is fine for most purposes. It is possible to write\nyour own Doclet  class to make the javadoc program into a class documentation veri‐\nfier, a Java-to-other-format (such as Java-to-RTF) documentation generator, or what‐\never you like. Those are actual examples; see the javadoc tools documentation that\ncomes with the JDK for documents and examples, or go to Oracle’s website . Visit\nDoclet  for a somewhat dated but useful collection of Doclets and other javadoc-based\ntools.\nJavadoc Versus JavaHelp\nJavadoc is for programmers using your classes; for a GUI application, end users will\nprobably appreciate standard online help. This is the role of the JavaHelp API, which\nis not covered in this book but is fully explained in Creating Effective  JavaHelp  by\nKevin Lewis (O’Reilly), which every GUI application developer should read. JavaHelp\nis another useful specification that was somewhat left to coast during the Sun sellout\nto Oracle; it is now hosted on java.net  at javahelp .\n15.2 Documenting Classes with Javadoc | 467",1653
612-Problem.pdf,612-Problem,,0
613-Solution.pdf,613-Solution,,0
614-15.4 Preparing a Class as a JavaBean.pdf,614-15.4 Preparing a Class as a JavaBean,"15.3 Beyond Javadoc: Annotations/Metadata\nProblem\nY ou want to generate not just documentation from your source code, but also other\ncode artifacts. Y ou want to mark code for additional compiler verification.\nSolution\nUse the Java Annotations, or Metadata, facility.\nDiscussion\nThe continuing success of the open source tool XDoclet —originally used to generate\nthe tedious auxiliary classes and deployment descriptor files for the widely criticized\nEJB2 framework—led to a demand for a similar mechanism in standard Java. Java\nAnnotations  were the result. The annotation  mechanism uses an interface-like syntax,\nin which both declaration and use of annotations use the name preceded by an at\ncharacter ( @). This was chosen, according to the designers, to be reminiscent of “Java‐\ndoc tags, a preexisting ad hoc annotation facility in the Java programming language. ”\nJavadoc is ad hoc only in the sense that its @ tags were never fully integrated into the\nlanguage; most were ignored by the compiler, but @deprecated  was always under‐\nstood by the compiler (see Recipe 1.9 ).\nAnnotations can be read at runtime by use of the Reflection API; this is discussed in\nRecipe 17.10 , where I also show you how to define your own annotations. Annota‐\ntions can also be read post–compile time by tools such as code generators (and others\nto be invented, perhaps by you, gentle reader!).\nAnnotations are also read by javac  at compile time to provide extra information to\nthe compiler.\nFor example, a common coding error is overloading a method when you mean to\noverride it, by mistakenly using the wrong argument type. Consider overriding the\nequals method in Object . If you mistakenly write\npublic boolean equals(MyClass obj) {\n    ...\n}\nthen you have created a new overload that will likely never be called, and the default\nversion in Object  will be called. To prevent this, an annotation included in java.lang\nis the Override  annotation. This has no parameters but simply is placed before the\nmethod call, like this:\n/**\n * AnnotationOverrideDemo - Simple demonstation of Metadata being used to\n468 | Chapter 15: Packages and Packaging",2173
615-Problem.pdf,615-Problem,,0
616-Solution.pdf,616-Solution,,0
617-Discussion.pdf,617-Discussion,"* verify that a method does in fact override (not overload) a method\n * from the parent class. This class provides the method.\n */\nabstract  class Top {\n    public abstract  void myMethod (Object o);\n}\n/** Simple demonstation of Metadata being used to verify\n * that a method does in fact override (not overload) a method\n * from the parent class. This class is supposed to do the overriding,\n * but deliberately introduces an error to show how the modern compiler\n * behaves\n */\nclass Bottom {\n    @Override\n    public void myMethod (String s) {    // EXPECT COMPILE ERROR\n        // Do something here...\n    }\n}\nAttempting to compile this results in a compiler error that the method in question\ndoes not override a method, even though the annotation says it does; this is a fatal\ncompile-time error:\nC:> javac AnnotationOverrideDemo.java\nAnnotationOverrideDemo.java:16: method does not override a method\n            from its superclass\n        @Override public void myMethod(String s) {     // EXPECT COMPILE ERROR\n         ^\n1 error\nC:> \n15.4 Preparing a Class as a JavaBean\nProblem\nY ou have a class that you would like to use as a JavaBean.\nSolution\nMake sure the class meets the JavaBeans requirements. Optionally, create a JAR file\ncontaining the class, a manifest, and any ancillary entries.\nDiscussion\nSeveral kinds of Java components are called either Beans or JavaBeans:\n•Visual components for use in GUI builders, as discussed in this recipe.\n15.4 Preparing a Class as a JavaBean | 469\n•Plain Old Java Objects (POJOs), or components meant for reuse.\n•Java Enterprise has Enterprise JavaBeans (EJBs), JSP JavaBeans, JSF Managed\nBeans, and CDI Beans, containing features for building enterprise-scale applica‐\ntions. Creating and using Java EE components is more involved than regular Jav‐\naBeans and would take us very far afield, so they are not covered in this book.\nWhen you need to learn about enterprise functionality, turn to  Java EE 7 Essen‐\ntials by Arun Gupta.\n•The Spring Framework  also uses the term “Beans” (or “Spring Beans”) for the\nobjects it manages.\nWhat all these types of beans have in common are certain naming paradigms. All\npublic properties should be accessible by get/set accessor methods. For a given prop‐\nerty Prop  of type Type , the following two methods should exist (note the capitaliza‐\ntion):\npublic Type getProp( );\npublic void setProp(Type)\nFor example, the various AWT and Swing components that have textual labels all\nhave the following pair of methods:\npublic String getText( );\npublic void setText(String newText);\nOne commonly permitted variance to this pattern is that, for boolean  or Boolean\narguments, the getter method is usually called isProp()  rather than getProp() .\nY ou should use this set/get design pattern (set/get methods) for methods that control\na bean. Indeed, this technique is useful even in nonbean classes for regularity. The\nbean containers for the APIs listed at the start of this section generally use Java intro‐\nspection (see Chapter 17 ) to find the set/get method pairs, and some use these to con‐\nstruct properties editors for your bean. Bean-aware IDEs, for example, provide edi‐\ntors for all standard types (colors, fonts, labels, etc.). Y ou can supplement this with a\nBeanInfo  class to provide or override information.\nThe bare minimum a class requires to be usable as a JavaBean is the following:\n•The class must have a no-argument constructor.\n•The class should use the set/get paradigm.\n•The class must implement java.io.Serializable , although many containers\ndon’t enforce this.\n•Depending on the intended use, the class file might need to be packaged into a\nJAR file (see Recipe 15.5 ).\n470 | Chapter 15: Packages and Packaging\nNote that a JavaBean with no required  inheritance or implement s is also called a\nPOJO. Most new Java frameworks accept POJO components, instead of (as in days of\nyore) requiring inheritance (e.g., Struts 1 org.struts.Action  class) or implementa‐\ntion of interfaces (e.g., EJB2 javax.ejb.SessionBean  interface).\nHere is a sample JavaBean that might have been a useful addition to one’s Java GUI\ntoolbox, the LabelText  widget. It combines a label and a one-line text field into a sin‐\ngle unit, making it easier to compose GUI applications. A demo program in the\nonline source directory sets up three LabelText  widgets, as shown in Figure 15-2 .\nFigure 15-2. LabelText bean\nThe code for LabelText  is shown in Example 15-2 . Notice that it is serializable and\nuses the set/get paradigm for most of its public methods. Most of the public set/get\nmethods simply delegate to the corresponding methods in the label or the text field.\nThere isn’t really a lot to this bean, but it’s a good example of aggregation, in addition\nto being a good example of a bean.\nExample 15-2. darwinsys-api/src/main/java/com/darwinsys/swingui/LabelText.java\n// package com.darwinsys.swingui;\npublic class LabelText  extends JPanel implements  java.io.Serializable  {\n    private static final long serialVersionUID  = -8343040707105763298L ;\n    /** The label component */\n    protected  JLabel theLabel ;\n    /** The text field component */\n    protected  JTextField  theTextField ;\n    /** The font to use */\n    protected  Font myFont;\n    /** Construct the object with no initial values.\n     * To be usable as a JavaBean there must be a no-argument constructor.\n     */\n    public LabelText () {\n        this(""(LabelText)"" ,  12);\n    }\n    /** Construct the object with the label and a default textfield size */\n    public LabelText (String label) {\n        this(label, 12);\n    }\n15.4 Preparing a Class as a JavaBean | 471\n    /** Construct the object with given label and textfield size */\n    public LabelText (String label, int numChars ) {\n        this(label, numChars , null);\n    }\n    /** Construct the object with given label, textfield size,\n     * and ""Extra"" component\n     * @param label The text to display\n     * @param numChars The size of the text area\n     * @param extra A third component such as a cancel button\n     * may be null, in which case only the label and textfield exist.\n     */\n    public LabelText (String label, int numChars , JComponent  extra) {\n        super();\n        setLayout (new BoxLayout (this, BoxLayout .X_AXIS));\n        theLabel  = new JLabel(label);\n        add(theLabel );\n        theTextField  = new JTextField (numChars );\n        add(theTextField );\n        if (extra != null) {\n            add(extra);\n        }\n    }\n    /** Get the label's horizontal alignment */\n    public int getLabelAlignment () {\n        return theLabel .getHorizontalAlignment ();\n    }\n    /** Set the label's horizontal alignment */\n    public void setLabelAlignment (int align) {\n        theLabel .setHorizontalAlignment (align);\n    }\n    /** Get the text displayed in the text field */\n    public String getText() {\n        return theTextField .getText();\n    }\n    /** Set the text displayed in the text field */\n    public void setText(String text) {\n        theTextField .setText(text);\n    }\n    /** Get the text displayed in the label */\n    public String getLabel () {\n        return theLabel .getText();\n    }\n    /** Set the text displayed in the label */\n    public void setLabel (String text) {\n        theLabel .setText(text);\n472 | Chapter 15: Packages and Packaging",7474
618-15.5 Archiving with JAR.pdf,618-15.5 Archiving with JAR,,0
619-Problem.pdf,619-Problem,,0
620-Solution.pdf,620-Solution,,0
621-15.6 Running a Program from a JAR.pdf,621-15.6 Running a Program from a JAR,"}\n    /** Set the font used in both subcomponents. */\n    public void setFont(Font f) {\n        // This class' constructors call to super() can trigger\n        // calls to setFont() (from Swing.LookAndFeel.installColorsAndFont),\n        // before we create our components, so work around this.\n        if (theLabel  != null)\n            theLabel .setFont(f);\n        if (theTextField  != null)\n            theTextField .setFont(f);\n    }\n    /** Adds the ActionListener to receive action events from the textfield */\n    public void addActionListener (ActionListener  l) {\n        theTextField .addActionListener (l);\n    }\n    /** Remove an ActionListener from the textfield. */\n    public void removeActionListener (ActionListener  l) {\n        theTextField .removeActionListener (l);\n    }\n}\nOnce it’s compiled, it’s ready to be packaged into a JAR. Most build tools such as\nMaven will do this work for you.\n15.5 Archiving with JAR\nProblem\nY ou want to create a Java archive (JAR) file from your package (or any other collec‐\ntion of files).\nSolution\nUse jar.\nDiscussion\nThe jar archiver is Java’s standard tool for building archives. Archives serve the same\npurpose as the program libraries that some other programming languages use. Java\nnormally loads its standard classes from archives, a fact you can verify by running a\nsimple “Hello, World” program with the -verbose  option:\njava -verbose HelloWorld\nCreating an archive is a simple process. The jar tool takes several command-line\narguments: the most common are c for create, t for table of contents, and x for\n15.5 Archiving with JAR | 473",1637
622-Solution.pdf,622-Solution,"6Some people like to use names like MyPackage.mf  so that it’s clear which package it is for; the extension .mf is\narbitrary, but it’s a good convention for identifying manifest files.\nextract. The archive name is specified with -f and a filename. The options are fol‐\nlowed by the files and directories to be archived, like this:\njar cvf /tmp/MyClasses.jar .\nThe dot at the end is important; it means the current directory. This command cre‐\nates an archive of all files in the current directory and its subdirectories into the\nfile /tmp/MyClasses.jar .\nMost applications of JAR files depend on an extra file that is always present in a true\nJAR file, called a manifest . This file always lists the contents of the JAR and their\nattributes; you can add extra information into it. The attributes are in the form name :\nvalue , as used in email headers, properties files (see Recipe 7.10 ), and elsewhere.\nSome attributes are required by the application, whereas others are optional. For\nexample, Recipe 15.6  discusses running a main program directly from a JAR; this\nrequires a Main-Program  header. Y ou can even invent your own attributes, such as the\nfollowing:\nMySillyAttribute: true\nMySillynessLevel: high (5'11"")\nY ou store this in a file called, say, manifest.stub ,6 and pass it to jar with the -m switch.\njar includes your attributes in the manifest file it creates:\njar -cv -m manifest.stub -f /tmp/com.darwinsys.util.jar .\nThe jar program and related tools add additional information to the manifest, includ‐\ning a listing of all the other files included in the archive.\nIf you use a tool like Maven (see Recipe 1.7 ), it automatically cre‐\nates a JAR file from your source project just by saying mvn package .\n15.6 Running a Program from a JAR\nProblem\nY ou want to distribute a single large file containing all the classes of your application\nand run the main program from within the JAR.\n474 | Chapter 15: Packages and Packaging",1971
623-15.7 Packaging Web Tier Components into a WAR File.pdf,623-15.7 Packaging Web Tier Components into a WAR File,"Solution\nCreate a JAR file with a Main-Class : line in the manifest; run the program with the\njava -jar  option.\nDiscussion\nThe java command has a -jar  option that tells it to run the main program found\nwithin a JAR file. In this case, it will also find classes it needs to load from within the\nsame JAR file. How does it know which class to run? Y ou must tell it. Create a one-\nline entry like this, noting that the attribute fields are case-sensitive and that the colon\nmust be followed by a space:\nMain-Class: com.somedomainhere.HelloWorld\nPlace that in a file called, say, manifest.stub , and assuming that you want to run the\nprogram HelloWorld  from the given package. Y ou can then use the following com‐\nmands to package your app and run it from the JAR file:\nC:> javac HelloWorld.java\nC:> jar cvmf manifest.stub hello.jar HelloWorld.class\nC:> java -jar hello.jar\nHello, World of Java\nC:>\nY ou can now copy the JAR file anywhere and run it the same way. Y ou do not need to\nadd it to your CLASSPATH  or list the name of the main class.\nOn GUI platforms that support it, you can also launch this application by double-\nclicking the JAR file. This works on macOS, Microsoft Windows, and many X Win‐\ndows desktops.\nIn real life you would probably automate this with Maven, where your POM file\nwould contain, among other things, the following:\n<project ...>\n    ...\n    <packaging>jar</packaging>\n    ...\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>2.4</version>\n                <configuration>\n                    <archive>\n                        <manifest>\n                            <addclasspath>true</addclasspath>\n                            <mainClass>${main.class}</mainClass>\n                        </manifest>\n15.6 Running a Program from a JAR | 475",1959
624-Solution.pdf,624-Solution,"</archive>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\nWith this in place, mvn package  will build a runnable JAR file. However, if your class\nhas external dependencies, the preceding steps will not package them, and you will\nget a missing class exception when you run it. For this, you need to use the Maven\nassembly plug-in:\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-assembly-plugin</artifactId>\n    <version>2.6</version>\n    <configuration>\n        <descriptorRefs>\n            <descriptorRef>jar-with-dependencies</descriptorRef>\n        </descriptorRefs>\n        <archive>\n            <manifest>\n                <addDefaultImplementationEntries>true\n                </addDefaultImplementationEntries>\n                <mainClass>${main.class}</mainClass>\n                <!-- <manifestFile>manifest.stub</manifestFile> -->\n            </manifest>\n            <manifestEntries>\n                <Vendor-URL>http://YOURDOMAIN.com/SOME_PATH/</Vendor-URL>\n            </manifestEntries>\n        </archive>\n    </configuration>\n</plugin>\nNow, the invocation mvn package assembly:single  will produce a runnable JAR\nwith all dependencies. Note that your target  folder will contain both foo-0.0.1-\nSNAPSHOT.jar  and foo-0.0.1-SNAPSHOT-jar-with-dependencies.jar ; the latter is the\none you need.\nThe jpackage  tool (mentioned in this chapter’s introduction) will do much the same\njob as assembly:single , and is expected to ship with Java 14.\n15.7 Packaging Web Tier Components into a WAR File\nProblem\nY ou have some web-tier resources and want to package them into a single file for\ndeploying to the server.\n476 | Chapter 15: Packages and Packaging",1778
625-See Also.pdf,625-See Also,"Solution\nUse jar to make a web archive (W AR) file. Or, as mentioned earlier, use Maven with\npackaging= war.\nDiscussion\nServlets are server-side components for use in web servers. They can be packaged for\neasy installation into a web server. A web application  in the Servlet API specification\nis a collection of HTML and/or JSP pages, servlets, and other resources. A typical\ndirectory structure might include the following:\nProject Root Directory\n├── README.asciidoc\n├── index.html - typical web pages\n|── signup.jsp - ditto\n├── WEB-INF Server directory\n    ├── classes - Directory for individual .class files\n    ├── lib    - Directory for Jar files needed by app\n    └── web.xml - web app Descriptor (""Configuration file"")\nOnce you have prepared the files in this way, you just package them up with a build\ntool. Using Maven, with <packaging>war</packaging> , your tree might look like\nthis:\nProject Root Directory\n├── README.asciidoc\n├── pom.xml\n└── src\n    └── main\n        ├── java\n        │   └── foo\n        │       └── WebTierClass.java\n        └── webapp\n            ├── WEB-INF\n            │   ├── classes\n            │   ├── lib\n            │   └── web.xml\n            ├── index.html\n            └── signup.jsp\nThen mvn package  will compile things, put them in place, and create the W AR file for\nyou, leaving it under target . Gradle users would use a similar directory structure.\nY ou could also invoke jar manually, though this has little to recommend it. Y ou then\ndeploy the resulting W AR file into your web server. For details on the deployment\nstep, consult the documentation on the particular server you’re using.\n15.7 Packaging Web Tier Components into a WAR File | 477",1732
626-15.8 Creating a Smaller Distribution with jlink.pdf,626-15.8 Creating a Smaller Distribution with jlink,,0
627-Problem.pdf,627-Problem,,0
628-Solution.pdf,628-Solution,,0
629-15.9 Using JPMS to Create a Module.pdf,629-15.9 Using JPMS to Create a Module,"See Also\nFor more information on signing and permissions, see Java Security  by Scott Oaks.\nFor more information on the JDK tools mentioned here, see the documentation that\naccompanies the JDK you are using.\n15.8 Creating a Smaller Distribution with jlink\nProblem\nY ou are distributing your application to end users, and you want to minimize the size\nof your download.\nSolution\nModularize your application (see Recipe 15.9 ), use jdeps  to get a complete list of the\nmodules it uses, then use jlink  to create the mini-Java, and distribute that to your\nusers.\nDiscussion\njlink  is a command-line tool introduced in Java 9 that can make up a mini-Java dis‐\ntribution containing only your application and the JDK classes it uses. That is, it\nomits any of the thousands of JDK classes that your app will never use.\nFirst, you need to compile and package your module-info  and your application code.\nY ou can use Maven or Gradle, or just use the JDK tools directly:\n$ javac -d . src/*.java\n$ jar cvf demo.jar module-info.class  demo\nIf you wish to see the list of modules that will be included, you can optionally run the\njdeps  tool to get this list:\n$ jdeps --module-path . demo.jar\ndemo\n [file:///Users/ian/workspace/javasrc/jlink/./]\n   requires mandated java.base (@11.0.2)\ndemo -> java.base\n   demo          -> java.io        java.base\n   demo          -> java.lang      java.base\nOnce the classes have been compiled, you can run the jlink  tool to build a mini-java\ndistribution with your demo app imbedded:\njlink --module-path . --no-header-files \\n    --no-man-pages --compress =2 --strip-debug \\n    --launcher  rundemo=demo/demo.Hello \\n    --add-modules demo --output mini-java\n478 | Chapter 15: Packages and Packaging",1761
630-Problem.pdf,630-Problem,,0
631-Solution.pdf,631-Solution,,0
632-Discussion.pdf,632-Discussion,"The --launcher name=module/main  argument asks jlink  to create a script file\nnamed name  to run the application.\nIf you got no errors, you should be able to run it either with the java command or\nwith the generated shell script:\n$ mini-java/bin/java demo.Hello\nHello, world.\n$ mini-java/bin/rundemo\nHello, world.\n$\nY ou might want to copy the entire mini-Java folder to a machine that doesn’t have a\nregular Java installation and run it there in order to be sure you don’t have any miss‐\ning dependencies.\nThe concept of a mini-distribution is appealing, but you must con‐\nsider these issues:\n•There is no upgrade mechanism for such mini-Javas. These are\nquite suitable for microservice deployments where you rebuild\noften. For applications shipped to customers, though, you’ d\nhave to regenerate them and get your customers to download\nand reinstall (on short notice whenever there’s a security\nupdate).\n•Disk space is generally no longer expensive relative to the cost\nof your time in maintaining such a distribution.\nThus, you have to decide if this is worthwhile for your application.\n15.9 Using JPMS to Create a Module\nProblem\nY ou want your packaged archive to work smoothly with the Java Modules System\n(JPMS).\nSolution\nCreate a module-info.java  file in the root of the source directory.\nDiscussion\nThe file module-info.java  was introduced in Java 9 to provide the compiler and tools\nwith information about your library’s needs and what it provides. Note that this is not\neven a valid Java class filename because it contains a minus sign. The module also has\n15.9 Using JPMS to Create a Module | 479\na group of pseudokeywords, which only have their special meaning inside a module\nfile. The simplest module-info  is the following:\nmodule foo {\n    // Empty\n}\nBut just as a Java class with no members won’t get you very far in the real world, nei‐\nther will this empty module file. We need to provide some additional information.\nFor this example, I will modularize my darwinsys-api , a collection of 40 or so ran‐\ndomly accumulated classes that I reuse sometimes. Remember that Jigsaw (the mod‐\nule system’s early name) was initially proposed as a way of modularizing the over‐\ngrown JDK itself. Most applications will need the module java.base  (which is always\nincluded). If they need AWT, Swing, or certain other desktop-application-related\nclasses, they also need java.desktop . Thus I add the following line into the module\ndefinition:\nrequire java.desktop\nThis code also has some JUnit-annotated classes and makes use of JavaMail API, so\nwe need those as well. JUnit, however, is only needed at test time. While Maven offers\nscope s for compile, test, and runtime, the modules system does not. Thus we could\nomit JUnit from the POM file and add it to Eclipse. But then maven test  will not\nwork.\nAnd unfortunately, as of this writing, there does not appear to be modularized ver‐\nsion of JavaMail either. Fortunately, there is a feature known as automatic modules , by\nwhich if you place a JAR file on the module path that doesn’t declare a module, its\nJAR filename will be used as the basis of an automatically generated module. So we’ll\nalso add the following:\nrequires mail;\nUnfortunately, when we compile, Maven’s Java Compiler module spits out this scary-\nlooking warning:\n[WARNING] *********************************************************************\n[WARNING] * Required filename-based automodules detected. Please don't publish\n            this project to a public artifact repository! *\n[WARNING] *********************************************************************\nGiven that there are so many public Java API libraries out there, and that most of\nthem depend on other libraries in turn, I wonder: how is that state supposed to end?\nNonetheless, I have heeded that warning, and so people will continue to use the auto-\nmodule version of com.darwinsys.api  until I stumble across modularized JavaMail\nand JUnit4 APIs.\nThe module-info  also lists any packages that your module desires to make available,\nthat is, its public API. So we need a series of export commands:\n480 | Chapter 15: Packages and Packaging\nexports com.darwinsys.calendar;\nexports com.darwinsys.csv;\nexports com.darwinsys.database;\n...\nBy default, packages that are exported can not be examined using the Reflection API.\nTo allow a module to introspect (use the Reflection API) on another, say, a domain\nmodel used with JPA, use opens .\nOne of the points of Java interfaces is to allow multiple implementations of a service.\nThis is supported in JPMS by the service feature. Where an API is defined as one or\nmore interfaces in one module, and multiple implementations are provided, each in\nits own module, the implementation module(s) can define an implementation using\nprovides ... with , as in the following:\nrequires com.foo.interfacemodule;\nprovides com.foo.interfacemodule.Interface with com.foo.implmodule.ImplClass;\nThe completed module-info  for the darwinsys-api  module is shown in\nExample 15-3 .\nExample 15-3. DarwinSys-API module-info\nmodule com.darwinsys .api {\n    requires  java.desktop;\n    requires  java.persistence ;\n    requires  java.prefs;\n    requires  java.sql;\n    requires  java.sql.rowset;\n    requires  javax.servlet.api;\n    requires  mail;\n    requires  junit;\n    exports com.darwinsys .calendar ;\n    exports com.darwinsys .csv;\n    exports com.darwinsys .database ;\n    exports com.darwinsys .diff;\n    exports com.darwinsys .formatting ;\n    exports com.darwinsys .locks;\n    provides  com.darwinsys .locks.LockManager\n        with com.darwinsys .locks.LockManagerImpl ;\n    exports com.darwinsys .model;\n    opens com.darwinsys .model;\n    // another dozen and a half packages...\n}\nA module wanting to use the lock interface feature would need a requires com.dar\nwinsys  and might do something like this in code:\n15.9 Using JPMS to Create a Module | 481",5998
633-Chapter 16. Threaded Java.pdf,633-Chapter 16. Threaded Java,"import java.util.ServiceLoader;\nimport java.util.Optional;\nOptional<LockManager> opt = ServiceLoader.load(LockManager.class).findFirst();\nif (!opt.isPresent()) {\n    throw new RuntimeException(""Could not find implementation of LockManager"");\n}\nLockManager mgr = opt.get();\nThe Optional  interface is described in Recipe 8.6 .\nSee Also\nJPMS is relatively new, and library providers are still learning to use it properly. An\nearly posting was https://openjdk.java.net/projects/jigsaw/quick-start . A plan for\nmigrating to modules can be found at http://tutorials.jenkov.com/java/\nmodules.html#migrating-to-java-9 . A discussion about preparing a multi-module\nMaven application is at https://www.baeldung.com/maven-multi-module-project-java-\njpms . The book Java 9 Modularity: Patterns and Practices for Developing Maintainable\nApplications  by Sander Mak and Paul Bakker is probably the most comprehensive\ntreatment of JPMS.\n482 | Chapter 15: Packages and Packaging",980
634-16.0 Introduction.pdf,634-16.0 Introduction,"CHAPTER 16\nThreaded Java\n16.0 Introduction\nWe live in a world of multiple activities. A person may be talking on the phone while\ndoodling or reading a memo. A multifunction office machine may scan one fax while\nreceiving another and printing a document from somebody’s computer. We expect\nthe GUI programs we use to be able to respond to a menu while updating the screen.\nBut ordinary computer programs can do only one thing at a time. The conventional\ncomputer programming model—that of writing one statement after another, punctu‐\nated by repetitive loops and binary decision making—is sequential at heart.\nSequential processing is straightforward but not as efficient as it could be. To enhance\nperformance, Java offers threading , the capability to handle multiple flows of control\nwithin a single application or process. Java provides thread support and, in fact,\nrequires threads: the Java runtime itself is inherently multithreaded. For example,\nwindow system action handling and Java’s garbage collection—that miracle that lets\nus avoid having to free everything we allocate, as others must do when working in\nlanguages at or below C level—run in separate threads.\nJust as multitasking allows a single operating system to give the appearance of run‐\nning more than one program at the same time on a single-processor computer, multi‐\nthreading can allow a single program or process to give the appearance of working on\nmore than one thing at the same time. Multithreading leads to more interactive\ngraphics and more responsive GUI applications (the program can draw in a window\nwhile responding to a menu, with both activities occurring more or less independ‐\nently), more reliable network servers (if one client does something wrong, the server\ncontinues communicating with the others), and so on.\nNote that I did not say “multiprocessing” in the previous paragraph. The term multi-\ntasking is sometimes erroneously called multiprocessing, but that term in fact refers\n483\n6JSR stands for Java Specification Request. The Java Community Process calls standards, both proposed and\nadopted, JSRs. See http://www.jcp.org  for details.to different issue: it’s the case of two or more CPUs running under a single operating\nsystem. Multiprocessing per se is nothing new: IBM mainframes did it in the 1970s,\nSun SPARCstations did it in the 1980s, and Intel PCs did it in the 1990s. Since the\nmid-2010s, it has become increasingly hard to buy a single-processor computer pack‐\naged inside anything larger than a wristwatch. True multiprocessing allows you to\nhave more than one process running concurrently on more than one CPU. Java’s sup‐\nport for threading includes multiprocessing, as long as the operating system supports\nit. Consult your system documentation for details.\nThough most modern operating systems provide threads, Java was the first main‐\nstream programming language to have intrinsic support for threaded operations built\nright into the language. The semantics of java.lang.Object , of which all objects are\ninstances, includes the notion of monitor locking of objects, and some methods\n(notify , notifyAll , wait ) are meaningful only in the context of a multithreaded\napplication. Java also has language keywords such as synchronized  to control the\nbehavior of threaded applications.\nNow that the world has had years of experience with threaded Java, experts have\nstarted building better ways of writing threaded applications. The Concurrency Utilit‐\nies, specified in JSR 1666 and included in all modern Java releases, are heavily based\non the util.concurrent  package by Professor Doug Lea of the Computer Science\nDepartment at the State University of New Y ork at Oswego. This package aims to do\nfor the difficulties of threading what the Collections classes (see Chapter 7 ) did for\nstructuring data. This is no small undertaking, but they pulled it off.\nThe java.util.concurrent  package includes several main sections:\n•Executor s, thread pools ( ExecutorService s), and Future s/CompletableFuture s\n•Queue s and BlockingQueue s\n•Locks and conditions, with JVM support for faster locking and unlocking\n•Synchronizers, including Semaphore s and Barrier s\n•Atomic variables\nIn this chapter I will focus on the first set of these, thread pools and Future s.\nAn implementation of the Executor  interface is, as the name implies, a class that can\nexecute code for you. The code to be executed can be the familiar Runnable  or a new\ninterface Callable . One common kind of Executor  is a thread pool . The Future\ninterface represents the future state of something that has been started; it has\n484 | Chapter 16: Threaded Java",4708
635-16.1 Running Code in a Different Thread.pdf,635-16.1 Running Code in a Different Thread,,0
636-Problem.pdf,636-Problem,,0
637-Solution.pdf,637-Solution,,0
638-Discussion.pdf,638-Discussion,"methods to wait until the result is ready. A CompletableFuture  is an implementation\nof Future  that adds many additional methods for chaining CompletableFuture s and\npost-applied methods.\nThese brief definitions are oversimplifications. Addressing all the issues is beyond the\nscope of this chapter, but I do provide several examples.\n16.1 Running Code in a Different  Thread\nProblem\nY ou need to write a threaded application.\nSolution\nWrite code that implements Runnable ; pass it to an Executor , or instantiate a Thread\nand start it.\nDiscussion\nThere are several ways to implement threading, and they all require you to implement\nthe Runnable  or Callable  interface. Runnable  has only one method, and it returns no\nvalue; this is its signature:\npublic interface  java.lang.Runnable  {\n  public abstract  void run();\n}\nCallable  has similarly only one method, but the call()  method returns a specific\ntype so the interface has a type parameter ( V here, for “value”):\npublic interface  java.util.concurrent .Callable <V> {\n  public abstract  V call() throws Exception ;\n}\nY ou must provide an implementation of the run()  or call()  method. There is noth‐\ning special to this method; it’s an ordinary method and you could call it yourself. But\nif you did, what then? There wouldn’t be the special magic that launches it as an inde‐\npendent flow of control, so it wouldn’t run concurrently with your main program or\nflow of control. For this, you need to invoke the magic of thread creation.\nThe original way of using threads, no longer generally recommended, is to create\nThread  objects directly and call their start()  method, which would cause the thread\nto call the run()  method after the new thread had been initialized. There was no sup‐\nport for the Callable  interface in the original threads model. Y ou create threads by\ndoing one of the following things:\n16.1 Running Code in a Different  Thread | 485\n•Subclass java.lang.Thread  (which implements Runnable ) and override the\nrun()  method.\n•Create your Runnable  and pass it into the Thread  constructor.\n•With Java 8+, as shown in Recipe 9.0 , you can use a lambda expression to imple‐\nment Runnable .\nThis approach is no longer recommended because of issues such as performance\n(Thread  objects are expensive to create and tear down, and a thread is unusable once\nits run()  method returns). Because it is no longer recommended to invoke threading\nin this fashion, I no longer show examples of doing so. There are some examples in\nthe online source, in the threads  directory; see especially ThreadsDemo4 .\nInstead, the recommended way to perform threaded operations is to use the\njava.util.concurrent  package’s ExecutorService . An ExecutorService  is, as its\nname implies, a service class that can execute code for you. The code to be executed\ncan be in a Runnable  or a Callable . Y ou obtain an ExecutorService  by invoking a\nfactory method on the Executors  class. The code in Example 16-1  shows a simple\nexample of a thread pool.\nExample 16-1. main/src/main/java/threads/ThreadPoolDemo.java\n        final ExecutorService  pool = Executors .newFixedThreadPool (HOWMANY);\n        List<Future<Integer>> futures = new ArrayList <>(HOWMANY);\n        for (int i = 0; i < HOWMANY; i++) {\n            Future<Integer> f = pool.submit(new DemoRunnable (i));\n            System.out.println(""Got 'Future' of type ""  + f.getClass ());\n            futures.add(f);\n        }\n        Thread.sleep(3 * 1000);\n        done = true;\n        for (Future<Integer> f : futures) {\n            System.out.println(""Result ""  + f.get());\n        }\n        pool.shutdown ();\nThis will print a series of lines like the following, showing the threads running inter‐\nspersed:\nRunning Thread[pool-1-thread-3,5,main]\nRunning Thread[pool-1-thread-3,5,main]\nRunning Thread[pool-1-thread-1,5,main]\nRunning Thread[pool-1-thread-1,5,main]\nNote that there are several submission methods, the first in the parent interface Execu\ntor and two more in ExecutorService :\n486 | Chapter 16: Threaded Java\npublic void execute(Runnable );\npublic Future<T> submit(Callable <T>);\npublic Future<T> submit(Runnable );\nThat is, execute()  takes a Runnable  and returns nothing, whilst the submit()  meth‐\nods both return a Future<T>  (for the method submit(Runnable) , the type parameter\nx is always java.lang.Void ).\nWhen you are finished with the thread pool, you should call its shutDown()  method.\nUnderstanding Future and CompletableFuture\nFuture  is an interface representing a claim ticket on some deliverable that may or\nmay not be ready. It’s a software analogue of the claim ticket you are given when you\ntake laundry in to a dry cleaning service or take some item in to be repaired. The fol‐\nlowing describes the important methods of the Future  interface:\npublic interface  java.util.concurrent .Future<V> {\n    public abstract  boolean isDone();\n    public abstract  V get() throws InterruptedException ,\n        java.util.concurrent .ExecutionException ;\n    public abstract  V get(long, java.util.concurrent .TimeUnit )\n        throws InterruptedException ,\n        java.util.concurrent .ExecutionException ,\n        java.util.concurrent .TimeoutException ;\n    public abstract  boolean cancel(boolean);\n    public abstract  boolean isCancelled ();\n}\nThe purpose of each method in this interface is shown here:\nisDone()\nReturns true if the operation that will deliver the result has completed\nget()\nWill return the deliverable immediately if isDone()  is true; else will block indefi‐\nnitely until it becomes true\nget(long, TimeUnit)\nWill return the deliverable immediately if isDone()  is true, blocking until it\nbecomes true, or until the specified time has elapsed, in which case it will throw a\nTimeoutException\ncancel(boolean)\nWill cancel the operation if it hasn’t started (if the boolean  is false) or even if it is\nin process (if the boolean  is true)\nisCancelled()\nReturns true if the operation has been canceled\n16.1 Running Code in a Different  Thread | 487\nFuture  is commonly returned from a thread pool execute()  operation, as shown in\nExample 16-2 .\nExample 16-2. main/src/main/java/threads/FutureFromThreadpool.java\n        double d = 2;\n        Callable <Double> computeTotal  = () -> d + d;\n        Future<Double> future = threadPool .submit(computeTotal );\n        while (!future.isDone()) {\n            Thread.sleep(100);\n        }\n        double value = future.get();\n        process(value);\n        threadPool .shutdown ();\nThere are many classes implementing Future  in various parts of Java SE and Jakarta.\nThe most general and powerful is CompletableFuture<V> , so called because you can\ncontrol it by calling a complete(V)  method at any time. This has far too many public\nmethods (120) for a complete treatment here. In fairness, the number of methods is\nhigh because many methods can accept either a Runnable  or a Callable , and many\nhave multiple overloads (a plain one, one with Async  appended to the name, and one\nwith Async  that lets you provide the Executor ). I’ll show examples of these shortly.\nY ou can create an empty CompletableFuture  by calling a no-argument constructor,\nmaking this available to some calling code, and calling its complete()  method when\nyou have a result:\nCompletableFuture <Integer> cf = new CompletableFuture <>();\n// Do some work\ncf.complete ();\nMany of the more interesting methods in CompletableFuture  have to do with chain‐\ning operations. First, you can specify a function to be invoked automatically when the\nresult is ready:\n  public CompletableFuture <Void> thenRun(java.lang.Runnable );\n  public CompletableFuture <Void> thenRunAsync (java.lang.Runnable );\n  public CompletableFuture <Void> thenRunAsync (java.lang.Runnable , Executor );\n  public <U> CompletableFuture <U> thenApply (\n      Function <? super T,\n          ? extends U>);\n  public <U> CompletableFuture <U> thenApplyAsync (\n      Function <? super T,\n          ? extends U>);\n  public <U> CompletableFuture <U> thenApplyAsync (\n      Function <? super T,\n          ? extends U>, Executor );\n  public CompletableFuture <Void> thenAccept (Consumer <? super T>);\n  public CompletableFuture <Void> thenAcceptAsync (Consumer <? super T>);\n  public CompletableFuture <Void> thenAcceptAsync (\n      Consumer <? super T>, Executor );\n488 | Chapter 16: Threaded Java",8495
639-16.2 Displaying a Moving Image with Animation.pdf,639-16.2 Displaying a Moving Image with Animation,,0
640-Problem.pdf,640-Problem,,0
641-Solution.pdf,641-Solution,,0
642-Discussion.pdf,642-Discussion,"These methods will invoke the given Runnable , Consumer , or Function  after the\nFuture  is completed. Each of these exists in the three forms as mentioned above. The\nfirst will run it on the same thread as the main task. The second method will run it in\na default executor. The third allows you to provide your own executor. Example 16-3\nis a simple demo of creating a CompletableFuture , giving it a thenApply  method call\nand a final run method, both of which don’t fire until the Future  is completed.\nExample 16-3. main/src/main/java/threads/CompletableFutureSimple.java\nclass CompletableFutureSimple  {\n    static String twice(String x) { return x + ' ' + x; }\n    public static void main(String[] args) {\n        CompletableFuture <String> cf = new CompletableFuture <>();\n        cf.thenApply (x -> twice(x))\n          .thenAccept (x -> System.out.println(x));\n        // Possibly some computation going on here... Then:\n        cf.complete (""Hello"");\n    }\n}\nThe online source includes CompletableFutureDemo.java , which offers some more\nsophisticated examples.\n16.2 Displaying a Moving Image with Animation\nProblem\nY ou need to update a graphical display while other parts of the program are running.\nSolution\nUse a background thread to drive the animation.\nDiscussion\nOne common use of threads is an animator, a class that displays a moving image.\nThis animator program does just that. It draws a graphical image at locations around\nthe screen; the location is updated and redrawn from a different Thread  for each such\nimage so that all the animations run in parallel. Y ou can see the program running in\nFigure 16-1 .\n16.2 Displaying a Moving Image with Animation | 489\n6The title belies some unfulfilled ambitions to make the animations follow the bouncing curves seen in some\nflashier animation demonstrations.\nFigure 16-1. Animator\nThe code for the animator program consists of two classes, Sprite  (see\nExample 16-4 ) and Bounce6 (see Example 16-5 ). A Sprite  is one image that moves\naround; Bounce  is the main program.\nExample 16-4. main/src/main/java/threads/Sprite.java (part of animator program)\n/** A Sprite is one Image that moves around the screen on its own */\npublic class Sprite extends Component  implements  Runnable  {\n    private static final long serialVersionUID  = 1L;\n    protected  static int spriteNumber  = 0;\n    protected  int number;\n    protected  int x, y;\n    protected  Component  parent;\n    protected  Image image;\n    protected  volatile  boolean done = false;\n    /** The time in mSec to pause between each move. */\n    protected  volatile  int sleepTime  = 250;\n490 | Chapter 16: Threaded Java\n    /** The direction for this particular sprite. */\n    protected  Direction  direction ;\n    enum Direction  {\n        VERTICAL , HORIZONTAL , DIAGONAL\n    }\n    /** Construct a Sprite with a Component parent, image and direction.\n     * Construct and start a Thread to drive this Sprite.\n     */\n    public Sprite(Component  parent, Image image, Direction  direction ) {\n        this.parent = parent;\n        this.image = image;\n        this.direction  = direction ;\n        this.number = Sprite.spriteNumber ++;\n        setSize(image.getWidth (this), image.getHeight (this));\n    }\n    /** Construct a Sprite with the default direction */\n    public Sprite(Component  parent, Image image) {\n        this(parent, image, Direction .DIAGONAL );\n    }\n    /** Stop this Sprite. */\n    public void stop() {\n        System.out.println(""Stopping ""  + number);\n        done = true;\n    }\n    /** Adjust the motion rate */\n    protected  void setSleepTime (int n) {\n        sleepTime  = n;\n    }\n    /**\n     * Run one Sprite around the screen.\n     * This version just moves them around either across, down, or\n     * at some 45-degree angle.\n     */\n    public void run() {\n        int width = parent.getSize().width;\n        int height = parent.getSize().height;\n        // Set initial location\n        x = (int)(Math.random() * width);\n        y = (int)(Math.random() * height);\n        // Flip coin for x & y directions\n        int xincr = Math.random()>0.5?1:-1;\n        int yincr = Math.random()>0.5?1:-1;\n        while (!done) {\n            width = parent.getSize().width;\n            height = parent.getSize().height;\n            if ((x+=xincr) >= width)\n                x=0;\n            if ((y+=yincr) >= height)\n16.2 Displaying a Moving Image with Animation | 491\n                y=0;\n            if (x<0)\n                x = width;\n            if (y<0)\n                y = height;\n            switch(direction ) {\n                case VERTICAL:\n                    x = 0;\n                    break;\n                case HORIZONTAL:\n                    y = 0;\n                    break;\n                case DIAGONAL:\n                    // Let it wrap around\n                    break;\n            }\n            //System.out.println(""from "" + getLocation() + ""->"" + x + "","" + y);\n            setLocation (x, y);\n            repaint();\n            try {\n                Thread.sleep(sleepTime );\n            } catch (InterruptedException  e) {\n                return;\n            }\n        }\n    }\n    /** paint -- just draw our image at its current location */\n    public void paint(Graphics  g) {\n        g.drawImage (image, 0, 0, this);\n    }\n}\nThis example features several uses of the volatile  keyword. The volatile  keyword\nis used to inform Java that a variable is subject to change by more than one thread, so\nthat its current value must always be fetched when it is used. Absent this keyword, it\nis legal for Java to use a cached version of the given variable. That increases perfor‐\nmance when a variable is only used in one thread, but (without volatile ) can give\nincorrect results when the variable is modified in one thread and observed in another.\nExample 16-5. main/src/main/java/threads/Bounce.java (part of animator program)\npublic class Bounce extends JPanel {\n    private static final long serialVersionUID  = -5359162621719520213L ;\n    /** The main Panel */\n    protected  JPanel p;\n    /** The image, shared by all the Sprite objects */\n    protected  Image img;\n    /** A Thread Pool */\n492 | Chapter 16: Threaded Java\n    protected  ExecutorService  tp = Executors .newCachedThreadPool ();\n    /** A Vector of Sprite objects. */\n    protected  List<Sprite> v = new Vector<Sprite>(); // multithreaded, use Vector;\n    public static void main(String[] args) {\n        JFrame jf = new JFrame(""Bounce Demo"" );\n        jf.add(new Bounce(args.length > 0 ? args[0] : null));\n        jf.setSize(300, 300);\n        jf.setVisible (true);\n        jf.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE );\n    }\n    public Bounce(String imgName) {\n        setLayout (new BorderLayout ());\n        JButton b = new JButton(""Add a Sprite"" );\n        b.addActionListener (e -> {\n            System.out.println(""Creating another one!"" );\n            Sprite s = new Sprite(this, img);\n            tp.execute(s);\n            p.add(s);\n            v.add(s);\n        });\n        add(b, BorderLayout .NORTH);\n        add(p = new JPanel(), BorderLayout .CENTER);\n        p.setLayout (null);\n        if (imgName == null) imgName = ""duke.gif"" ;\n        final URL resource  = getClass ().getResource (""/"" + imgName);\n        if (resource  == null) {\n            throw new IllegalStateException (""Could not load image ""  + imgName);\n        }\n        img = Toolkit.getDefaultToolkit ().getImage (resource );\n        MediaTracker  mt = new MediaTracker (this);\n        mt.addImage (img, 0);\n        try {\n            mt.waitForID (0);\n        } catch(InterruptedException  e) {\n            throw new IllegalArgumentException (\n                ""InterruptedException while loading image ""  + imgName);\n        }\n        if (mt.isErrorID (0)) {\n            throw new IllegalArgumentException (\n                ""Couldn't load image ""  + imgName);\n        }\n        JButton stopper = new JButton(""Shut down"" );\n        stopper.addActionListener (e -> {\n            stop();\n            tp.shutdown ();\n        });\n        add(stopper, BorderLayout .SOUTH);\n    }\n    public void stop() {\n16.2 Displaying a Moving Image with Animation | 493",8372
643-16.3 Stopping a Thread.pdf,643-16.3 Stopping a Thread,,0
644-Problem.pdf,644-Problem,,0
645-Solution.pdf,645-Solution,,0
646-Discussion.pdf,646-Discussion,"for (Sprite s : v) {\n            s.stop();\n        }\n        v.clear();\n        try {\n            tp.awaitTermination (5, TimeUnit .SECONDS);\n            System.out.println(""ThreadPool is shut down, ending program"" );\n            System.exit(0);\n        } catch (InterruptedException  e) {\n            // Empty\n        }\n    }\n}\n16.3 Stopping a Thread\nProblem\nY ou need to stop a thread.\nSolution\nDon’t use the Thread.stop()  method; instead, use a boolean  tested at the top of the\nmain loop in the run()  method.\nDiscussion\nThough you can use the thread’s stop()  method, it is not recommended. That’s\nbecause the method is so drastic that it can never be made to behave reliably in a pro‐\ngram with multiple active threads. That is why, when you try to use it, the compiler\nwill generate deprecation warnings. The recommended method is to use a boolean\nvariable in the main loop of the run()  method. The program in Example 16-6  prints\na message endlessly until its shutDown()  method is called; it then sets the controlling\nvariable done  to false, which terminates the loop. This causes the run()  method to\nreturn, ending its processing.\nExample 16-6. main/src/main/java/threads/StopBoolean.java\npublic class StopBoolean  {\n    // Must be volatile to ensure changes visible to other threads.\n    protected  volatile  boolean done = false;\n    Runnable  r = () -> {\n        while (!done) {\n            System.out.println(""StopBoolean running"" );\n            try {\n494 | Chapter 16: Threaded Java\n                Thread.sleep(720);\n            } catch (InterruptedException  ex) {\n                // nothing to do\n            }\n        }\n        System.out.println(""StopBoolean finished."" );\n    };\n    public void shutDown () {\n        System.out.println(""Shutting down..."" );\n        done = true;\n    }\n    public void doDemo() throws InterruptedException  {\n        ExecutorService  pool = Executors .newSingleThreadExecutor ();\n        pool.submit(r);\n        Thread.sleep(1000*5);\n        shutDown ();\n        pool.shutdown ();\n        pool.awaitTermination (2, TimeUnit .SECONDS);\n    }\n    public static void main(String[] args) throws InterruptedException  {\n        new StopBoolean ().doDemo();\n    }\n}\nRunning it looks like this:\nStopBoolean running\nStopBoolean running\nStopBoolean running\nStopBoolean running\nStopBoolean running\nStopBoolean running\nStopBoolean running\nStopBoolean finished.\nBut what if your thread is blocked reading from a network connection? Y ou then can‐\nnot check a boolean , because the thread that is reading is asleep. This is what the\nstop  method was designed for, but, as we’ve seen, it is now deprecated. Instead, you\ncan simply close the socket. The program shown in Example 16-7  intentionally dead‐\nlocks itself by reading from a socket that you are supposed to write to, simply to\ndemonstrate that closing the socket does in fact terminate the loop.\nExample 16-7. main/src/main/java/threads/StopClose.java\npublic class StopClose  extends Thread {\n    protected  Socket io;\n    public void run() {\n16.3 Stopping a Thread | 495\n        try {\n            io = new Socket(""java.sun.com"" , 80);    // HTTP\n            BufferedReader  is = new BufferedReader (\n                new InputStreamReader (io.getInputStream ()));\n            System.out.println(""StopClose reading"" );\n            // The following line will deadlock (intentionally), since HTTP\n            // enjoins the client to send a request (like ""GET / HTTP/1.0"")\n            // and a null line, before reading the response.\n            String line = is.readLine ();    // DEADLOCK\n            // Should only get out of the readLine if an interrupt\n            // is thrown, as a result of closing the socket.\n            // So we shouldn't get here, ever:\n            System.out.printf(""StopClose FINISHED after reading %s!?"" , line);\n        } catch (IOException  ex) {\n            System.out.println(""StopClose terminating: ""  + ex);\n        }\n    }\n    public void shutDown () throws IOException  {\n        if (io != null) {\n            // This is supposed to interrupt the waiting read.\n            synchronized (io) {\n                io.close();\n            }\n        }\n        System.out.println(""StopClose.shutDown() completed"" );\n    }\n    public static void main(String[] args)\n    throws InterruptedException , IOException  {\n        StopClose  t = new StopClose ();\n        t.start();\n        Thread.sleep(1000*5);\n        t.shutDown ();\n    }\n}\nWhen run, it prints a message that the close is happening:\nStopClose reading\nStopClose terminating: java.net.SocketException: Resource temporarily unavail-\nable\n“But wait, ” you say. “What if I want to break the wait, but not really terminate the\nsocket?” A good question, indeed, and there is no perfect answer. But you can inter‐\nrupt the thread that is reading; the read is interrupted by a java.io.Interrupte\ndIOException , and you can retry the read. The file Intr.java  in this chapter’s source\ncode shows this.\n496 | Chapter 16: Threaded Java",5139
647-16.4 Rendezvous and Timeouts.pdf,647-16.4 Rendezvous and Timeouts,,0
648-Problem.pdf,648-Problem,,0
649-Solution.pdf,649-Solution,,0
650-16.5 Synchronizing Threads with the synchronized Keyword.pdf,650-16.5 Synchronizing Threads with the synchronized Keyword,"16.4 Rendezvous and Timeouts\nProblem\nY ou need to know whether something finished or whether it finished in a certain\nlength of time.\nSolution\nStart that something in its own thread and call its join()  method with or without a\ntimeout value.\nDiscussion\nThe join()  method of the target thread is used to suspend the current thread until\nthe target thread is finished (returns from its  run()  method). This method is overloa‐\nded; a version with no arguments waits forever for the thread to terminate, whereas a\nversion with arguments waits up to the specified time. For a simple example, I create\n(and start!) a simple thread that just reads from the console terminal, and the main\nthread simply waits for it. When I run the program, it looks like this:\ndarwinsys.com$ java threads.Join\nStarting\nJoining\nReading\nhello from standard input # waits indefinitely for me to type this line\nThread Finished.\nMain Finished.\ndarwinsys.com$\nExample 16-8  lists the code for the join()  demo.\nExample 16-8. main/src/main/java/threads/Join.java\npublic class Join {\n    public static void main(String[] args) {\n        Thread t = new Thread() {\n            public void run() {\n                System.out.println(""Reading"" );\n                try {\n                    System.in.read();\n                } catch (java.io.IOException  ex) {\n                    System.err.println(ex);\n                }\n                System.out.println(""Thread Finished."" );\n            }\n        };\n        System.out.println(""Starting"" );\n16.4 Rendezvous and Timeouts | 497",1583
651-Problem.pdf,651-Problem,,0
652-Solution.pdf,652-Solution,,0
653-Discussion.pdf,653-Discussion,"t.start();\n        System.out.println(""Joining"" );\n        try {\n            t.join();\n        } catch (InterruptedException  ex) {\n            // should not happen:\n            System.out.println(""Who dares interrupt my sleep?"" );\n        }\n        System.out.println(""Main Finished."" );\n    }\n}\nAs you can see, it uses an inner class Runnable  (see Recipe 16.1 ) in Thread t  to be\nrunnable.\n16.5 Synchronizing Threads with the synchronized\nKeyword\nProblem\nY ou need to protect certain data from access by multiple threads.\nSolution\nUse the synchronized  keyword on the method or code you wish to protect.\nDiscussion\nI discussed the synchronized  keyword briefly in Recipe 13.5 . This keyword specifies\nthat only one thread at a time is allowed to run the given method (or any other\nsynchronized method in the same class) in a given object instance (for static meth‐\nods, only one thread is allowed to run the method at a time). Y ou can synchronize\nmethods or smaller blocks of code. It is easier and safer to synchronize entire meth‐\nods, but this can be more costly in terms of blocking threads that could run. Y ou can\nsimply add the synchronized  keyword on the method. For example, many of the\nmethods of Vector  (see Recipe 7.4 ) are synchronized in order to ensure that the vec‐\ntor does not become corrupted or give incorrect results when two threads update or\nretrieve from it at the same time.\nBear in mind that threads can be interrupted at almost any time, in which case con‐\ntrol is given to another thread. Consider the case of two threads appending to a data\nstructure at the same time. Let’s suppose we have the same methods as Vector , but\nwe’re operating on a simple array. The  add()  method simply uses the current number\nof objects as an array index, then increments it:\n498 | Chapter 16: Threaded Java\npublic void add(Object obj) {\n   data[max] = obj; \n   max = max + 1;   \n}\nThreads A and B both wish to call this method. Suppose that Thread A gets interrup‐\nted after \n  but before \n , and then Thread B gets to run.\nThread B does \n , overwriting the contents of data[max] ; we’ve now lost all refer‐\nence to the object that Thread A passed in!\nThread B then increments max at \n  and returns. Later, Thread A gets to run\nagain; it resumes at \n  and increments max past the last valid object. So not only\nhave we lost an object, but we have an uninitialized reference in the array. This\nstate of affairs is shown in Figure 16-2 .\nFigure 16-2. Non-thread-safe add method in operation: normal and failed updates\nNow you might think, “No problem, I’ll just combine the two lines of code!”:\ndata[max++] = obj;\nAs the game show host sometimes says, “Bzzzzt! Thanks for playing!” This change\nmakes the code a bit shorter but has absolutely no effect on reliability. Interrupts\ndon’t happen conveniently on Java statement boundaries; they can happen between\nany of the many JVM machine instructions that correspond to your program. The\ncode can still be interrupted after the store and before the increment. The only good\nsolution is to use proper synchronization.\nMaking the method synchronized  means that any invocations of it will wait if one\nthread has already started running the method:\n16.5 Synchronizing Threads with the synchronized Keyword | 499\n6A servlet  is a low-level server-side API for interacting with remote clients; today it would probably be written\nin the form of a JavaServer Faces (JSF) handler.public synchronized void add(Object obj) {\n    ...\n}\nAny time you wish to synchronize some code, but not an entire method, use the\nsynchronized  keyword on an unnamed code block within a method, like this:\npublic void add(Object obj) {\n    synchronized (someObject) {\n        // this code will execute in one thread at a time\n    }\n}\nThe choice of object to synchronize on is up to you. Sometimes it makes sense to syn‐\nchronize on the object containing the code, as in Example 16-9 . For synchronizing\naccess to an ArrayList , it would make sense to use the ArrayList  instance, like this:\nsynchronized(myArrayList) {\n     if (myArrayList.indexOf(someObject) != -1) {\n         // do something with it.\n     } else {\n         create an object and add it...\n    }\n}\nExample 16-9  is a web servlet that I wrote for use in the classroom, following a sug‐\ngestion from fellow Learning Tree instructor Scott Weingust.6 It lets you play a quiz\nshow game of the style where the host asks a question and the first person to press\ntheir buzzer (buzz in) gets to try to answer the question correctly. To ensure against\nhaving two people buzz in simultaneously, the code uses a synchronized block around\nthe code that updates the Boolean  buzzed  variable. And for reliability, any code that\naccesses this Boolean  is also synchronized.\nExample 16-9. main/src/main/java/threads/BuzzInServlet.java\npublic class BuzzInServlet  extends HttpServlet  {\n    /** The attribute name used throughout. */\n    protected  final static String WINNER = ""buzzin.winner"" ;\n    /** doGet is called from the contestants web page.\n     * Uses a synchronized code block to ensure that\n     * only one contestant can change the state of ""buzzed"".\n     */\n    public void doGet(HttpServletRequest  request, HttpServletResponse  response )\n    throws ServletException , IOException  {\n500 | Chapter 16: Threaded Java\n        ServletContext  application  = getServletContext ();\n        boolean iWon = false;\n        String user = request.getRemoteHost () + '@' + request.getRemoteAddr ();\n        // Do the synchronized stuff first, and all in one place.\n        synchronized (application ) {\n            if (application .getAttribute (WINNER) == null) {\n                application .setAttribute (WINNER, user);\n                application .log(""BuzzInServlet: WINNER ""  + user);\n                iWon = true;\n            }\n         }\n        response .setContentType (""text/html"" );\n        PrintWriter  out = response .getWriter ();\n        out.println(""<html><head><title>Thanks for playing</title></head>"" );\n        out.println(""<body bgcolor=\""white\"">"" );\n        if (iWon) {\n            out.println(""<b>YOU GOT IT</b>"" );\n            // TODO - output HTML to play a sound file :-)\n        } else {\n                out.println(""Thanks for playing, ""  + request.getRemoteAddr ());\n                out.println("", but ""  + application .getAttribute (WINNER) +\n                    "" buzzed in first"" );\n        }\n        out.println(""</body></html>"" );\n    }\n    /** The Post method is used from an Administrator page (which should\n     * only be installed in the instructor/host's localweb directory).\n     * Post is used for administrative functions:\n     * 1) to display the winner;\n     * 2) to reset the buzzer for the next question.\n     */\n    public void doPost(HttpServletRequest  request, HttpServletResponse  response )\n    throws ServletException , IOException  {\n        ServletContext  application  = getServletContext ();\n        response .setContentType (""text/html"" );\n        HttpSession  session = request.getSession ();\n        PrintWriter  out = response .getWriter ();\n        if (request.isUserInRole (""host"")) {\n            out.println(""<html><head><title>Welcome back, ""  +\n                request.getUserPrincipal ().getName() + ""</title><head>"" );\n            out.println(""<body bgcolor=\""white\"">"" );\n            String command = request.getParameter (""command"" );\n            if (command.equals(""reset"")) {\n16.5 Synchronizing Threads with the synchronized Keyword | 501\n                // Synchronize what you need, no more, no less.\n                synchronized (application ) {\n                    application .setAttribute (WINNER, null);\n                }\n                session.setAttribute (""buzzin.message"" , ""RESET"");\n            } else if (command.equals(""show"")) {\n                String winner = null;\n                synchronized (application ) {\n                    winner = (String)application .getAttribute (WINNER);\n                }\n                if (winner == null) {\n                    session.setAttribute (""buzzin.message"" ,\n                        ""<b>No winner yet!</b>"" );\n                } else {\n                    session.setAttribute (""buzzin.message"" ,\n                        ""<b>Winner is: </b>""  + winner);\n                }\n            }\n            else {\n                session.setAttribute (""buzzin.message"" ,\n                    ""ERROR: Command ""  + command + "" invalid."" );\n            }\n            RequestDispatcher  rd = application .getRequestDispatcher (\n                ""/hosts/index.jsp"" );\n            rd.forward(request, response );\n        } else {\n            out.println(""<html><head><title>Nice try, but... </title><head>"" );\n            out.println(""<body bgcolor=\""white\"">"" );\n            out.println(\n                ""I'm sorry, Dave, but you know I can't allow you to do that."" );\n            out.println(""Even if you are ""  + request.getUserPrincipal ());\n        }\n        out.println(""</body></html>"" );\n    }\n}\nTwo HTML pages lead to the servlet. The contestant’s page simply has a large link ( <a\nhref=/servlet/BuzzInServlet> ). Anchor links generate an HTML GET, so the\nservlet engine calls doGet() :\n<html><head><title>Buzz In!</title></head>\n<body>\n<h1>Buzz In!</h1>\n<p>\n<font size=+6>\n<a href=""servlet/BuzzInServlet"">\nPress here to buzz in!\n</a>\n</font>\nThe HTML is pretty plain, but it does the job. Figure 16-3  shows the look and feel.\n502 | Chapter 16: Threaded Java\nFigure 16-3. BuzzInServlet in action\nThe game show host has access to an HTML form with a POST method, which calls\nthe doPost()  method. This displays the winner to the game show host and resets the\nbuzzer for the next question.\n<html><head><title> Reset Buzzer </title></head>\n<body>\n<h1>Display Winner </h1>\n<p>\n<b>The winner is: </b>\n<form method=""post"" action=""servlet/BuzzInServlet"" >\n    <input type=""hidden""  name=""command""  value=""show"">\n    <input type=""hidden""  name=""password""  value=""syzzy"">\n    <input type=""submit""  name=""Show"" value=""Show"">\n</form>\n<h1>Reset Buzzer </h1>\n<p>\n<b>Remember to RESET before you ask the contestants each question! </b>\n<form method=""post"" action=""servlet/BuzzInServlet"" >\n    <input type=""hidden""  name=""command""  value=""reset"">\n    <input type=""hidden""  name=""password""  value=""syzzy"">\n    <input type=""submit""  name=""Reset"" value=""RESET!"" >\n</form>\n16.5 Synchronizing Threads with the synchronized Keyword | 503",10655
654-16.6 Simplifying Synchronization with Locks.pdf,654-16.6 Simplifying Synchronization with Locks,,0
655-Problem.pdf,655-Problem,,0
656-Discussion.pdf,656-Discussion,"A password is provided; it’s hardcoded here, but in reality the password would come\nfrom a properties file ( Recipe 7.10 ) or a servlet initialization parameter (as described\nin Java Servlet Programming  [O’Reilly]):\nThe game show host functionality is shown in Figure 16-4 .\nFigure 16-4. BuzzInServlet game show host function\nFor a more complete game, of course, the servlet would keep a Stack  (see Recipe\n7.16) of people in the order they buzzed in, in case the first person doesn’t answer the\nquestion correctly. Access to this would have to be synchronized, too.\n16.6 Simplifying Synchronization with Locks\nProblem\nY ou want an easier means of synchronizing threads.\nSolution\nUse the Lock  mechanism in java.util.concurrent.locks .\n504 | Chapter 16: Threaded Java\nDiscussion\nUse the java.util.concurrent.locks  package; its major interface is Lock . This\ninterface has several methods for locking and one for unlocking. Here is the general\npattern for using it:\nLock thelock = ....\ntry  {\n        lock.lock( );\n        // do the work that is protected by the lock\n} finally {\n        lock.unlock( );\n}\nThe point of putting the unlock()  call in the finally  block is, of course, to ensure\nthat it is not bypassed if an exception occurs (the code may also include one or more\ncatch  blocks, as required by the work being performed).\nThe improvement here, compared with the traditional synchronized methods and\nblocks, is that using a Lock  actually looks like a locking operation! And, as I men‐\ntioned, several means of locking are available, shown in Table 16-1 .\nTable 16-1. Locking methods of the Lock class\nReturn\ntypeMethod Meaning\nvoid lock( ) Get the lock, even if you have to wait until another thread\nfrees it first\nboolean tryLock( ) Get the lock only if it is free right now\nboolean tryLock(long time, TimeUnit \nunits) throws\nInterruptedExceptionTry to get the lock, but only wait for the length of time\nindicated\nvoid lockInterruptibly( ) throws\nInterruptedExceptionGet the lock, waiting unless interrupted\nvoid unlock( ) Release the lock\nThe TimeUnit  class lets you specify the units for the amount of time specified, includ‐\ning TimeUnit.SECONDS , TimeUnit.MILLISECONDS , TimeUnit.MICROSECONDS , and Time\nUnit.NANOSECONDS .\nIn all cases, the lock must be released with unlock()  before it can be locked again.\nThe standard Lock  is useful in many applications, but depending on the application’s\nrequirements, other types of locks may be more appropriate. Applications with asym‐\nmetric load patterns may benefit from a common pattern called the reader-writer\nlock; I call this one a readers-writer lock to emphasize that there can be many readers\nbut only one writer. It’s actually a pair of interconnected locks; any number of readers\n16.6 Simplifying Synchronization with Locks | 505\ncan hold the read lock and read the data, as long as it’s not being written (shared read\naccess). A thread trying to lock the write lock, however, waits until all the readers are\nfinished and then locks them out until the writer is finished (exclusive write access).\nTo support this pattern, both the ReadWriteLock  interface and the implementing\nclass ReentrantReadWriteLock  are available. The interface has only two methods, \nreadLock()  and writeLock() , which provide a reference to the appropriate Lock\nimplementation. These  methods do not, in themselves, lock or unlock the locks ; they\nonly provide access to them, so it is common to see code like this:\nrwlock.readLock( ).lock( );\n...\nrwlock.readLock( ).unlock( );\nTo demonstrate ReadWriteLock  in action, I wrote the business logic portion of a web-\nbased voting application. It could be used in voting for candidates or for the more\ncommon web poll. Presuming that you display the results on the home page and\nchange the data only when somebody takes the time to click a response to vote, this\napplication fits one of the intended criteria for ReadWriteLock —that is, that you have\nmore readers than writers. The main class, ReadersWritersDemo , is shown in\nExample 16-10 . The helper class BallotBox  is online; it simply keeps track of the\nvotes and returns a read-only Iterator  upon request. Note that in the  run()  method\nof the reading threads, you could obtain the iterator while holding the lock but\nrelease the lock before printing it; this allows greater concurrency and better perfor‐\nmance, but it could (depending on your application) require additional locking\nagainst concurrent update.\nExample 16-10. main/src/main/java/threads/ReadersWriterDemo.java\npublic class ReadersWriterDemo  {\n    private static final int NUM_READER_THREADS  = 3;\n    public static void main(String[] args) {\n        new ReadersWriterDemo ().demo();\n    }\n    /** Set this to true to end the program */\n    private volatile  boolean done = false;\n    /** The data being protected. */\n    private BallotBox  theData;\n    /** The read lock / write lock combination */\n    private ReadWriteLock  lock = new ReentrantReadWriteLock ();\n    /**\n     * Constructor: set up some quasi-random initial data\n     */\n506 | Chapter 16: Threaded Java\n    public ReadersWriterDemo () {\n        List<String> questionsList  = new ArrayList <>();\n        questionsList .add(""Agree"");\n        questionsList .add(""Disagree"" );\n        questionsList .add(""No opinion"" );\n        theData = new BallotBox (questionsList );\n    }\n    /**\n     * Run a demo with more readers than writers\n     */\n    private void demo() {\n        // Start two reader threads\n        for (int i = 0; i < NUM_READER_THREADS ; i++) {\n            new Thread() {\n                public void run() {\n                    while (!done) {\n                        lock.readLock ().lock();\n                        try {\n                            theData.forEach(p ->\n                                System.out.printf(""%s: votes %d%n"" ,\n                                    p.getName(),\n                                    p.getVotes ()));\n                        } finally {\n                            // Unlock in ""finally"" to be sure it gets done.\n                            lock.readLock ().unlock();\n                        }\n                        try {\n                            Thread.sleep(((long)(Math.random()* 1000)));\n                        } catch (InterruptedException  ex) {\n                            // nothing to do\n                        }\n                    }\n                }\n            }.start();\n        }\n        // Start one writer thread to simulate occasional voting\n        new Thread() {\n            public void run() {\n                while (!done) {\n                    lock.writeLock ().lock();\n                    try {\n                        theData.voteFor(\n                            // Vote for random candidate :-)\n                            // Performance: should have one PRNG per thread.\n                            (((int)(Math.random()*\n                            theData.getCandidateCount ()))));\n                    } finally {\n                        lock.writeLock ().unlock();\n16.6 Simplifying Synchronization with Locks | 507",7239
657-See Also.pdf,657-See Also,,0
658-16.7 Simplifying ProducerConsumer with the Queue Interface.pdf,658-16.7 Simplifying ProducerConsumer with the Queue Interface,,0
659-Problem.pdf,659-Problem,,0
660-Solution.pdf,660-Solution,,0
661-Discussion.pdf,661-Discussion,"}\n                    try {\n                        Thread.sleep(((long)(Math.random()*1000)));\n                    } catch (InterruptedException  ex) {\n                        // nothing to do\n                    }\n                }\n            }\n        }.start();\n        // In the main thread, wait a while then terminate the run.\n        try {\n            Thread.sleep(10 * 1000);\n        } catch (InterruptedException  ex) {\n            // nothing to do\n        } finally {\n            done = true;\n        }\n    }\n}\nBecause this is a simulation and the voting is random, it does not always come out\n50/50. In two consecutive runs, the following were the last line of each run:\nAgree(6), Disagree(6)\nAgree(9), Disagree(4)\nSee Also\nThe Lock  interface also makes available Condition  objects, which provide even more\nflexibility. Consult the online documentation for more information.\n16.7 Simplifying Producer/Consumer with the Queue\nInterface\nProblem\nY ou need to control producer/consumer implementations involving multiple threads.\nSolution\nUse the Queue  interface or the BlockingQueue  subinterface.\nDiscussion\nAs an example of the simplifications possible with the java.util.Concurrent  pack‐\nage, consider the standard producer/consumer program. An implementation\nsynchronized using traditional Thread  code (wait()  and notifyAll() ) is in the\n508 | Chapter 16: Threaded Java\nonline source as ProdCons2 . Example 16-11 , ProdCons15.java , uses the java\n.util.BlockingQueue  (a subinterface of java.util.Queue ) to reimplement Prod\nCons2  in about two-thirds the number of lines of code, and it’s simpler. The applica‐\ntion simply puts items into a queue and takes them from it. In the example, I have\nfour producers and only three consumers, so the producers eventually wait. Running\nthe application on one of my older notebooks, the producers’ lead over the consum‐\ners increases to about 350 over the 10 seconds or so of running it.\nExample 16-11. main/src/main/java/threads/ProdCons15.java\npublic class ProdCons15  {\n    protected  volatile  boolean done = false;\n    /** Inner class representing the Producer side */\n    class Producer  implements  Runnable  {\n        protected  BlockingQueue <Object> queue;\n        Producer (BlockingQueue <Object> theQueue ) { this.queue = theQueue ; }\n        public void run() {\n            try {\n                while (!done) {\n                    Object justProduced  = getRequestFromNetwork ();\n                    queue.put(justProduced );\n                    System.out.println(\n                        ""Produced 1 object; List size now ""  + queue.size());\n                }\n            } catch (InterruptedException  ex) {\n                System.out.println(""Producer INTERRUPTED"" );\n            }\n        }\n        Object getRequestFromNetwork () {    // Simulation of reading from client\n            try {\n                    Thread.sleep(10); // simulate time passing during read\n            } catch (InterruptedException  ex) {\n                 System.out.println(""Producer Read INTERRUPTED"" );\n            }\n            return new Object();\n        }\n    }\n    /** Inner class representing the Consumer side */\n    class Consumer  implements  Runnable  {\n        protected  BlockingQueue <Object> queue;\n        Consumer (BlockingQueue <Object> theQueue ) { this.queue = theQueue ; }\n16.7 Simplifying Producer/Consumer with the Queue Interface | 509\n        public void run() {\n            try {\n                while (true) {\n                    Object obj = queue.take();\n                    int len = queue.size();\n                    System.out.println(""List size now ""  + len);\n                    process(obj);\n                    if (done) {\n                        return;\n                    }\n                }\n            } catch (InterruptedException  ex) {\n                    System.out.println(""CONSUMER INTERRUPTED"" );\n            }\n        }\n        void process(Object obj) {\n            // Thread.sleep(123) // Simulate time passing\n            System.out.println(""Consuming object ""  + obj);\n        }\n    }\n    ProdCons15 (int nP, int nC) {\n        BlockingQueue <Object> myQueue = new LinkedBlockingQueue <>();\n        for (int i=0; i<nP; i++)\n            new Thread(new Producer (myQueue)).start();\n        for (int i=0; i<nC; i++)\n            new Thread(new Consumer (myQueue)).start();\n    }\n    public static void main(String[] args)\n    throws IOException , InterruptedException  {\n        // Start producers and consumers\n        int numProducers  = 4;\n        int numConsumers  = 3;\n        ProdCons15  pc = new ProdCons15 (numProducers , numConsumers );\n        // Let the simulation run for, say, 10 seconds\n        Thread.sleep(10*1000);\n        // End of simulation - shut down gracefully\n        pc.done = true;\n    }\n}\nProdCons15  is superior to ProdCons2  in almost all aspects. However, the queue sizes\nthat are output no longer necessarily exactly reflect the size of the queue after the\nobject is inserted or removed. Because there’s no longer any locking ensuring atomic‐\nity here, any number of queue operations could occur on other threads between the\nProducer  thread’s queue.put()  and the Consumer  thread’s queue size query.\n510 | Chapter 16: Threaded Java",5391
662-16.8 Optimizing Parallel Processing with ForkJoin.pdf,662-16.8 Optimizing Parallel Processing with ForkJoin,,0
663-Problem.pdf,663-Problem,,0
664-Solution.pdf,664-Solution,,0
665-Discussion.pdf,665-Discussion,"16.8 Optimizing Parallel Processing with Fork/Join\nProblem\nY ou want to optimize use of multiple processors and/or large problem spaces.\nSolution\nUse the Fork/Join framework.\nDiscussion\nFork/Join is an ExecutorService  intended mainly for reasonably large tasks that can\nnaturally be divided recursively, where you don’t have to ensure equal timing for each\ndivision. It uses work-stealing to keep threads busy.\nThe basic means of using Fork/Join is to extend RecursiveTask  or RecursiveAction\nand override its compute()  method along these lines:\nif (assigned  portion of work is “small enough”) {\n perform the work myself\n} else {\n split my work into two pieces\n invoke the two pieces and await the results\n}\nThere are two classes: RecursiveTask  and RecursiveAction . The main difference is\nthat RecursiveTask  has each step of the work returning a value, whereas\nRecursiveAction  does not. In other words, the RecursiveAction  method compute()\nhas a return type of void, whereas the RecursiveAction  method of the same name\nhas a return type of T, some type parameter. Y ou might use RecursiveTask  when each\ncall returns a value that represents the computation for its subset of the overall task,\nin other words, to divide a problem like summarizing data—each task would summa‐\nrize one part and return that. Y ou might use RecursiveAction  to operate over a large\ndata structure performing some transform of the data in place.\nThere are two demos of the Fork/Join framework here, named after the ForkJoin\nTask  that each subclasses:\n•RecursiveTaskDemo  uses fork()  and join()  directly.\n•RecursiveActionDemo  uses invokeAll()  to invoke the two subtasks. invoke()  is\njust a fork()  and a join() ; and invokeAll()  just does this repeatedly until done.\nCompare the versions of compute()  in Examples 16-12  and 16-13  and this will\nmake sense.\n16.8 Optimizing Parallel Processing with Fork/Join | 511\nExample 16-12. main/src/main/java/threads/RecursiveActionDemo.java\n/** A trivial demonstration of the ""Fork-Join"" framework:\n * square a bunch of numbers using RecursiveAction.\n * We use RecursiveAction here b/c we don't need each\n * compute() call to return its result; the work is\n * accumulated in the ""dest"" array.\n * @see RecursiveTaskDemo when each computation has to return a value.\n * @author Ian Darwin\n */\npublic class RecursiveActionDemo  extends RecursiveAction  {\n    private static final long serialVersionUID  = 3742774374013520116L ;\n    static int[] raw = {\n        19, 3, 0, -1, 57, 24, 65, Integer.MAX_VALUE , 42, 0, 3, 5\n    };\n    static int[] sorted = null;\n    int[] source;\n    int[] dest;\n    int length;\n    int start;\n    final static int THRESHOLD  = 4;\n    public static void main(String[] args) {\n        sorted = new int[raw.length];\n        RecursiveActionDemo  fb =\n            new RecursiveActionDemo (raw, 0, raw.length, sorted);\n        ForkJoinPool  pool = new ForkJoinPool ();\n        pool.invoke(fb);\n        System.out.print('[');\n        for (int i : sorted) {\n            System.out.print(i + "","");\n        }\n        System.out.println(']');\n    }\n    public RecursiveActionDemo (int[] src, int start, int length, int[] dest) {\n        this.source = src;\n        this.start = start;\n        this.length = length;\n        this.dest = dest;\n      }\n    @Override\n    protected  void compute() {\n        System.out.println(""RecursiveActionDemo.compute()"" );\n        if (length <= THRESHOLD ) { // Compute Directly\n            for (int i = start; i < start + length; i++) {\n                dest[i] = source[i] * source[i];\n            }\n512 | Chapter 16: Threaded Java\n        } else {                    // Divide and Conquer\n            int split = length / 2;\n            invokeAll (\n              new RecursiveActionDemo (source, start,         split,          dest),\n              new RecursiveActionDemo (source, start + split, length - split, dest));\n        }\n    }\n}\nExample 16-13. main/src/main/java/threads/RecursiveTaskDemo.java\n/**\n * Demonstrate the Fork-Join Framework to average a large array.\n * Running this on a multi-core machine as e.g.,\n * $ time java threads.RecursiveTaskDemo\n * shows that the CPU time is always greater than the elapsed time,\n * indicating that we are making use of multiple cores.\n * That said, it is a somewhat contrived demo.\n *\n * Use RecursiveTask<T> where, as in this example, each call returns\n * a value that represents the computation for its subset of the overall task.\n * @see RecursiveActionDemo when each computation does not return a value,\n * e.g., when each is just working on some section of a large array.\n * @author Ian Darwin\n */\npublic class RecursiveTaskDemo  extends RecursiveTask <Long> {\n    private static final long serialVersionUID  = 3742774374013520116L ;\n    static final int N = 10000000 ;\n    final static int THRESHOLD  = 500;\n    int[] data;\n    int start, length;\n    public static void main(String[] args) {\n        int[] source = new int[N];\n        loadData (source);\n        RecursiveTaskDemo  fb = new RecursiveTaskDemo (source, 0, source.length);\n        ForkJoinPool  pool = new ForkJoinPool ();\n        long before = System.currentTimeMillis ();\n        pool.invoke(fb);\n        long after = System.currentTimeMillis ();\n        long total = fb.getRawResult ();\n        long avg = total / N;\n        System.out.println(""Average: ""  + avg);\n        System.out.println(""Time :""  + (after - before) + "" mSec"");\n    }\n    static void loadData (int[] data) {\n        Random r = new Random();\n        for (int i = 0; i < data.length; i++) {\n16.8 Optimizing Parallel Processing with Fork/Join | 513",5748
666-16.9 Scheduling Tasks Future Times Background Saving in an Editor.pdf,666-16.9 Scheduling Tasks Future Times Background Saving in an Editor,,0
667-Solution.pdf,667-Solution,"data[i] = r.nextInt();\n        }\n    }\n    public RecursiveTaskDemo (int[] data, int start, int length) {\n        this.data = data;\n        this.start = start;\n        this.length = length;\n    }\n    @Override\n    protected  Long compute() {\n        if (length <= THRESHOLD ) { // Compute Directly\n            long total = 0;\n            for (int i = start; i < start + length; i++) {\n                total += data[i];\n            }\n            return total;\n        } else {                    // Divide and Conquer\n            int split = length / 2;\n            RecursiveTaskDemo  t1 =\n                new RecursiveTaskDemo (data, start,         split);\n            t1.fork();\n            RecursiveTaskDemo  t2 =\n                new RecursiveTaskDemo (data, start + split, length - split);\n            return t2.compute() + t1.join();\n        }\n    }\n}\nThe biggest undefined part there is “small enough”; you may have to do some experi‐\nmentation to see what works well as a chunk size. Or, better yet, write more code\nusing a feedback control system, measuring the system throughput as the parameter\nis dynamically tweaked up and down, and have the system automatically arrive at the\noptimal value for that particular computer system and runtime. This is left as an\nextended exercise for the reader.\n16.9 Scheduling Tasks: Future Times, Background Saving\nin an Editor\nProblem\nY ou need to schedule something for a fixed time in the future. Y ou need to save the\nuser’s work periodically in an interactive program.\n514 | Chapter 16: Threaded Java",1587
668-Discussion.pdf,668-Discussion,"Solution\nFor one-shot future tasks, use the Timer  service with a TimerTask  object. For recur‐\nring tasks, either use a background thread, or use the Timer  service and recompute\nthe next time. For more complex tasks, such as running something at high noon\nevery second Thursday, consider using a third-party scheduling library such as\nQuartz  or, in JavaEE/Jakarta, the EJB Timer Service .\nDiscussion\nThere are several ways of scheduling things in the future. For one-shot scheduling,\nyou can use the Timer  service from java.util . For recurring tasks, you can use a\nRunnable , which sleeps in a loop.\nHere is an example of the Timer  service in java.util . These are the basics of using\nthis API:\n1.Create a Timer  service object.\n2.Use it to schedule instances of TimerTask  with a legacy Date  object indicating the\ndate and time.\nThe example code in Example 16-14  uses Item  as a subclass of TimerTask  to perform\na simple notification action in the future, based on reading lines with year-month-\nday-hour-minute Task , such as the following:\n2020 12 25 10 30 Get some sleep.\n2020 12 26 01 27 Finish this program\n2020 12 25 01 29 Document this program\nExample 16-14. main/src/main/java/threads/ReminderService.java\npublic class ReminderService  {\n    /** The Timer object */\n    Timer timer = new Timer();\n    class Item extends TimerTask  {\n        String message;\n        Item(String m) {\n            message = m;\n        }\n        public void run() {\n            message(message);\n        }\n    }\n    public static void main(String[] argv) throws Exception  {\n        new ReminderService ().loadReminders ();\n16.9 Scheduling Tasks: Future Times, Background Saving in an Editor | 515\n    }\n    private String dfPattern  = ""yyyy MM dd hh mm ss"" ;\n    private SimpleDateFormat  formatter  = new SimpleDateFormat (dfPattern );\n    protected  void loadReminders () throws Exception  {\n        Files.lines(Path.of(""ReminderService.txt"" )).forEach(aLine -> {\n            ParsePosition  pp = new ParsePosition (0);\n            Date date = formatter .parse(aLine, pp);\n            String task = aLine.substring (pp.getIndex ());\n            if (date == null) {\n                System.out.println(""Invalid date in ""  + aLine);\n                return;\n            }\n            System.out.println(""Date = ""  + date + ""; task = ""  + task);\n            timer.schedule (new Item(task), date);\n        });\n    }\nIn real life the program would need to run for long periods of time and use some\nmore sophisticated messaging pattern; here we only show the timing scheduling por‐\ntion.\nThe code fragment in Example 16-15  creates a background thread to handle back‐\nground saves, as in most word processors.\nExample 16-15. main/src/main/java/threads/ReminderService.java\npublic class AutoSave  extends Thread {\n    /** The FileSave interface is implemented by the main class. */\n    protected  FileSaver  model;\n    /** How long to sleep between tries */\n    public static final int MINUTES = 5;\n    private static final int SECONDS = MINUTES * 60;\n    public AutoSave (FileSaver  m) {\n        super(""AutoSave Thread"" );\n        setDaemon (true);        // so we don't keep the main app alive\n        model = m;\n    }\n    public void run() {\n        while (true) {        // entire run method runs forever.\n            try {\n                sleep(SECONDS*1000);\n            } catch (InterruptedException  e) {\n                // do nothing with it\n            }\n            if (model.wantAutoSave () && model.hasUnsavedChanges ())\n516 | Chapter 16: Threaded Java",3633
669-See Also.pdf,669-See Also,"model.saveFile (null);\n        }\n    }\n    // Not shown:\n    // 1) saveFile() must now be synchronized.\n    // 2) method that shuts down main program be synchronized on *SAME* object\n}\n/** Local copy of FileSaver interface, for compiling AutoSave demo. */\ninterface  FileSaver  {\n    /** Load new model from fn; if null, prompt for new fname */\n    public void loadFile (String fn);\n    /** Ask the model if it wants AutoSave done for it */\n    public boolean wantAutoSave ();\n    /** Ask the model if it has any unsaved changes, don't save otherwise */\n    public boolean hasUnsavedChanges ();\n    /** Save the current model's data in fn.\n     * If fn == null, use current fname or prompt for a filename if null.\n     */\n    public void saveFile (String fn);\n}\nAs you can see in the run()  method, this code sleeps for five minutes (300 seconds),\nthen checks whether it should do anything. If the user has turned autosave off, or\nhasn’t made any changes since the last save, nothing needs to be done. Otherwise, we\ncall the saveFile()  method in the main program, which saves the data to the current\nfile. It would be smarter to save it to a recovery file of some name, as the better word\nprocessors do.\nWhat’s not shown is that now all the methods must be synchronized. It’s easy to see\nwhy if you think about how the save method would work if the user clicked the Save\nbutton at the same time that the autosave method called it, or if the user clicked Exit\nwhile the file save method had just opened the file for writing. The strategy of saving\nto a recovery file gets around some of this, but it still needs a great deal of care.\nSee Also\nFor details on java.util.concurrent , see the documentation accompanying the\nJDK. For background on JSR 166, see Doug Lea’s home page  and his JSR 166 page .\nA great reference on Java threading is Java Concurrency in Practice  by Brian Goetz et\nal. (Addison-Wesley).\nProject Loom: Fibers and Continuations  aims to promote easier-to-use, lighter-\nweight concurrency mechanisms.\n16.9 Scheduling Tasks: Future Times, Background Saving in an Editor | 517",2132
670-Chapter 17. Reflection or A Class Named Class.pdf,670-Chapter 17. Reflection or A Class Named Class,,0
671-17.1 Getting a Class Descriptor.pdf,671-17.1 Getting a Class Descriptor,"CHAPTER 17\nReflection,  or “A Class Named Class”\n17.0 Introduction\nThe class java.lang.Class  and the reflection package java.lang.reflect  provide a\nnumber of mechanisms for gathering information from the Java Virtual Machine.\nKnown collectively as reflection , these facilities allow you to load classes on the fly, to\nfind methods and fields in classes, to generate listings of them, and to invoke meth‐\nods on dynamically loaded classes. There is even a mechanism to let you construct a\nclass from scratch (well, actually, from an array of bytes) while your program is run‐\nning. This is about as close as Java lets you get to the magic, secret internals of the\nJava machine.\nThe JVM itself is a large program, normally written in C and/or C++, that imple‐\nments the Java Virtual Machine abstraction. Y ou can get the source for OpenJDK and\nother JVMs via the internet, which you could study for months. Here we concentrate\non just a few aspects, and only from the point of view of a programmer using the\nJVM’s facilities, not how it works internally; that is an implementation detail that\ncould vary from one vendor’s JVM to another.\nI’ll start with loading an existing class dynamically, move on to listing the fields and\nmethods of a class and invoking methods, and end by creating a class on the fly using\na ClassLoader . One of the more interesting aspects of Java, and one that accounts for\nits flexibility (applets in days of yore, servlets, web services, and other dynamic APIs)\nwhile also once being part of its perceived speed problem, is the notion of dynamic\nloading . For example, even the simplest “Hello, Java” program has to load the class file\nfor your HelloJava  class, the class file for its parent (usually java.lang.Object ), the\nclass for PrintStream  (because you used System.out ), the class for PrintStream ’s\nparent, and IOException , and its parent, and so on. To see this in action, try some‐\nthing like this:\n519",1972
672-Problem.pdf,672-Problem,,0
673-17.2 Finding and Using Methods and Fields.pdf,673-17.2 Finding and Using Methods and Fields,"java -verbose HelloJava | more\nTo take another example, when applets were popular, a browser would download an\napplet’s bytecode file over the internet and run it on your desktop. How does it load\nthe class file into the running JVM? We discuss this little bit of Java magic in Recipe\n17.4. The chapter ends with replacement versions of the JDK tools javap  and a cross-\nreference tool that you can use to become a famous Java author by publishing your\nvery own reference to the complete Java API.\n17.1 Getting a Class Descriptor\nProblem\nY ou want to get a Class  object from a class name or instance.\nSolution\nIf the type name is known at compile time, you can get the class instance using the\ncompiler keyword .class , which works on any type that is known at compile time,\neven the eight primitive types.\nOtherwise, if you have an object (an instance of a class), you can call the\njava.lang.Object  method getClass() , which returns the Class  object for the\nobject’s class (now that was a mouthful!):\n        System.out.println(""Trying the ClassName.class keyword:"" );\n        System.out.println(""Object class: ""  + Object.class);\n        System.out.println(""String class: ""  + String.class);\n        System.out.println(""String[] class: ""  + String[].class);\n        System.out.println(""Calendar class: ""  + Calendar .class);\n        System.out.println(""Current class: ""  + ClassKeyword .class);\n        System.out.println(""Class for int: ""  + int.class);\n        System.out.println();\n        System.out.println(""Trying the instance.getClass() method:"" );\n        System.out.println(""Sir Robin the Brave"" .getClass ());\n        System.out.println(Calendar .getInstance ().getClass ());\nWhen we run it, we see this:\nC:\javasrc\reflect> java  ClassKeyword \nTrying the ClassName.class keyword:\nObject class: class java.lang.Object\nString class: class java.lang.String\nString[] class: class [Ljava.lang.String;\nCalendar class: class java.util.Calendar\nCurrent class: class ClassKeyword\nClass for int: int\n520 | Chapter 17: Reflection,  or “A Class Named Class”",2098
674-Problem.pdf,674-Problem,,0
675-Solution.pdf,675-Solution,,0
676-Discussion.pdf,676-Discussion,"Trying the instance.getClass( ) method:\nclass java.lang.String\nclass java.util.GregorianCalendar\nC:\javasrc\reflect>\nNothing fancy, but as you can see, you can get the Class  object for almost anything\nknown at compile time, whether it’s part of a package or not.\n17.2 Finding and Using Methods and Fields\nProblem\nY ou need to find arbitrary method or field names in arbitrary classes.\nSolution\nUse the reflection package java.lang.reflect .\nDiscussion\nIf you just wanted to find fields and methods in one particular class, you wouldn’t\nneed this recipe; you could simply create an instance of the class using new and refer\nto its fields and methods directly. But this allows you to find methods and fields in\nany class, even classes that have not yet been written! Given a class object created as\nin Recipe 17.1 , you can obtain a list of constructors, a list of methods, or a list of\nfields. The method getMethods()  lists the methods available for a given class as an\narray of Method  objects. Similarly, getFields()  returns a list of Field  objects.\nBecause constructor methods are treated specially by Java, there is also a getConstruc\ntors()  method, which returns an array of Constructor  objects. Even though Class  is\nin the package java.lang , the Constructor , Method , and Field  objects it returns are\nin java.lang.reflect , so you need an import of this package. The ListMethods  class\n(see Example 17-1 ) shows how get a list of methods in a class whose name is known\nat runtime.\nExample 17-1. main/src/main/java/reflection/ListMethods.java\npublic class ListMethods  {\n    public static void main(String[] argv) throws ClassNotFoundException  {\n        if (argv.length == 0) {\n            System.err.println(""Usage: ListMethods className"" );\n            return;\n        }\n        Class<?> c = Class.forName(argv[0]);\n        Constructor <?>[] cons = c.getConstructors ();\n        printList (""Constructors"" , cons);\n17.2 Finding and Using Methods and Fields | 521\n        Method[] meths = c.getMethods ();\n        printList (""Methods"" , meths);\n    }\n    static void printList (String s, Object[] o) {\n        System.out.println(""*** "" + s + "" ***"");\n        for (int i=0; i<o.length; i++)\n            System.out.println(o[i].toString ());\n    }\n}\nFor example, you could run Example 17-1  on a class like java.lang.String  and get a\nfairly lengthy list of methods; I’ll only show part of the output so you can see what it\nlooks like:\n> java reflection.ListMethods java.lang.String\n*** Constructors ***\npublic java.lang.String( )\npublic java.lang.String(java.lang.String)\npublic java.lang.String(java.lang.StringBuffer)\npublic java.lang.String(byte[])\n// and many more...\n*** Methods ***\npublic static java.lang.String java.lang.String.copyValueOf(char[])\npublic static java.lang.String java.lang.String.copyValueOf(char[],int,int)\npublic static java.lang.String java.lang.String.valueOf(char)\n// and more valueOf( ) forms...\npublic boolean java.lang.String.equals(java.lang.Object)\npublic final native java.lang.Class java.lang.Object.getClass( )\n// and more java.lang.Object methods...\npublic char java.lang.String.charAt(int)\npublic int java.lang.String.compareTo(java.lang.Object)\npublic int java.lang.String.compareTo(java.lang.String)\nY ou can see that this could be extended (almost literally) to write a BeanMethods  class\nthat would list only the set/get methods defined in a JavaBean (see Recipe 15.4 ).\nAlternatively, you can find a particular method and invoke it, or find a particular field\nand refer to its value. Let’s start by finding a given field, because that’s the easiest.\nExample 17-2  is code that, given an Object  and the name of a field, finds the field\n(gets a Field  object) and then retrieves and prints the value of that Field  as an int.\nExample 17-2. main/src/main/java/reflection/FindField.java\npublic class FindField  {\n    public static void main(String[] unused)\n    throws NoSuchFieldException , IllegalAccessException  {\n        // Create instance of FindField\n        FindField  gf = new FindField ();\n522 | Chapter 17: Reflection,  or “A Class Named Class”\n        // Create instance of target class (YearHolder defined below).\n        Object o = new YearHolder ();\n        // Use gf to extract a field from o.\n        System.out.println(""The value of 'currentYear' is: ""  +\n            gf.intFieldValue (o, ""currentYear"" ));\n    }\n    int intFieldValue (Object o, String name)\n    throws NoSuchFieldException , IllegalAccessException  {\n        Class<?> c = o.getClass ();\n        Field fld = c.getField (name);\n        int value = fld.getInt(o);\n        return value;\n    }\n}\n/** This is just a class that we want to get a field from */\nclass YearHolder  {\n    /** Just a field that is used to show getting a field's value. */\n    public int currentYear  = Calendar .getInstance ().get(Calendar .YEAR);\n}\nWhat if we need to find a method? The simplest way is to use the methods\ngetMethod()  and invoke() . But this is not altogether trivial. Suppose that somebody\ngives us a reference to an object. We don’t know its class but have been told that it\nshould have this method:\npublic void work(String s) { }\nWe wish to invoke work() . To find the method, we must make an array of Class\nobjects, one per item in the parameter list. So, in this case, we make an array contain‐\ning only a reference to the class object for String . Because we know the name of the\nclass at compile time, we’ll use the shorter invocation String.class  instead of\nClass.forName() . This, plus the name of the method as a string, gets us entry into\nthe getMethod()  method of the Class  object. If this succeeds, we have a Method\nobject. But guess what? In order to invoke the method, we have to construct yet\nanother array, this time an array of Object  references actually containing the data to\nbe passed to the invocation. We also, of course, need an instance of the class in whose\ncontext the method is to be run. For this demonstration class, we need to pass only a\nsingle string, because our array consists only of the string. Example 17-3  is the code\nthat finds the method and invokes it.\nExample 17-3. main/src/main/java/reflection/GetAndInvokeMethod.java\n/**\n * Get a given method, and invoke it.\n * @author Ian F. Darwin, http://www.darwinsys.com/\n17.2 Finding and Using Methods and Fields | 523\n */\npublic class GetAndInvokeMethod  {\n    /** This class is just here to give us something to work on,\n     * with a println() call that will prove we got into it.\n     */\n    static class X {\n        public void work(int i, String s) {\n            System.out.printf(""Called: i=%d, s=%s%n"" , i, s);\n        }\n        // The main code does not use this overload.\n        public void work(int i) {\n            System.out.println(""Unexpected call!"" );\n        }\n    }\n    public static void main(String[] argv) {\n        try {\n            Class<?> clX = X.class; // or Class.forName(""X"");\n            // To find a method we need the array of matching Class types.\n            Class<?>[] argTypes  = {\n                int.class,\n                String.class\n            };\n            // Now find a Method object for the given method.\n            Method worker = clX.getMethod (""work"", argTypes );\n            // To INVOKE the method, we need the invocation\n            // arguments, as an Object array.\n            Object[] theData = {\n                42,\n                ""Chocolate Chips""\n            };\n            // The obvious last step: invoke the method.\n            // First arg is an instance, null if static method\n            worker.invoke(new X(), theData);\n        } catch (Exception  e) {\n            System.err.println(""Invoke() failed: ""  + e);\n        }\n    }\n}\nNot tiny, but it’s still not bad. In most programming languages, you couldn’t do that\nin the 40 lines it took us here.\nA word of caution: when the arguments to a method are of a primitive type, such as\nint, you do not pass Integer.class  into getMethod() . Instead, you must use the\nclass object representing the primitive type int. The easiest way to find this class is in\n524 | Chapter 17: Reflection,  or “A Class Named Class”",8308
677-17.3 Accessing Private Methods and Fields via Reflection.pdf,677-17.3 Accessing Private Methods and Fields via Reflection,,0
678-Problem.pdf,678-Problem,,0
679-Solution.pdf,679-Solution,,0
680-17.4 Loading and Instantiating a Class Dynamically.pdf,680-17.4 Loading and Instantiating a Class Dynamically,"the Integer  class, as a public constant named TYPE , so you’ d pass Integer.TYPE . The\nsame is true for all the primitive types; for each, the corresponding wrapper class  has\nthe primitive class  referred to as TYPE .\nJava also includes a mechanism called a MethodHandle  that was intended both to sim‐\nplify and to generalize use of Reflection to invoke methods; we do not cover it here\nbecause in practice it has not shown to be a significant improvement over using the\nReflection API.\n17.3 Accessing Private Methods and Fields via Reflection\nProblem\nY ou want to access private fields and have heard you can do so using the Reflection\nAPI.\nSolution\nIt’s generally a bad idea to access private fields. But if you have to, and the Security\nManager  allows you to use Reflection, you can.\nDiscussion\nThere is occasionally a need to access private fields in other classes. For example, I\ndid so recently in writing a JUnit test case that needed to see all the fields of a target\nclass. The secret is to call the Field  or Method  descriptor’s setAccessible()  method\npassing the value true  before trying to get the value or invoke the method. It really is\nthat easy, as shown in Example 17-4 .\nExample 17-4. main/src/main/java/reflection/DefeatPrivacy.java\nclass X {\n    @SuppressWarnings (""unused"" ) // Used surreptitiously below.\n    private int p = 42;\n    int q = 3;\n}\n/**\n * Demonstrate that it is, in fact, all too easy to access private members\n * of an object using Reflection, using the default SecurityManager\n */\npublic class DefeatPrivacy  {\n    public static void main(String[] args) throws Exception  {\n        new DefeatPrivacy ().process();\n    }\n17.3 Accessing Private Methods and Fields via Reflection  | 525",1762
681-Problem.pdf,681-Problem,,0
682-Solution.pdf,682-Solution,,0
683-Discussion.pdf,683-Discussion,"private void process() throws Exception  {\n        X x = new X();\n        System.out.println(x);\n        // System.out.println(x.p); // Won't compile\n        System.out.println(x.q);\n        Class<? extends X> class1 = x.getClass ();\n        Field[] flds = class1.getDeclaredFields ();\n        for (Field f : flds) {\n            f.setAccessible (true);    // bye-bye ""private""\n            System.out.println(f + ""=="" + f.get(x));\n            f.setAccessible (false);    // reset to ""correct"" state\n        }\n    }\n}\nUse this with extreme care , because it can defeat some of the most\ncherished principles of Java programming.\n17.4 Loading and Instantiating a Class Dynamically\nProblem\nY ou want to load classes dynamically, just like web servers load your servlets.\nSolution\nUse class.forName(""ClassName"");  and the class’s newInstance( )  method.\nDiscussion\nSuppose you are writing a Java application and want other developers to be able to\nextend your application by writing Java classes that run in the context of your appli‐\ncation. In other words, these developers are, in essence, using Java as an extension\nlanguage, in the same way that applets are an extension of a web browser. Y ou would\nprobably want to define a small set of methods that these extension programs would\nhave and that you could call for such purposes as initialization, operation, and termi‐\nnation. The best way to do this is, of course, to publish a given, possibly abstract, class\nthat provides those methods and get the developers to subclass from it. Sound famil‐\niar? It should. This is just how web browsers such as Netscape allow the deployment\nof applets.\nWe’ll leave the thornier issues of security and of loading a class file over a network\nsocket for now and assume that the user can install the classes into the application\n526 | Chapter 17: Reflection,  or “A Class Named Class”\ndirectory or into a directory that appears in the CLASSPATH  at the time the program is\nrun. First, let’s define our class. We’ll call it Cooklet  (see Example 17-5 ) to avoid\ninfringing on the overused word applet . Pretend each subclass will represent the code\nto drive some elaborate kind of food-preparing-and-cooking appliance through the\nsteps of one traditional recipe. And we’ll initially take the easiest path from ingredi‐\nents to cookies before we complicate it.\nExample 17-5. Cooklet.java\n/** A simple class, just to provide the list of methods that\n * users need to provide to be usable in our application.\n * Note that the class is abstract so you must subclass it,\n * but the methods are non-abstract so you don't have to provide\n * dummy versions if you don't need a particular functionality.\n */\npublic abstract  class Cooklet {\n    /** The initialization method. The Cookie application will\n     * call you here (AFTER calling your no-argument constructor)\n     * to allow you to initialize your code\n     */\n    public void initialize ( ) {\n    }\n    /** The work method. The cookie application will call you\n     * here when it is time for you to start cooking.\n     */\n    public void work( ) {\n    }\n    /** The termination method. The cookie application will call you\n     * here when it is time for you to stop cooking and shut down\n     * in an orderly fashion.\n     */\n    public void terminate ( ) {\n    }\n}\nNow, because we’ll be baking, er, making this available to other people, we’ll probably\nwant to cook up a demonstration version too; see Example 17-6 .\nExample 17-6. main/src/main/java/reflection/DemoCooklet.java\npublic class DemoCooklet  extends Cooklet {\n    public void work() {\n        System.out.println(""I am busy baking cookies."" );\n    }\n    public void terminate () {\n        System.out.println(""I am shutting down my ovens now."" );\n17.4 Loading and Instantiating a Class Dynamically | 527\n    }\n}\nBut how does our application use it? Once we have the name of the user’s class, we\nneed to create a Class  object for that class. This can be done easily using the static\nmethod Class.forName() . Then we can create an instance of it using the Class\nobject’s newInstance()  method; this calls the class’s no-argument constructor. Then\nwe simply cast the newly constructed object to our Cooklet  class, and we can call its\nmethods! It actually takes longer to describe this code than to look at the code, so let’s\ndo that now; see Example 17-7 .\nExample 17-7. main/src/main/java/reflection/Cookies.java\npublic class Cookies {\n    public static void main(String[] argv) {\n        System.out.println(""Cookies Application Version 0.0"" );\n        Cooklet cooklet = null;\n        String cookletClassName  = argv[0];\n        try {\n            Class<Cooklet> cookletClass  =\n                (Class<Cooklet>) Class.forName(cookletClassName );\n            cooklet = cookletClass .newInstance ();\n        } catch (Exception  e) {\n            System.err.println(""Error ""  + cookletClassName  + e);\n        }\n        cooklet.initialize ();\n        cooklet.work();\n        cooklet.terminate ();\n    }\n}\nAnd if we run it?\n$ java Cookies DemoCooklet\nCookies Application  Version 0.0\nI am busy baking cookies.\nI am shutting  down my ovens now.\n$\nOf course, this version has rather limited error handling. But you already know how\nto fix that. Y our ClassLoader  can also place classes into a package by constructing a\nPackage  object; you should do this if loading any medium-sized set of application\nclasses.\n528 | Chapter 17: Reflection,  or “A Class Named Class”",5574
684-17.5 Constructing a Class from Scratch with a ClassLoader.pdf,684-17.5 Constructing a Class from Scratch with a ClassLoader,,0
685-Problem.pdf,685-Problem,,0
686-Solution.pdf,686-Solution,,0
687-17.6 Constructing a Class from Scratch with JavaCompiler.pdf,687-17.6 Constructing a Class from Scratch with JavaCompiler,"17.5 Constructing a Class from Scratch with a ClassLoader\nProblem\nY ou need to load a class from a nonstandard location and run its methods.\nSolution\nExamine the existing loaders such as java.net.URLClassLoader . If none is suitable,\nwrite and use your own ClassLoader .\nDiscussion\nA ClassLoader , of course, is a program that loads classes. One ClassLoader  is built\ninto the Java Virtual Machine, but your application can create others as needed.\nLearning to write and run a working ClassLoader  and using it to load a class and run\nits methods is a nontrivial exercise. In fact, you rarely need to write a ClassLoader ,\nbut knowing how is helpful in understanding how the JVM finds classes, creates\nobjects, and calls methods.\nClassLoader  itself is abstract; you must subclass it, presumably providing a load\nClass()  method that loads classes as you wish. It can load the bytes from a network\nconnection, a local disk, RAM, a serial port, or anywhere else. Or you can construct\nthe class file in memory yourself, if you have access to a compiler.\nThere is a general-purpose loader called java.net.URLClassLoader  that can be used\nif all you need is to load classes via the web protocol (or, more generally, from one or\nmore URLs).\nY ou must call the ClassLoader  loadClass()  method for any classes you wish to\nexplicitly load from it. Note that this method is called to load all classes required for\nclasses you load (superclasses that aren’t already loaded, for example). However, the\nJVM still loads classes that you instantiate with the new operator normally via\nclasspath.\nWhen writing a ClassLoader , your loadClass()  method needs to get the class file\ninto a byte array (typically by reading it), convert the array into a Class  object, and\nreturn the result.\nWhat? That sounds a bit like “ And Then a Miracle Occurs… ” And it is. The miracle of\nclass creation, however, happens down inside the JVM, where you don’t have access\nto it. Instead, your ClassLoader  has to call the protected defineClass()  method in\nyour superclass (which is java.lang.ClassLoader ). This is illustrated in Figure 17-1 ,\nwhere a stream of bytes containing a hypothetical Chicken  class is converted into a\nready-to-run Chicken  class in the JVM by calling the defineClass()  method.\n17.5 Constructing a Class from Scratch with a ClassLoader | 529",2373
688-Problem.pdf,688-Problem,,0
689-Solution.pdf,689-Solution,,0
690-Discussion.pdf,690-Discussion,"Figure 17-1. ClassLoader in action\nWhat next?\nTo use your ClassLoader  subclass, you need to instantiate it and call its loadClass()\nmethod with the name of the class you want to load. This gives you a Class  object for\nthe named class; the Class  object in turn lets you construct instances, find and call\nmethods, etc. Refer back to Recipe 17.2 .\n17.6 Constructing a Class from Scratch with JavaCompiler\nProblem\nY ou’ d rather construct a class dynamically by generating source code and compiling\nit.\nSolution\nUse the JavaCompiler  from javax.tools .\nDiscussion\nThere are many cases where you might need to generate code on the fly. If you’re\nwriting a framework, you might want to introspect on a model class to find its fields,\nand generate accessors for them on the fly. As we’ve seen in Recipe 17.2 , you can do\nthis with the Field  class. However, for a high-volume operation it may well be more\nefficient to generate direct access code.\nThe Java Compiler API has been around since Java 1.6 and is fairly easy to use for\nsimple cases. Here are the basic steps:\n•Get the JavaCompiler  object for your current Java Runtime. If it’s not available,\neither give up altogether, or fall back to using reflection.\n530 | Chapter 17: Reflection,  or “A Class Named Class”\n•Get a CompilerTask  (which is also a Callable ) to run the compilation, passing\ninput and outputs.\n•Invoke the Callable , either directly or by using an ExecutorService .\n•Check the results. If true, invoke the class.\nThis is demonstrated in Example 17-8 .\nExample 17-8. main/src/main/java/reflection/JavaCompilerDemo.java\npackage reflection ;\nimport java.lang.reflect.Method ;\nimport java.net.URI ;\nimport java.util.List ;\nimport java.util.concurrent.Callable ;\n// tag::main[]\nimport javax.tools.JavaCompiler ;\nimport javax.tools.SimpleJavaFileObject ;\nimport javax.tools.ToolProvider ;\n/** Demo the Java Compiler API: Create a class, compile, load, and run it.\n * N.B. Will not run under Eclipse due to classpath settings;\n * best run it standalone using ""java JavaCompiler.java""\n * @author Ian Darwin\n */\npublic class JavaCompilerDemo  {\n    private final static String PACKAGE = ""reflection"" ;\n    private final static String CLASS = ""AnotherDemo"" ;\n    private static boolean verbose;\n    public static void main(String[] args) throws Exception  {\n        String source = ""package ""  + PACKAGE + "";\n"" +                  \n            ""public class ""  + CLASS + "" {\n"" +\n            ""\tpublic static void main(String[] args) {\n""  +\n            ""\t\tString message = (args.length > 0 ? args[0] : \""Hi\"")""  + "";\n"" +\n            ""\t\tSystem.out.println(message + \"" from AnotherDemo\"");\n""  +\n            ""\t}\n}\n"" ;\n        if (verbose)\n            System.out.print(""Source to be compiled:\n""  + source);\n        JavaCompiler  compiler  = ToolProvider .getSystemJavaCompiler ();   \n        if (compiler  == null) {\n            throw new IllegalStateException (""No default compiler, giving up."" );\n        }\n        Callable <Boolean> compilation  =\n            compiler .getTask(null, null, null, List.of(""-d"","".""), null, \n            List.of(new MySource (CLASS, source)));\n        boolean result = compilation .call();                            \n        if (result) {\n            System.out.println(""Compiled OK"" );\n17.6 Constructing a Class from Scratch with JavaCompiler | 531\n            Class<?> c = Class.forName(PACKAGE + ""."" + CLASS);          \n            System.out.println(""Class = ""  + c);\n            Method m = c.getMethod (""main"", args.getClass ());            \n            System.out.println(""Method descriptor = ""  + m);\n            Object[] passedArgs  = { args };\n            m.invoke(null, passedArgs );                                 \n        } else {\n            System.out.println(""Compilation failed"" );\n        }\n    }\n}\n// end::main[]\nclass MySource  extends SimpleJavaFileObject  {\n    final String source;\n    MySource (String fileName , String source) {\n        super(URI.create(""string:///""  + fileName .replace('.', '/') +\n                Kind.SOURCE.extension ), Kind.SOURCE);\n        this.source = source;\n    }\n    @Override\n    public CharSequence  getCharContent (boolean ignoreEncodingErrors ) {\n        return source;\n    }\n}\nThe source code that we want to compile. In real life it would probably be\ndynamically generated, maybe using a StringBuffer .\nGet a reference to the default JavaCompiler  object.\nAsk the compiler to create a CompilerTask  to do the compilation. CompilerTask\nis also Callable  and we save it under that type. The -d and . are standard javac\narguments. MySource  extends the compiler-provided API class SimpleJavaFi\nleObject  to give access to a file by creating a file://  URL.\nA Callable  can be put into a thread pool ( ExecutorService ) (see Recipe 16.1 );\nwe don’t need this capability but the Compiler API returns it. We invoke the Call\nable  directly.\nAssuming the result  was true  indicating success, we load the class with\nClass.forName() .\nWe have to find the main()  method in the generated class. We reuse the\nString[].class  type from args, since all main  methods have the same argument.\n532 | Chapter 17: Reflection,  or “A Class Named Class”",5304
691-17.7 Performance Timing.pdf,691-17.7 Performance Timing,,0
692-Problem.pdf,692-Problem,,0
693-Solution.pdf,693-Solution,,0
694-Discussion.pdf,694-Discussion,"Finally, we can invoke the main  method, reusing the incoming args  array to pass\nany welcome  message along.\nRunning this program with and without an argument shows that the argument\npassed to the JavaCompilerDemo  is being passed correctly to the generated Another\nDemo  class:\n$ java src/main/java/reflection /JavaCompilerDemo .java\nCompiled  OK\nClass = class reflection .AnotherDemo\nMethod descriptor  = public static void\n  reflection .AnotherDemo .main(java.lang.String[])\nHi from AnotherDemo\n$ java src/main/java/reflection /JavaCompilerDemo .java Welcome\nCompiled  OK\nClass = class reflection .AnotherDemo\nMethod descriptor  = public static void\n  reflection .AnotherDemo .main(java.lang.String[])\nWelcome from AnotherDemo\n$\nThere is a lot to explore in the Compiler API, including the JavaFileManager  that\nlets you control the placement of class files (other than by using -d as we did here),\nlisteners to monitor compilation, and control of output and error streams. Consult\nthe javax.tools.JavaCompiler  documentation  for details.\n17.7 Performance Timing\nProblem\nSlow performance?\nSolution\nUse a profiler , or time individual methods using System.currentTimeMillis()\nbefore and after invoking the target method; the difference is the time that method\ntook.\nDiscussion\nProfilers\nProfiling tools—profilers—have a long history as one of the important tools in a pro‐\ngrammer’s toolkit. A commercial profiling tool will help find bottlenecks in your pro‐\ngram by showing both the number of times each method was called and the amount\nof time in each.\n17.7 Performance Timing | 533\nQuite a bit of useful information can be obtained from a Java application by use of the\nVisualVM  tool, which was part of the Oracle JDK up until Java 8. With Java 9 this tool\nwas open-sourced, and it’s now available from the VisualVM project .\nAnother tool that is part of the JDK is Java Flight Recorder , which is now open-\nsourced and built into the JDK. Its data is meant to be analyzed by  Java Mission Con‐\ntrol. There are also third-party profilers that will give more detailed information; a\nweb search will find current commercial offerings.\nMeasuring a single method\nThe simplest technique is to save the JVM’s accumulated time before and after\ndynamically loading a main program and then calculate the difference between those\ntimes. Code to do just this is presented in Example 17-11 ; for now, just remember\nthat we have a way of timing a given Java class.\nOne way of measuring the efficiency of a particular operation is to run it many times\nin isolation. The overall time the program takes to run thus approximates the total\ntime of many invocations of the same operation. Gross numbers like this can be com‐\npared if you want to know which of two ways of doing something is more efficient.\nConsider the case of string concatenation versus println() . The code\nprintln(""Time is "" + n.toString( ) + "" seconds"");\nwill probably work by creating a StringBuilder ; appending the string ""Time is"" , the\nvalue of n as a string, and ""seconds"" ; and finally converting the finished\nStringBuilder  to a String  and passing that to println() . Suppose you have a pro‐\ngram that does a lot of this, such as a Java servlet that creates a lot of HTML this way,\nand you expect (or at least hope) your website to be sufficiently busy so that doing\nthis efficiently will make a difference. There are two ways of thinking about this:\n•Theory A: this string concatenation is inefficient.\n•Theory B: string concatenation doesn’t matter; println()  is inefficient, too.\nA proponent of Theory A might say that because println()  just puts stuff into a\nbuffer, it is very fast and that string concatenation is the expensive part.\nHow to decide between Theory A and Theory B? Assume you are willing to write a\nsimple test program that tests both theories. Let’s just write a simple program both\nways and time it. Example 17-9  is the timing program for Theory A.\nExample 17-9. main/src/main/java/performance/StringPrintA.java\npublic class StringPrintA  {\n    public static void main(String[] argv) {\n        Object o = ""Hello World"" ;\n534 | Chapter 17: Reflection,  or “A Class Named Class”\n        for (int i=0; i<100000; i++) {\n            System.out.println(""<p><b>""  + o.toString () + ""</b></p>"" );\n        }\n    }\n}\nStringPrintAA  (in the javasrc  repo but not printed here) is the same but explicitly\nuses a StringBuilder  for the string concatenation. Example 17-10  is the tester for\nTheory B.\nExample 17-10. main/src/main/java/performance/StringPrintB.java\npublic class StringPrintB  {\n    public static void main(String[] argv) {\n        Object o = ""Hello World"" ;\n        for (int i=0; i<100000; i++) {\n            System.out.print(""<p><b>"" );\n            System.out.print(o.toString ());\n            System.out.print(""</b></p>"" );\n            System.out.println();\n        }\n    }\n}\nTiming results\nI ran StringPrintA , StringPrintAA , and StringPrintB  twice each on the same com‐\nputer. To eliminate JVM startup times, I ran them from a program called TimeNoArgs ,\nwhich takes a class name and invokes its main()  method, using the Reflection API.\nTimeNoArgs  and a shell script to run it, stringprinttimer.sh , are in the performance\nfolder of the javasrc  source repository. Here are the results:\n2004 program Seconds\nStringPrintA 17.23, 17.20 seconds\nStringPrintAA 17.23, 17.23 seconds\nStringPrintB 27.59, 27.60 seconds\n2014 program Seconds\nStringPrintA 0.714, 0.525 seconds\nStringPrintAA 0.616, 0.561 seconds\nStringPrintB 1.091, 1.039 seconds\nAlthough the times went down by a factor of roughly 20 over a decade due to both\nJVM improvements and faster hardware, the ratios remain remarkably consistent:\n17.7 Performance Timing | 535\nStringPrintB , which calls print()  and println()  multiple times, takes roughly\ntwice as long.\nMoral: don’t guess. If it matters, time it.\nAnother moral: multiple calls to System.out.print()  cost more than the same num‐\nber of calls to a StringBuilder ’s append()  method, by a factor of roughly 1.5 (or\n150%). Theory B wins; the extra println  calls appear to save a string concatenation\nbut make the program take substantially longer.\nOther aspects of performance: GC\nThere are many other aspects of software performance. One that is fundamental\nto Java is garbage collection behavior. Sun/Oracle usually discusses this at JavaOne.\nFor example, see the 2003 JavaOne presentation  “Garbage Collection in the Java Hot‐\nSpot Virtual Machine” . See also the 2007 JavaOne talk by the same GC development\nteam,  “Garbage Collection-Friendly Programming, ” TS-2906 . JavaOne 2010 featured\nan updated presentation entitled “The Garbage Collection MythBusters” .\nA timing program\nIt’s pretty easy to build a simplified time  command in Java, given that you have\nSystem.currentTimeMillis()  to start with. Run my Time  program, and, on the com‐\nmand line, specify the name of the class to be timed, followed by the arguments (if\nany) that class needs for running. The program is shown in Example 17-11 . The time\nthat the class took is displayed. But remember that System.currentTimeMillis()\nreturns clock time, not necessarily CPU time. So you must run it on a machine that\nisn’t running a lot of background processes. And note also that I use dynamic loading\n(see Recipe 17.4 ) to let you put the Java class name on the command line.\nExample 17-11. main/src/main/java/performance/Time.java\npublic class Time {\n    public static void main(String[] argv) throws Exception  {\n        // Instantiate target class, from argv[0]\n        Class<?> c = Class.forName(argv[0]);\n        // Find its static main method (use our own argv as the signature).\n        Class<?>[] classes = { argv.getClass () };\n        Method main = c.getMethod (""main"", classes);\n        // Make new argv array, dropping class name from front.\n        // Normally Java doesn't get the class name, but in\n        // this case the user puts the name of the class to time\n        // as well as all its arguments...\n        String nargv[] = new String[argv.length - 1];\n        System.arraycopy (argv, 1, nargv, 0, nargv.length);\n536 | Chapter 17: Reflection,  or “A Class Named Class”",8323
695-See Also.pdf,695-See Also,,0
696-17.8 Printing Class Information.pdf,696-17.8 Printing Class Information,,0
697-Problem.pdf,697-Problem,,0
698-17.9 Listing Classes in a Package.pdf,698-17.9 Listing Classes in a Package,"Object[] nargs = { nargv };\n        System.err.println(""Starting class ""  + c);\n        // About to start timing run. Important to not do anything\n        // (even a println) that would be attributed to the program\n        // being timed, from here until we've gotten ending time.\n        // Get current (i.e., starting) time\n        long t0 = System.currentTimeMillis ();\n        // Run the main program\n        main.invoke(null, nargs);\n        // Get ending time, and compute usage\n        long t1 = System.currentTimeMillis ();\n        long runTime = t1 - t0;\n        System.err.println(\n             ""runTime=""   + Double.toString (runTime/1000D));\n    }\n}\nOf course, you can’t directly compare the results from the operating system time\ncommand with results from running this program. There is a rather large, but fairly\nconstant, initialization overhead—the JVM startup and the initialization of Object\nand System.out , for example—that is included in the former and excluded from the\nlatter. One could even argue that my Time  program is more accurate because it\nexcludes this constant overhead. But, as noted, it must be run on a single-user\nmachine to yield repeatable results. And no fair running an editor in another window\nwhile waiting for your timed program to complete!\nSee Also\nJava Performance  by Scott Oaks (O’Reilly) provides information on tuning Java\nperformance.\n17.8 Printing Class Information\nProblem\nY ou want to print all the information about a class, similar to the way javap  does.\nSolution\nGet a Class  object, call its getFields()  and getMethods() , and print the results.\n17.8 Printing Class Information | 537\nDiscussion\nThe JDK includes a program called javap , the Java Printer. Sun’s JDK version nor‐\nmally prints the outline of a class file—a list of its methods and fields—but can also\nprint out the Java bytecodes or machine instructions. The Kaffe package did not\ninclude a version of javap , so I wrote one and contributed it (see Example 17-12 ). The\nKaffe folks have expanded it somewhat, but it still works basically the same. My ver‐\nsion doesn’t print the bytecodes; it behaves rather like Sun’s behaves when you don’t\ngive its version any command-line options.\nThe getFields()  and getMethods()  methods return arrays of Field  and Method ,\nrespectively; these are both in package java.lang.reflect . I use a Modifiers  object\nto get details on the permissions and storage attributes of the fields and methods. In\nmany Java implementations, you can bypass this and simply call toString()  in each\nField  and Method  object (as I do here for Constructors ). Doing it this way gives me\na bit more control over the formatting.\nExample 17-12. main/src/main/java/reflection/MyJavaP.java\npublic class MyJavaP {\n    /** Simple main program, construct self, process each class name\n     * found in argv.\n     */\n    public static void main(String[] argv) {\n        MyJavaP pp = new MyJavaP();\n        if (argv.length == 0) {\n            System.err.println(""Usage: MyJavaP className [...]"" );\n            System.exit(1);\n        } else for (int i=0; i<argv.length; i++)\n            pp.doClass(argv[i]);\n    }\n    /** Format the fields and methods of one class, given its name.\n     */\n    protected  void doClass(String className ) {\n        try {\n            Class<? extends Object> c = Class.forName(className );\n            final Annotation [] annotations  = c.getAnnotations ();\n            for (Annotation  a : annotations ) {\n                System.out.println(a);\n            }\n            System.out.println(c + "" {"");\n            Field fields[] = c.getDeclaredFields ();\n            for (Field f : fields) {\n538 | Chapter 17: Reflection,  or “A Class Named Class”",3784
699-Problem.pdf,699-Problem,,0
700-Solution.pdf,700-Solution,,0
701-Discussion.pdf,701-Discussion,"final Annotation [] fldAnnotations  = f.getAnnotations ();\n                for (Annotation  a : fldAnnotations ) {\n                    System.out.println(a);\n                }\n                if (!Modifier .isPrivate (f.getModifiers ()))\n                    System.out.println(""\t"" + f + "";"");\n            }\n            Constructor <? extends Object>[] constructors  = c.getConstructors ();\n            for (Constructor <? extends Object> con : constructors ) {\n                System.out.println(""\t"" + con + "";"");\n            }\n            Method methods[] = c.getDeclaredMethods ();\n            for (Method m : methods) {\n                final Annotation [] methodAnnotations  = m.getAnnotations ();\n                for (Annotation  a : methodAnnotations ) {\n                    System.out.println(a);\n                }\n                if (!Modifier .isPrivate (m.getModifiers ())) {\n                    System.out.println(""\t"" + m + "";"");\n                }\n            }\n            System.out.println(""}"");\n        } catch (ClassNotFoundException  e) {\n            System.err.println(""Error: Class ""  +\n                className  + "" not found!"" );\n        } catch (Exception  e) {\n            System.err.println(""JavaP Error: ""  + e);\n        }\n    }\n}\n17.9 Listing Classes in a Package\nProblem\nY ou want to get a list of all the classes in a package.\nSolution\nY ou can’t, in the general case. There are some limited approaches, most involving\nCLASSPATH  scanning.\nDiscussion\nThere is no way to find out all the classes in a package, in part because, as we just saw\nin Recipe 17.5 , you can add classes to a package at any time! And, for better or for\n17.9 Listing Classes in a Package | 539\nworse, the JVM and standard classes such as java.lang.Package  do not even allow\nyou to enumerate the classes currently in a given package.\nThe nearest you can come is to look through the CLASSPATH . And this will surely\nwork only for local directories and JAR files; if you have locally defined or network-\nloaded classes, this is not going to help. In other words, it will find compiled classes,\nbut not dynamically loaded ones. There are several libraries that can automate this for\nyou, and you’re welcome to use them. The code to scan the CLASSPATH  is fairly simple\nat heart, though, so classy developers with heart will want to examine it.\nExample 17-13  shows my ClassesInPackage  class with its one static method. The\ncode works but is rather short on error handling, and it will crash on nonexistent\npackages and other failures.\nThe code goes through a few gyrations to get the CLASSPATH  as an enumeration of\nURLs, then looks at each element.\nfile\nURLs will contain the pathname of the file containing the .class  file, so we can\njust list it.\njar\nURLs contain the filename as “file:/path_to_jar_file!package/name, ” so we have\nto pull this apart; the “package name” suffix is slightly redundant in this case\nbecause it’s the package we asked the ClassLoader  to give us.\nExample 17-13. main/src/main/java/reflection/ClassesInPackage.java\npublic class ClassesInPackage  {\n    /** This approach began as a contribution by Paul Kuit at\n     * http://stackoverflow.com/questions/1456930/, but his only\n     * handled single files in a directory in classpath, not in Jar files.\n     * N.B. Does NOT handle system classes!\n     * @param packageName\n     * @return\n     * @throws IOException\n     */\n    public static String[] getPackageContent (String packageName )\n        throws IOException  {\n        final String packageAsDirName  = packageName .replace(""."", ""/"");\n        final List<String> list = new ArrayList <>();\n        final Enumeration <URL> urls =\n                Thread.currentThread ().\n                getContextClassLoader ().\n                getResources (packageAsDirName );\n        while (urls.hasMoreElements ()) {\n            URL url = urls.nextElement ();\n540 | Chapter 17: Reflection,  or “A Class Named Class”\n            // System.out.println(""URL = "" + url);\n            String file = url.getFile();\n            switch (url.getProtocol ()) {\n            case ""file"":\n                // This is the easy case: ""file"" is\n                // the full path to the classpath directory\n                File dir = new File(file);\n                for (File f : dir.listFiles ()) {\n                    list.add(packageAsDirName  + ""/"" + f.getName());\n                }\n                break;\n            case ""jar"":\n                // This is the harder case; ""file"" is of the form\n                // ""jar:/home/ian/bleah/darwinsys.jar!com/darwinsys/io""\n                // for some jar file that contains at least one class from\n                // the given package.\n                int colon = file.indexOf(':');\n                int bang = file.indexOf('!');\n                String jarFileName  = file.substring (colon + 1, bang);\n                JarFile jarFile = new JarFile(jarFileName );\n                Enumeration <JarEntry > entries = jarFile.entries();\n                while (entries.hasMoreElements ()) {\n                    JarEntry  e = entries.nextElement ();\n                    String jarEntryName  = e.getName();\n                    if (!jarEntryName .endsWith (""/"") &&\n                        jarEntryName .startsWith (packageAsDirName )) {\n                        list.add(jarEntryName );\n                    }\n                }\n                break;\n            default:\n                throw new IllegalStateException (\n                ""Dunno what to do with URL ""  + url);\n            }\n        }\n        return list.toArray(new String[] {});\n    }\n    public static void main(String[] args) throws IOException  {\n        String[] names = getPackageContent (""com.darwinsys.io"" );\n        for (String name : names) {\n            System.out.println(name);\n        }\n        System.out.println(""Done"");\n    }\n}\nNote that if you run this application in the javasrc  project, it will list the members of\nthe demonstration package ( com.darwinsys.io ) twice, because it will find them both\nin the build directory and in the JAR file. If this is an issue, change the List  to a Set\n(see Recipe 7.3 ).\n17.9 Listing Classes in a Package | 541",6307
702-17.10 Using and Defining Annotations.pdf,702-17.10 Using and Defining Annotations,,0
703-Problem.pdf,703-Problem,,0
704-Solution.pdf,704-Solution,,0
705-Discussion.pdf,705-Discussion,"17.10 Using and Defining  Annotations\nProblem\nY ou need to know how to use annotations in code or to define your own annotations.\nSolution\nApply annotations in your code using @AnnotationName  before a class, method, field,\netc. Define annotations with @interface  at the same level as class , interface , etc.\nDiscussion\nAnnotations are a way of adding additional information beyond what the source code\nconveys. Annotations may be directed at the compiler or at runtime examination.\nTheir syntax was somewhat patterned after javadoc annotations (such as @author ,\n@version  inside doc comments). Annotations are what I call class-like things  (so they\nhave initial-cap names) but are prefixed by @ sign where used (e.g., @Override ). Y ou\ncan place them on classes, methods, fields, and a few other places; they must appear\nimmediately before what they annotate (ignoring space and comments). A given\nannotation may only appear once in a given position (this is relaxed in Java 8 or 9).\nAs an example of the benefits of a compile-time annotation, consider the common\nerror made when overriding: as shown in Example 17-14 , a small error in the method\nsignature can result it an overload when an override was intended.\nExample 17-14. MyClass.java (an example of why we need annotations)\npublic class MyClass {\n    public boolean equals(MyClass object2) {\n        // compare, return boolean\n    }\n}\nThe code will compile just fine on any release of Java, but it is incorrect. The standard\ncontract of the equals()  method (see Recipe 8.1 ) requires a method whose solitary\nargument is of type java.lang.Object . The preceding version creates an accidental\noverload. Because the main use of equals()  (and its buddy method hashCode() ; see\nRecipe 8.1 ) is in the Collections classes (see Chapter 7 ), this overloaded method will\nnever get called, resulting both in dead code and in incorrect operation of your class\nwithin Sets and Maps.\nThe solution is very simple: using the annotation java.lang.Override , as in\nExample 17-15 , informs the compiler that the annotated method is required to over‐\n542 | Chapter 17: Reflection,  or “A Class Named Class”\nride a method inherited from a supertype (such as a superclass or an interface). If not,\nthe code will not compile.\nExample 17-15. MyClass.java with @Override annotation\npublic class MyClass {\n    @Override\n    public boolean equals(MyClass object2) {\n        // compare, return boolean\n    }\n}\nThis version of equals() , while still incorrect, will be flagged as erroneous at compile\ntime, potentially avoiding a lot of debugging time. This annotation, on your own\nclasses, will help both at the time you write new code and as you maintain your code‐\nbase; if a method is removed from a superclass, all the subclasses that still attempt to\noverride it and have the @Override  annotation will cause an error message, allowing\nyou to remove a bunch of dead code.\nThe second major use of annotations is to provide metadata at runtime. For example,\nthe Java Persistence API (JPA, see https://darwinsys.com/db_in_java ) uses its own set\nof annotations from the package javax.persistence  to mark up entity classes to be\nloaded and/or persisted. A JPA entity class might look like Example 17-16 .\nExample 17-16. main/src/main/java/domain/Person.java (JPA annotations)\n@Entity\npublic class Person {\n    int id;\n    protected  String firstName ;\n    protected  String lastName ;\n    public Person() {\n        // required by JPA; must code it since we need 2-arg form.\n    }\n    public Person(String firstName , String lastName ) {\n        this.firstName  = firstName ;\n        this.lastName  = lastName ;\n    }\n    @Id @GeneratedValue (strategy =GenerationType .AUTO, generator =""my_poid_gen"" )\n    public int getId() {\n        return id;\n    }\n    public void setId(int id) {\n17.10 Using and Defining  Annotations | 543\n        this.id = id;\n    }\n    public String getFirstName () {\n        return firstName ;\n    }\n    public void setFirstName (String firstName ) {\n        this.firstName  = firstName ;\n    }\n    @Column(name=""surname"" )\n    public String getLastName () {\n        return lastName ;\n    }\n    public void setLastName (String lastName ) {\n        this.lastName  = lastName ;\n    }\n    @Override\n    public String toString () {\n        return getFullName ();\n    }\n    @Transient  /* synthetic: cannot be used in JPA queries. */\n    public String getFullName () {\n        StringBuilder  sb = new StringBuilder ();\n        if (firstName  != null)\n            sb.append(firstName ).append(' ');\n        if (lastName  != null)\n            sb.append(lastName );\n        if (sb.length() == 0)\n            sb.append(""NO NAME"" );\n        return sb.toString ();\n    }\n}\nThe @Entity  annotation at class level directs JPA to treat this as a data object to be\nmapped into the database. The @Id informs JPA that this id is the primary key\nproperty,  and the @GeneratedValue  tells it how to assign the primary key values for\nnewly created objects. The @Column  annotation is only needed when the column\nname in the relational database differs from the expected name based on the prop‐\nerty; in this case, the SQL database designer has used surname , whereas the Java\ndeveloper wants to use lastName .\nI said that annotations are class-like things, and therefore, you can define your own.\nThe syntax here is a bit funky; you use @interface . It is rumored that the team devel‐\noping this feature was either told not to, or was afraid to, introduce a new keyword\ninto the language, due to the trouble that doing so had caused when the enum\n544 | Chapter 17: Reflection,  or “A Class Named Class”\nkeyword  was introduced in Java SE 1.4. Or, maybe they just wanted to use a syntax\nthat was more reminiscent of the annotation’s usage. At any rate, Example 17-17  is a\ntrivial example of a custom annotation.\nExample 17-17. Trivial annotation defined\npackage lang;\npublic @interface MyToyAnnotation {\n}\nAnnotations are class-like things, so they should be named the same way—that is,\nnames that begin with a capital letter and, if public, are stored in a source file of the\nsame name (e.g, MyToyAnnotation.java ).\nCompile the Example 17-17  with javac  and you’ll see there’s a new MyToyAnnota‐\ntion.class  file. In Example 17-18 , we examine this with javap , the standard JDK class\ninspection tool.\nExample 17-18. Running javap on trivial annotation\n$ javap lang.MyToyAnnotation\nCompiled from ""MyToyAnnotation.java""\npublic interface lang.MyToyAnnotation extends java.lang.annotation.Annotation {\n}\n$\nAs it says, an Annotation  is represented in the class file format as just an interface\nthat extends Annotation  (to answer the obvious question, you could write simple\ninterfaces this way, but it would be a truly terrible idea). In Example 17-19 , we take a\nquick look at Annotation  itself.\nExample 17-19. The Annotation Interface in Detail\n$ javap java.lang.annotation.Annotation\nCompiled from ""Annotation.java""\npublic interface java.lang.annotation.Annotation {\n  public abstract boolean equals(java.lang.Object);\n  public abstract int hashCode();\n  public abstract java.lang.String toString();\n  public abstract java.lang.Class<? extends java.lang.annotation.Annotation>\n    annotationType();\n}\n$\nAnnotations can be made such that the compiler will only allow them in certain\npoints in your code. Example 17-20  is one that can only go on classes or interfaces.\n17.10 Using and Defining  Annotations | 545\nExample 17-20. Sample Annotation for Classes, Interfaces, etc.\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyAnnotation {\n}\nThe @Target  specifies where the annotation can be used: ElementType.TYPE  makes it\nusable on classes, interfaces, class-like things such as enums, even annotations! To\nrestrict it to use just on annotations, there is ElementType.ANNOTATION_TYPE . Other\ntypes include METHOD , FIELD , CONSTRUCTOR , LOCAL_VARIABLE , PACKAGE , and PARAME\nTER. So, this annotation is itself annotated with two @ANNOTATION_TYPE -targeted\nannotations.\nUsage of annotations with an existing framework requires consulting their documen‐\ntation. Using annotations for your own purpose at runtime requires use of the Reflec‐\ntion API, as shown in Example 17-21 .\nOne more thing to note about annotations is that they may have attributes. These are\ndefined as methods in the annotation source code but used as attributes where the\nannotation is used. Example 17-21  is an annotated annotation with one such\nattribute.\nExample 17-21. main/src/main/java/lang/AnnotationDemo.java\n/**\n * A sample annotation for types (classes, interfaces);\n * it will be available at run time.\n */\n@Target(ElementType .TYPE)\n@Retention (RetentionPolicy .RUNTIME)\npublic @interface  AnnotationDemo  {\n    public boolean fancy() default false;\n    public int order() default 42;\n}\n/** A simple example of using the annotation */\n@AnnotationDemo (fancy=true)\n@Resource (name=""Dumbledore"" )\nclass FancyClassJustToShowAnnotation  {\n    /** Print out the annotations attached to this class */\n    public static void main(String[] args) {\n        Class<?> c = FancyClassJustToShowAnnotation .class;\n        System.out.println(""Class ""  + c.getName() + "" has these annotations:"" );\n        for (Annotation  a : c.getAnnotations ()) {\n            if (a instanceof  AnnotationDemo ) {\n                AnnotationDemo  ad = (AnnotationDemo )a;\n                System.out.println(""\t"" +a +\n546 | Chapter 17: Reflection,  or “A Class Named Class”",9700
706-17.11 Finding Plug-In-Like Classes via Annotations.pdf,706-17.11 Finding Plug-In-Like Classes via Annotations,,0
707-Problem.pdf,707-Problem,,0
708-Solution.pdf,708-Solution,,0
709-Discussion.pdf,709-Discussion,""" with fancy=""  + ad.fancy() +\n                    "" and order ""  + ad.order());\n            } else {\n                System.out.println(""\tSomebody else's annotation: ""  + a);\n            }\n        }\n    }\n}\nAnnotationDemo  has the meta-annotation @Target(ElementType.TYPE)  to indicate\nthat it can annotate user-defined types (such as classes). Other ElementType  choices\ninclude METHOD , FIELD , and PARAMETER . If more than one is needed, use array initial‐\nizer syntax.\nAnnotationDemo  also has the @Retention(RetentionPolicy.RUNTIME)  annotation to\nrequest that it be preserved until runtime. This is obviously required for any annota‐\ntion that will be examined by a framework at runtime.\nThese two meta-annotations are common on user-defined annotations that will be\nexamined at runtime.\nThe class FancyClassJustToShowAnnotation  shows using the AnnotationDemo  anno‐\ntation, along with a standard Java one (the @Resource  annotation).\nRefer to Recipe 17.11  for a full example of using this mechanism.\n17.11 Finding Plug-In-Like Classes via Annotations\nProblem\nY ou want to do plug-in-like things without using an explicit plug-in API.\nSolution\nDefine an annotation for the purpose, and use it to mark the plug-in classes.\nDiscussion\nSuppose we want to model how the Java EE standard javax.annotations.Named  or\njavax.faces.ManagedBean  annotations work; for each class that is so annotated, con‐\nvert the class name to an instance-like name (e.g, lowercase the first letter), and do\nsomething special with it. Y ou’ d want to do something like the following:\n1.Get the list of classes in the given package(s) (see Recipe 17.9 ).\n2.Check if the class is annotated.\n17.11 Finding Plug-In-Like Classes via Annotations | 547\n3.If so, save the name and Class  descriptor for later use.\nThis is implemented in Example 17-22 .\nExample 17-22. main/src/main/java/reflection/PluginsViaAnnotations\n/** Discover ""plugins"" or other add-in classes via Reflection using Annotations */\npublic class PluginsViaAnnotations  {\n    /**\n     * Find all classes in the given package which have the given\n     * class-level annotation class.\n     */\n    public static List<Class<?>> findAnnotatedClasses (String packageName ,\n        Class<? extends Annotation > annotationClass ) throws Exception  {\n        List<Class<?>> ret = new ArrayList <>();\n        String[] clazzNames  = ClassesInPackage .getPackageContent (packageName );\n        for (String clazzName  : clazzNames ) {\n            if (!clazzName .endsWith ("".class"" )) {\n                continue ;\n            }\n            clazzName  = clazzName .replace('/', '.').replace("".class"" , """");\n            Class<?> c = null;\n            try {\n                c = Class.forName(clazzName );\n            } catch (ClassNotFoundException  ex) {\n                System.err.println(""Weird: class ""  + clazzName  +\n                    "" reported in package but gave CNFE: ""  + ex);\n                continue ;\n            }\n            if (c.isAnnotationPresent (annotationClass ) &&\n                    !ret.contains (c))\n                    ret.add(c);\n        }\n        return ret;\n    }\nWe can take this one step further and support particular method annotations, similar\nto javax.annotations.PostCreate , which is meant to decorate a method that is to\nbe called after an instance of the bean has been instantiated by the framework. Our\nflow is now something like this, and the code is shown in Example 17-23 :\n1.Get the list of classes in the given package(s) (again, see Recipe 17.9 ).\n2.If you are using a class-level annotation, check if the class is annotated.\n3.If this class is still of interest, get a list of its methods.\n4.For each method, see if it contains a given method-specific annotation.\n548 | Chapter 17: Reflection,  or “A Class Named Class”",3874
710-See Also.pdf,710-See Also,,0
711-17.12 Program CrossRef.pdf,711-17.12 Program CrossRef,"5.If so, add the class and method to a list of invocable methods.\nExample 17-23. main/src/main/java/reflection/PluginsViaAnnotations  (find  annotated\nmethods)\n    /**\n     * Find all classes in the given package which have the given\n     * method-level annotation class on at least one method.\n     */\n    public static List<Class<?>> findClassesWithAnnotatedMethods (String packageName ,\n            Class<? extends Annotation > methodAnnotationClass ) throws Exception  {\n        List<Class<?>> ret = new ArrayList <>();\n        String[] clazzNames  = ClassesInPackage .getPackageContent (packageName );\n        for (String clazzName  : clazzNames ) {\n            if (!clazzName .endsWith ("".class"" )) {\n                continue ;\n            }\n            clazzName  = clazzName .replace('/', '.').replace("".class"" , """");\n            Class<?> c = null;\n            try {\n                c = Class.forName(clazzName );\n                // System.out.println(""Loaded "" + c);\n            } catch (ClassNotFoundException  ex) {\n                System.err.println(""Weird: class ""  + clazzName  +\n                    "" reported in package but gave CNFE: ""  + ex);\n                continue ;\n            }\n            for (Method m : c.getDeclaredMethods ()) {\n                // System.out.printf(""Class %s Method: %s\n"",\n                //     c.getSimpleName(), m.getName());\n                if (m.isAnnotationPresent (methodAnnotationClass ) &&\n                        !ret.contains (c)) {\n                    ret.add(c);\n                }\n            }\n        }\n        return ret;\n    }\nSee Also\nRecipe 17.10  and the rest of this chapter.\n17.12 Program: CrossRef\nY ou’ve probably seen those other Java books that consist entirely of listings of the Java\nAPI for version thus-and-such of the JDK. I don’t suppose you thought the authors of\nthese works sat down and typed the entire contents from scratch. As a programmer,\nyou would have realized, I hope, that there must be a way to obtain that information\n17.12 Program: CrossRef | 549\nfrom Java. But you might not have realized how easy it is! If you’ve read this chapter\nfaithfully, you now know that there is one true way: make the computer do the walk‐\ning. Example 17-24  is a program that puts most of the techniques together. This ver‐\nsion generates a cross-reference listing, but by overriding the last few methods, you\ncould easily convert it to print the information in any format you like, including an\nAPI reference book. Y ou’ d need to deal with the details of this or that publishing soft‐\nware—FrameMaker, troff, TEX, or whatever—but that’s the easy part.\nThis program makes fuller use of the Reflection API than did MyJavaP  in Recipe 17.8 .\nIt also uses the java.util.zip  classes (see Recipe 10.15 ) to crack the JAR archive\ncontaining the class files of the API. Each class file found in the archive is loaded and\nlisted; the listing part is similar to MyJavaP .\nExample 17-24. main/src/main/java/reflection/CrossRef.java\npublic class CrossRef  extends APIFormatter  {\n    /** Simple main program, construct self, process each .ZIP file\n     * found in CLASSPATH or in argv.\n     */\n    public static void main(String[] argv) throws IOException  {\n        CrossRef  xref = new CrossRef ();\n        xref.doArgs(argv);\n    }\n    /**\n     * Print the fields and methods of one class.\n     */\n    protected  void doClass(Class<?> c) {\n        startClass (c);\n        try {\n            Field[] fields = c.getDeclaredFields ();\n            Arrays.sort(fields, new Comparator <Field>() {\n                public int compare(Field o1, Field o2) {\n                    return o1.getName().compareTo (o2.getName());\n                }\n            });\n            for (int i = 0; i < fields.length; i++) {\n                Field field = (Field)fields[i];\n                if (!Modifier .isPrivate (field.getModifiers ()))\n                    putField (field, c);\n                // else System.err.println(""private field ignored: "" + field);\n            }\n            Method methods[] = c.getDeclaredMethods ();\n            Arrays.sort(methods, new Comparator <Method>() {\n                public int compare(Method o1, Method o2) {\n                    return o1.getName().compareTo (o2.getName());\n                }\n550 | Chapter 17: Reflection,  or “A Class Named Class”\n            });\n            for (int i = 0; i < methods.length; i++) {\n                if (!Modifier .isPrivate (methods[i].getModifiers ()))\n                    putMethod (methods[i], c);\n                // else System.err.println(""pvt: "" + methods[i]);\n            }\n        } catch (Exception  e) {\n            e.printStackTrace ();\n        }\n        endClass ();\n    }\n    /** put a Field's information to the standard output.  */\n    protected  void putField (Field fld, Class<?> c) {\n        println(fld.getName() + "" field ""  + c.getName() + "" "");\n    }\n    /** put a Method's information to the standard output.  */\n    protected  void putMethod (Method method, Class<?> c) {\n        String methName  = method.getName();\n        println(methName  + "" method ""  + c.getName() + "" "");\n    }\n    /** Print the start of a class. Unused in this version,\n     * designed to be overridden */\n    protected  void startClass (Class<?> c) {\n    }\n    /** Print the end of a class. Unused in this version,\n     * designed to be overridden */\n    protected  void endClass () {\n    }\n    /** Convenience routine, short for System.out.println */\n    protected  final void println(String s) {\n        System.out.println(s);\n    }\n}\nY ou probably noticed the methods startClass()  and endClass() , which are null.\nThese methods are placeholders designed to make subclassing easy for when you\nneed to write something at the start and end of each class. One example might be a\nfancy text formatting application in which you need to output a bold header at the\nbeginning of each class. Another would be XML, where you’ d want to write a tag like\n<class>  at the front of each class and </class>  at the end. Example 17-25  is an XML-\nspecific subclass that generates (limited) XML for each field and method.\n17.12 Program: CrossRef | 551",6285
712-See Also.pdf,712-See Also,"Example 17-25. main/src/main/java/reflection/CrossRefXML.java\npublic class CrossRefXML  extends CrossRef  {\n    public static void main(String[] argv) throws IOException  {\n        CrossRef  xref = new CrossRefXML ();\n        xref.doArgs(argv);\n    }\n    /** Print the start of a class.\n     */\n    protected  void startClass (Class<?> c) {\n        println(""<class><classname>""  + c.getName() + ""</classname>"" );\n    }\n    protected  void putField (Field fld, Class<?> c) {\n        println(""<field>""  + fld + ""</field>"" );\n    }\n    /** put a Method's information to the standard output.\n     * Marked protected so you can override it (hint, hint).\n     */\n    protected  void putMethod (Method method, Class<?> c) {\n        println(""<method>""  + method + ""</method>"" );\n    }\n    /** Print the end of a class.\n     */\n    protected  void endClass () {\n        println(""</class>"" );\n    }\n}\nBy the way, if you publish a book using either of these and get rich, “Remember,\nremember me!”\nSee Also\nWe have not investigated all the ins and outs of reflection or the ClassLoader  mecha‐\nnism, but by now you should have a basic idea of how it works.\nPerhaps the most important omissions are SecurityManager  and ProtectionDomain .\nOnly one SecurityManager  can be installed in a given instance of the JVM (e.g., to\nprevent malicious code from providing its own!). A browser running the old Java\nApplet API, for example, provides a SecurityManager  that is far more restrictive than\nthe standard one. Writing such a SecurityManager  is left as an exercise for the reader\n—an important exercise for anyone planning to load classes over the internet! (For\nmore information about security managers and the Java Security APIs, see Java Secu‐\n552 | Chapter 17: Reflection,  or “A Class Named Class”\nrity by Scott Oaks (O’Reilly). A ProtectionDomain  can be provided with a Class\nLoader  to specify all the permissions needed for the class to run.\nI’ve also left unexplored many topics in the JVM; see the (somewhat dated) O’Reilly\nbooks Java Virtual Machine  by Troy Downing and Jon Meyer, and  Java Language Ref‐\nerence  by Mark Grand. Y ou can also read the Sun/Oracle Java Language Specification\nand JVM Specification  documents (both updated with new releases, available online ),\nfor a lifetime of reading enjoyment and edification!\nThe Apache Software Foundation maintains a vast array of useful software packages\nthat are free to get and use. Source code is always available without charge from its\nwebsite. Two packages you might want to investigate include the Commons BeanU‐\ntils and the Byte Code Engineering Library (BCEL). The Commons BeanUtils  claims\nto provide easier-to-use wrappers around some of the Reflection API. BCEL is a\nthird-party toolkit for building and manipulating bytecode class files. Written by \nMarkus Dahm, BCEL has become part of the Apache Commons Project .\n17.12 Program: CrossRef | 553",2966
713-Chapter 18. Using Java with Other Languages.pdf,713-Chapter 18. Using Java with Other Languages,,0
714-18.1 Running an External Program from Java.pdf,714-18.1 Running an External Program from Java,"CHAPTER 18\nUsing Java with Other Languages\n18.0 Introduction\nJava has several methods of running programs written in other languages. Y ou can\ninvoke a compiled program or executable script using Runtime.exec() , as I’ll\ndescribe in Recipe 18.1 . There is an element of system dependency here, because you\ncan only run external applications under the operating system they are compiled for.\nAlternatively, you can invoke one of a number of scripting languages (or dynamic lan‐\nguages )—running the gamut: awk, bsh, Clojure, Ruby, Perl, Python, Scala—using\njavax.script , as illustrated in Recipe 18.3 . Or you can drop down to C level with\nJava’s native code  mechanism and call compiled functions written in C/C++; see\nRecipe 18.6 . From native code, you can call to functions written in just about any lan‐\nguage. Not to mention that you can contact programs written in any language over a\nsocket (see Chapter 13 ), with HTTP services (see Chapter 13 ), or with Java clients in\nRMI or CORBA clients in a variety of languages.\nThere is a wide range of other JVM languages, including these:\n•BeanShell, a general scripting language for Java.\n•Groovy  is a Java-based scripting language that pioneered the use of closures in\nthe Java language ecosystem. It also has a rapid-development web package called \nGrails  and a build tool called Gradle (see Recipe 1.8 ). Gradle is also used as the\nbuild tool in modern Android development.\n•Jython , a full Java implementation of Python.\n•JRuby , a full Java implementation of the Ruby language.\n•Scala , a JVM language that claims to offer the “best of functional and OO” lan‐\nguages.\n555",1656
715-Problem.pdf,715-Problem,,0
716-Solution.pdf,716-Solution,,0
717-Discussion.pdf,717-Discussion,"6kwrite  is Unix-specific; it’s a part of the K Desktop Environment (KDE) .•Clojure , a predominantly functional Lisp-1  dialect for the JVM.\n•Renjin  (pronounced “R engine”), a fairly complete open source clone of the R\nstatistics package with the ability to scale to the cloud. See Recipe 11.5  for an\nexample using Renjin.\nThese are JVM-centric, and some can be called directly from Java to script, or vice\nversa, without using javax.script . A list of these languages can be found on\nWikipedia .\n18.1 Running an External Program from Java\nProblem\nY ou want to run an external program from within a Java program.\nSolution\nUse one of the exec()  methods in the java.lang.Runtime  class. Or set up a Process\nBuilder  and call its start()  method.\nDiscussion\nThe exec()  method in the Runtime  class lets you run an external program. The com‐\nmand line you give is broken into strings by a simple StringTokenizer  (see Recipe\n3.1) and passed on to the operating system’s “execute a program” system call. As an\nexample, here is a simple program that uses exec()  to run kwrite , a windowed text\neditor program.6 On Windows, you’ d have to change the name to notepad  or word\npad, possibly including the full pathname, for example, c:/windows/notepad.exe  (you\ncan also use backslashes, but be careful to double them because the backslash is spe‐\ncial in Java strings):\npublic class ExecDemoSimple  {\n    public static void main(String av[]) throws Exception  {\n        // Run the ""notepad"" program or a similar editor\n        Process p = Runtime.getRuntime ().exec(""kwrite"" );\n        p.waitFor();\n    }\n}\nWhen you compile and run it, the appropriate editor window appears:\n556 | Chapter 18: Using Java with Other Languages\n$ javac -d . ExecDemoSimple.java\n$ java otherlang.ExecDemoSimple # causes a KWrite window to appear.\n$\nThis version of exec()  assumes that the pathname contains no blanks because these\nbreak proper operation of the StringTokenizer . To overcome this potential problem,\nuse an overloaded form of exec() , taking an array of strings as arguments.\nExample 18-1  runs the Windows or Unix version of the Firefox web browser, assum‐\ning that Firefox was installed in the default directory (or another directory that is on\nyour PATH ). It passes the name of a help file as an argument, offering a kind of primi‐\ntive help mechanism, as displayed in Figure 18-1 .\nExample 18-1. main/src/main/java/otherlang/ExecDemoNS.java\npublic class ExecDemoNS  extends JFrame {\n    private static final String BROWSER = ""firefox"" ;\n    Logger logger = Logger.getLogger (ExecDemoNS .class.getSimpleName ());\n    /** The name of the help file. */\n    protected  final static String HELPFILE  = ""./help/index.html"" ;\n    /** A stack of process objects; each entry tracks one running process */\n    Stack<Process> pStack = new Stack<>();\n    /** main - instantiate and run */\n    public static void main(String av[]) throws Exception  {\n        String program = av.length == 0 ? BROWSER : av[0];\n        new ExecDemoNS (program).setVisible (true);\n    }\n    /** The path to the binary executable that we will run */\n    protected  static String program;\n    /** Constructor - set up strings and things. */\n    public ExecDemoNS (String program) {\n        super(""ExecDemo: ""  + program);\n        this.program = program;\n        Container  cp = getContentPane ();\n        cp.setLayout (new FlowLayout ());\n        JButton b;\n        cp.add(b=new JButton(""Exec""));\n        b.addActionListener (e -> runProgram ());\n        cp.add(b=new JButton(""Wait""));\n        b.addActionListener (e -> doWait());\n        cp.add(b=new JButton(""Exit""));\n        b.addActionListener (e -> System.exit(0));\n        pack();\n    }\n18.1 Running an External Program from Java | 557\n    /** Start the help, in its own Thread. */\n    public void runProgram () {\n        new Thread() {\n            public void run() {\n                try {\n                    // Get a ""file:"" URL for the Help File\n                    URL helpURL = this.getClass ().getClassLoader ().\n                        getResource (HELPFILE );\n                    // Start the external browser from the Java Application.\n                    String osname = System.getProperty (""os.name"" );\n                    String run;\n                    if (""Mac OS X"" .equals(osname)) {\n                        run = ""open -a ""  + program;\n                        // ""if"" allows for other OSes needing special handling\n                    } else {\n                        run = program;\n                    }\n                    pStack.push(Runtime.getRuntime ().exec(run + "" "" + helpURL));\n                    logger.info(""In main after exec ""  + pStack.size());\n                } catch (Exception  ex) {\n                    JOptionPane .showMessageDialog (ExecDemoNS .this,\n                        ""Error"" + ex, ""Error"",\n                        JOptionPane .ERROR_MESSAGE );\n                }\n            }\n        }.start();\n    }\n    public void doWait() {\n        if (pStack.size() == 0) {\n            logger.info(""Nothing to wait for."" );\n            return;\n        }\n        logger.info(""Waiting for process ""  + pStack.size());\n        try {\n            Process p = pStack.pop();\n            p.waitFor();\n            // wait for process to complete\n            // (may not work as expected for some old Windows programs)\n            logger.info(""Process ""  + p + "" is done."" );\n        } catch (Exception  ex) {\n            JOptionPane .showMessageDialog (this,\n                ""Error"" + ex, ""Error"",\n558 | Chapter 18: Using Java with Other Languages\n                JOptionPane .ERROR_MESSAGE );\n        }\n    }\n}\nFigure 18-1. ExecDemoNS in action\nA newer class, ProcessBuilder , replaces most nontrivial uses of Runtime.exec() .\nThis ProcessBuilder  uses generic collections to let you modify or replace the envi‐\nronment, as shown in Example 18-2 .\nExample 18-2. main/src/main/java/otherlang/ProcessBuilderDemo.java\n        List<String> command = new ArrayList <>();            \n        command.add(""notepad"" );\n        command.add(""foo.txt"" );\n        ProcessBuilder  builder = new ProcessBuilder (command);\n        builder.environment ().put(""PATH"",\n                ""/windows;/windows/system32;/winnt"" );        \n        final Process godot = builder.directory (\n            new File(System.getProperty (""user.home"" ))).      \n            start();\n        System.err.println(""Waiting for Godot"" );             \n        godot.waitFor();                                     \nSet up the command-line argument list: editor program name and filename.\nUse that to start configuring the ProcessBuilder .\n18.1 Running an External Program from Java | 559",6830
718-18.2 Running a Program and Capturing Its Output.pdf,718-18.2 Running a Program and Capturing Its Output,,0
719-Problem.pdf,719-Problem,,0
720-Solution.pdf,720-Solution,,0
721-Discussion.pdf,721-Discussion,"Configure the builder’s environment to a list of common MS Windows\ndirectories.\nSet the initial directory to the user’s home, and start the process!\nI always wanted to be able to use this line in code.\nWait for the end of our little play.\nFor more on ProcessBuilder , see the javadoc for java.lang.ProcessBuilder .\n18.2 Running a Program and Capturing Its Output\nProblem\nY ou want to run a program but also capture its output.\nSolution\nUse the Process  object’s getInputStream() ; read and copy the contents to Sys\ntem.out  or wherever you want them.\nDiscussion\nThe original notion of standard output and standard error was that they would\nalways be connected to the terminal; this notion dates from an earlier time when\nalmost all computer users worked at the command line. Today, a program’s standard\noutput and error output do not always automatically appear anywhere. Arguably\nthere should be an automatic way to make this happen. But for now, you need to add\na few lines of code to grab the program’s output and print it:\npublic class ExecDemoLs  {\n    private static Logger logger =\n        Logger.getLogger (ExecDemoLs .class.getSimpleName ());\n    /** The program to run */\n    public static final String PROGRAM = ""ls""; // ""dir"" for Windows\n    /** Set to true to end the loop */\n    static volatile  boolean done = false;\n    public static void main(String argv[]) throws IOException  {\n        final Process p;         // Process tracks one external native process\n        BufferedReader  is;    // reader for output of process\n        String line;\n560 | Chapter 18: Using Java with Other Languages\n        p = Runtime.getRuntime ().exec(PROGRAM);\n        logger.info(""In Main after exec"" );\n        // Optional: start a thread to wait for the process to terminate.\n        // Don't just wait in main line, but here set a ""done"" flag and\n        // use that to control the main reading loop below.\n        Thread waiter = new Thread() {\n            public void run() {\n                try {\n                    p.waitFor();\n                } catch (InterruptedException  ex) {\n                    // OK, just quit.\n                    return;\n                }\n                System.out.println(""Program terminated!"" );\n                done = true;\n            }\n        };\n        waiter.start();\n        // getInputStream gives an Input stream connected to\n        // the process p's standard output (and vice versa). We use\n        // that to construct a BufferedReader so we can readLine() it.\n        is = new BufferedReader (new InputStreamReader (p.getInputStream ()));\n        while (!done && ((line = is.readLine ()) != null))\n            System.out.println(line);\n        logger.info(""In Main after EOF"" );\n        return;\n    }\n}\nThis is such a common occurrence that I’ve packaged it up into a class called ExecAnd\nPrint , which is part of my com.darwinsys.lang  package. ExecAndPrint  has several\noverloaded forms of its run()  method (see the documentation for details), but they\nall take at least a command and optionally an output file to which the command’s\noutput is written. Example 18-3  shows the code for some of these methods.\nExample 18-3. darwinsys-api/src/main/java/com/darwinsys/lang/ExecAndPrint.java\n    /** Need a Runtime object for any of these methods */\n    protected  final static Runtime r = Runtime.getRuntime ();\n    /** Run the command given as a String, output to System.out\n     * @param cmd The command\n     * @return The command's exit status\n     * @throws IOException if the command isn't found\n     */\n18.2 Running a Program and Capturing Its Output | 561\n    public static int run(String cmd) throws IOException  {\n        return run(cmd, new OutputStreamWriter (System.out));\n    }\n    /** Run the command given as a String, output to ""out""\n     * @param cmd The command and list of arguments\n     * @param out The output file\n     * @return The command's exit status\n     * @throws IOException if the command isn't found\n     */\n    public static int run(String cmd, Writer out) throws IOException  {\n        Process p = r.exec(cmd);\n        FileIO.copyFile (new InputStreamReader (p.getInputStream ()), out, true);\n        try {\n            p.waitFor();    // wait for process to complete\n        } catch (InterruptedException  e) {\n            return -1;\n        }\n        return p.exitValue ();\n    }\nAs a simple example of using exec()  directly along with ExecAndPrint , I’ll create\nthree temporary files, list them (directory listing), and then delete them. When I run\nthe ExecDemoFiles  program, it lists the three files it has created:\n-rw-------  1 ian  wheel  0 Jan 29 14:29 file1\n-rw-------  1 ian  wheel  0 Jan 29 14:29 file2\n-rw-------  1 ian  wheel  0 Jan 29 14:29 file3\nIts source code is in Example 18-4 .\nExample 18-4. main/src/main/java/otherlang/ExecDemoFiles.java\n        // Get and save the Runtime object.\n        Runtime rt = Runtime.getRuntime ();\n        // Create three temporary files (the slow way!)\n        rt.exec(""mktemp file1"" );\n        rt.exec(""mktemp file2"" );\n        rt.exec(""mktemp file3"" );\n        // Run the ""ls"" (directory lister) program\n        // with its output sent into a file\n        String[] args = { ""ls"", ""-l"", ""file1"", ""file2"", ""file3"" };\n        ExecAndPrint .run(args);\n        rt.exec(""rm file1 file2 file3"" );\n562 | Chapter 18: Using Java with Other Languages\nA process isn’t necessarily destroyed when the Java program that created it exits or\nbombs out. Simple text-based programs will be, but window-based programs like\nkwrite  Netscape, or even a Java-based JFrame  application, will not. For example, our\nExecDemoNS  program started Netscape, and when ExecDemoNS ’s Exit button is clicked,\nExecDemoNS  exits but Netscape stays running. What if you want to be sure a process\nhas completed? The Process  object has a waitFor()  method that lets you do so, and\nan exitValue()  method that tells you the return code from the process. Finally,\nshould you wish to forcibly terminate the other process, you can do so with the Pro\ncess  object’s destroy()  method, which takes no argument and returns no value.\nExample 18-5  is ExecDemoWait , a program that runs whatever program you name on\nthe command line (along with arguments), captures the program’s standard output,\nand waits for the program to terminate.\nExample 18-5. main/src/main/java/otherlang/ExecDemoWait.java\n        // A Runtime object has methods for dealing with the OS\n        Runtime r = Runtime.getRuntime ();\n        Process p;         // Process tracks one external native process\n        BufferedReader  is;    // reader for output of process\n        String line;\n        // Our argv[0] contains the program to run; remaining elements\n        // of argv contain args for the target program. This is just\n        // what is needed for the String[] form of exec.\n        p = r.exec(argv);\n        System.out.println(""In Main after exec"" );\n        // getInputStream gives an Input stream connected to\n        // the process p's standard output. Just use it to make\n        // a BufferedReader to readLine() what the program writes out.\n        is = new BufferedReader (new InputStreamReader (p.getInputStream ()));\n        while ((line = is.readLine ()) != null)\n            System.out.println(line);\n        System.out.println(""In Main after EOF"" );\n        System.out.flush();\n        try {\n            p.waitFor();    // wait for process to complete\n        } catch (InterruptedException  e) {\n            System.err.println(e);    // ""Can't Happen""\n            return;\n        }\n        System.err.println(""Process done, exit status was ""  + p.exitValue ());\n18.2 Running a Program and Capturing Its Output | 563",7852
722-See Also.pdf,722-See Also,,0
723-18.3 Calling Other Languages via javax.script.pdf,723-18.3 Calling Other Languages via javax.script,,0
724-Problem.pdf,724-Problem,,0
725-Solution.pdf,725-Solution,,0
726-Discussion.pdf,726-Discussion,"See Also\nY ou wouldn’t normally use any form of exec()  to run one Java program from another\nin this way; instead, you’ d probably create it as a thread within the same process,\nbecause this is generally quite a bit faster (the Java interpreter is already up and run‐\nning, so why wait for another copy of it to start up?). See Chapter 16 .\nWhen building industrial-strength applications, note the cautionary remarks in the\nJava API docs for the Process  class concerning the danger of losing some of the I/O\ndue to insufficient buffering by the operating system.\n18.3 Calling Other Languages via javax.script\nProblem\nY ou want to invoke a script written in some other language from within your Java\nprogram, running in the JVM, with the ability to pass variables directly to/from the\nother language.\nSolution\nIf the script you want is written in any of the two-dozen-plus supported languages,\nuse javax.script . Those languages include awk, Perl, Python, Ruby, BeanShell,\nPNuts, Ksh/Bash, R (Renjin), and several implementations of JavaScript.\nDiscussion\nOne of the first tasks when using this API is to find out the installed scripting\nengines, and then pick one that is available. The ScriptEnginesDemo  program in\nExample 18-6  lists the installed engines and runs a simple script in the default lan‐\nguage, ECMAScript (aka JavaScript).\nExample 18-6. main/src/main/java/otherlang/ScriptEnginesDemo.java\npublic class ScriptEnginesDemo  {\n    public static void main(String[] args) throws ScriptException  {\n        ScriptEngineManager  scriptEngineManager  = new ScriptEngineManager ();\n        // Print list of supported languages\n        scriptEngineManager .getEngineFactories ().forEach(factory ->\n            System.out.println(factory.getLanguageName ()));\n        // Run a script in the JavaScript language\n        String lang = ""JavaScript"" ;\n        ScriptEngine  engine =\n564 | Chapter 18: Using Java with Other Languages\n            scriptEngineManager .getEngineByName (lang);\n        if (engine == null) {\n            System.err.println(""Could not find engine"" );\n            return;\n        }\n        engine.eval(""print(\""Hello from ""  + lang + ""\"");"");\n    }\n}\nExample 18-7  is a very simple demo of calling Python from Java using javax.script\ning. We know the name of the scripting engine we want to use: Python. We’ll use the\nin-vm implementation known as jython , which was originally called JPython but was\nchanged due to a trademark issue. Once we put the jython-standalone-2.nnn.jar  onto\nour CLASSPATH , the script engine is automatically detected. Just in case it fails, we\nprint a verbose message including a list of the engines that are available.\nExample 18-7. main/src/main/java/otherlang/PythonFromJava.java\n/**\n * demo using Python (jython) to get a Java variable, print, and change it.\n * @author Ian Darwin\n */\npublic class PythonFromJava  {\n    private static final String PY_SCRIPTNAME  = ""pythonfromjava.py"" ;\n    public static void main(String[] args) throws Exception  {\n        ScriptEngineManager  scriptEngineManager  = new ScriptEngineManager ();\n        ScriptEngine  engine = scriptEngineManager .getEngineByName (""python"" );\n        if (engine == null) {\n            final String message =\n                ""Could not find 'python' engine; add its jar to CLASSPATH"" ;\n            System.out.println(message);\n            System.out.println(""Available script engines are: "" );\n            scriptEngineManager .getEngineFactories ().forEach(factory ->\n                System.out.println(factory.getLanguageName ()));\n            throw new IllegalStateException (message);\n        }\n        final Bindings  bindings  = engine.getBindings (ScriptContext .ENGINE_SCOPE );\n        bindings .put(""meaning"" , 42);\n        // Let's run a python script stored on disk (well, on classpath):\n        InputStream  is =\n            PythonFromJava .class.getResourceAsStream (""/"" + PY_SCRIPTNAME );\n        if (is == null) {\n            throw new IOException (""Could not find file ""  + PY_SCRIPTNAME );\n        }\n        engine.eval(new InputStreamReader (is));\n        System.out.println(""Java: Meaning is now ""  + bindings .get(""meaning"" ));\n18.3 Calling Other Languages via javax.script | 565",4301
727-See Also.pdf,727-See Also,,0
728-18.4 Mixing Languages with GraalVM.pdf,728-18.4 Mixing Languages with GraalVM,,0
729-Problem.pdf,729-Problem,,0
730-Solution.pdf,730-Solution,,0
731-18.5 Marrying Java and Perl.pdf,731-18.5 Marrying Java and Perl,"}\n}\nSee Also\nBefore Oracle dismantled java.net, there used to be a list of many languages (see this\narchived list ; the links don’t work, but it shows the extent of the languages that were\navailable). Back then, you could download the script engines from that site. I am not\naware of a current official list of engines, unfortunately. However, the list maintained\nas part of the scripting project per se can be found in an unofficial source code repos‐\nitory, by viewing https://github.com/scijava/javax-scripting , from which it should in\ntheory be possible to build the one you want. A dozen or so other engines are main‐\ntained by others outside this project; for example, there is a Perl5  script engine from\nGoogle Code .\nThere is a also a list of Java-compatible scripting languages  (not necessarily all using\njavax.script ).\nIt is possible to roll your own scripting engine; see my write-up at https://darwin\nsys.com/java/scriptengines.html .\n18.4 Mixing Languages with GraalVM\nProblem\nGraalVM aims to be multilanguage, and you’ d like to use different languages in the\nVM.\nSolution\nUse gu (graal utility) to install additional language packs and call other languages.\nDiscussion\nWhile GraalVM positions itself as able to support a wide variety of programming lan‐\nguages, the number currently supported is small but growing. Let’s try invoking\nPython code from within Java. Assuming you’ve installed Graal itself as per Recipe\n1.2, you should have gu on your executable path, so try the following:\n$ gu install python\nDownloading: Component catalog from www.graalvm.org\nProcessing component archive: Graal.Python\nDownloading: Component python: Graal.Python  from github.com\nInstalling new component: Graal.Python (org.graalvm.python, version 19.2.0.1)\nIMPORTANT NOTE:\n---------------\n566 | Chapter 18: Using Java with Other Languages",1876
732-Problem.pdf,732-Problem,,0
733-Discussion.pdf,733-Discussion,"Set of GraalVM components that provide language implementations have changed.\n  The Polyglot native image and polyglot native C library may be out of sync:\n- new languages may not be accessible\n- removed languages may cause the native binary to fail on missing resources\n  or libraries.\nTo rebuild and refresh the native binaries, use the following command:\n      Library/Java/JavaVirtualMachines/graalvm-ce-19.2.0.1/Contents/Home/bin/gu\n      rebuild-images\nYou may need to install ""native-image"" component which provide the rebuild \ntools.\nThen the code in Example 18-8  can be used.\nExample 18-8. graal/src/JavaCallPython.java\nimport java.io.* ;\nimport java.util.stream.* ;\nimport org.graalvm.polyglot.* ;\n/**\n * GraalVM polyglot: calling Python from Java/\n */\n// tag::main[]\npublic class JavaCallPython  {\n    public static void main(String[] args) throws java.io.IOException  {\n         try (Context context = Context.create(""jython"" )) {\n            Value result = context.execute(""2 + 2"");\n            System.out.println(result.asString ());\n        }\n    }\n}\n// end::main[]\n18.5 Marrying Java and Perl\nProblem\nY ou want to call Java from Perl, or vice versa.\nSolution\nTo call Java from Perl, use the Perl Inline::Java  module. To go the other way—call‐\ning Perl from Java—use javax.script , as in Recipe 18.3 .\n18.5 Marrying Java and Perl | 567\nDiscussion\nPerl is often called a glue language that can be used to bring together diverse parts of\nthe software world. But, in addition, it is a full-blown language for creating software.\nA wealth of extension modules provide ready-to-run solutions for quite diverse prob‐\nlems, and most of these modules are available free from CPAN, the Comprehensive\nPerl Archive Network . Also, as a scripting language, it is ideally suited for rapid pro‐\ntotyping. On the other hand, although building graphical user interfaces is definitely\npossible in Perl, it is not exactly one of the language’s strengths. So you might want to\nconstruct your GUI using Java Swing, and, at the same time, reuse business logic\nimplemented in Perl.\nFortunately, among the many CPAN modules, Inline::Java  makes the integration\nof Perl and Java a breeze. Let’s assume first that you want to call into Java from Perl.\nFor business logic, I have picked a CPAN module that measures the similarity of two\nstrings (the so-called Levenshtein edit distance ). Example 18-9  shows the complete\nsource. Y ou need at least version 0.44 of the module Inline::Java ; previous versions\ndid not support threaded applications properly, so use of Swing wasn’t possible.\nUsing the module this way requires that the Java source be included in the Perl script\nwith special delimiters, as shown in Example 18-9 .\nExample 18-9. Swinging.pl\n#! /usr/bin/perl\n# Calling Java from Perl\nuse strict;\nuse warnings;\nuse Text::Levenshtein qw( );\n  # Perl module from CPAN to measure string similarity\nuse Inline 0.44 ""JAVA"" =&gt; ""DATA"";  # pointer to the Inline java source\nuse Inline::Java qw(caught);  # helper function to determine exception type\nmy $show = new Showit;     # construct Java object using Perl syntax\n$show-&gt;show(""Just another Perl hacker"");            # call method on that object\neval {\n  # Call a method that will call back to Perl;\n  # catch exceptions, if any.\n  print ""matcher: "", $show-&gt;match(""Japh"", shift||""Java""),\n  "" (displayed from Perl)\n"";\n};\nif ($@) {\n  print STDERR ""Caught:"", caught($@), ""\n"";\n  die $@ unless caught(""java.lang.Exception"");\n568 | Chapter 18: Using Java with Other Languages\n  print STDERR $@-&gt;getMessage( ), ""\n"";\n}\n__END_  _\n__JAVA_  _\n// Java starts here\nimport javax.swing.*;\nimport org.perl.inline.java.*;\nclass Showit extends InlineJavaPerlCaller {\n  // extension only neeeded if calling back into Perl\n  /** Simple Java class to be called from Perl, and to call back to Perl\n   */\n  public Showit( ) throws InlineJavaException { }\n  /** Simple method */\n  public void show(String str) {\n    System.out.println(str + "" inside Java"");\n  }\n  /** Method calling back into Perl */\n  public int match(String target, String pattern)\n      throws InlineJavaException, InlineJavaPerlException {\n    // Calling a function residing in a Perl Module\n    String str = (String)CallPerl(""Text::Levenshtein"", ""distance"",\n          new Object [] {target, pattern});\n    // Show result\n    JOptionPane.showMessageDialog(null, ""Edit distance between '"" + target +\n        ""' and '"" + pattern + ""' is "" + str,\n        ""Swinging Perl"", JOptionPane.INFORMATION_MESSAGE);\n    return Integer.parseInt(str);\n  }\n}\nSince this uses the Text::Levenshtein  and the Inline::Java  modules, you will have\nto install that. Here’s the standard way:\n$ perl -MCPAN -e shell\n> install Text::Levenshtein\n> install Inline::Java\n> quit\nOn some systems there may be an OS-specific module; for example, on OpenBSD\nUnix, it’s this:\n$ doas pkg_add p5-Text-LevenshteinXS\n18.5 Marrying Java and Perl | 569\nIn a simple Perl+Java program like this, you don’t even need to write a separate Java\nsource file: you combine all the code, Perl and Java alike, in one single file. Y ou do not\nneed to compile anything, either; just execute it by typing:\nperl Swinging.pl\n(Y ou can also add a string argument.) After a little churning, a Java message box pops\nup, telling you that the distance between Japh  and Java  is 2. At the same time, your\nconsole shows the string “Just another Perl hacker inside Java. ” When you close the\nmessage box, you get the final result “matcher: 2 (displayed from Perl). ”\nIn between, your Perl program has created an instance of the Java class Showit  by\ncalling its constructor. It then called that object’s show()  method to display a string\nfrom within Java. It then proceeded to call the match()  method, but this time, some‐\nthing more complicated happens: the Java code calls back into Perl, accessing method\ndistance  of module Text::Levenshtein  and passing it two strings as arguments. It\nreceives the result, displays it in a message box, and finally, for good measure, returns\nit to the Perl main program that it had been called from.\nIncidentally, the eval { }  block around the method call is the Perlish way of catching\nexceptions. In this case, the exception is thrown from within Java.\nIf you restart the program, you will notice that startup time is much shorter, which is\nalways good news. Why is that so? On the first call, Inline::Java  took the input\napart, precompiled the Java part, and saved it to disk (usually, in a subdirectory called\n_Inline ). On subsequent calls, it just makes sure that the Java source has not changed\nand then calls the class file that is already on disk. (Of course, if you surreptitiously\nchanged the Java code, it is recompiled just as automagically.) Behind the scenes, even\nstranger things are going on, however. When the Perl script is executed, a Java server\nis constructed and started unbeknownst to the user, and the Perl part and the Java bits\ncommunicate through a TCP socket (see Chapter 13 ).\nMarrying two platform-independent languages, like Perl and Java, in a portable way\nskirts many portability problems. When distributing inlined applications, be sure to\nsupply not just the source files but also the contents of the _Inline  directory. (It is\nadvisable to purge that directory and to rebuild everything just before distribution\ntime; otherwise, old compiled versions left lying around might make it into the distri‐\nbution.) Each target machine needs to repeat the magic steps of Inline::Java , which\nrequires a Java compiler. In any case, the Inline::Java  module must be installed.\nBecause Perl has Inline  modules for a number of other languages (ordinary lan‐\nguages like C, but others as exotic as Befunge), one might even consider using Perl as\nglue for interoperation between those other languages, jointly or separately, and Java.\nI am sure many happy hours can be spent working out the intricacies of such\ninteractions.\n570 | Chapter 18: Using Java with Other Languages",8141
734-See Also.pdf,734-See Also,,0
735-18.6 Calling Other Languages via Native Code.pdf,735-18.6 Calling Other Languages via Native Code,,0
736-Problem.pdf,736-Problem,,0
737-Solution.pdf,737-Solution,,0
738-Discussion.pdf,738-Discussion,"See Also\nY ou can find full information on Inline::Java  on CPAN  or in the POD (Plain Old\nDocumentation) that is installed along with the module itself.\n18.6 Calling Other Languages via Native Code\nProblem\nY ou wish to call native C/C++ functions from Java, either for efficiency or to access\nhardware- or system-specific features.\nSolution\nUse JNI, the Java Native Interface. Or, use GraalVM.\nDiscussion\nJava lets you load native or compiled code into your Java program. Why would you\nwant to do such a thing? The best reason would probably be to access OS-dependent\nfunctionality, or existing code written in another language. A less good reason would\nbe speed: native code can sometimes run faster than Java, though this is becoming\nless important as computers get faster and more multicore. Like everything else in\nJava, the native code mechanism is subject to security restrictions; for example, app‐\nlets were not allowed to access native code.\nThe native code language bindings are defined for code written in C or C++. If you\nneed to access a language other than C/C++, write a bit of C/C++ and have it pass\ncontrol to other functions or applications, using any mechanism defined by your\noperating system.\nDue to such system-dependent features as the interpretation of header files and the\nallocation of the processor’s general-purpose registers, your native code may need to\nbe compiled by the same C compiler used to compile the Java runtime for your plat‐\nform. For example, on Solaris you can use SunPro C or maybe gcc. On Win32 plat‐\nforms, use Microsoft visual C++ Version 4.x or higher (32 bit). For Linux and macOS,\nyou should be able to use the provided gcc-based compiler. For other platforms, see\nyour Java vendor’s documentation.\nAlso note that the details in this section are for the Java Native Interface (JNI) of Java\n1.1 and later, which differs in some details from 1.0 and from Microsoft’s native\ninterface.\n18.6 Calling Other Languages via Native Code | 571\nIan’s Basic Steps: Java Calling Native Code\nTo call native code from Java, follow these steps:\n1.Write Java code that calls a native method.\n2.Compile this Java code.\n3.Create an .h file using javah .\n4.Write a C function that does the work.\n5.Compile the C code into a loadable object.\n6.Try it!\nThe first step is to write Java code that calls a native method. To do this, use the key‐\nword native  to indicate that the method is native, and provide a static code block\nthat loads your native method using System.loadLibrary() . (The dynamically load‐\nable module is created in step 5.) Static blocks are executed when the class containing\nthem is loaded; loading the native code here ensures it is in memory when needed!\nObject variables that your native code may modify should carry the volatile  modi‐\nfier. The file HelloJni.java , shown in Example 18-10 , is a good starting point.\nExample 18-10. main/src/main/java/jni/HelloJni.java\n/**\n * A trivial class to show Java Native Interface 1.1 usage from Java.\n  */\npublic class HelloJni  {\n  int myNumber  = 42; // used to show argument passing\n  // declare native class\n  public native void displayHelloJni ();\n  // Application main, call its display method\n  public static void main(String[] args) {\n    System.out.println(""HelloJni starting; args.length="" +\n                       args.length+""..."");\n    for (int i=0; i<args.length; i++)\n                       System.out.println(""args[""+i+""]=""+args[i]);\n    HelloJni  hw = new HelloJni ();\n    hw.displayHelloJni ();// call the native function\n    System.out.println(""Back in Java, \""myNumber\"" now ""  + hw.myNumber );\n  }\n  // Static code blocks are executed once, when class file is loaded\n  static {\n    System.loadLibrary (""hello"");\n572 | Chapter 18: Using Java with Other Languages\n  }\n}\nThe second step is simple; just use javac HelloJni.java  as you normally would. Y ou\nprobably won’t get any compilation errors on a simple program like this; if you do,\ncorrect them and try the compilation again.\nNext, you need to create an .h file. Use javah  to produce this file:\njavah jni.HelloJni            // produces HelloJni.h\nThe .h file produced is a glue file, not really meant for human consumption and par‐\nticularly not for editing. But by inspecting the resulting .h file, you’ll see that the C\nmethod’s name is composed of the name Java , the package name (if any), the class\nname, and the method name:\nJNIEXPORT void JNICALL Java_HelloJni_displayHelloWorld(JNIEnv *env,\n    jobject this);\nThen create a C function that does the work. Y ou must use the same function signa‐\nture as is used in the .h file.\nThis function can do whatever it wants. Note that it is passed two arguments: a JVM\nenvironment variable and a handle for the this  object. Table 18-1  shows the corre‐\nspondence between Java types and the C types (JNI types) used in the C code.\nTable 18-1. Java and JNI types\nJava type JNI Java array type JNI\nbyte jbyte byte[] jbyteArray\nshort jshort short[] jshortArray\nint jint int[] jintArray\nlong jlong long[] jlongArray\nfloat jfloat float[] jfloatArray\ndouble jdouble double[] jdoubleArray\nchar jchar char[] jcharArray\nboolean jboolean boolean[] jbooleanArray\nvoid jvoid\nObject jobject Object[] jobjectArray\nClass jclass\nString jstring\narray jarray\nThrowable jthrowable\n18.6 Calling Other Languages via Native Code | 573\nExample 18-11  is a complete C native implementation. Passed an object of type Hello\nJni.java , it increments the integer myNumber  contained in the object.\nExample 18-11. main/src/main/java/jni/HelloJni.c\n#include <jni.h>\n#include ""HelloJni.h""\n#include <stdio.h>\n/*\n * This is the Java Native implementation of displayHelloJni.\n */\nJNIEXPORT void JNICALL Java_HelloJni_displayHelloJni(JNIEnv *env, jobject this) {\n  jfieldID fldid;\n  jint n, nn;\n  (void)printf(""Hello from a Native Method\n"");\n  if (this == NULL) {\n    fprintf(stderr, ""'this.' pointer is null!\n"");\n    return;\n  }\n  if ((fldid = (*env)->GetFieldID(env,\n        (*env)->GetObjectClass(env, this), ""myNumber"", ""I"")) == NULL) {\n    fprintf(stderr, ""GetFieldID failed"");\n    return;\n  }\n  n = (*env)->GetIntField(env, this, fldid);/* retrieve myNumber */\n  printf(""\""myNumber\"" value is %d\n"", n);\n  (*env)->SetIntField(env, this, fldid, ++n);/* increment it! */\n  nn = (*env)->GetIntField(env, this, fldid);\n  printf(""\""myNumber\"" value now %d\n"", nn); /* make sure */\n  return;\n}\nFinally, you compile the C code into a loadable object. Naturally, the details depend\non platform, compiler, etc. For example, on Windows, you could use this:\n> set JAVA_HOME=C:\java               # or wherever\n> set INCLUDE=%JAVA_HOME%\include;%JAVA_HOME%\include\Win32;%INCLUDE%\n> set LIB=%JAVA_HOME%\lib;%LIB%\n> cl HelloJni.c -Fehello.dll -MD -LD\nAnd on Unix, you could use this:\n$ export JAVAHOME=/local/java    # or wherever\n$ cc -I$JAVAHOME/include -I$JAVAHOME/include/solaris \\n -G HelloJni.c -o libhello.so\nExample 18-12  is a makefile for Unix.\n574 | Chapter 18: Using Java with Other Languages\nExample 18-12. main/src/main/java/jni/Makefile  (Unix version)\n# Configuration Section\nCFLAGS_FOR_SO = -G # Solaris\nCFLAGS_FOR_SO = -shared\nCSRCS        = HelloJni.c\n# JAVA_HOME should be been set in the environment\n#INCLUDES    = -I$(JAVA_HOME)/include -I$(JAVAHOME)/include/solaris\n#INCLUDES    = -I$(JAVA_HOME)/include -I$(JAVAHOME)/include/openbsd\nINCLUDES    = -I$(JAVA_HOME)/include\nall:        testhello testjavafromc\n# This part of the Makefile is for C called from Java, in HelloJni\ntesthello:        hello.all\n        @echo\n        @echo ""Here we test the Java code \""HelloJni\"" that calls C code.""\n        @echo\n        LD_LIBRARY_PATH=`pwd`:. java HelloJni\nhello.all:        HelloJni.class libhello.so\nHelloJni.class: HelloJni.java\n        javac HelloJni.java\nHelloJni.h:    HelloJni.class\n        javah -jni HelloJni\nHelloJni.o::    HelloJni.h\nlibhello.so:    $(CSRCS) HelloJni.h\n    $(CC) $(INCLUDES) $(CFLAGS_FOR_SO) $(CSRCS) -o libhello.so\n# This part of the Makefile is for Java called from C, in javafromc\ntestjavafromc:    javafromc.all hello.all\n    @echo\n    @echo ""Now we test HelloJni using javafromc instead of java""\n    @echo\n    ./javafromc HelloJni\n    @echo\n    @echo ""That was, in case you didn't notice, C->Java->C. And,""\n    @echo ""incidentally, a replacement for JDK program \""java\"" itself!""\n    @echo\njavafromc.all:    javafromc\njavafromc:    javafromc.o\n    $(CC) -L$(LIBDIR) javafromc.o -ljava -o $@\njavafromc.o:    javafromc.c\n18.6 Calling Other Languages via Native Code | 575",8688
739-See Also.pdf,739-See Also,,0
740-18.7 Calling Java from Native Code.pdf,740-18.7 Calling Java from Native Code,,0
741-Problem.pdf,741-Problem,,0
742-Discussion.pdf,742-Discussion,"$(CC) -c $(INCLUDES) javafromc.c\nclean:\n    rm -f core *.class *.o *.so HelloJni.h\nclobber: clean\n    rm -f javafromc\nAnd you’re done! Just run the Java interpreter on the class file containing the main\nprogram. Assuming that you’ve set whatever system-dependent settings are necessary\n(possibly including both CLASSPATH  and LD_LIBRARY_PATH  or its equivalent), the pro‐\ngram should run as follows:\nC> java jni.HelloJni\nHello from a Native Method      // from C\n""myNumber"" value is 42          // from C\n""myNumber"" value now 43         // from C\nValue of myNumber now 43        // from Java\nCongratulations! Y ou’ve called a native method. However, you’ve given up portability;\nthe Java class file now requires you to build a loadable object for each operating sys‐\ntem and hardware platform. Multiply {Windows, Mac OS X, Sun Solaris, HP/UX,\nLinux, OpenBSD, NetBSD, FreeBSD} times {Intel-32, Intel-64/AMD64, Arm,\nArm-64, and maybe SPARC64, PowerPC, and HP-PA}, and you begin to see the\nportability issues.\nBeware that problems with your native code can and will crash the runtime process\nright out from underneath the Java Virtual Machine. The JVM can do nothing to pro‐\ntect itself from poorly written C/C++ code. Memory must be managed by the pro‐\ngrammer; there is no automatic garbage collection of memory obtained by the system\nruntime allocator. Y ou’re dealing directly with the operating system and sometimes\neven the hardware, so, be careful. Be very careful.\nSee Also\nIf you need more information on Java native methods, you might be interested in the\ncomprehensive treatment found in Essential JNI: Java Native Interface  by Rob Gordon\n(Prentice Hall).\n18.7 Calling Java from Native Code\nProblem\nY ou need to go the other way, calling Java from C/C++ code.\nSolution\nUse JNI again.\n576 | Chapter 18: Using Java with Other Languages\nDiscussion\nJNI (Java Native Interface) provides an interface for calling Java from C, with calls to:\n1.Create a JVM.\n2.Load a class.\n3.Find and call a method from that class (e.g., main).\nJNI lets you add Java to legacy code. That can be useful for a variety of purposes and\nlets you treat Java code as an extension language.\nThe code in Example 18-13  takes a class name from the command line, starts up the\nJVM, and calls the main()  method in the class.\nExample 18-13. main/src/main/java/jni/javafromc.c (Calling Java from C)\n/*\n * This is a C program that calls Java code.\n * This could be used as a model for building Java into an\n * existing application as an extention language, for example.\n */\n#include <stdio.h>\n#include <jni.h>\nint\nmain(int argc, char *argv[]) {\n    int i;\n    JavaVM *jvm;        /* The Java VM we will use */\n    JNIEnv *myEnv;        /* pointer to native environment */\n    JDK1_1InitArgs  jvmArgs; /* JNI initialization arguments */\n    jclass myClass, stringClass ;    /* pointer to the class type */\n    jmethodID  myMethod ;    /* pointer to the main() method */\n    jarray args;        /* becomes an array of Strings */\n    jthrowable  tossed;    /* Exception object, if we get one. */\n    JNI_GetDefaultJavaVMInitArgs (&jvmArgs);    /* set up the argument pointer */\n    /* Could change values now, like: jvmArgs.classpath = ...; */\n    /* initialize the JVM! */\n    if (JNI_CreateJavaVM (&jvm, &myEnv, &jvmArgs) < 0) {\n        fprintf(stderr, ""CreateJVM failed \n"");\n        exit(1);\n    }\n    /* find the class named in argv[1] */\n    if ((myClass = (*myEnv)->FindClass (myEnv, argv[1])) == NULL) {\n        fprintf(stderr, ""FindClass %s failed \n"", argv[1]);\n        exit(1);\n18.7 Calling Java from Native Code | 577\n    }\n    /* find the static void main(String[]) method of that class */\n    myMethod  = (*myEnv)->GetStaticMethodID (\n        myEnv, myClass, ""main"", ""([Ljava/lang/String;)V"" );\n    /* myMethod = (*myEnv)->GetMethodID(myEnv, myClass, ""test"", ""(I)I""); */\n    if (myMethod  == NULL) {\n        fprintf(stderr, ""GetStaticMethodID failed \n"");\n        exit(1);\n    }\n    /* Since we're calling main, must pass along the command line arguments,\n     * in the form of Java String array\n     */\n    if ((stringClass  = (*myEnv)->FindClass (myEnv, ""java/lang/String"" )) == NULL){\n        fprintf(stderr, ""get of String class failed!! \n"");\n        exit(1);\n    }\n    /* make an array of Strings, subtracting 1 for progname & 1 for the\n     * java class name */\n    if ((args = (*myEnv)->NewObjectArray (myEnv, argc-2, stringClass , NULL))==NULL) {\n        fprintf(stderr, ""Create array failed! \n"");\n        exit(1);\n    }\n    /* fill the array */\n    for (i=2; i<argc; i++)\n        (*myEnv)->SetObjectArrayElement (myEnv,\n            args, i-2, (*myEnv)->NewStringUTF (myEnv, argv[i]));\n    /* finally, call the method. */\n    (*myEnv)->CallStaticVoidMethodA (myEnv, myClass, myMethod , &args);\n    /* And check for exceptions */\n    if ((tossed = (*myEnv)->ExceptionOccurred (myEnv)) != NULL) {\n        fprintf(stderr, ""%s: Exception detected: \n"", argv[0]);\n        (*myEnv)->ExceptionDescribe (myEnv);    /* writes on stderr */\n        (*myEnv)->ExceptionClear (myEnv);    /* OK, we're done with it. */\n    }\n    (*jvm)->DestroyJavaVM (jvm);    /* no error checking as we're done anyhow */\n    return 0;\n}\n====\n578 | Chapter 18: Using Java with Other Languages",5368
743-Afterword.pdf,743-Afterword,"Afterword\nWriting this book—and keeping it up to date—has been a humbling experience. It has\ntaken far longer than I had predicted or than I would like to admit. And, of course,\nit’s not finished yet. Despite my best efforts and those of the technical reviewers, edi‐\ntors, and many other talented folks, a book this size is bound to contain errors, omis‐\nsions, and passages that are less clear than they might be. Do let us know if you hap‐\npen across any of these things; you can view and submit errata through them the\nbook’s catalog page . Subsequent editions will incorporate changes sent in by readers\njust like you!\nIt has been said that you don’t really know something until you’ve taught it. I have\nfound this true of lecturing, and I find it equally true of writing.\nI tell my students that when Java was very young, it was possible for one person to\nstudy hard and know almost everything about it. After a release or two, this was no\nlonger true. Today, nobody in his or her right mind would seriously claim to “know\nall about Java”—if they do, it should cause your bogosity detector to go off at full vol‐\nume. And the amount you need to know keeps growing. How can you keep up? Java\nbooks? Java magazines? Java courses? Conferences? There is no single answer; all of\nthese are useful to some people. Oracle and others have programs that you should be\naware of:\n•For many years, JavaOne was the dominant conference on Java, put on by Sun\nMicrosystems and briefly by Oracle. Recently, Oracle has folded this into Code\nOne , the annual Oracle conference.\n•Marcus Biel has a pretty complete list of worldwide Java conferences .\n•The Oracle Java Technology Network , a free web-based service for getting the lat‐\nest APIs, news, and views.\n•Over Java’s lifetime, the publishing industry has changed a lot. There used to be\nseveral Java-related magazines published in print, some of whose articles would\nappear on the web. Today there are, so far as I know, no print magazines dedica‐\ndlxxix\nted to Java. Oracle currently (2020) publishes the online-only Java Magazine\nevery month with technical articles on many aspects of Java (including some by\nyours truly); see the magazine’s website  to view the latest issue and back issues.\n•The Java Community Process , the home of Java standardization and enhance‐\nment.\n•The OpenJDK community  maintains and builds the open source version of the\n“official” JDK.\n•O’Reilly books  and conferences  are among the very best available!\n•I keep my own list of Java resources that I update sporadically, on my Java site ;\nfollow the link to Java Resources.\n•The most interesting advanced topic discussions show up in Heinz Kabutz’s Java\nSpecialists Newsletter .\nThere is no end of Java APIs to learn about. And there are still more books to be\nwritten . . . and read.\ndlxxx | Afterword",2873
744-Appendix A. Java Then and Now.pdf,744-Appendix A. Java Then and Now,,0
745-Introduction Always in Motion the Java Is.pdf,745-Introduction Always in Motion the Java Is,,0
746-What Was New in Java 8.pdf,746-What Was New in Java 8,,0
747-Java 8 API Changes.pdf,747-Java 8 API Changes,"6Sun Microsystems, “Java Technology: The Early Y ears” article can be found at https://web.archive.org/web/\n20090311011509/http://java.sun.com/features/1998/05/birthday.html  and on the Paderborn University website\nat http://gcc.upb.de/www/WI/WI2/wi2_lit.nsf/7544f3043ee53927c12573e70058bbb6/\nabf8d70f07c12eb3c1256de900638899/$FILE/Java%20Technology%20-%20An%20early%20history.pdf .APPENDIX A\nJava Then and Now\nIntroduction: Always in Motion the Java Is\nJava has always been a moving target for developers and writers. I meet developers\nin my commercial training programs who are still not aware of some of the features\nadded to ancient Java releases, let alone current ones. This appendix looks at each of\nthe major releases of Java. See Jon Byous’s Sun Microsystems article  “Java Technology:\nThe Early Y ears” for a review of Java’s early history. Y ou can also find a copy at the\nPaderborn University website.6\nDetails on releases prior to Java 8 are considered ancient history and have been\nmoved to my website, https://darwinsys.com/java/ancientHistory.html .\nWhat Was New in Java 8\nJava 8 Language Changes\nThe biggest new feature in the Java 8 language is lambda expressions. After a decade\nof debate on how to implement them, closures, or lambda expressions, finally arrived\nwith Java 8. This is such a vast topic that it gets an entire chapter in this edition; see\nChapter 9 .\nAnnotations can now be placed on structured types.\n581",1461
748-Java 9 Language Changes.pdf,748-Java 9 Language Changes,"Java 8 API Changes\nJava 8 brings in the new date/time API from JSR-310. This provides a more consistent\nand sensible set of classes and routines for dealing with time. Chapter 6  has been\ncompletely rewritten to use the new API, ending with a recipe showing various con‐\nversions between the old and new APIs.\nJava 8 introduced functional programming techniques such as closures, Streams , and\nparallel collections, which we discuss in Chapter 9 . In support of Streams , there are\nnew methods in interfaces such as List , Map, and Set, which had until now been\nlargely unchanged since the long-gone days of Java 1.1. Fortunately the Java 8 lan‐\nguage support adds a default  method type in interfaces, so your custom implemen‐\ntations of these interfaces are not required to change (as long as you make sure you\nchange your IDE settings to an up-to-date compiler level).\nAs one example of default  methods in action, Iterable  gets a new default  method\ncalled forEach() , which lets you write code like this:\nmyList.forEach(e -> /* do something with e here... */ );\nThis is discussed further in “Iterable.forEach method (Java 8)” on page 198 .\nA new JavaScript implementation codenamed Nashorn  is available via javax.script\n(see Recipe 18.3 ) and can also be run from the command line.\nJavadoc (see Recipe 15.2 ) was extended to the javax.tools  API.\nAnnotations can be repeated, obviating the need to manually code wrapper annota‐\ntions, for example, javax.persistence.NamedQueries  (plural), which is just a con‐\ntainer for a list of javax.persistence.NamedQuery  (singular) annotations.\nFinally, Java provides support for Base 64 encoding/decoding in the form of\njava.util.Base64  with two nested classes for encoding and decoding.\nThere were also dozens of other small changes, such as those covered by OpenJDK .\nWhat Was New in Java 9\nJava 9 is best known for introducing the Java Platform Module System, JPMS.\nSince the JDK itself is modularized (the original intention of JPMS!), the new jlink\ntool lets you build a minimal JDK with only the parts needed for your modularized\napplication.\nAnother new tool is JShell, a REPL (Read-Evaluate-Print-Loop) expression evaluator\nfor Java. Also known as an interactive Java, JShell is useful for prototyping, trying out\nnew ideas, and so on. JShell is covered in Recipe 1.4 .\n582 | Appendix A: Java Then and Now",2396
749-Java 9 API Changes.pdf,749-Java 9 API Changes,,0
750-What Was New in Java 10 March 2018.pdf,750-What Was New in Java 10 March 2018,,0
751-Java 10 API Changes.pdf,751-Java 10 API Changes,"This release also marked the beginning of the six-month major release cadence, in\nwhich a new major release (Java 10, Java 11, etc) would be made available every six\nmonths. At the same time, Java 8 and Java 11 were declared to be LTS (Long-Term\nSupport) releases.\nJava 9 Language Changes\nThe new module-info  file introduces several pseudokeywords, words which have\nreserved meaning only in a module-info  file, but can still be used as user-defined\nnames in Java classes. These include module, requires, exports, provides, with, and a\nfew others. This also impacts the meaning of the visibility modifiers when used\nwithin a module.\nInterfaces (which added default methods in Java 8) now allow private methods as\nwell, for use by default methods.\nJava 9 API Changes\nImprovements to the Streams API, with several new methods in the Stream  interface.\nImprovements to the Collections API, including the of()  factory method to quickly\ncreate a List  or Set from several values.\nWhat Was New in Java 10 (March 2018)\nJava 10 is famous for the var keyword and the first actual release on the six-month\ncadence.\nJava 10 introduces GraalVM, a just-in-time compiler (like HotSpot) but written in\nJava.\nIn Java 10, the OpenJDK version of the cacerts  file is fully populated, making it far\nmore likely that connecting via https  will work out of the box.\nThe javah  tool for native code headers is removed, replaced by equivalent-or-better\nfunctionality in javac  itself.\nJava 10 Language Changes\nThe var keyword, for local variables only, allows you to not fuss over the actual type\nof a variable. Of course the compiler must be able to infer the type of the variable.\nLet’s explore some options in jshell :\njshell> var x = 10;\nx ==> 10\njshell> var y = 123.4d;\nJava Then and Now | 583",1809
752-What Was New in Java 11 September 2018.pdf,752-What Was New in Java 11 September 2018,"y ==> 123.4\njshell> var z = java.time.LocalDateTime .now();\nz ==> 2019-08-31T20:47:36.440491\njshell> var map = new HashMap<String,Integer>();\nmap ==> {}\njshell> map.put(""Meh"", 123);\n$4 ==> null\njshell> var huh;\n|  Error:\n|  cannot infer type for local variable  huh\n|    (cannot use 'var' on variable  without initializer )\n|  var huh;\n|  ^------^\njshell>\nSomewhat surprisingly, var is not actually a language keyword, so this word can still\nbe used as a user-defined name:\njshell> var var = 123;\nvar ==> 123\njshell> var\nvar ==> 123\nSee https://developer.oracle.com/java/jdk-10-local-variable-type-inference.html  for\nexplanation and more details on var.\nJava 10 API Changes\nList  and Set add the new copyOf()  method to make a truly unmodifiable copy; the\nprevious List.unmodifiableList()  made an  unmodifiable  view , which would\nappear to change if the underlying List  were changed.\nSee Also\nQuite a few old features were removed or deprecated; see this list on DZone .\nSimon Ritter has an article titled “Java 10 Pitfalls for the Unwary” .\n584 | Appendix A: Java Then and Now",1110
753-Java 11 API Changes.pdf,753-Java 11 API Changes,,0
754-What Was New in Java 12 March 2019.pdf,754-What Was New in Java 12 March 2019,,0
755-Java 12 Language Changes.pdf,755-Java 12 Language Changes,,0
756-What Is New in Java 13 September 2019.pdf,756-What Is New in Java 13 September 2019,"What Was New in Java 11 (September 2018)\nJava 11 introduced what I call “single-file run-from-source” (JEP 330); you can now\ntype the following:\njava HelloWorld.java\nand the Java command will both compile and run the named program. This makes it\nmuch  easier to work with single files, which is the primary thing it works with. If you\nhave two or more files, the second through nth must be compiled and on your CLASS\nPATH ; the source file you specify on the command line must be the one with main()\nand must not be compiled on your CLASSPATH . So it’s good for simple things, but not\nfor complex applications.\nSee also this list on DZone .\nJava 11 API Changes\nFor a more complete list of Java 11 changes, see this DZone list .\nWhat Was New in Java 12 (March 2019)\nJava 12 introduced the notion of Preview Changes , features added to the JDK but not\nyet made part of the official specification. This is basically what others might have\ncalled beta mode; if enough users indicate that they have serious issues with a Preview\nMode feature, the JDK team can fix it or even kill it off before declaring it part of the\nJDK specification (or declaring it dead).\nJava 12 Language Changes\n•switch  statements that can yield a value (Preview)\nJava 12 API Changes\nSome of the more visible changes:\n•A Tee Collector for Stream s (copies input to multiple output Stream s).\n•A CompactNumberFormat , replacing my ScaledNumberFormat  (prints the number\n2,048 as 2K, for example).\n•String.indent(n)  returns a copy of the String  with n spaces prepended.\n•GC improvements (JEP 189: Shenandoah: Low-Pause-Time GC); pause-time\nimprovements to G1 GC.\nJava Then and Now | 585",1685
757-Looking Ahead.pdf,757-Looking Ahead,"There are numerous other minor changes; see https://www.azul.com/39-new-features-\nand-apis-in-jdk-12  and https://openjdk.java.net/projects/jdk/12 .\nWhat Is New in Java 13 (September 2019)\nJava 13 was the latest official release as of this writing. It includes the following\nfeatures:\n•Improved garbage collection (again)\n•Improved application class-data sharing (AppCDS) to allow writing an archive of\nall classes used in an app\n•Text blocks  to replace and simplify multiline String  literals (Preview)\n•Improvements to switch  statements that can yield a value\n•Rewrite of the Socket  and ServerSocket  implementation (not changing the API)\nSee also this JavaWorld article .\nLooking Ahead\nThere will be a Java 14 in 2020, around the time that this book goes to press.\nThese are some of the features that are in the works:\n•Record types (in Preview; see Recipe 7.18 ).\n•Sealed types, which permit a class designer to control subclassing by enumerating\nall the allowed subclasses. The syntax at present looks like this:\npublic abstract sealed class Person permits Customer, SalesRep {\n    ...\n}\nclass Customer extends Person {\n    ...\n}\n•Text blocks, a.k.a. multiline text strings, delimited with a triplet of double quotes:\nString long = """"""\nThis is a long\ntext String.""""""\n•A new packaging tool, jpackage , which will generate a complete self-installing\napplication on the main supported operating systems.\nThere are several other interesting JEPs for Java 14. A complete list can be found at\nOpenJDK . The JEPs linked from that page are interesting reading for those interested\n586 | Appendix A: Java Then and Now\nin the rationale for (and the amount of work that goes into) each of these new fea‐\ntures.\nThere will also be a Java 15 in 2020, but it entered Early Access just as this book was\ngoing to print, so we don’t have coverage of it in this edition. “ Always in motion Java’s\nfuture is, ” Y oda says.\nThe Evolution of Client-Side Java: Applets, Browser Wars, Swing, JavaFX\nWhile you can infer some of this from the per-JDK revision notes given in the rest of\nthis appendix, it seems fitting to provide a unified narrative on the role of Java in the\ndesktop.\nJava began its public life as a vehicle for embedding flashy dynamic content in web\npages via Java applets. Applets got off to a flying start with their incorporation in the\nNetscape line of browsers in 1995–96. Incidentally, part of the cross-licensing agree‐\nment between Sun and Netscape was that Netscape could use the term “JavaScript”\nfor what was then its “LiveScript” web scripting language.\nApplets never took over the world for a variety of reasons, including the fact that\nMicrosoft never allowed Java applets to become a full player in Internet Explorer (at\nthat time one of the most widely used browsers), users’ fear of security issues (some of\nwhich surfaced from time to time), difficulties of installing and updating, and the\nincreasing capabilities of CSS and JavaScript, and later HTML5.\nThere were some large users—for example, the Blackboard product  used for student–\ninstructor communication in hundreds of colleges and universities. However, even\nthese have had issues of compatibility, sometimes requiring students to load a particu‐\nlar update like JDK 1.6 Update 42 in order to be supported on a given release of\nBlackboard.\nAlong the way, the original AWT GUI package was supplanted by Swing, a newer and\nbetter GUI package. Around this time, the Applet  class was supplemented with the\nJApplet  class to allow Applets  to be full users of Swing GUI classes.\nY et Java was never without competition on the desktop. Adobe Flash came along soon\nafter Java. It was single-sourced and came from the home of Illustrator and Photo‐\nshop, which the web’s graphic designers loved, and therefore Flash prospered.\nMore recently, the browsers themselves have become competitors to both Java and\nFlash. The HTML5 standard introduces a large number of technologies such as\nincreased JavaScript, the Canvas  object for graphics, and access to some local devices.\nMany new projects today are starting with HTML5. Though JavaScript is not as nice a\nprogramming environment as Java, its familiarity to the large number of web devel‐\nopers in circulation has helped it dominate large areas of desktop development. So\nboth Java applets and Adobe Flash are dead or dying, replaced by browser-native\ncapabilities.\nJava Then and Now | 587\nOne of Sun’s responses was to target a new technology that is now called JavaFX to the\ndesktop. JavaFX can be used in browsers or in desktop applications. It does provide\nconsiderable benefits to GUI and graphics developers. There is information on Jav‐\naFX at https://openjfx.io .\nAlso in the area of client-side technologies, Sun insisted from the beginning that\nmobile phone developers use the Java Micro Edition (ME), based on a severely cut-\ndown JVM and a totally different user interface package. Fortunately for Sun, Black‐\nBerry (then called Research In Motion, or RIM), agreed to this. At the time, it made\nsense—when the early versions of BlackBerry OS came out, mobile CPUs were slow,\nand memory was limited, so a tiny LCDUI made sense.\nWhen Google wanted to expand into the mobile space to expand the reach of its\nadvertising business, it soon found—and bought—a company called Android that\nhad a Linux-based OS with a rewritten Java implementation. Android’s developers\nhad tried to reason with Sun about using more complete Java on mobile, given how\nmobile device CPU and memory were growing, but the negotiations were not suc‐\ncessful. So Android went off and built its own user interface, which has since become\nthe most widely used Java platform. But during this time, Sun was acquired by Oracle.\nLive on stage at the first JavaOne conference after the acquisition, Larry Ellison wel‐\ncomed Android as part of the Java ecosystem. But when Android continued its mete‐\noric rise, Oracle’s lawyers thought they could muscle in on this, and Oracle sued Goo‐\ngle for a billion dollars, alleging copyright, trademark, and trade secret violations. The\nsuit was very complex, but one of the most important aspects was Oracle’s claim that\nit could copyright the API separately from the code. Thus, anybody ever wanting to\nwrite a class called String  with the methods described in the String  class’s javadoc\npage would—in Oracle’s theory—have to apply for permission from Oracle. Needless\nto say, several old-line software companies like Microsoft lined up with Oracle, while\nthe entire open source world lined up with Google, fearing the “chilling effects” this\nwould have on the entire open source world. And, fortunately for Android and for\nthe open source world, so did the judge. This suit was won by Google, but Oracle\nlaunched an appeal, which unfortunately for the open source world, was successful.\nOh, and back to BlackBerry. Unfortunately for BlackBerry, as time and Moore’s law\nmarched on in tandem, Java ME did not keep in step and was left behind. BlackBerry,\nobligated to stay on the ME platform, and unable to modify the Java ME classes, had\nto spend billions of dollars in R&D through the late 1990s and the 2000s building a\nparallel package structure to provide modern GUI and device capabilities, which it\ndid all through OS versions 5, 6, and 7. When it finally dawned on RIM management\nthat the JVM+OS combination itself was the bottleneck, they first tried to make their\ncurrent JVM run on QNX, a Unix-based operating system from a company of the\nsame name, which RIM acquired. This was doomed to failure, but a skunkworks\nproject within the company took the open source Android and made that run in a\nmatter of weeks. Management decided to abandon Java ME and Java as its main\ndevelopment language but allow Java-based Android apps to run as almost-first-class\n588 | Appendix A: Java Then and Now\ncitizens in the BB10 environment. Alas, it took them a year and a half to get QNX\nworking well enough on its new BlackBerry 10 devices that they could release it. Dur‐\ning this time of uncertainty its sales tanked. BB10 was available for a while and\nworked well enough (and ran most Android apps). But unfortunately, the delay in\ngetting to market was fatal, and BlackBerry devices now run Android. BlackBerry is\nrepositioning QNX as an automotive platform and is selling security software. Black‐\nBerry as a mobile platform is thus dead.\nJava continues to be used on the desktop (although the market for desktop apps is\nsteadily losing ground to mobile devices and increasingly capable native applications)\nand in mobile (particularly on Android devices). Java also continues to be heavily\nused in enterprise environments using packages like Java EE servers, JSP/JSF pages,\nSpring Framework, and Hibernate.\nJava Then and Now | 589",8902
758-Index.pdf,758-Index,"Index\nSymbols\n+ operator, 65\n- (dash), 48\n/ (filename separator), 48\n/bin/false command, 37\n: (PATH separator), 48\n:$PATH, 4\n\ (escape character), 48\nA\nabstract class, 250\nabstract methods, 253\naccented characters, 120\naccept() method, 418, 424, 426\nacceptCamera() method, 280\nactionPerformed() method, 274\nADAMS, 368\nadd() method, 192, 193, 201, 201, 498\nadd-on libraries, JSF, 42\naddElement() method, 193\naddresses, network, 389-391\nAgile Software Development Ecosystems\n(Highsmith), xx\naligning strings, 69-72\nalternatives command, 4\nAndroid\nabout, 588\ndeveloping for, 6\nlocales and, 87\nAndroid Cookbook (Darwin), xvii\nanimation, 489-492\nannotations\nabout, 468\ndefining with reflection, 542-547plug-in-like classes, finding with, 547\nusing with reflection, 542-547\nanonymous methods, 276\nanonymous package, 463\nAnt (Apache), 21, 22\nANTLR, 320\nApache (website), 22\nApache Ant, 21, 22\nApache Buildr, 21, 22\nApache Commons Math library, 155\nApache Commons Project, 553\nApache Commons StringUtils, 95\nApache DeltaSpike, 42, 277\nApache Harmony, 3\nApache Jakarta Commons Logging (JCL), 436\nApache Logfile Parsing program, 123\nApache Logging Services Project, 436\nApache Maven\nabout, 15, 21, 22, 23\nautomating with, 23-27\ndependency management and, 22, 26\nmodules, 16\npros and cons of, 26\nrepositories and, 19\nApache Software Foundation, 41\nApache Spark, 369-371\nApache Subversion, 20\nAPIs, packaged, 51\nappend() methods, 65, 66, 73, 536\nappendReplacement() method, 112\nappendTail() method, 113\napplets, 587\napply() method, 282\napplyAsInt() method, 282\n591\napplyPattern() method, 143\nArrayList, 190, 233-235\narrays, 188, 222\nArrays.asList() method, 193\nArrays.binarySearch() method, 221\nArrays.of() method, 199\nArrays.sort() method, 213, 221\narrow notation, 278\nThe Art of Computer Programming (Knuth),\nxix\nAsciiDoctor, xiv\nAssertJ, 33\nassertThat() method, 33\nassignment arrow (R language), 373\nasynchronous sockets, 384\natZone() method, 182\nauto-boxing/auto-unboxing, 135\nB\nBakker, Paul\nJava 9 Modularity: Patterns and Practices\nfor Developing Maintainable Applica‐\ntions, xviii , 52, 482\nBates, Bert\nHead First Design Patterns, 239\nHead First Java, xiv, xviii\nBeanShell, 555\nBeck, Kent\neXtreme Programming, 31\nExtreme Programming Explained, xx\nBiel, Marcus, dlxxix\nBien, Adam\nReal World Java EE Patterns: Rethinking\nBest Practices, xviii\nBig Data (see data science)\nbig numbers, 133\nbinary data\nas input/output, 331\nreading/writing over networks, 394-397\nreturning over sockets, 418-420\nbinary numbers, 146\nbinarySearch() method, 220\nbison, 320\nBitbucket, 41\nBlackBerry, 588\nBloch, Joshua\nEffective Java, 238, 256\nJava Puzzlers books, xiii\nboolean matches() method, 106BootsFaces (JSF), 42\nbridging, 194\nBrown, Doug, 320\nbrowsers, 587\nBSD license, 19\nBSD make, 21\nBuild Now icon, 37\nBuildr (Apache), 21, 22\nBurke, Bill\nRESTful Java with JAX-RS 2.0, 2nd Edition,\n388\nButterFaces (JSF), 42\nC\nCalendar classes, 30, 182-184\ncalendars, adding to/subtracting from, 177\ncall() method, 485\ncancel() method, 487\nCANON-EQ flag, 119\ncanonical matching, 120\ncanonical name, 344\ncase, 81, 119\nCASE_INSENSITIVE flag, 120\ncatch clause, 39\nCDI (Context and Dependency Injection), 265,\n267\nCDI Beans, 470\nChambers, John, 374\ncharacter sets, converting, 329\ncharacter strings (see strings)\ncharAt() method, 58, 68, 73\nChat Client program, 406-410\nchecksum, 69\nCheswick, William R.\nFirewalls and Internet Security, 447\nChoiceFormat, 149\nchoose() method, 278\nCI (Continuous Integration), 21, 34-38\nCircleCI, 35\nclass statement, 13\nclass-like constructs, 542\nClass.forName() method, 270\nclasses\nClassLoader, constructing with, 529-530\nJavaCompiler, constructing with, 530-533\nlisting, in packages, 539-541\nloading/instantiating dynamically, 526-528\nplug-in-like, 547\npreparing as JavaBeans, 469-473\n592 | Index\nprinting information of, 537-538\nreflection and, 520\nClassLoader, 529-530\nCLASSPATH\nabout, 2\nenvironment variable, setting as an, 14\nJAR files, adding, 51\nusing, 13\nclean command (Maven), 25\ncleanUp() method, 238\nclear() method, 192\nClojure, 274, 556\nclone() method, 238, 246, 263\nclose() method, 290\nclosures, 276-279\ncloz() method, 290\nCoad, Peter\nJava Design, xx\ncode\ncompletion, 5\nContinuous Integration (CI) and, 34-38\ndownloading examples, 15-22\nexamples, xxii\ncode folding, 279\nCode One, dlxxix\ncode reuse, 464\nCodehaus, 41\ncodePointAt() method, 68\nColebourne, Stephen, 167\ncollect() method, 284, 287\ncollections\nconverting to arrays, 222\nfinding objects in, 220-222\nsorting, 213-218\nCollections API, 237\nCollections Framework, 186, 189\nCollections.binarySearch() method, 222\nCollections.sort() method, 213\ncollectors, simplifying streams with, 284-287\ncom.darwinsys packages, 17\ncommand prompt window, 307\ncommand-line Git client, 20\nCOMMENTS flag (regex), 120\nCommons BeanUtils, 553\nComparator.comparing() method, 214\ncompareToIgnoreCase() method, 292\ncompile command (Maven), 25\ncompiling, 2, 23-29\ncomplete() method, 488complex numbers, 155-156\ncomposite characters, matching, 120\ncompressing tabs, 76-80\ncompute() method, 511\ncomputeArea() method, 253\ncomputeReplacement method, 114\nConcurrency Utilities, 484\nConcurrent Versions System (CVS), 20\nconsole() method, 307\nconsoles, reading from, 304-307\ncontains() method, 192, 201, 220\ncontainsKey() method, 220\ncontainsValue() method, 220\nContext and Dependency Injection (CDI), 265,\n267\nContinuous Integration (CI), 21, 34-38\ncontinuous time, 168\ncopyOf() method, 584\nCPAN (Comprehensive Perl Archive Network),\n568\nCRAN (Comprehensive R Archive Network),\n372\ncreateDirectories() method, 345\ncreateDirectory() method, 323, 345\ncreateFile() method, 323, 345\ncreateNewFile() method, 353\ncreateTempDirectory() method, 351\ncreateTempFile() method, 351, 353\nCreating Effective JavaHelp (Lewis), 467\nCrossRef program, 549-553\nCruiseControl, 35\nculture lessons, 85\nCUP, 320\nCVS (Concurrent Versions System), 20\nCygWin, 98\nCzarnecki, David\nJava Internationalization, 85\nD\ndaemon, 93\nDahm, Markus, 553\nDarwin, Ian\nAndroid Cookbook, xvii\ndarwinsys-api repository, 16, 17-18, 26\nData Mining: Practical Machine Learning and\nTechniques (Witten), 369\ndata science, 367\ndata structures, 185-235\nabout, 185\nIndex | 593\nArrayLists and, 190\narrays and, 186\ncollections framework, 189\nconverting collections to arrays, 222\ngeneric types in classes, 194-197\nHashMap, 207-209\nHashtable, 207-209\niterating over, 197-200\nIterator interface and, 223-226\nlinked lists, 202-207\nmultidimensional, 229-231\nobject stacks, 226-229\nresizing arrays, 188\nSet inteface, 201\nsimplifying data objects, 231-233\nsorting collections, 213-218\nsorting, avoiding, 218-220\nstoring strings, 209-213\nTiming Comparisons program, 233-235\ndata, using in Apache Spark, 369-371\nDatabase Programming with JDBC & Java\n(Reese), xviii\nDatabricks, 369\nDate class, 30\nDate/Time API, 167-184\nabout, 167\nadding to, 177\nbasics of, 169\nCalendar classes, 182-184\ncomputing periods between dates with, 176\nconverting, 174\ncurrent date/time, finding, 170\nformatting with, 172-173\nhuman time, 169\nlegacy code and, 182-184\nmethods, 168\npackages, 168\nparsing strings, 175\nperiods, adding or subtracting, 177\nrecurring events, 178-180\nsupport, 170\ntime zones and, 181\nDateFormat class, 30\nDateFormatter, 172\ndebug() method, 440\ndecimal numbers, 146\nDeep Java Learning (DJL), 368\nDeepLearning4Java, 153, 368\ndefault method, 226defineClass() method, 529\nDeitsch, Andy\nJava Internationalization, 85\ndelegation, 238\ndelete() method, 66, 351\ndeleteCharAt() method, 66\ndeleteIfExists() method, 351\ndeleteOnExit() method, 352, 353\ndependency, 23-29\ndependency injection, 265-268\ndeploy command (Maven), 25\ndeployment, automating, 23-29\ndeprecation warnings, 29-31\nDercimalFormat, 143\ndesign books, xx\ndesign patterns, 239\nDesign Patterns (Gamma, Helm, Johnson and\nVlissades), xx, 31\ndesktop module (Maven), 16\ndestroy() method, 563\ndiamond operator, 192\nDigital Equipment, 417\ndirectories\ncreating, 345\nlisting, 48, 353\nroots of, 354\nDJL (Deep Java Learning), 368\ndocumentation, javadoc, 464\ndoPost() method, 503\nDOS directory list command, 48\ndot commands, 92\nDOTALL flag, 120\nDouble.equals() method, 141\nDouble.isNaN() method, 138\nDowning, Troy\nJava Virtual Machine, xviii , 553\ndownloading, 1, 15-22\ndrive letter, 358\ndynamic languages, 555\nE\nEckstein, Robert\nJava Swing, xviii\nEclipse\nabout, 6\nNew Java Class Wizard, 7\nrepositories and, 19\nRun Configuration dialog, 46\nsupport for Maven from, 25\n594 | Index\nsupport for running JUnit, 33\nwebsite, 10, 25\nEclipse Marketplace, 10\nEclipse Software Foundation, 41\neditions, GraalVM, 4\nee module (javasrc repository), 16\nEE Web containers, 15\nEffective Java (Bloch), 238, 256\nEfficient Java Matrix Library (EJML), 153\nEJB Timer Service, 515\nEJBs (Enterprise JavaBeans), 470\nEJML (Efficient Java Matrix Library), 153\nelementAt() method, 193\nThe Elements of Programming Style (Ker‐\nnighan and Plauger), xx\nELKI, 368\nEllison, Larry, 588\nemail() method, 233\nempty() method, 227\nend() method, 110\nend-of-line characters, 330\nendClass() method, 551\nendonym, 87\nEnterprise JavaBeans (EJBs), 470\nentrySet() method, 208\nenum constants, 256\nenumerations, 198, 200, 255-259\nenvironment variables, 43\nepoch seconds, 174\nepsilon, 140\nequals() method, 81, 139, 140, 201, 216, 231,\n233, 241-245, 542\nequalsIgnoreCase() method, 81\nerasure, 194\nerror handling, 391\nerror() method, 440\nescape character (\), 48\nescapes, 82\nEssential JNI: Java Native Interface (Gordon),\n576\nEvans, Benjamin\nJava in a Nutshell, xiv, xviii\nevents, recurring, 178-180\nexception handling, custom, 263\nexec() method, 556, 562, 564\nexecute() method, 487\nexitValue() method, 563\nexpanding tabs, 76-80\nextensions, 51eXtreme Programming (Beck), 31\nExtreme Programming (XP), 31\nExtreme Programming Explained (Beck), xx\nF\nfactory methods, 143\nFastR, 375, 378-380\nfatal() method (logging), 440\nfields, reflection and, 521-525\nFile class, 48\nfilename separator (/), 48\nfiles\ncopying, 324\ncreating, 345\ndeleting, 349-351\nfinding, 336-338\npath and, 338-345\nproperties of, 48\nreading, 301-304\nrenaming, 346-348\ntransient/temporary, 351-353\nFiles.copy() method, 324\nFiles.delete() method, 349\nFiles.lines() method, 286\nFiles.move() method, 347\nFiles::lines() method, 301\nFileWatcher service, 356\nfinalize() method, 238\nfind() method (regex), 109, 110\nFind: Walking a File Tree program, 361-364\nfindstr command, 98\nfinish() method, 359\nFinnegan, Ken\nJBoss Weld CDI for Java Platform, 268\nFirewalls and Internet Security (Cheswick), 447\nfirst() method (collections), 219\nfirstInMonth() method, 179\nFlanagan, David\nJava in a Nutshell, xiv, xviii\nflatMap() method, 286\nflex, 320\nFloat.isNaN() method, 138\nfloating point numbers, 132, 136, 137-142\nfluent API, 170\nfluent programming, 283\nflush() method, 420\nfolds, 284\nfoo() method, 136\nfor each loop, 68, 198, 199\nIndex | 595\nfor loop, 68, 198, 200, 208\nFord, Neal\nFunctional Thinking, 276\nforEach() method, 192, 199, 208, 249, 582\nfork() method, 511\nfork/join framework, 511-514\nformat() method, 70, 92, 308\nformatting\ndates/times, 172-173\nnumbers, 142-146\nwith correct plurals, 149\nFowler, Martin\non Continuous Integration (CI), 34\nRefactoring, xx\nUML Distilled, xxi\nFriedl, Jeffrey\nMastering Regular Expressions, 99\nfunctional interface, 198, 274, 276\nfunctional programming, 273-295\nabout, 273-276\nclosures, 276-279\ncustom interfaces, 280-282\nlambdas, 276-279\nmethod references, 289-293\nmixins, 293-295\nparallel streams, 287-289\nstreams and, 283-287\nFunctional Thinking (Ford), 276\nFuture interface, 487\nG\nGafter, Neal\nJava Puzzlers books, xiii\nGamma, Erich\nDesign Patterns, xx, 31\nGang of Four (GoF), xx, 239\nGarbage Collection in the Java HotSpot Virtual\nMachine paper, 536\nThe Garbage Collection MythBusters presenta‐\ntion, 536\nGarbage-Collection-Friendly Programming,\nTS-2906, 536\ngeneral programming books, xix\ngeneric types, 191, 194-197\nGentleman, Robert, 375\nget() method, 193, 194, 201, 487\ngetByName() method, 389\ngetCharAt() method, 59\ngetClass() method, 336, 520getClassLoader() method, 336\ngetConstructors() method, 521\ngetenv() method, 44\ngetFields() method, 521, 537\ngetHostAddress() method, 389\ngetInetAddress() method, 390\ngetInputStream() method, 333, 392, 394, 396,\n418, 424, 560\ngetInstance() method, 262\ngetLastModified() method, 348\ngetLength() method, 398\ngetLocalHost() methd, 390\nGetMark program, xiv\ngetMethod() method, 521, 523, 537\ngetName() method, 333\ngetNextMeeting() method, 180\ngetopt library, 126\ngetOutputStream() method, 359, 392, 394, 396,\n418, 424\ngetProp() method, 470\ngetResource() method, 336-338, 336\ngetResourceAsStream() method, 336-338, 336\ngetWriter() method, 359\ngetY ear() method, 378\nGit, 20\ngit clone command, 16, 19\ngit pull command, 16, 19\nGitHub (website), 20, 41\nGitLab, 41\nGNU make, 21\nGnuWin32, 98\nGoetz, Brian\nJava Concurrency in Practice, 517\nGoF (Gang of Four), xx, 239\nGoogle Code, 566\nGoogle Guice, 265\nGordon, Rob\nEssential JNI: Java Native Interface, 576\ngraal module (Maven), 16\nGraalVM\nabout, 3-5, 583\nFastR, 378-380\nmixing languages with, 566\nwebsite, 4\nGradle\nabout, 15, 21, 22, 555\nautomating with, 27-29\ndependency management and, 22\nwebsite, 22, 28\n596 | Index\nGrails, 555\ngrammatical structures, input/output with,\n319-323\nGrand, Mark\nJava Language Reference, 553\ngrep, 98, 118, 121\ngroff, 92\nGroovy, 28, 555\ngroup() method, 110, 115\ngroupCount() method, 110\nGupta, Arun\nJava EE 7 Essentials: Enterprise Developer\nHandbook, xviii , 410, 414, 470\ngzip compression, 336\nH\nHacking Exposed (McClure), 447\nHadoop, 275, 367\nHamcrest matchers, 33\nHarold, Elliotte\nJava I/O, xviii , 146, 301\nJava Network Programming, xviii , 385, 447\nhashCode() method, 231, 233, 241-246\nHashMap, 207-209\nHashtable, 207-209\nhasMoreElements() method, 67, 200\nhasMoreTokens() method, 60\nhasNext() method, 223\nhasRoom() method, 228\nHead First Design Patterns (Bates), 239\nHead First Java (Bates and Sierra), xiv, xviii\nheadMap() method, 219\nheadSet() method, 219\nHelm, Richard\nDesign Patterns, xx, 31\nhexadecimal numbers, 146\nHighsmith, Jim\nAgile Software Development Ecosystems, xx\nHinojosa, Daniel, 165\nhist() method, 374\nHitchens, Ron\nJava NIO, 301\nHTTP protocol, 428\nHTTP/REST web client, 385-388\nhuman time, 169\nhuman-readable number formatting, 145\nHunt, Andrew\nThe Pragmatic Programmer, xxI\nI18N, 85-88\nIan's Rule, 5\nIcefaces, 42\nIDE (see Integrated Development Environment\n(IDE))\nIEEE Standard 754, 140\nIhaka, Ross, 375\nincremental compiling features, as a feature of\nIDE, 5\nindent() method (String class), 57\nindenting strings, 69-72\nindexOf() method, 61, 192, 220\nInetAddress.getByName() method, 417\ninfo() method (logging), 440\ninner classes, 247-253\ninput/output, 297-364\nbinary data as, 331\nconverting character sets, 329\ndirectories, creating, 345\ndirectories, listing, 353\ndirectory roots, 354\nend-of-line characters, 330\nfiles and path, 338-345\nfiles, copying, 324\nfiles, creating, 345\nfiles, deleting, 349-351\nfiles, finding, 336-338\nfiles, renaming, 346-348\nFileWatcher service, 356\nFind: Walking a File Tree program, 361-364\nfrom console, 304-307\nfrom terminal, 304-307\njava.util.Formatter, 308\nof JAR files, 332-336\nof ZIP files, 332-336\nplatform-independent code, 330\nreading text files, 301-304\nreassigning standard streams, 326-328\nSave User Data to Disk program, 358-361\nScanner class, 316-317\nstandard in, 304-307\nstreams, 299, 325-328\nstreams, duplicating, 326-328\nStreamTokenizer and, 312-314\ntransient/temporary files, 351-353\nwith grammatical structures, 319-323\ninsert() method, 66\ninstall command (Maven), 25\nIndex | 597\ninstall.packages() method, 380\nInteger.parseInt() method, 306\nintegers, 136, 147\nIntegrated Development Environment (IDE)\nchoosing, 9\ncompiling, running and testing with an,\n5-11\nfeatures of, 5\nsupport for Maven from, 25\nsupport for running JUnit, 33\nIntelliJ IDEA\nabout, 6\nGit and, 20\nwebsite, 10\ninternal iteration, 199\ninternationalization, 85\ninvoke() method, 523\nisBlank() method, 57\nisCancelled() method, 487\nisDone() method, 487\nisEmpty() method, 201, 260\nisNaN() method, 137\nisPresent() method, 260\nisProbablyPrime() method, 160\nisProp() method, 470\nistabstop() method, 80\niterable data, 223-226\nIterable interface, 223\nIterable.forEach() method, 198, 198\niterating, 197-200\niterator() method, 225\nJ\nJackson, 452\nJakarta, xvii, 6, 35\nJaphar, 3\nJAR files\nabout, 14\narchive files, 473-474\ninput/output of, 332-336\npickling JavaBeans into, 469-473\nrunning programs from, 474-476\nJar Packager, 3\nJava\nbooks on, xvii\nbuild tools for, 21\ncalling from native code, 576-578\ncalling languages via native code, 571-576\ncollections, 189compiling and running, 2-13\ndownloading, 1\nevolution of client-side, 587\ninput/output in, 297-301\njavax.script, 564-566\nJSON in, 449\nmachine learning (ML) with, 368\nmixing languages with GraalVM, 566\nnetworking in, 383-385\nobject-oriented programming in, 237-239\npackages in, 461\nPerl and, 567-571\nreflection in, 519\nrunning external programs from, 556-560\nrunning programs and capturing output,\n560-564\nsockets in, 413\ntesting with an IDE, 5-11\nthreading in, 483-485\nusing from within R sessions, 377\nusing R from within apps, 375-377\nusing with other languages, 555-577\nversions of, 46-51\nJava 8, 226, 581\nJava 8 Lambdas (Warburton), xviii , 276\nJava 9, 582\nJava 9 Modularity: Patterns and Practices for\nDeveloping Maintainable Applications (Mak\nand Bakker), xviii , 52, 482\nJava 10, 583\nJava 11, 585\nJava 12, 585\nJava 13, 586\nJava 14 record, 233\nJava API, source code for, 39\nJava CC, 320\njava command, 2, 55\nJava Community Process (JCP), 461, dlxxx\nJava Concurrency in Practice (Goetz), 517\nJava Design (Coad), xx\nJava Development Kit (JDK), 1, 2-3, 14\nJava EE 7 Essentials: Enterprise Developer\nHandbook (Gupta), xviii , 410, 414, 470\nJava EE 8 Cookbook (Moraes), xvii\nJava Enterprise Edition (Java EE), 265, 267, 414\nJava Flight Recorder, 534\nJava Generics and Collections (Naftalin and\nWadler), 194\nJava Help API, 467\n598 | Index\nJava I/O (Harold), xviii , 146, 301\nJava in a Nutshell (Flanagan and Evans), xiv,\nxviii\nJava Internationalization (Deitsch and Czar‐\nnecki), 85\nJava Language Reference (Grand), 553\nJava libraries, 40-42\nJava Magazine, dlxxx\nJava Message Service (Richards), 447\nJava Micro Edition (ME), xvii, 588\nJava Mission Control, 534\nJava Network Programming (Harold), xviii ,\n385, 447\nJava NIO (Hitchens), 301\nJava Performance), 537\nJava Persistence API, 543\nJava Platform Module System (JPMS), 52-56,\n479-482\nJava Puzzlers book (Bloch and Gafter), xiii\nJava Runtime Environment (JRE), 1\nJava SDK, 1, 2-3, 14\nJava Security (Oaks), 433, 478, 552\nJava Servlet & JSP Cookbook (Perry), xvii\nJava Servlet Programming, 504\nJava Specialists Newsletter, dlxxx\nJava Specification Request (JSR), 484\nJava Swing (Eckstein), xviii\nJava Technology: The Early Y ears article, 581\nJava Virtual Machine (Downing and Meyer),\nxviii , 553\njava.awtTaskbar class, 51\njava.io.File class, 48\njava.io.Reader, 40\njava.lang.Math.random() method, 151\njava.lang.Runtime class, 43\njava.util.Date class, 29\njava.util.Formatter, 308\njava.util.Iterator() method, 198, 199\njava.util.logging, 444-447\nJavaBeans, pickling into JAR, 469-473\njavac command, 2, 15, 39, 197, 233\nJavaCompiler, 530-533\njavadoc, 238, 464\nJavaFX, 587\nJavaOne, dlxxix\njavap command, 233, 538\nJavaServer Faces (JSF), 41, 470\njavasrc repository, xiv, 16, 26, 92, 183, 282, 463\njavaw command, 2javax.script, 564-566\njava_home command, 4\nJAX-RS, 433-435\nJBoss community, 41\nJBoss Weld CDI for Java Platforms (Finnegan),\n268\nJCP (Java Community Process), 461, dlxxx\nJDK (Java Development Kit), 1, 2-3, 14\nJenkins/Hudson, 21, 35, 38\nJFlex, 320\nJGrep program, 125\nJigsaw, 480\njlink, 1, 16, 478\nJNode, 3\njobs, 35\nJoda-Time package, 167\nJohnson, Ralph\nDesign Patterns, xx, 31\njoin() method, 497, 511\nJParsec, 320\nJPMS (Java Platform Module System), 52-56,\n479-482\nJRE (Java Runtime Environment), 1\nJRuby, 555\nJSF (JavaServer Faces), 41, 470\nJSFUnit, 42\nJShell\nabout, 11, 582\ncommand, 233\nfeatures and benefits of, 12\nfile/directory methods in, 348\nprototyping Java code with, 12\nrunning Java with, 11-13\nJSON, 449-459\ngenerating, 451\nin Java, 449-451\nJackson, 452\nJSON-B, 455\nJSON-Pointer, 457-459\norg.json, 453-455\njson module (javasrc repository), 16\nJSON-B, 455\nJSON-Pointer, 457-459\nJSP JavaBeans, 470\nJSR (Java Specification Request), 484\nJSR-310 API (see Date/Time API)\nJSSE, 430-433\nJUnit, 31-34\nJVM shutdown hook, 353\nIndex | 599\nJython, 555\nK\nKabutz, Heinz, dlxxx\nKaffe, 3\nKeith, Mike\nPro JPA 2: Mastering the Java Persistence\nAPI, xviii\nKernighan, Brian W .\nElements of Programming Style, The, xx\nPractice of Programming, The, xx\nSoftware Tools, xx, 79\nSoftware Tools in Pascal, xx\nUNIX: A History and a Memoir, xx\nKnuth, Donald E.\nThe Art of Computer Programming, xix\nL\nlambda expressions, 276-279\nlanguage lessons, 85\nlast() method, 219\nlastIndexOf() method, 61\nLavarand, 133\nlayout() method, 374\nlazy evaluation, 263\nLea, Doug, 484, 517\nLearning Java, xiv\nlegacy dates, 182-184\nLevenshtein string edit distance algorithm, 95,\n568\nLewis, Kevin\nCreating Effective JavaHelp, 467\nlex, 320\nline() method (Files class), 303\nlines() method (Files class), 306\nlinked lists, 185, 202-207\nLinux, 53, 145\nlist() method, 354\nList.of() method, 193\nLiterate Programming, 464\nload average, 53\nload() method, 46\nloadAverage() method, 53\nloadClass() method, 529\nLocalDate class, 30\nLocalDate.now() method, 378\nLocalDateTime class, 30\nLocale.getAvailableLocales() method, 88\nlocales, 87, 88localization, 85\nlocks, 504-508\nlog() method, 439\nlog4j, 436, 439-444\nlogging, 436, 439-444\nlogic error, 138\nLombok, 231\nlookingAt() method, 109\nLoukides, Mike\nUnix Power Tools, 99\nWhat Is Data Science, 367\nM\nMac, 74\nmachine learning (ML), 368\nmacOS, 3, 86\nmain module (javasrc repository), 16\nmain() method, 13, 39, 182, 532, 535, 577, 585\nMak, Sander\nJava 9 Modularity: Patterns and Practices\nfor Developing Maintainable Applica‐\ntions, xviii , 52, 482\nmake, 21\nMakefiles, 21\nMallet (ML for text), 368\nmanifest, 474\nMap/Reduce algorithm, 367\nMastering Regular Expressions (Friedl), 99\nmatch() method, 109, 115, 570\nmatcher.matches() method, 125\nmatches() method, 110\nMath.round() method, 137, 141\nmatrices, multiplying, 153-155\nMaven (see Apache Maven)\nMaven Central, 26, 41\nMcClure, Stuart\nHacking Exposed, 447\nME (Java Micro Edition), xvii, 588\nMessageFormat class, 150\nmetacharacters, 99\nmetadata, 468\nmethod references, 289-293\nmethods, reflection and, 521-525\nMeyer, Jon\nJava Virtual Machine, xviii , 553\nMicrosoft VSCode, 9\nminus() method, 177, 181\nmixins, 293-295\nMKIndex tool, xiv\n600 | Index\nML (see machine learning (ML))\nmock objects, 34\nMockito, 34\nmodule path, 15\nmodule-info.java file, 54, 55\nMoraes, Elder\nJava EE 8 Cookbook, xvii\nMoreUnit plugin, 33\nmount point, 358\nmultidimensional structures, 229-231\nMULTILINE flag, 120\nmultiline strings, 331\nmultiline text strings (see text blocks)\nN\nNaftalin, Maurice\nJava Generics and Collections, 194\nname() method, 233\nnative code, 555, 571-576, 576-578\nnative-image tool, 5\nnative2ascii, 329\nND4J package, 153\nnegate() method, 158\nNetBeans, 6, 10\nNetwork Information Services (NIS), 390\nnetworking, 383-412\nbinary data, reading/writing, 394-397\nChat Client program, 406-410\ncontacting servers, 388\nerrors, handling, 391\nHTTP/REST web client, 385-388\nin Java, 383-385\njava.util.logging and, 444-447\nlog4j, logging with, 436, 439-444\nnetwork addresses, 389-391\nnetwork interfaces, finding, 417\nreturning objects over, 422\nserialized data, reading/writing, 394-397\nSimple HTTP Link Checker program,\n410-412\ntext data, reading/writing, 392-394\nTFTP UDP Client program, 401-406\nUDP datagrams, 397-400\nURI, 400\nURL, 400\nURN, 400\nnewInstance() method, 526, 528\nnewlines, matching in text, 121\nnext() method, 223, 316nextBoolean() method, 152\nnextBytes() method, 152\nnextDouble() method, 152, 316, 373\nnextElement() method, 200\nnextFloat() method, 152\nnextGaussian() method, 152, 373\nnextInt() method, 151, 152, 316\nnextLong() method, 152\nnextRandom() method, 152, 373\nnextString() method, 316\nnextToken() method, 60\nNIS (Network Information Services), 390\nnonprintable characters, 82\nnow() method, 170\nNPEs, 259\nnroff, 92\nNumber Palindromes program, 162-165\nNumberFormat.getInstance() method, 143\nnumbers, 131-165\nabout, 131\nchecking validity of strings of, 131-165\ncomplex, 155-156\nconverting to/from objects, 135\nconverting types of, 146\nformatting, 142-146\nformatting with correct plurals, 149\nfractions of integers, 136\nmatrices, multiplying, 153-155\nNumber Palindromes program, 162-165\nrandom number generators, 151-153\nseries of integers, 147\nTempConverter program, 160-161\ntypes of, 131\nvery large, 158-160\nnumeric expression, 58\nNumerical Recipes books, 155\nO\nO'Reilly Online Learning Platform, xvii\nO'Reilly, Tim\nUnix Power Tools, 99\nOaks, Scott\nJava Performance, 537\nJava Security, 433, 478, 552\nobject orientation, 52\nobject serialization, 396\nobject stacks, 226-229\nobject wrappers, 132\nobject-oriented programming, 237-271\nIndex | 601\nabstract methods, 253\ndependency injection, 265-268\nenumerations, 255-259\nexceptions, custom, 263\nin Java, 237-239\ninner classes, 247-253\nNPEs, 259\nobject methods, 240-246\nPlotter program, 268-271\npolymorphism, 253\nsingleton patterns, 261-263\nobjects\narrays for, 186\nconverting to/from numbers, 135\nfinding in collections, 220-222\noctal numbers, 146\nof() method, 193\nofDays() method, 178\nofPettern() method, 176\nOmniFaces (JSF), 42\nopen source, 41\nOpenFaces (JSF), 42\nOpenJDK community, dlxxx\nOpenJDK JShell Tutorial, 13\noperating systems, 46\nOracle (website), 1\nOracle Java Technology Network, dlxxix\norElse() method, 260\norg.json, 453-455\nP\npackage goal (Maven), 25\npackaged APIs, 51\npackages, 461-482\ncreating, 462\ndistributing, 478\ndocumenting, 464\nin Java, 461\nJAR files, 473-474\nJavaBeans as, 469-473\nlisting classes in, 539-541\nW AR files as, 476\nparallel streams, 287-289\nparallelStream() method, 288\nparameter order, 309\nparse() method, 175\nParsing Expression Grammar (PEG), 320\nparsing strings into dates, 175\nPATH separator (:), 48paths, files and, 338-345\npathSeparator property, 48\npathSeparatorChar property, 48\npattern matching, 97-126\naccented characters, 120\ncomposite characters, 120\nfinding matching text, 109-112\nnewlines in text, 121\nprinting lines containing, 118\nprinting occurrences of, 115-117\nreplacing matched text, 112-114\ntesting for patterns, 106-109\nwith regular expressions, 97-126\nPattern.compile() method, 108, 119, 122\npeek() method, 226\nPeek, Jerry\nUnix Power Tools, 99\nPEG (Parsing Expression Grammar), 320\nperformance timing, 533-537\nPeriod.between() method, 176\nPerl, Java and, 567-571\nPerry, Bruce\nJava Servlet & JSP Cookbook, xvii\nPike, Rob\nThe Practice of Programming, xx\npiping, 325\nplatform-independent code, 330\nPlauger, P . J.\nElements of Programming Style, The, xx\nSoftware Tools, xx, 79\nSoftware Tools in Pascal, xx\nPlotter program, 268-271\nplug-in-like classes, 547\nplus() method, 177, 181\npng() method, 374\npoll() method, 423\npolymorphism, 253\npom.xml file, 19, 23\npom.xml module (Maven), 16\npop() method, 194, 226\nPowers, Shelley\nUnix Power Tools, 99\nThe Practice of Programming (Kernighan and\nPike), xx\nThe Pragmatic Programmer (Hunt and Tho‐\nmas), xx\npreferences, storing strings in, 209-213\npreferences.get() method, 210\nPreview Changes, 585\n602 | Index\nPrimeFaces, 42\nprimitive types, 131, 186\nprint() method, 328, 330, 536\nprintf() method, 142, 308\nprinting, 115-117\nprintln() method, 90, 241, 328, 330, 449, 451,\n534, 536\nprintStackTrace() method, 39\nPRNG (Pseudorandom Number Generator),\n133, 151\nPro JPA 2: Mastering the Java Persistence API\n(Keith and Schincariol), xviii\nprocessing strings, 67\nproducer-consumer implementation, 508-510\nprofiler, 533\nProject Jigsaw (see Java Platform Module Sys‐\ntem (JPMS))\nProject Loom: Fibers and Continuations, 517\nproperties, 45, 209-213\nProperties class, 45, 211\nPseudorandom Number Generator (PRNG),\n133, 151\npure functions, 274\npush() method, 194, 226\nput() method, 194\nQ\nQNX, 588\nQuartz, 515\nqueue interface, 508-510\nR\nR, 367-381\nabout, 367\nFastR, 378-380\nimplementations, comparing/choosing, 374\nusing from withing Java apps, 375-377\nusing in web apps, 380\nusing interactively, 372-374\nusing Java from within sessions, 377\nR Foundation for Statistical Computing, 375\nR statistics package, 152\nrandom numbers, 133, 151-153\nrandom() method, 151\nrange() method, 147\nrangeClosed() method, 147\nRatFor (Rational Fortran), 79\nRats! (parser generator), 320\nRdemo-web module (javasrc repository), 16read() method, 40, 305, 312, 330, 369\nread-evaluate-print loop (REPL), 11, 372\nreadInt() method, 395\nreadLine() method, 58, 306, 312, 330\nreadLock() method, 506\nreadPassword() method, 307\nreadUnsignedByte() method, 395\nreadUnsignedShort() method, 395\nreal numbers, 132\nReal World Java EE Patterns: Rethinking Best\nPractices (Bien), xviii\nrecurring events, 178-180\nREDemo, 102\nredirection, 325\nReese, George\nDatabase Programming with JDBC & Java,\nxviii\nRefactoring (Fowler), xx\nrefactoring, as a feature of IDE, 5\nreflection, 519-553\nannotations, using/defining, 542-547\nclass descriptors and, 520\nclasses, loading/instantiating dynamically,\n526-528\nClassLoader and, 529-530\nfields, accessing, 521-525\nin Java, 519\nJavaCompiler, 530-533\nlisting classes and, 539-541\nmethods, accessing, 521-525\nperformance timing, 533-537\nprinting class information with, 537-538\nprivate fields/methods, accessing, 525\nregular expressions (regex)\nabout, 98\ncontrolling case in, 82, 119\nJGrep program, 125\npattern matching with, 97-126\npatterns, testing for, 106-109\nstrings and, 61\nsyntax, 99-106\nremote interface, 250\nremove() method, 192, 200, 200, 201, 223, 225\nrendezvous, 497\nRenjin, 375, 375-377, 556\nREPL (read-evaluate-print loop), 11, 372\nreplace() method, 66\nreplaceAll() method, 112, 114\nreplaceFirst() method, 112, 114\nIndex | 603\nrepository (see Git) (see javasrc repository) (see\nSCM (source code management) reposi‐\ntory)\nresizing arrays, 188\nresource bundles, 89\nResourceBundle, 85\nResourceBundle.getBundle() method, 87, 89\nREST web services, 433-435\nrestdemo module (javasrc repository), 16\nRESTful Java with JAX-RS 2.0, 2nd Edition\n(Burke), 388\nreverse() method, 66, 75\nreversing strings by word or character, 75\nRichards, Mark\nJava Message Service, 447\nRichFaces, 42\nripgrep (rg), 125\nRitchie, Dennis, 174, 200\nRogue Wave Software, 155\nRoman numeral formatting, 145\nRomanNumberFormat.parseObject() method,\n146\nround() method, 141\nrounding, 141\nRserve, 375\nrun() method, 274, 426, 485, 494, 497, 506, 517,\n561\nrunenv_jpms, 56\nruntime environment, 43-56\nenvironment variables, acquiring, 43\nextensions and, 51\nJava Platform Module System (JPMS), 52\nJDK version, finding, 46-51\npackaged APIs and, 51\nsystem properties, acquiring, 44-46\nRuntime.exit() method, 43\nRuntime.getRuntime() method, 261\nS\nS, 374\nSaltzer, J., 92\nsam text editor, 121\nSave User Data to Disk program, 358-361\nsaveFile() method, 517\nScala, 274, 555\nscanf() method, 316\nScanner class, 316-317\nSchincariol, MerrickPro JPA 2: Mastering the Java Persistence\nAPI, xviii\nSCM (source code management) repository, 35\nsearch() method, 220, 281\nsed, 121\nselect() method, 423\nsensitivity training, 85\nseparator property, 48\nseparatorChar property, 48\nserialized data, reading/writing over networks,\n394-397\nservers, contacting, 388\nServerSocket class documentation, 425\nservlets, 476\nset methods, 143\nsetAccessible() method, 525\nsetCharAt() method, 59\nsetClock() method, 171\nsetLastModifiedTime() method, 347\nsetMinimumIntegerDigits() method, 143\nsetPort() method, 398\nsets, 201\nsetSoTimeout() method, 402\nsettabpos() method, 80\nshoulder surfing, 307\nshow() method, 570\nshutDown() method, 494\nSierra, Kathy\nHead First Java, xiv, xviii\nSimple HTTP Link Checker program, 410-412\nSimple Logging Facade for Java (SLF4J), 436,\n437-439\nsingleton patterns, 261-263\nsize() method, 201, 222\nslashSlashComment() method, 313\nSLF4J (Simple Logging Facade For Java), 436,\n437-439\nsockets, 413-447\nbinary/string data, returning over, 418-420\nHTTP protocol, 428\nin Java, 413\njava.util.logging and, 444-447\nJAX-RS, 433-435\nlog4j, 439-444\nlogging, 436\nmultiple, 423-428\nnetwork interfaces, finding, 417\nopening, 414-417\nreturning objects over, 422\n604 | Index\nreturning responses, 418-420\nSLF4J, 437-439\nSSL, securing with, 430-433\nSoftware Tools (Kernighan and Plauger), xx, 79\nSoftware Tools in Pascal (Kernighan and\nPlauger), xx\nsort tool (Unix), 151\nsort() method, 214, 214\nsorting, 213-218, 218-220\nSoundex Name Comparisons program, 92-95\nsource code, 39\nsource code management (SCM) repository, 35\nSourceforge.net, 41\nSpark (Apache), 369-371\nspark module (javasrc repository), 16\nsplit() method, 287\nSPlus, 375\nSpring Framework, 41, 42, 265, 277, 435, 470\nSSL, 430-433\nstack traces, 38\nstandalone GUI clients, 20\nstandard input, 304-307, 304\nStandard JDK, 2-3\nstart() method, 110, 485, 556\nstartClass() method, 551\nstarting seed, 152\nstartsWith() method, 103\nstatic import feature, 293\nSteven, W . Richard\nUnix Network Programming, 410\nstop() method, 494\nstream() method, 288\nStream.forEach() method, 198, 198\nStream.sorted() method, 354\nstreams\nduplicating, 326-328\nfunctional programming and, 283-287\ninput/output, 299\nreassigning, 325-328\nStreamTokenizer, 312-314\nString objects, immutability of, 58\nString trim() method, 83\nString.format() method, 69, 142\nString.join() method, 67\nString.substring() methods, 111\nStringAlign class, 70\nStringBuffer, 65\nStringBuilder, 59, 65-67, 165\nStringBuilder.length() method, 67strings, 57-95\nabout, 57\naligning, 69-72\nblanks, trimming, 83\ncharacters, processing, 67-69\ncontrolling case in, 81\nconverting to Unicode characters, 73-75\ncreating messages with I18N resources,\n85-88\nimmutability of, 65\nindenting, 69-72\nnonprintable characters and, 82\nof numbers, checking validity of, 134-135\nparsing into dates, 175\nresource bundles, 89\nreturning over sockets, 418-420\nreversing, 75\nstoring in properties/preferences, 209-213\nStringBuilder and, 65-67\nsubstrings, 60-65\ntabs, expanding/compressing, 76-80\ntokenizing, 60-65\nun-indenting, 69-72\nusing locales, 88\nStringTokenizer, 62\nstrip() method, 83\nstripLeading() method, 57, 83\nstripTrailing() method, 57, 83\nsubclassing, 238, 250\nsubstring() method, 60, 112, 115, 275\nsubstrings, 60-65\nsupplementary characters, 73\nsurrogate pairs, 73\nSwing, 587\nSwing JButton, 86\nsynchronization, 498-504, 504-508\nsynchronized wrappers, 288\nsynchronous sockets, 384\nSystem class, 43\nsystem properties object, 49\nsystem properties, getting information from,\n44-46\nSystem.arrayCopy() method, 188\nSystem.currentTimeMillis() method, 174\nSystem.exit() method, 43\nSystem.getenv() method, 44\nSystem.getProperties() method, 45\nSystem.getProperty() method, 45, 47, 378\nSystem.nanoTime() method, 174\nIndex | 605\nSystem.out.println() method, 58\nSystem.properties, 47\nSystem.setErr() method, 327\nSystem.setOut() method, 327\nT\nTabs class, 76, 80\ntabs, expanding and compressing, 76-80\ntailMap() method, 219\ntailSet() method, 219\nTDD (Test Driven Development), 31\nTeamCity, 35\ntee command (Unix), 326\nTempConverter program, 160-161\nterminals, reading from, 304-307\nTest Driven Development (TDD), 31\ntest goal (Maven), 25\ntesting\nautomating, 23-29\nfor patterns, 106-109\nJava with an IDE, 5-11\ntesting module (Maven), 16\nTestNG, 33\ntext blocks, 58, 586\ntext data, reading/writing, 392\nText Formatter program, 90-92\nTFTP (trivial file transfer protocol), 385\nTFTP UDP Client program, 401-406\nThalinger, Chris, 4\nthird-party frameworks, 40\nThomas, David\nThe Pragmatic Programmer, xx\nThompson, Ken, 174\nthread pool, 484\nthreading, 483\nanimation, 489-492\nconstructing threads, 485-489\nfork/join framework, 511-514\nin Java, 483-485\nlocks, 504-508\nqueue interface, 508-510\nrendezvous, 497\nscheduling tasks, 514\nstopping, 494-496\nsynchronization of, 498-504\ntimeouts, 497\ntilde characters, 459\ntime zones, 181\ntimeouts, 497times, 172-173, 174\nTiming Comparisons program, 233-235\ntoArray() method, 193, 222\ntoBinaryString() method, 147\ntoCharArray() method, 68\ntoHexString() method, 147\ntokenizing, 60-65\ntolerance, 140\ntoLowerCase() method, 81, 287\nTomcat (web server), 22\ntoOctalString() method, 147\ntoString() method, 59, 65, 66, 147, 170, 176,\n231, 231, 240, 258, 331, 378, 438, 440, 444,\n455, 538\ntoUpperCase() method, 59, 81, 275\ntransform() method, 57\nTravisCI, 35\nTreeMap, 219\nTreeSet, 219\ntrim() method, 83\ntrimming blanks from ends of strings, 83\ntrivial file transfer protocol (TFTP), 385\ntroff, 92\ntype parameter, 190\nU\nUDP datagrams, 397-400\nUML Distilled (Fowler), xxi\nUML Process, xxi\nUML User Guide, xxi\nun-indenting strings, 69-72\nUNC filename, 355\nUnderstanding Open Source and Free Software\nLicensing (O'Reilly), 40\nUnicode, converting between strings and, 73-75\nUNICODE_CASE flag, 120\nuniq tool (Unix), 151\nunit testing, 31-34\nUnix\ncharacters in, 74\ndefault locale in, 86\ndirectory list command, 48\ngetopt library, 126\ngrep, 118\ngroff, 92\nhuman-readable number formatting and,\n145\nload average in, 53\nlocales in, 87\n606 | Index\nnroff, 92\nroff, 92\nsort tool, 151\ntime in, 168\ntroff, 92\nUniq tool, 151\nuptime command, 55\nUnix Network Programming (Stevens), 410\nUnix Power Tools (Loukides, O'Reilly, Peek and\nPowers), 99\nUNIX: A History and Memoir (Kernighan), xx\nUNIX_LINES flag, 120\nunlock() method, 505\nunmodifiable view, 584\nUnsafe class, 53\nunsafe module (Maven), 16\nunsafe subdirectory, 53\nuptime command, 55\nURI, 400\nURL, 400\nURN, 400\nuseful operations, 167\nUTF-16 (16-bit Unicode Transformation For‐\nmat), 73\nV\nvalue() method, 258\nvalueOf() method, 136, 147\nVisual Studio make, 21\nVisualVM project, 534\nVlissades, John\nDesign Patterns, xx, 31\nW\nWadler, Philip\nJava Generics and Collections, 194\nwaitFor() method, 563\nwalkFileTree() method, 354\nW AR files, servlets packaged as, 476\nWarburton, Richard\nJava 8 Lambdas, xviii , 276\nwarn() method, 440warning messages, 53\nweb application, 477\nweb apps, 380\nweb tier resources, 42\nWeka, 368\nWhat Is Data Science (Loukides), 367\nwhile loop, 198, 200\nwho program (Unix), 326\nwholist, 326\nWildFly (EE application server), 22, 26\nWindows\ncharacters in, 74\ndefault locale in, 86\ngrep, 98\nlocales in, 87\nwith() method, 179\nwithLocale() method, 176\nWitten, Ian\nData Mining: Pratical Machine Learning\nand Techniques, 369\nword frequency count algorithm, 286\nwrapper types, 131\nwrite() method, 326\nwriteLock() method, 506\nX\nX11() method, 374\nXCode, 3, 9\nXCode make, 21\nXenix, 48\nxml module (Maven), 16\nXmlForm, xiv\nXP (Extreme Programming), 31\nY\nyacc, 320\nYMDHMS, 174\nZ\nzero-based index, 61\nZIP files, input/output of, 332-336\nIndex | 607",39880
759-About the Author.pdf,759-About the Author,"About the Author\nIan F. Darwin  has worked in the computer industry for several decades. He wrote the\nfreeware file(1) command used on Linux and BSD, and is the author of Checking C\nPrograms with Lint , Android Cookbook , and more than a hundred articles and several\ncourses on C, Unix, and Java. In addition to programming and consulting, Ian\nteaches Unix and Java courses for Learning Tree International, one of the world’s larg‐\nest technical training companies. He has a M.Sc. in Computing from Staffordshire\nUniversity and several technical certifications. His eclectic website can be found at\nhttps://darwinsys.com . Along with his wife and children, Ian used to raise chickens on\na rural property.\nColophon\nThe animal on the cover of Java Cookbook , Fourth Edition, is a domestic chicken\n(Gallus domesticus ). Domestic chickens are descended from the wild red jungle fowl\nof India. Domesticated over 8,000 years ago in the area that is now Vietnam and\nThailand, chickens are raised for meat and eggs, and the males for sport as well\n(although cockfighting is currently illegal in many places).\nWith their big, heavy bodies and small wings, these birds are well suited to living on\nthe ground, and they can fly only short distances. Their four-toed feet are designed\nfor scratching in the dirt, where they find the elements of their usual diet: worms,\nbugs, seeds, and various plant matter.\nA male chicken is called a rooster and a female is known as a hen. The incubation\nperiod for a chicken egg is about three weeks; newly hatched chickens are precocial,\nmeaning they have downy feathers and can walk around on their own right after\nemerging from the egg. They’re also not dependent on their mothers for food; not\nonly can they procure their own, but they also can live for up to a week after hatching\non egg yolk that remains in their abdomen after birth.\nThe topic of chickens comes up frequently in ancient writings. Chinese documents\ndate their introduction to China to 1400 BC, Babylonian carvings mention them in\n600 BC, and Aristophanes wrote about them in 400 BC. The rooster has long symbol‐\nized courage: the Romans thought chickens were sacred to Mars, god of war, and the\nfirst French Republic chose the rooster as its emblem.\nThe cover illustration is by Karen Montgomery, based on a black and white engraving\nfrom Dover. The cover fonts are Gilroy Semibold and Guardian Sans. The text font is\nAdobe Minion Pro; the heading font is Adobe Myriad Condensed; and the code font\nis Dalton Maag’s Ubuntu Mono.\nThere’s much more  \nwhere this came from.\nExperience books, videos, live online  \ntraining courses, and more from O’Reilly  \nand our 200+ partners—all in one place.\nLearn more at oreilly.com/online-learning\n©2019 O’Reilly Media, Inc. O’Reilly is a registered trademark of O’Reilly Media, Inc. | 175",2865
