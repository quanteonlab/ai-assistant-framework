# 002

## cognitivetech/obook_summary:q3_k_m

### filename,title,text,len

**Filename:**
- Contains name of document or image file (e.g., "example.txt")

**Title:**
- Brief description of content for searchability and organization (e.g., "Example Document")

**Text:**
- Detailed explanation or summary of the provided information
- Use headings and terms in bold to highlight key points
- Break up text into bulleted notes for easy scanning (e.g., 
  **Importance of Filenames**:
    - Contains important metadata used by operating systems
    - Helps users quickly identify file contents
    - Should be descriptive yet concise, with no spaces or special characters

**Length:**
- Indicates file size in bytes for binary files (e.g., "1024 bytes")
- For text files, focus on character count instead of byte size (e.g., "500 characters")

### 01-Half Title.pdf,01-Half Title,Living Documentation\nThis page intentionally left blank,56

**Essentials of Living Documentation:** Half Title

**Living Documentation**: Half Title
- This page intentionally left blank,56 (Half Title)
- Repeat as needed.

**Instructions**:
- The provided text is a description of "Living Documentation" and its component, the "Half Title".
- Emphasize concision by using headings and terms in bold for easier reference.

**Essentials of Living Documentation:** Half Title

**Description**:
- Text describing "Living Documentation" and its element, "Half Title"
- This page left blank intentionally (56)

**Components**:
- Living Documentation
  - Half Title

**Instructions for Use**:
- Repeat provided text as needed.

### 02-Dedication.pdf,02-Dedication,"Living Documentation\nContinuous Knowledge Sharing by Design\nCyrille Martraire\nBoston • Columbus • New Y ork • San

**Living Documentation:** Continuous Knowledge Sharing by Design

**Authors:** Cyrille Martraire, Mark L. Taub, Chris Zahn, Sandra Schroeder, Tonya Simpson, Kitty Wilson, Erika Millen, Linda Morris

**Publisher:** N/A

**Designations:**
- Various designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
- Initial capital letters or all caps indicate trademarked designations that appear in the book.

**Disclaimer:**
- No express or implied warranty is given for errors or omissions.
- No liability is assumed for incidental or consequential damages resulting from using the information or programs contained herein.

**Special Sales Opportunities:**
- Contact corporate sales department at corpsales@pearsoned.com or (800) 382-3419 for information about buying this title in bulk quantities or custom content tailored to your business, training goals, marketing focus, or branding interests.

**Government Sales:**
- Contact governmentsales@pearson.com for government sales inquiries.

**Permissions Requests:**
- Visit www.pearsoned.com/permissions/ for information about obtaining permissions to reproduce content from this book.

**ISBN:**
- 978-0-13-468932-6 (Hardcover)
- ISBN-10: 0-13-468932-1

**Dedication:**
- To my wife, Yunshan, and our children, Norbert and Gustave.

### 03-Contents.pdf,03-Contents,"viiContents\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xx \

**Living Documentation:** An Effective Approach to Documenting Software Development

**Background:**
- Living documentation is essential for successful software development projects
- It focuses on creating a dynamic, evolving document that reflects the current state of the project

**Benefits:**
- Clear communication between team members and stakeholders
- Improved understanding of system design intentions
- Enhanced knowledge transfer between teams and generations

**Best Practices:**
1. **Start with a Problem**: Identify an actual problem or goal to work towards
2. **Collaborative Documentation**: Encourage active participation from team members
3. **Focus on Differences**: Emphasize what sets the project apart
4. **Flexible Content**: Use various media types (text, images, videos) for documentation
5. **Search-Friendly Documentation**: Organize content in a logical and accessible manner
6. **Conspicuous Documentation**: Make it visually appealing with posters, infographics, etc.
7. **Affordable and Attractive**: Use low-cost or free tools for documentation
8. **Humor and Cheap Media**: Keep the environment lighthearted to foster engagement
9. **Goodies/Swag**: Provide team members with branded merchandise as motivation
10. **Comics and Infodecks**: Use visual aids to simplify complex concepts
11. **Visualizations and Animations**: Illustrate relationships between components or processes
12. **LEGO Bricks, Furniture, 3D Printed Stuff**: Use physical models for better understanding

**Documenting Legacy Applications:**
- Documentation is crucial for understanding and maintaining legacy systems
- Approach documentation as an "archeology project" to uncover hidden knowledge

**Conspicuous Documentation:**
1. **Focus on Differences**: Identify unique aspects of the project or system
2. **Fast Media and Prior Preparation**: Use tools that allow for quick creation and sharing
3. **Together, Now**: Encourage real-time collaboration between team members
4. **Infodecks, Posters, Domestic Ads, Memes**: Utilize various media types to engage audiences
5. **Maxims**: Establish guiding principles for the project or organization
6. **Information Radiators**: Display critical information in a visible and accessible format
7. **Humor and Cheap Media**: Maintain a lighthearted environment to boost morale and creativity
8. **Goodies/Swag, Comics**: Provide team members with branded merchandise or custom illustrations
9. **Infodecks, Visualizations, Animations**: Use visual aids to simplify complex concepts
10. **LEGO Bricks, Furniture, 3D Printed Stuff**: Create physical models for better understanding

**Documentation Bankruptcy:**
- Outdated or inadequate documentation can hinder progress and lead to misunderstandings
- Documentation should be updated regularly and reviewed for relevancy
11. **Easter Eggs and Fun Anecdotes, Promoting News**: Incorporate unique stories and news into the documentation
12. **Unorthodox Media: Meme-Based Posters, Memes, Affordable and Attractive Documentation**: Use various media types to engage audiences
13. **Maxims, Posters, Domestic Ads, Humor**: Keep the environment lighthearted to foster engagement
14. **Information Radiators, Cheap Media, Goodies/Swag, Comics, Visualizations**: Utilize multiple formats for documentation
15. **LEGO Bricks, Furniture, 3D Printed Stuff**: Create physical models for better understanding.

### 04-Acknowledgments.pdf,04-Acknowledgments,"Acknowledgments\nFirst, I’d like to give special thanks my official reviewers, Rebecca Wirfs-Brock, Steve \

**Acknowledgments:**
* **Special thanks to official reviewers**: Rebecca Wirfs-Brock, Steve Hayes, and Woody Zuill for insightful manuscript review
* **Pearson team acknowledgements**: Chris Zahn (developmental editor), Mark Taub (publisher), Kitty Wilson (copy editing), Tanya Simpson, Chris Guzikowski (executive editor) for support throughout the publishing process
* **Origins of ideas**: Dan North, Chris Matts, Liz Keogh (Behavioral Driven Development), Eric Evans (Domain-Driven Design), Gojko Adzic (living documentation), Ward Cunningham and Kent Beck (patterns movement)
* **Contributions from authors and colleagues**: Martin Fowler, Ade Oshyneye, Andreas Rüping, Simon Brown, Rinat Abdulin, Eric Evans, Brian Marick, Vaughn Vernon, Sandro Mancuso, George Dinwiddie, Paul Rayner, Jeremie Chassaing, Arnauld Loyer, and Romeu Moura
* **Feedback from conferences and events**: Maxime Sanglan, Franziska Sauerwein, Agile France, Socrates Germany, Socrates France, Codefreeze Finland, Meetup Software Craftsmanship Paris, NCrafts in Paris, Domain-Driven Design eXchange in London, Bdx.io in Bordeaux, and ITAKE Bucharest
* **Support from colleagues and community**: Fabien Maury, Romeu Moura, Arnauld Loyer, Yvan Vu, Somkiane Vongnoukoun, Gilles Philippart, Bruno Boucard, Thomas Pierrain, Clémo Charnay, Alexandre Pavillon, Bruno Dupuis, James Kouthon, and the Craftsmanship center at SGCIB
* **Company support**: Commodity department at SGCIB, Asset Arena teams at Sungard Asset Management, Swapstream, CME, and other companies
* **Appreciation for partners**: Café Loustic and Ethiopian single origin coffee from Caffenation
* **Personal acknowledgements**: Parents for encouragement, wife Yunshan's support and love.

### 05-Introduction.pdf,05-Introduction,"About the Author\nCyrille Martraire (@cyriux on T witter) is CTO, co-founder, and partner at Arolla \n(@ArollaFr

**Cyrille Martraire's Book on Living Documentation**

**About the Author**:
- Cyrille Martraire: CTO, co-founder, and partner at Arolla; founder of Paris Software Crafters community; regular speaker at international conferences
- Over 20 years experience in software development for startups, software vendors, and corporations as employee and consultant
- Passionate about software design, including test-driven development, behavior-driven development, and domain-driven design
- Lives in Paris with wife Yunshan and children Norbert and Gustave

**Introduction**:
- Cyrille initially wanted to create tools that could understand design decisions made during coding
- Later recognized the need for better ways of documenting software development
- Book expands on the idea of **living documentation**, which is about keeping documentation up-to-date as code evolves

**What This Book Covers**:
- **Rethinking Documentation**: Provides a foundation for the rest of the book
- **Behavior-Driven Development as an Example of Living Specifications**: Discusses how BDD is a key inspiration behind living documentation
- **Knowledge Exploitation** and **Knowledge Augmentation**: Lay a foundation for other practices
- **Living Curation: Identifying Authoritative Knowledge**: Shows how to turn knowledge into something useful
- **Automating Documentation**: Expands on turning knowledge into documentation that lives at the pace of the code
- **Runtime Documentation**: Discusses using knowledge accessible only at runtime
- **Refactorable Documentation**: Focuses on using development tools to keep documentation up-to-date
- **Stable Documentation**: Examines documenting knowledge that doesn't change
- **Avoiding Traditional Documentation**: Takes a rebellious perspective on alternative means of documentation
- **Beyond Documentation: Living Design**: Explores how focusing on documentation can improve design
- **Living Architecture Documentation**: Applies the living documentation ideas to software architecture
- **Introducing Living Documentation to a New Environment**: Offers guidance on introducing living documentation
- **Documenting Legacy Applications**: Provides patterns for dealing with legacy challenges
- **Conspicuous Documentation**: A bonus chapter on practical advice to make all living documentation initiatives more effective

**Registering the Book**:
- Register the book at informit.com for convenient access to downloads, updates, and corrections

### 06-Chapter 1 Rethinking Documentation.pdf,06-Chapter 1 Rethinking Documentation,,0

**Rethinking Documentation: Chapter 1**

**Key Points**:
- Focus on understanding the provided document's purpose
- Identify the main topic: "Rethinking Documentation"
- Break down the title into components for analysis

**Title Components**:
1. **"Rethinking"**: Suggests a shift in perspective or approach
2. **"Documentation"**: Refers to recording information for future reference
3. **"Chapter 1"**: Indicates this is an introductory piece, possibly part of a larger work
4. **"Rethinking Documentation"**: The focus is on examining the concept of documentation and how it's approached

**Understanding the Purpose**:
- The given text doesn't provide much context regarding the purpose
- Assessing the title can help glean some information about the topic and tone

**Tips for Expanding Bulleted Notes**:
- Use headings and terms in bold to organize your notes
- Add terms and concepts to your own words to expand on the meaning
- Provide examples or illustrations to reinforce key ideas.

### 07-Why This Feature.pdf,07-Why This Feature,"1Chapter 1\nRethinking Documentation\nForget about documentation. Instead, focus on the speed of working

**Rethinking Documentation**

**Focus on Faster Software Development:**
- Deliver software faster for long-term sustainability
- Team or company wide focus on productivity
- Faster programming languages, frameworks, tools, and skills

**Bottlenecks Beyond Technology:**
- Making decisions based on knowledge
- Learning experiments and collaboration for new knowledge
- Time-consuming and valuable when needed

**Value of Learning Fast:**
- Quickly recover prior valuable knowledge
- Illustrated through a story: A Software Project

**The Story:**
- Developing a new application in a company project
- Adding a new kind of discount for loyal customers
- Importance of learning fast and making decisions based on knowledge.

### 08-Sorry We Dont Have Marketing Documents.pdf,08-Sorry We Dont Have Marketing Documents,"Chapter 1 Rethinking Documentation 2\nWhy This Feature?\nY ou

**Rethinking Documentation**

**Chapter 1**:
- **Why This Feature?**
  - Franck (marketing team) explains rationale to Lisa (professional tester) and others
    - Reward recent loyal customers to increase customer retention in a gamification approach
    - Suggests a link on Wikipedia about the topic
  - Lisa takes notes on main points and scenarios
  - Easy communication as everyone is around the table
- **Concrete Examples**:
  - Help clarify anything unclear
  - Faster understanding than hard-to-read documents with ambiguities
  - Allows team members to spend time on what matters

**That Afternoon**:
- Colleagues Georges and Esther ask about design decision
- Team evaluates options on a whiteboard (no need for UML)
- Quickly choose a solution: use two different topics in the messaging system
  - Need for full isolation between incoming orders and shipment requests
- Esther takes picture of whiteboard with her phone for reference
- Solution implemented within half a day, so she deletes the saved image
- Dragos (new team member) wonders why code is written that way and uses `git blame` to find out the rationale.

**Unified Modeling Language**:
- Mentioned as a resource for further reading.

### 09-The Future of Living Documentation Is Now.pdf,09-The Future of Living Documentation Is Now,"A T ale from the Land of Living Documentation 3\nSorry,

**Living Documentation**

**A Tale from the Land of Living Documentation:**
- Marketing manager Michelle replaces Franck
- Michelle wants to know about customer retention
- No marketing document exists, but she finds information through:
  - Website search (customer retention scenarios)
  - Asking team members for help
  - Glossary on project's website (updates during every build)

**Difference between Purchase and Order:**
- Michelle asks about difference, usually would ask developers
- Team has anticipating question and provides glossary
- Glossary updated from code automatically

**Dependency Diagram:**
- Want to remove toxic dependency between modules
- Ask Esther for dependency diagram
- Esther generates diagram using open-source library and Graphviz
- Spots a design weakness in the generated diagram
- Weakness fixed during next project iteration, and diagram updated automatically.

### 10-The Problem with Traditional Documentation.pdf,10-The Problem with Traditional Documentation,,0

**The Issue of Traditional Documentation (10-The Problem with Traditional Documentation)**

### 11-The Flaws of Documentation.pdf,11-The Flaws of Documentation,"The Problem with Traditional Documentation 5\nThe Future of Living Documentation Is N

**The Flaws of Traditional Documentation**

**Documentation as a Problem**:
- Quote from William Gibson: "The future has arrived, it's just not evenly distributed yet."
- Tools and techniques are available, but documentation is not mainstream
- Documentation is often seen as a "boring topic" and a source of frustration for developers

**Flaws and Anti-Patterns in Traditional Documentation**:
- **Separate Activities**: Documentation, coding, testing, etc. are treated as separate tasks
- **Manual Transcription**: Manually transcribing information from code/specs into documentation
- **Test Doc Code Specs**: Using documentation to test, code, and write specs
- **Redundant Knowledge**: Duplication of knowledge between documentation and code
- **Boring Time Sink**: Documentation is not as exciting or rewarding as writing code
- **Brain Dump**: Documentation is a "random brain dump" without much thought or organization
- **Polished Diagrams**: Overly formal diagrams that take too much time to create
- **Notification Obsession/Notation Ignorance**: UML notation and other modeling approaches
- **Information Graveyard**: Inadequate documentation management tools lead to outdated or poor quality documentation
- **Misleading Help**: Outdated documentation that is no longer accurate or relevant
- **There's Always Something More Important Right Now**: Documentation often takes a backseat to more pressing tasks

### 12-The Agile Manifesto and Documentation.pdf,12-The Agile Manifesto and Documentation,,0

**Agile Manifesto and Documentation**

**The Agile Manifesto**:
- Contains guiding principles for software development using an agile approach
- Emphasizes values such as:
  - Individuals and interactions over processes and tools
  - Working software over comprehensive documentation
  - Customer collaboration over customer satisfaction
  - Responding to change over following a plan

**Agile Documentation**:
- Focuses on providing value to the development team and customers
- Should not be excessive, but provide enough detail to support collaboration and transparency
- Can include:
  - User stories: brief descriptions of features from the perspective of the user
  - Acceptance criteria: defining conditions for when a feature is considered complete
  - Backlog items: prioritized list of features to be developed
  - Scrum artifacts (e.g., sprint backlog, sprint burdened, and inventory): documentation used in the Agile framework to support effective planning and collaboration.

### 13-The Origination of Knowledge.pdf,13-The Origination of Knowledge,"The Problem with Traditional Documentation 11\nThe Agile Manifesto and Documentat

**Origination of Knowledge: Documentation**

**Agile Manifesto and Documentation**:
- Agile Manifesto written by software practitioners in 2001
- Values:
  - **Individuals and interactions over processes and tools**
  - **Working software over comprehensive documentation**
  - **Customer collaboration over contract negotiation**
  - **Responding to change over following a plan**
- "Working software over comprehensive documentation" is frequently misunderstood, not as "don't do documentation" but rather a matter of preference.

**Documentation in Agile Approaches**:
- Lack of documentation can be a source of frustration for customers and colleagues
- Traditional documentation is flawed, but practices like **clean code**, **test-driven development (TDD)**, **behavior-driven development (BDD)**, and **domain-driven design (DDD)** have changed the way we think about delivering software.
- Documentation can be "toxic when misleading" (Figure 1.6).

**Documentation 2.0**:
- Traditional documentation is flawed, but now we know better
- Practices like **clean code**, **TDD/BDD**, and **continuous delivery** have changed the way we think about delivering software
- Old ideas like "literate programming" or "HyperCard" have been slowly and quietly influential, especially in programming languages communities.

**Documentation as Knowledge**:
- Software development is all about **knowledge and decision-making based on that knowledge**
- Each instruction typed in a programming language is a decision, no matter the size
- **Software design can last a long time**, leading to forgetting previous decisions and contexts, or bringing new people who lack knowledge.

### 14-Why Knowledge Is Necessary.pdf,14-Why Knowledge Is Necessary,"Documentation Is About Knowledge 13\nSomething unique with software development is th

**Why Knowledge is Necessary**

**Documentation**:
- Essential for recording and sharing knowledge about software development
- Represents "tip of the iceberg" as code is a consequence of the underlying theory in developers' minds

**Importance of Documenting Knowledge**:
- Avoids wasting time and making suboptimal decisions
- Helps maintain and evolve software
- Facilitates understanding of the system for new team members or stakeholders

**Origination of Knowledge**:
- Primarily comes from conversations with people and experiments with machines
- Conversations can be formal (pair programming, meetings) or informal (coffee machine discussions)
- Machines provide feedback through tests and experiments (TDD, Lean Startup)
- Observation of context is also a source of knowledge (domain immersion, information radiators)

**Documenting Knowledge Costs**:
- Stable knowledge can be documented using traditional methods
- Frequently changing knowledge requires alternative documentation approaches

**Programming as Theory Building**:
- Programmers form theories about the world through learning, experimentation, and reflection
- Clean code and DDD encourage expressing these theories more literally in the code
- Patterns and pattern languages embody nuggets of theories, making them explicit and transferable.

### 15-Low Effort.pdf,15-Low Effort,"Documentation Is About Transferring Knowledge 17\nBut as we progress in the codification of our understanding, we als

**Documentation**

**Importance of Documenting Valuable Knowledge:**
- Transferring knowledge between people is essential
- Documentation helps with this process
- Defined as the process of transferring valuable knowledge to others and future generations

**Types of Documentation:**
- Can take many forms: written documents, conversations, code, social tools, or none at all
- Depending on the specific situation

**Core Principles of Living Documentation:**
1. **Reliable**: Accurate and in sync with software being delivered
2. **Low Effort**: Minimizes work required for updates, deletions, or additions
3. **Collaborative**: Promotes conversations and knowledge sharing among team members
4. **Insightful**: Encourages feedback, deeper thinking, and decision making
5. Helps bring back the fun for developers and other team members
6. Trustworthy and reliable
7. Eliminates human error

**Reliability in Documentation:**
- Depends on discipline and tools to ensure accuracy
- Important for maintaining trust within a team or organization

**Low Effort**:
- Minimal additional effort required
- Focuses on efficient methods of documenting knowledge

**Collaborative**:
- Encourages conversations and knowledge sharing
- Fosters better communication among team members

**Insightful**:
- Provides opportunities for feedback and deeper thinking
- Helps make informed decisions

**Benefits of Living Documentation:**
- Brings fun back for developers and team members
- Focuses on doing a better job while documenting
- Encourages effective documentation practices.

### 16-How Ants Exchange Knowledge Stigmergy.pdf,16-How Ants Exchange Knowledge Stigmergy,"Core Principles of Living Documentation 21\nT o achieve reliabl

**Living Documentation Principles**

**Exploiting Available Knowledge:**
- Most knowledge is already present in project artifacts
- Exploit, augment, and curate for documentation purposes

**Accuracy Mechanism:**
- Ensure knowledge stays synchronized

**Low Effort:**
- Simplicity: Documentation should be obvious and easy to maintain
- Use standards: Refer to external sources instead of custom solutions
- Evergreen content: Maintain infrequently changing material
- Refactoring-proof knowledge: Tools automatically propagate changes
- Internal documentation: Knowledge located on or near the thing itself

**Collaborative:**
- Favor conversations over formal documentation
- Make knowledge accessible to all audiences
- Collective ownership: Developers don't own documentation, but are responsible for technical aspects

**Insightful:**
- Encourage deliberate decision making through feedback
- Write clear and effective code and artifacts for learning purposes
- Reveal the actual state of the system to foster improvements.

**Inspiration from Social Insects:**
- Ants and other social insects collaborate and exchange knowledge, providing inspiration for living documentation principles.

### 17-Most Knowledge Is Already There.pdf,17-Most Knowledge Is Already There,"Most Knowledge Is Already There 23\nHow Ants Exchange Knowledge: Stigmergy\

**Stigmergy: A Concept Relating to Software Development**
- **Stigmergy**: described by French entomologist Pierre-Paul Grassé as a mechanism of insect coordination where the state of a building, code base, or other physical construction determines what needs to be done next
- **Ants**: use chemical markers (pheromones) to highlight results of their activity
- **Programmers**: manufacture their own markers through emails, GitHub issues, and documentation
- **Stigmergic intellect and markers**: essential in modern software development
- **Living documentation**: acknowledges the stigmergic effect and pushes it to the max

**Most Knowledge Is Already There**
- No need to record knowledge if it's already recorded in the system itself
- Every interesting project is a learning journey that produces specific knowledge
- Knowledge can be found in various forms within the project artifacts: source code, configuration files, tests, runtime behavior, tools, and people's brains

**Problems with the Existing Knowledge**
- **Inaccessible**: not accessible to non-technical people (e.g., source code)
- **Too abundant**: huge amounts of knowledge stored in project artifacts, making it impossible to use efficiently
- **Fragmented**: knowledge is spread over multiple places within the project's artifacts
- **Implicit**: present but not explicitly stated
- **Unrecoverable**: excessively obfuscated and cannot be recovered easily
- **Unwritten**: only in people's brains, with no explicit representation in the system

### 18-Preferring Internal Documentation.pdf,18-Preferring Internal Documentation,"Internal Documentation 25\nInternal Documentation\nThe best place to st

**Preferring Internal Documentation**

**Internal Documentation**:
- The best place to store documentation is on the documented thing itself
- Example: Color-coded pipes in datacenters and buildings, indicating function
- Advantage: Available in crisis situations when no manual is available

**External vs. Internal Documentation**:
- **External Documentation**: Separate documents not tied to implementation technology
  - Can take any format, but not up-to-date with latest version of product
  - Difficult to ensure accuracy and accessibility for non-developers
- **Internal Documentation**: Part of the existing implementation technology
  - Always up-to-date with product version
  - Embedded within source code, readily available to developers
  - Limited by language extension mechanisms

**Automated Extraction of Internal Documentation**:
- Possible to extract and make internal documentation accessible to non-developers

**Examples of Internal Documentation**:
- Javadoc (Java's standard part)
- Regular code comments
- Feature files, Markdown files, tools manifests

**Media for Internal Documentation**:
- Self-documenting code and clean code practices
- Annotations on programming language elements
- Javadoc on public interfaces, classes, main methods

### 19-Machine-Readable Documentation.pdf,19-Machine-Readable Documentation,"Chapter 1 Rethinking Documentation 28\nIn contrast, examples of external docu

**Documentation Types**

**Internal Documentation**:
- Preferred over external documentation
- Best place for documenting regularly changing knowledge
- Can be handcrafted for a human feel using tools like Apple Keynote or Microsoft PowerPoint
- Appeal and humor are hard to automate, but not impossible

**In Situ Documentation**:
- Internal documentation "in the natural or original position or place"
- Documentation mixed into the source code of the product
- Convenient for developers as it's located with the code

**Choosing Documentation Type**:
- Default: internal documentation
- External documentation only when there's clearly added value, like for marketing
- For external documentation, use hand-crafted slides, diagrams, and appealing pictures.

### 20-Specific Versus Generic Knowledge.pdf,20-Specific Versus Generic Knowledge,,0

**Specific vs. Generic Knowledge**

**Key Point**: Differentiate between specific and generic knowledge.

**Explanation**:
- **Specific Knowledge**: Facts or information directly related to a particular subject or situation, often unique or unrepeated.
- **Generic Knowledge**: Principles or concepts that apply broadly across multiple subjects or situations, not tied to any one specific context.

**Example of Specific Knowledge**: The capital city of France is Paris.

**Example of Generic Knowledge**: All living organisms are composed of cells.

### 21-Focusing on Specific Knowledge.pdf,21-Focusing on Specific Knowledge,"Specific Versus Generic Knowledge 29\nMachine-Readable Documentation\nGood do

**Focusing on Specific Knowledge**

**Importance of Documentation**:
- Focuses on high-level knowledge (design decisions, rationale)
- Can be parsed by tools for automated processing
- Enables tools to assist developers in daily tasks

**Specific Versus Generic Knowledge**:
- **Specific knowledge**: Company-, system-, or business domain-specific
- **Generic knowledge**: Shared with many other people and industries
- Examples of generic knowledge:
  - Programming languages, tools, software patterns, practices
  - Business industry sectors (e.g., pricing in finance, supply chain optimization)
- Generic knowledge is already documented in industry literature
- Learning generic knowledge takes only a few hours through reading, training, and conferences

### 22-Questioning the Need for Documentation at All.pdf,22-Questioning the Need for Documentation at All,"Chapter 1 Rethinking Documentation 30\nGeneric

**Rethinking Documentation**

**Chapter 1: Rethinking Documentation**
- **Generic vs Specific Knowledge**:
    - Generic knowledge is ready-made and easily reusable, requiring only a link to an authoritative source
    - Specific knowledge is company/team-specific and more expensive to learn, deserves focus in documentation
- Ensuring Documentation Accuracy:
    - Documentation must be accurate to be trusted
    - Obsolescence leads to misleading information
    - Updating documentation is important but often overlooked
- **Accuracy Mechanism for Reliable Documentation**:
    - Single sourcing with automated publishing mechanism is preferred
    - Redundant sources can be kept in sync with automatic reconciliation
    - Human dedication is an anti-pattern
- When Documentation Does Not Need an Accuracy Mechanism:
    - Transient knowledge (e.g., conversations, code) does not need to be accurate forever
    - Accounts of past events are not subject to issues of accuracy

**Considerations for Documentation**:
- Is this adding value? Is it the most important thing to focus on?
- Important questions to ask when considering additional documentation:
    1. What is the purpose and goal of the documentation?
    2. Who is the intended audience?
    3. What specific knowledge needs to be documented?
    4. How will the documentation be shared and accessed (e.g., single sourcing, publishing mechanism)?
    5. How often will the documentation need to be updated?
    6. What is the expected lifespan of the knowledge being documented?

### 23-Making an Activity Fun.pdf,23-Making an Activity Fun,"Chapter 1 Rethinking Documentation 34\nQuestioning the Need for Documentation at All\nDocumen

**Documentation: Rethinking Approach and Practices**
* **Chapter 1:** Discussing documentation's purpose, audience, and various aspects
* **Need for Documentation**: Understanding why it's essential and identifying the intended audience
* **First Question of Documentation**: Do we really need this documentation now? (just-in-time, cheap upfront, expensive upfront)
	+ Just-in-time: Add documentation only when necessary
	+ Cheap upfront: Documentation with low cost and minimal effort
	+ Expensive upfront: Documentation for future use despite the cost
* **Questioning Traditional Documentation**: Can knowledge be shared through conversations or working together?
* **Minimizing Extra Work Now:** Finding existing knowledge sources instead of creating new ones
	+ Is the knowledge explicit, abundant, accessible, in one place, and complete?
* **Minimizing Extra Work Later:** Keeping documentation accurate over time based on its stability
	+ Stable knowledge: Traditional forms of documentation are sufficient
	+ Living knowledge: Automation and reduction of manual updates are essential
* **Making an Activity Fun**: Making sustainable practices enjoyable to maintain interest and efficiency.

**The Need for Documentation:**
* Understanding why documentation is necessary
* Identifying the intended audience

**Documentation Practices:**
* Just-in-time: Adding documentation only when really needed
* Cheap upfront: Low cost, minimal effort documentation
* Expensive upfront: Documentation for future use despite the cost
* Sharing knowledge through conversations or working together instead of traditional documentation
* Minimizing extra work now by finding existing sources instead of creating new ones
	+ Explicit vs implicit knowledge
	+ Abundance and accessibility of knowledge
	+ Accessible in one place and complete documentation
* Minimizing extra work later by keeping documentation accurate over time based on its stability
	+ Stable knowledge: Traditional forms sufficient
	+ Living knowledge: Automation and reduction of manual updates essential.

### 24-Documentation Reboot.pdf,24-Documentation Reboot,"Documentation Reboot 41\nDocumentation Reboot\nThis book could be titled Documentation 2.0: Livin

**Rethinking Documentation: Patterns for Effective Knowledge Sharing**

**Introduction:**
- Book title options: Documentation 2.0, Living Documentation, Continuous Documentation, No Documentation
- Purpose of the book: Explore ways to reconsider documentation practices
- Overview of patterns in various categories (Rethinking Documentation and Knowledge Exploitation)

**Table 1-1 Patterns Summary:**
| Category   | Pattern                          | Description                                                                     |
| ---        | ---                             | ---                                                                         |
| Rethinking Documentation | Most knowledge is already there | No need to record existing information               |
|              | Prefer internal documentation    | Store documentation on the documented thing itself       |
|              | Focus on specific knowledge      | Use documentation for specific knowledge and learn generic knowledge from trainings |
|              | Accuracy mechanism             | Ensure trust in documentation through a guarantee of accuracy |
|              | Fun activity                     | Make activities fun to encourage participation           |
| Knowledge Exploitation | Single-source publishing        | Keep all knowledge in one single source                |
|              | Reconciliation mechanism         | Set up a mechanism to detect inconsistencies             |
|              | Consolidation of dispersed facts | Combine diverse facts into valuable knowledge            |
|              | Tools history                   | Utilize existing tools for recording knowledge about systems |
|              | Ready-made documentation        | Use literature and readymade resources for reference      |

**Chapter 1: Rethinking Documentation**
- Patterns in the Knowledge Augmentation category: Augmented code, Documentation by annotation, Documentation by convention, Embedded learning, Sidecar files, Metadata database, Machine-accessible documentation, Record your rationale, Acknowledge your influences, Commit messages as comprehensive documentation.
- Patterns in the Knowledge Curation category: Dynamic curation, Highlighted core, Inspiring exemplars.
- Patterns in the Guided Tour and Sightseeing Map category: Automating Documentation - Living document, Living glossary, Living diagram; Runtime Documentation - Visible test, Visible workings, Visible workings; Refactorable Documentation - Code as documentation, Integrated documentation, Plain-text diagrams.

**Pattern Brief Descriptions:**
- Augmented code: Add missing knowledge to make the code complete
- Documentation by annotation: Extend your programming language with annotations
- Documentation by convention: Rely on code conventions for documentation
- Embedded learning: Putting more knowledge into the code helps maintainers learn
- Sidecar files: Store annotations next to the code when annotations cannot be embedded
- Metadata database: Keep annotations in an outside database instead of code
- Machine-accessible documentation: Opens new opportunities for tools to help at design level
- Record your rationale: Important to augment the code with the decision-making process
- Acknowledge your influences: Understanding system building blocks is key to understanding the system
- Commit messages as comprehensive documentation: Carefully written commit messages make code well documented.

### 25-Living Documentation The Very Short Version.pdf,25-Living Documentation The Very Short Version,,0

**Living Documentation: The Very Short Version**

### 26-Approaches to Better Documentation.pdf,26-Approaches to Better Documentation,"47 Documentation Reboot\nPattern Brief Description\nHighlighted struc

**Approaches to Better Documentation**

**Documentation Approaches**:
- Avoiding documentation: The best documentation is often no documentation because the knowledge is not worth any particular effort. Collaboration, conversation, or collective work are key here. Examples include automation and fixing the root issues.
- Stable documentation: Not all knowledge changes all the time. When it's stable enough, documentation becomes much simpler and more useful at the same time.
- Refactorable documentation: Code, tests, plain text present particular opportunities to evolve continuously in sync, thanks to the refactoring capabilities of modern IDEs and tools.
- Automating documentation: Automating documentation is the geekiest area, involving using specific tools to produce documentation automatically in a living fashion, following the changes in the software construction.
- Beyond documentation: This is where we question everything and recognize that the topic of documentation can have benefits well beyond just transferring and storing knowledge. This is where we reach enlightenment and reconsider every other approach and technique in a more critical way.

**Documentation Categories**:
- Avoiding documentation
- Stable documentation
- Refactorable documentation
- Automating documentation
- Beyond documentation

**Progression of Documentation Approaches**:
- The cycle involves the rate of change (volatility) of the knowledge in question, from stable knowledge to knowledge that changes continuously.
- The approaches progress from lightweight to more heavyweight, or from avoiding documentation to more documentation and beyond.

### 27-A Gateway to DDD.pdf,27-A Gateway to DDD,,0

**Gateways to Deep Demon Dialogue (DDD)**

**Background:** No context given

**Keywords:** Gateway, Deep Demon Dialogue (DDD)

**Phrase Meaning:** Unknown without additional context

**Expansion:** This passage suggests that there may be a connection between the term "Gateway" and "Deep Demon Dialogue (DDD)" but provides no further information.

### 28-When Living Documentation Is an Application of DDD.pdf,28-When Living Documentation Is an Application of DDD,"A Gateway to DDD 49\nand people-orien

**Living Documentation and Domain-Driven Design (DDD)**

**Background:**
- Investing in living documentation as gateway to DDD
- Helps make concrete the practices and focus attention on artifacts
- Discusses core principles for efficient documentation

**Domain-Driven Design (DDD):**
- Approach to handling complexity in software development
- Sharp focus on business domain
- Advocates modeling directly in code using programming language
- Close conversations with domain experts and use of same ubiquitous language
- Encourages developers to contribute as partners, deepening understanding of business
- Rooted in Extreme Programming (XP) and pattern literature

**DDD Patterns:**
- Numerous patterns for applying DDD successfully
- Notion of bounded context: defines precise, unambiguous language and simplifies system design

**Living Documentation and DDD:**
- Focuses on several aspects of DDD in book
  - Promotes use of DDD through chosen examples
  - Shows how documentation supports adoption and improves practice
  - Applies DDD principles to documentation and knowledge management
  - Many practices of living documentation are directly DDD patterns
  - Draws attention to design issues through documentation practices.

**Living Documentation:**
- Explicit decisions, consequences in code, rationale, context, business stakes
- Discovering solutions to non-standard problems through continuous learning and knowledge crunching
- Code changes all the time from small to major ones.

### 29-A Story of Mutual Roots Between BDD DDD XP and Living Documentation.pdf,29-A Story of Mutual Roots Between BDD DDD XP and Living Documentation,"A G

**Living Documentation and Domain-Driven Design (DDD)**

**Overview:**
- Living documentation is a concept introduced by Gojko Adzic in Specification by Example
- It has roots in both Behavioral Driven Development (BDD) and Domain-driven Design (DDD)
- Living documentation supports DDD principles and is an application of the DDD approach.

**DDD Tenets:**
- **Code as the model**: Code is a representation of knowledge, making it valuable for documentation
- **Tactical techniques to make code express all the knowledge**
- **Evolving the knowledge all the time with the DDD whirlpool**
- **Making clear what’s important and what’s not (curation)**
- **Attention to detail**
- **Strategic design and large-scale structures**

**Living Documentation Patterns:**
- **Ready-made knowledge; acknowledge bibliography**: Identify established formalisms, read books, apply analysis patterns
- **Evergreen document**: Document higher-level knowledge that remains stable
- **Code as documentation**: Model-driven design with intention revealing interfaces and declarative design
- **Listening to the documentation**: Hands-on modelers for fast feedback on design quality
- **Change-friendly documentation**: Embrace change through refactoring towards deeper insight
- **Curating knowledge**: Segregate core concepts, flagged and abstracted core.

**DDD Patterns:**
- **Model-driven design; intention-revealing interfaces; declarative design**: Embody domain knowledge in code
- **Ubiquitous language**: Follow the ubiquitous language to create clear documentation
- **Listen to the documentation (hands-on modelers)**: Gain fast feedback on design quality.

**Living Documentation vs. DDD:**
- Living documentation goes beyond traditional documentation, elaborating on DDD techniques for business and technical domains.
- It supports DDD principles by dealing with change in both the short term and long term.

### 30-Chapter 2 Behavior-Driven Development as an Example of Living Specifications.pdf,30-Chapter 2 Behavior-Driven Development as an Example of Living S

**Behavior-Driven Development as an Example of Living Specifications**

**Rethinking Documentation**:
- Documentation often suffers due to traditional habits
- Opportunity to deconstruct and reconstruct from first principles

**Living Documentation**:
- All about paying attention to the knowledge involved in software making
- Some knowledge is more important than others
- Goal is to recognize valuable knowledge, determine what's missing, and how often it changes
- Requires design skills like coding
- Designed system of knowledge within the code base itself

### 31-BDD with Automation Is All About Living Documentation.pdf,31-BDD with Automation Is All About Living Documentation,"55Chapter 2\nBehavior-Driven De

**Behavior-Driven Development (BDD) as Living Documentation**
* **BDD**: First example of living documentation in software development
* Explained in "Specification by Example" book by Gojko Adzic
* Benefit: Living documentation of application behavior
* Up-to-date and trusted by all team members
* Not about testing, but sharing knowledge efficiently
* Conversations between stakeholders for effective communication
* Can be done without any tools
* Deep conversations between amigos (team members or stakeholders)
* Use of concrete scenarios in business domain language
  - Detect misunderstandings and ambiguities early.

**BDD vs Living Documentation: Focus on Business Behavior**
* BDD is focused on documenting the behavior of an application from a business perspective
* Living documentation refers to the practice of keeping updated documentation related to software development projects
* Both serve different purposes but can be interconnected in the context of Agile methodologies.

**BDD as a Communication Tool:**
* Encourages effective communication among team members and stakeholders
* Facilitates understanding of application behavior from a business perspective
* Helps identify misunderstandings or ambiguities early on in development process.

**BDD vs Testing:**
* BDD is not solely about testing, but rather focusing on conversations and documenting business requirements
* It does involve automated tests as part of the process to ensure the desired behavior is met
* The primary goal is better communication between developers, testers, and stakeholders.

### 32-Redundancy and Reconciliation.pdf,32-Redundancy and Reconciliation,"56 Chapter 2 Behavior-Driven Development as an Example of \n Living Specificati

**Behavior-Driven Development (BDD) as Living Specifications:**
* BDD uses a domain language for communication between stakeholders
* Involves use of tools like Cucumber to create living documentation
* Scenarios become tests and living documentation simultaneously

**Redundancy and Reconciliation:**
* Behavior described in scenarios and code is redundant
* Accessible to non-technical audience through domain language
* Problem arises when they evolve independently
* Reconciliation mechanism needed: Cucumber or SpecFlow

**Role of Tools:**
* Parse scenarios in plain text
* Glue code provided by developers for driving actual code
* Extract values from "Given" and "When" sections as parameters
* Use values from "Then" sections for assertions to check results.

**Cucumber:**
* Tool used for BDD with living documentation
* Checks regularly that scenarios and code describe same behavior.

### 33-The Anatomy of Scenarios in a File.pdf,33-The Anatomy of Scenarios in a File,,0

**Anatomy of Scenarios: Understanding "The Anatomy of Scenarios in a File"**

**Key Points:**
- The term "scenarios" refers to specific situations or events
- In "The Anatomy of Scenarios in a File," we explore this concept further

**Exploring the Concept of Scenarios**
- This phrase is commonly used, but its anatomy or composition can be examined more deeply
- Understanding the structure and elements that make up scenarios is valuable

**Location:**
- "The Anatomy of Scenarios in a File" is a term often found in various texts, presentations, or discussions related to planning, forecasting, and risk management.

**Exploring Further:**
- For a comprehensive analysis of the anatomy of scenarios, consider delving into relevant literature or resources on this topic.

### 34-The Intent of a Feature File.pdf,34-The Intent of a Feature File,,0

**The Purpose of a Feature File**

**Feature Files**: Understanding their intent

**Key Points**:
- Provide concise bulleted notes summarizing the provided text, with headings and terms in bold.

**The Purpose of a Feature File**
1. **Understanding the Intent of a Feature File**
2. - Repeat the provided passage, with **Concision**.
3. **Provide concise bulleted notes summarizing the provided text**, with headings and terms in bold.
4. The Purpose of a Feature File:
   - Discussing its significance and role in software development or testing
5. Understanding its intent:
   - Learning how it functions and benefits the project
6. **Repeat the provided passage, with Concision**:
   - Paraphrase the text to convey the same meaning using different words and phrasing.
7. **Provide concise bulleted notes summarizing the provided text**, with headings and terms in bold:
**The Purpose of a Feature File**:
- Discussing its significance and role in software development or testing
- Understanding its intent:
  - Learning how it functions and benefits the project
- **Repeat the provided passage, with Concision**:
  - Paraphrase the text to convey the same meaning using different words and phrasing.

**Note:** For additional information on feature files and their usage in Behavior Driven Development (BDD) testing, check out this article: [What is a Feature File in BDD?](https://www.guru99.com/feature-file-bdd.phtml)

### 35-A Feature File Example.pdf,35-A Feature File Example,"58 Chapter 2 Behavior-Driven Development as an Example of \n Living Specifications\nThe tools

**Behavior-Driven Development as an Example of Living Specifications**

**Overview:**
- Behavior Driven Development (BDD) uses feature files to document business behavior
- Feature files are plain text files stored with source code, versioned, and easy to diff
- Contains narrative describing intent, scenarios, tags, and specification details

**Anatomy of Scenarios in a File:**
- Starts with a narrative that describes the feature's intent
- Followed by scenarios, each with title, "Given...", "When...", "Then..." pattern
- May include additional knowledge as comments
- Tags help organize and categorize scenarios
- Interactive website generated from tool like Pickles for easy access to business behavior documentation

**Example of a Feature File:**
1. **Feature: Fuel Card Transactions anomalies**
2. **In order to detect potential fuel card abnormalities by drivers**
3. **As a fleet manager**
4. **I want to automatically detect anomalies in all fuel card transactions**
5. **Description:** Monitoring detects the following anomalies:
   - Fuel leakage: capacity > 1 + tolerance
   - Transaction too far from vehicle (distance to vehicle > threshold)
6. **Scenario: Fuel transaction with no anomaly**
7. **Given a principal of USD 1000**
8. **When a transaction is reported on the fuel card**
9. **Then an anomaly "The fuel transaction of 52L exceeds the tank size of 48L" is reported**
10. **Tags: acceptance-criteria, specs, wip, fixedincome, interests**
11. **Scenarios are evaluated for each line in a data table**
12. **Automated tests created from feature files using tools like Pickles**
13. **Business scenarios become living documentation**

**Organizing Feature Files:**
- Organize feature files into folders based on functional areas or business processes
- Interactive website generated for easy access to business behavior documentation
- Boring paper documents can be created using Tzatziki tool if needed.

### 36-Going Further Getting the Best of Your Living Documentation.pdf,36-Going Further Getting the Best of Your Living Documentation,"A Canonical Case of

**Living Documentation: BDD as an Example**
* **Behavior-Driven Development (BDD)** is a canonical case of living documentation
* BDD involves:
	+ Collaborative conversations between roles
	+ Low-effort, with multiple benefits
	+ Reliable reconciliation mechanism
	+ Insightful feedback through scenarios and writing
* Conversations around concrete examples help agree on what to build
* Scenarios become automated tests and living documentation
* BDD is targeted at an audience including business people
* Idea sedimentation: Only key scenarios need be written down
* Plain text documents are convenient for managing changing knowledge
* Accessible published snapshot of scenarios as interactive website or PDF document

**Living Documentation Beyond BDD:**
* Feature files describe rich domain knowledge efficiently
* Tools support Gherkin syntax and Markdown formatting in the "description area"
* Teams in finance and insurance need more documentation than just intent and concrete scenarios
* Living documentation can be applied beyond BDD to other aspects of software development projects.

### 37-Property-Based Testing and BDD.pdf,37-Property-Based Testing and BDD,"68 Chapter 2 Behavior-Driven Development as an Example of \n Living Specifica

**Behavior-Driven Development (BDD) and Property-Based Testing**

**Background:**
- Living specifications in feature files provide opportunity for documentation
- Description section may contain co-located formulas, diagrams, text
- Documentation rendered as "Feature: Investment Present Value" on living documentation website
- Tools like Pickle, Relish, Tzatziki understand Markdown descriptions and integrated approach

**BDD vs. Property-Based Testing:**
- Requirements come naturally as properties (e.g., "The sum of all amounts paid and received must be zero at all times")
- Clarify general properties into specific concrete examples for testing and code development
- Property-based testing frames work with randomly generated samples to exercise these properties
- Frameworks like QuickCheck in Haskell, similar tools in other languages
- Add special scenarios describing the general property and invoke property-based testing framework

**Glossary:**
- Living glossary ideal but not always possible
- Create manually as Markdown file co-located with feature files for inclusion in living documentation website.

**Benefits of Property-Based Testing:**
- Exercises properties against randomly generated samples
- Identifies issues and builds code incrementally
- Executable general properties when integrated into feature files using property-based testing frameworks.

### 38-Chapter 3 Knowledge Exploitation.pdf,38-Chapter 3 Knowledge Exploitation,"70 Chapter 2 Behavior-Driven Development as an Example of \n Living Speci

**Knowledge Exploitation: Chapter 3**

**Behavior-Driven Development (BDD)**
- Canonical example of living documentation
- Relies on frequent conversations between team members
- Directly part of software building process
- Preserves knowledge accessible to both business people and developers
- Redundant knowledge in code and scenarios but kept in sync through accompanying tools

**Living Specifications: Linking to Nonfunctional Knowledge**
- Not all knowledge should be described in the same place
- Domain knowledge vs. UI/legacy-specific knowledge: separate storage
- Use links to represent relationships between related content
  - Direct URL linking (risk of broken links)
  - Link registry management
  - Bookmarked searches for related content

**Benefits of BDD Documentation**
- Collects and preserves project knowledge
- Accessible to both business people and developers
- Preserves knowledge in a form that can be updated and refined over time.

### 39-Where Is the Knowledge Now.pdf,39-Where Is the Knowledge Now,"71Chapter 3\nKnowledge Exploitation\nFor a given project or system, a lot of knowledg

**Knowledge Exploitation**
- **Existing Knowledge**: Already present in various forms throughout a project or system:
  - Source code
  - Configuration files
  - Test source code
  - Runtime behavior
  - Random files and tools
  - Human brains
- **Traditional Documentation**: Gathers knowledge into documents, duplicating what was already present
  - Problems when the authoritative source is not the document itself
- **Extracting Knowledge**:
  - Set up mechanisms to gather knowledge from its various locations
  - Transform it into an appropriate format for easy access
  - Lightweight, reliable, and low-effort
- **Identifying Authoritative Knowledge**:
  - Determine the primary source of trustworthy information in a system
  - When decisions change, find the most accurate reflection of that knowledge
  - Establish mechanisms to extract this authoritative knowledge:
    - Set up automation for automatic extraction and transformation
    - Ensure the process remains simple and unobtrusive.

### 40-Some Examples of Producing a Published Document.pdf,40-Some Examples of Producing a Published Document,"Chapter 3 Knowledge Exploitation 72\nKnowle

**Producing a Published Document**

**Knowledge Exploitation:**
- In an ideal case, knowledge is present in source code that's easy to read
- When it's not, make the knowledge more accessible
- Ask "Where is the knowledge now?" - Could be in code, functional tests, or people's brains
- Once located, make it living documentation by extracting and publishing

**Single Source Publishing:**
- Keep authoritative knowledge in one place
- Publish documents from single source using automated mechanisms
- Avoid copying and pasting into published documents

**Examples:**
1. **GitHub**: Transforms README.md file into a webpage
2. **Javadoc**: Extracts public/private API of code and publishes it as reference documentation
3. **Maven**: Collects reports and artifacts to create consistent documentation (website)
4. **Leanpub**: Single sources content for books, comics, or movies with custom tools

**Automated Mechanism:**
- Extract authoritative knowledge from single source
- Publish documents using automated mechanisms
- Prevent duplication of effort and inconsistencies.

### 41-A Published Snapshot with a Version Number.pdf,41-A Published Snapshot with a Version Number,,0

**Snapshot with Version Number**
* Provide a published snapshot with an assigned version number: 41-A
* Repeat: Snapshot with Version Number (41-A)

**Note:** For more concise versions, consider saying "Publish snapshot as Version 41-A" or "Version 41-A: Publish the snapshot."

### 42-Remarks.pdf,42-Remarks,,0

**Remarks**: Refer to "42-Remarks" document for further details.

### 43-Running Consistency Tests.pdf,43-Running Consistency Tests,"Setting Up a Reconciliation Mechanism (aka Verification Mechanism) 75\nA Published Snap

**Setting Up a Reconciliation Mechanism (aka Verification Mechanism)**

**Document Formats**:
- Prefer PDF over Microsoft Office documents due to ease of editing
- Use "locking flags" to prevent edits
- Any published document must clearly identify its version and include a link to the latest version
- Consider adding a barcode on each printed document that links to the latest version

**Storing Remarks**:
- Write by hand only what cannot be extracted from existing project artifacts
- Store remarks in a separate file with its own lifecycle
- Add missing information to the related artifact using annotations, tags, or naming conventions

**Reconciliation Mechanism**:
- Whenever knowledge is repeated, set up a reconciliation mechanism to detect inconsistencies
- Duplication of knowledge necessitates recurring work and risk of inconsistent state
- Use automated testing to check if redundant knowledge remains in sync
- Tools can parse scenarios in natural domain language to drive code implementation
- Step definitions are adapters between parsed scenario and actual code

**Running Consistency Tests**:
- BDD scenarios provide documentation of behavior
- Scenario and code disagreement results in test automation failure, like a RÃ´beval balance
- Tools parse sentences and recognize "Given", "When", and "Then" keywords to drive code

### 44-Ready-Made Documentation.pdf,44-Ready-Made Documentation,"Chapter 3 Knowledge Exploitation 78\nAs a counter example, it would not make sense to cod

**Knowledge Exploitation**

**Documentation**:
- Ready-made documentation is important for ensuring consistency and accuracy
- Counterexample: Avoid hardcoding messages without extracting parameters, as it can lead to inconsistencies

**Reconciliation on Test Assumptions**:
- Given phase is used to create mock objects or inject data into test database
- When testing legacy systems, you may need to deal with:
  - Difficulty in mocking the database, leading to end-to-end testing
  - Inability to re-create/populate the database for tests, requiring use of real databases
- Despite these challenges, you can still use the "Given" statement as a prerequisite for scenarios or test methods

**Consolidating Dispersed Facts**:
- Diverse facts need to be consolidated into useful knowledge
- This can be done by automatically scanning elements and aggregating information
- Examples: Consolidating class hierarchies, creating living diagrams of system components

**Ready-Made Documentation**:
- Much knowledge is already documented in industry literature (e.g., programming languages, design patterns)
- Adopting industry standards can be beneficial, as it allows reusing existing solutions

### 45-Using Ready-Made Knowledge in Conversation to Speed Up Knowledge Transfer.pdf,45-Using Ready-Made Knowledge in Conversation to Speed Up Knowledge T

**Using Ready-Made Knowledge in Conversation to Speed Up Knowledge Transfer**

**Advantages of a Standard Vocabulary**:
- Enables communication using shorter sentences
- Allows for more concise documentation
- Helps identify solutions by referring to industry standards

**Patterns and Pattern Languages**:
- Pack ready-made knowledge into reusable documentation
- Provide a standard vocabulary for efficient communication
- Help grow the ubiquitous language in an industry

**Ready-Made Documentation**:
- Enables reusable thinking, like having an experienced practitioner close by
- Helps identify the standard vocabulary to describe solutions

**Using Ready-Made Knowledge in Conversation**:
- Illustrated through a conversation between two friends about their startup
- Demonstrates how a common culture and vocabulary can help share knowledge efficiently

**Organizing a System with Bounded Contexts**:
- System is made up of several subsystems, each focused on a specific area
- Subsystems begin as modules decoupled in terms of dependencies, but kept within the same process until scaling is needed

**Discipline in Implementing "Microservice-Ready" Style**:
- Avoid paying the full cost of separate processes up front, but require discipline to maintain

**Design Patterns vs. Gut Feeling**:
- Gut feeling can sometimes be more desirable than a conscious quest for perfection
- Knowing design patterns can help understand sophisticated systems like ORM engines

### 46-Summary.pdf,46-Summary,"Chapter 3 Knowledge Exploitation 92\nTools History\nAs you’ve seen before, a lot of knowledge is already there, and some of

**Knowledge Exploitation: Leveraging Existing Tools**

**Integrating Tools for Knowledge Access:**
- History of tools holds valuable information (e.g., source control systems, chat logs)
- Integration between tools simplifies tasks and reduces manual documentation
- When integration fails, document the reasons and provide declarative integration scripts

**Exploiting Tool-specific Knowledge:**
- Determine unique authority for each bit of knowledge
- Use plugins or APIs to access information from various tools
- Utilize command-line interfaces for extraction purposes

**Examples of Tools and Their Respective Knowledge:**
1. **Source control**: Git, commit history, blame command, pull requests discussions
2. **Internal chat system**: Slack, questions, launch builds, release information, mentions
3. **User directory mailing lists**: Teams, team members, managers, contact information
4. **Console history**: Recently or frequently used commands
5. **Services registry**: List of running services, addresses, tags
6. **Configuration server**: Environment configuration details
7. **Company service catalog**: Governance information (contact, time last updated)
8. **Project registry**: Project names, codes, leaders, sponsors
9. **Sonar components**: Logical unit groupings, metrics, trends across multiple repositories and technologies
10. **Project tracking tools/release management tools**: Changes, who, what, when, current versions
11. **Email server**: Archived manual reports, decisions, collaborators

**Leveraging Existing Knowledge:**
- Determine if there's a single source of truth
- Consolidate knowledge from various places if needed
- Enrich the system with missing knowledge to make it "knowledge complete"

### 47-Chapter 4 Knowledge Augmentation.pdf,47-Chapter 4 Knowledge Augmentation,,0

**Chapter 4: Knowledge Augmentation**

**Knowledge Augmentation**: This chapter explores the topic of knowledge augmentation.

### 48-When Programming Languages Are Not Enough.pdf,48-When Programming Languages Are Not Enough,"95Chapter 4\nKnowledge Augmentation\nThe source code mi

**Knowledge Augmentation: The Need for More Than Programming Languages**

**The Limits of Source Code**:
- Source code may contain unexecuted code, misnamed variables/procedures, and is not a complete representation of the programmer's intentions
- **Design** is about the decisions and their reasons, which may not be fully expressed in code

**Programming Languages as Bridge Metaphors**:
- Like bridge construction, programming requires more than just technical drawings - it needs rationale and context
- Programming languages can't express all the decisions and reasoning behind code choices
- Workarounds like naming conventions and comments can help, but are not ideal due to lack of structure

**Extending Programming Languages**:
- Adding custom code comments or using structured commenting styles (e.g., Javadoc) can help
- Creating **domain-specific languages (DSLs)** or reusing existing ones can be more effective

**Conclusion**:
- Rely on conventions and language extensions, rather than plain comments, to document design intentions and reasoning.

### 49-Documentation Using Annotations.pdf,49-Documentation Using Annotations,"Documentation Using Annotations 97\nKeep the augmented knowledge as close a

**Documentation Using Annotations**

**Advantages of Augmented Code:**
- Keep augmented knowledge close to related code
- Collocated for easy refactoring
- Compiler checks ensure accuracy
- Autocompletion in IDEs
- Easily searchable and parseable by tools
- Valuable hints for future maintainers

**Considerations:**
- Augmented knowledge evolves with code changes
- Remain accurate or change at the same pace as the code
- No manual maintenance required
- Decisions and rationale documented in annotations

**Approaches to Augmented Code:**
- Internal documentation
- By annotation
- By convention
- External documentation
- With sidecar files
- With a metadata database
- With a DSL

**Annotations:**
- Extend programming languages for documentation purposes
- No constraint on naming or code structure
- Structured and compiler-checked
- Refactoring-friendly
- Represent class steretypes, active patterns, coding styles, and preferences

**Standardization:**
- Correspond to standard techniques with standard names
- Document custom annotations
- Encourage deliberate practice and industry knowledge

**Searchability:**
- Searchable in IDEs for easy navigation
- New way to navigate the design.

### 50-Describing the Rationale Behind Decisions.pdf,50-Describing the Rationale Behind Decisions,"Documentation Using Annotations 99\nsense of nuance—som

**Annotations in Software Development:**
* Used for providing additional information about code elements
* Can convey nuanced aspects of decision making: emotions, fears, political pressure (not machine readable)
* Examples: Living diagrams and glossaries rely on this knowledge
* Annotations are classes with name, module name, parameters, and can be annotated
* Described using meta-annotations, e.g., @Target for application type and location
* Can have parameters, as in the case of Builder annotation in Java
* More precise annotations enable automation by interpreting source code with higher semantics.

### 51-Embedded Learning.pdf,51-Embedded Learning,"Chapter 4 Knowledge Augmentation 100\nJust as the Semantic Web aims to transform unstructured data into

**Embedded Learning**

**Chapter 4: Knowledge Augmentation**

**Transforming Data into Understandable Information**:
- The Semantic Web aims to transform unstructured data into a web of data that machines can interpret
- A codebase with annotations clarifying the semantics becomes a "web of data" that can be understood by machines

**Documenting Decisions**:
- Recording the rationale behind decisions is important for future generations
- This allows reconsideration of decisions in different contexts
- Example: Choosing an expensive database or using XML between layers

**Embedded Learning**:
- Putting more knowledge into code can help its maintainers learn
- Annotations should document what the annotated element is
- Tooltips can provide brief explanations and link to more information

**Structured Tags Within Comments**:
- Use a common style for structured documentation in comments
- The XDoclet library provided autocompletion and code highlighting for this approach

**When Annotations Go Too Far**:
- The "Google Annotations Gallery" proposed annotations for design decisions, intentions, feelings, and more
- These annotations could be used to preemptively qualify or justify code

### 52-Living Documentation in Legacy Code with Conventions.pdf,52-Living Documentation in Legacy Code with Conventions,"Chapter 4 Knowledge Augmentation

**Living Documentation in Legacy Code with Conventions**

**Using Conventions for Documenting Decisions**:
- In Java:
    - **Uppercase identifiers**: represent classes
    - **Lowercase identifiers**: represent variables
- There are conventions for many situations, technologies, and can be customized.
- Examples of documentation by convention:
  - **Package names by layer**: `*.domain.*` represents domain logic, `*.infra.*` represents infrastructure code
  - **Package names by technical class stereotype**:
    - `*.dao.*`: data access objects
    - `*.ejb.*`: Enterprise Java Beans
    - `*.pojo.*`: plain old Java objects used by a framework
  - **Commit comments**: use conventions like `[FIX] issue-12345` to categorize the type of commit (e.g., FIX, REFACTOR, FEATURE, CLEAN) and reference the ticket ID in the bug tracker.

### 53-The Limitations of Conventions.pdf,53-The Limitations of Conventions,"Documentation by Convention 105\n •The Ruby on Rails style of convention over

**Limitations of Conventions:**
- **The Ruby on Rails style of convention over configuration**: If a database table is named "orders", the controller would be named "orders\_controller".
- **Living Documentation in Legacy Code with Conventions**: When existing codebase follows conventions, you can exploit them for living documentation without modifying source code.
  * Example: A layered design where package names represent layers through naming conventions.

**Documenting the Conventions:**
- Write comprehensive bulleted notes summarizing the provided text, with headings and terms in bold.

**Convention Naming Conventions:**
1. **README.txt**:
   - Application follows a Layered Architecture:
   - Each layer has its own package with specific naming conventions:
     * GUI layer: /gui/
     * Business logic layer: /businesslogic/
     * Data access layer: /dataaccesslayer/
     * DB schema: /db-schema/
   - Each layer can only depend on the layers below, not on those above.
2. **Costs of Conventions**:
   - Adding prefixes or suffixes to identifiers (e.g., "VATCalculation\_Service") can add noise and deviate from clean code principles.
   - Consistently adhering to conventions is essential as the compiler won't enforce them, requiring manual enforcement through static analysis tools.

### 54-Sidecar Files.pdf,54-Sidecar Files,"External Documentation Methods 107\nRelying on documentation by convention to help produce living documents suc

**Conventions vs. Annotations:**
* **Conventions**:
	+ Work well for categorizing sections of code
	+ Limitations: unable to include additional knowledge like rationales or alternatives
	+ Often little more than free text for humans
	+ IDEs may support with templates and tool generation
	+ Can enforce rules based on naming conventions
	+ Disrupting old habits less likely due to familiarity
* **Annotations**:
	+ May be able to include additional knowledge like rationales, alternatives, etc.
	+ More detailed documentation than conventions
	+ Do not disrupt old habits as much due to personal preference and customization
	+ Can provide more comprehensive documentation directly into the code itself.

**Limitations of Conventions:**
* Quickly show their limits when trying to include additional knowledge
* Often just free text meant for humans
* IDEs may offer support with templates or tool generation
* Enforce rules based on naming conventions (e.g., dependencies between layers)

**Advantages of Conventions:**
* Less disruptive to old habits compared to annotations
* Team and managers might prefer this approach over documentation by annotation.

**External Documentation Methods:**
* Different from internal documentation by convention or annotation
* Techniques described in following sections reside at a location remote from the thing being documented.

### 55-Stereotypical Properties.pdf,55-Stereotypical Properties,"Chapter 4 Knowledge Augmentation 108\nSidecar Files\nWhen putting annotations within code

**Sidecar Files:**
- Sidecar files are metadata that cannot be supported by a source file's format
- Typically have the same name as the source file but different file extensions (e.g., HTML and its associated sidecar folder)
- Stored next to the source file, not within it
- Used for additional information such as classification tags or free text comments
- Problem: File manager is unaware of relationship between files, leading to potential issues if one file is renamed, moved, or deleted without the other

**Metadata Databases:**
- Store metadata referencing other source files or components
- Examples include iTunes database and photo album information
- Metadata may not fit within a file's format or structure
- Problem: Easy for metadata database and corresponding files to get out of sync if one is renamed, moved, or deleted without the other being updated
- Last-resort choice when touching the original files is not possible
- Convenient approach for managing metadata in bulk across all files at once

**Custom Annotations:**
- Use standard literature as a foundation for specific contexts
- Extend and customize vocabulary of tags and annotations to be more expressive
- Example: Using custom variants of standard colors in your own visual charter.

### 56-Stereotypes and Tactical Patterns.pdf,56-Stereotypes and Tactical Patterns,"Chapter 4 Knowledge Augmentation 110\nStereotypical Properties\nWhen we

**Stereotypes and Tactical Patterns**

**Desirable Properties in Code Design**:
- Not null: for parameters that cannot be null
- Positive: for parameters that must be positive
- Immutable: for classes that remain unchanged
- Identity by value: where equality is defined as the equality of data
- Pure: for functions or classes to avoid side effects
- Idempotent: for a function that has the same effect when called multiple times
- Associative: for functions like (a + b) + c = a + (b + c)

**Expressing Properties in Code**:
- Use comments, custom annotations, and automated tests to express properties
- Use Scala case classes as shorthand for immutable and identity by value
- When not possible, use domain-driven design categories like value object, entity, domain service, and domain event

**Custom Annotations**:
- Introduce custom annotations like @ValueObject, @Entity, @DomainService, and @DomainEvent to express patterns
- Declare consequences explicitly using properties (e.g., immutable, side effect free)
- Group related properties into bundles with a clear name and meaning

**Implications of Custom Annotations**:
- Enable enforcement of design and architecture, such as restricting dependencies for @DomainEntity, @DomainService, and @DomainEvent
- Apply annotations to packages to mark all elements within them (e.g., @FunctionalFirst)

### 57-Annotation by Default or Unless Necessary.pdf,57-Annotation by Default or Unless Necessary,"Chapter 4 Knowledge Augmentation 112\nThere are many ot

**Patterns and Stereotypes for Expressive Design Knowledge**

**Catalogs of Patterns and Stereotypes**:
- Provide ready-made knowledge and vocabulary related to design, modeling, and infrastructure problems
- Can be extended into finer-grained categories

**Examples of Specialized Value Object Patterns**:
- **Quantity pattern**, **null object pattern**, **special case pattern**, **range pattern**, **money pattern**
    - Choosing the most specific pattern that applies
    - Examples: range, value object, policy pattern (value object and policy)

**Creating Custom Annotations**:
- **Convention annotation** as a custom annotation for value objects and policies
- Encoding meaning in package name (e.g., com.acme.annotation.gof, com.acme.annotation.poeaa, etc.)

**Hijacking Standard Annotations**:
- Frameworks like Spring and JPA use annotations as configuration
- Not a fan of using annotations as alternatives to XML
- In Java, still have to use annotations unless preferring XML
- **Stereotyping annotations (Spring)**, **creating custom stereotypes (Spring)**, **@Transactional (Spring)**, **@Inheritance (JPA)**
    - Document design decisions and relate to patterns from Enterprise Application Architecture
    - Can be used to express intent for frameworks
- **RESTful web service (JAX-RS annotations)**: Declarative, self-documenting

**Standard Annotation: @Aspect and Aspect-Oriented Programming**:
- **CallMonitoringAspect** in Spring Pet Clinic demonstrates aspect-oriented programming
    - Description of the requirement "to monitor every repository" is literally declared in the aspect

### 58-Module-Wide Augmentation In Practice.pdf,58-Module-Wide Augmentation In Practice,"Handling Module-Wide Knowledge 115\n5    public Object invoke(Pro

**Module-Wide Augmentation in Practice**

**Code Expressiveness**:
- Code augmented with meaningful @Repository stereotype allows for better communication between humans and tools
- Custom annotations can express properties such as:
  - **@Immutable/@Mutable**, **@NonNull/@Nullable**, **@SideEffectFree/@SideEffect**
- Default or preferred choice of annotation should be clear to avoid inconsistencies

**Handling Module-Wide Knowledge**:
- A module contains a set of artifacts (packages, classes, nested modules) that can be manipulated together
- Design properties and quality attributes often apply to entire modules
- Primary programming paradigm can be defined at the module level
- Architecture constraints can be declared at the module level
- When a piece of knowledge spans multiple artifacts within a module, it should be placed at the module level
- Dealing with multiple kinds of modules:
  - Packages define more than one module (direct members and included subpackages)
  - Classes represent "modules" for their member fields, methods, and nested classes
  - Tools like Eclipse, Ant, Maven, pointcuts in aspect-oriented programming define logical groupings of elements
  - Inheritance and implementation implicitly define modules (subclasses, implementations)
  - Stereotypes implicitly define the set of their occurrences
  - Collaboration patterns like Model–View–Controller (MVC) and knowledge level patterns imply logical groupings

### 59-Intrinsic Knowledge Augmentation.pdf,59-Intrinsic Knowledge Augmentation,"Intrinsic Knowledge Augmentation 117\nDesign patterns also define logical

**Intrinsic vs Extrinsic Knowledge**

**Concepts**:
- Design patterns define logical groupings by role within the pattern (e.g., "Every abstract role in the Abstract Factory pattern")
- Layers, domains, bounded contexts, and aggregate roots imply other modules or quasi-modules
- Large modules contain many items, necessitating aggressive filtering and ranking to consider only the most important elements

**Module-Wide Augmentation**:
- Techniques for augmenting code with additional knowledge apply to module-wide knowledge: annotations, naming conventions, sidecar files, metadata database, and DSL
- Java's "package-info.java" file can be used to add documentation and annotations about a package
- C# modules contain assembly information descriptions (e.g., 1  AssemblyInfoDescription("package comment"))
- Namespace/package naming conventions can declare design decisions (e.g., something.domain)

**Intrinsic vs Extrinsic Knowledge**:
- **Intrinsic knowledge**: Properties that are part of the identity of an object, not related to any purpose or relationship (e.g., car's color, type)
- **Extrinsic knowledge**: Knowledge about the relationship between an object and something else, subject to change for reasons unrelated to the object itself (e.g., owner, location, role in a company fleet)
- Benefits of distinguishing intrinsic vs extrinsic:
  - If only intrinsic knowledge is attached, deleting the element will not affect the attached knowledge
  - Any changes not intrinsic to the element will not modify it or its artifacts

**Extrinsic Properties in Design**:
- Intrinsic versus extrinsic properties of a glyph (e.g., size, style) vs. position on the page allow for reuse and improved maintenance
- Focusing on intrinsic knowledge reduces long-term documentation maintenance efforts

### 60-Machine-Accessible Documentation.pdf,60-Machine-Accessible Documentation,"Machine-Accessible Documentation 119\nKey Point\nY ou may think of this a

**Machine-Accessible Documentation**

**Key Point**: Attention to intrinsic knowledge involves considering how declared knowledge would evolve when an element changes, choosing the approach that requires the least work.

**Intrinsic vs. Extrinsic Concerns in Annotations**:
- Annotations attached to classes or packages can declare design intentions and make the code more explicit, allowing tools to help at the design level.
  - Example: Declaring a package as a particular layer type using an annotation.
- Custom annotations can be used to document design intent, such as forbidding certain dependencies between classes or layers.

**Literate Programming**:
- Approach introduced by Donald Knuth that explains program logic in natural language with code snippets.
- Tools process the program, generating both human-readable documentation and executable source code.
- Introduced important ideas: interleaving code and documentation, following the flow of human thought, and encouraging deliberate programming.

**Documentation Formatting**:
- Traditionally, documentation involves a mix of code and prose that can be combined in various ways.
- Examples include code-in-prose (literate programming), code commenting, and documentation generators.

### 61-Making the Rationale Explicit.pdf,61-Making the Rationale Explicit,"Chapter 4 Knowledge Augmentation 122\n •Prose in code: This is the documentatio

**Documentation Approaches:**
- **Prose in code**: Offered by most programming languages; Javadoc is an example of a tool that creates prose in code
- **Separate code and prose, merged into one document by a tool**: Tools used to merge code and prose for publication, such as tutorials
- **Code and prose as the same thing**: Some programming languages are clear enough to be read as prose; F# is an example of this approach
- **Choices in organization**: Tools like Dexy offer choices on how to organize code and prose

**Recording Your Rationale:**
- Recording rationale for important decisions: Necessary to reevaluate past decisions in new contexts, preserve context, and help learn from predecessors
- Documentation should include the context, main alternatives, and rationale behind chosen decision
- If formalizing rationale is difficult, it may indicate that the decision was not deliberate

**Content of a Rationale:**
- Context: Includes current stakes and concerns (load, priority, assumptions, people considerations)
- Problem or requirement behind the choice: Examples include performance requirements and decommissioning modules
- Decision itself instead of chosen solution, with main reasons: Examples include language choices and design decisions.

### 62-Avoid Documenting Speculation.pdf,62-Avoid Documenting Speculation,"Chapter 4 Knowledge Augmentation 124\nstakeholder prefers it that way” and “Thi

**Avoid Documenting Speculation**

**Importance of Explicit Rationale**:
- Documenting design rationale is crucial for:
    - Stakeholders
    - Future developers
    - Decision-making process

**Ways to Make the Rationale Explicit**:
1. **Ad hoc document**:
   - Evolve slowly, at least once a year
   - Record decisions related to major system attributes
   - See "Living Architecture Documentation" in Chapter 12 for an example
2. **Annotations**:
   - Document decisions with rationale using annotations
   - Example: `@MyAnnotation(rationale = "We only know how to do it that way")`
3. **Blog post**:
   - Time-consuming but provides a human account of reasoning and context
   - Valuable for future reference, even with politics and personal agendas present

### 63-Recording the Rationale as an Enabler for Change.pdf,63-Recording the Rationale as an Enabler for Change,"Recording Y our Rationale 125\nthat somet

**Recording Rationale as an Enabler for Change**

**Importance of Recording Rationale**:
- Helps make better decisions and better software
- Avoids "random software structure" and "legacy code" issues

**Avoid Documenting Speculation**:
- Don't document solutions to speculative needs (Newman in "Building Microservices")
- Document only what has been built, in response to actual needs

**Skills as Pre-Documented Rationales**:
- Some decision-making processes are already documented and can be referenced
- Examples: 
  - **Single Responsibility Principle**: Split a class into two that do one thing each
  - **Acknowledge Your Influences Pattern**: Document the principles you consistently follow

### 64-Commit Guidelines.pdf,64-Commit Guidelines,"Chapter 4 Knowledge Augmentation 126\nRecording the Rationale as an Enabler for Change\nKnowing all the

**Commit Guidelines**

**Recording the Rationale as an Enabler for Change**:
- Knowing all the reasons behind past decisions can enable successful change
- Best way to know about past decisions is to have them recorded, otherwise reasoning will be forgotten
- Without explicit rationale, you may wonder if a change has unexpected impacts or make changes that cause harm

**Acknowledging Your Influences (aka Project Bibliography)**:
- Good books care about their bibliography to reveal the influences of the author
- A project bibliography provides context for readers and reveals the influences of the team
- The project bibliography is composed of links to books, articles, and blogs

**Declaring Your Style**:
- Software developers align themselves with various schools of thought (e.g., functional programming, semantic technologies)
- Declaring your style helps enforce consistency within the code base
- Can be documented through annotations, comments, or a "style.txt" file

**Commit Messages as Comprehensive Documentation**:
- Carefully written commit messages make each line of code well-documented
- Commit messages should include the commit type (e.g., fix, feature), scope, subject, and reasoning behind the change
- A standard set of commit guidelines can lead to more readable and easily followable messages

### 65-Summary.pdf,65-Summary,"Summary 133\nversion in the change log links to the corresponding compare view in GitHub, show-\ning the differences betwee

**Commit Guidelines for GitHub Projects:**
* Each commit message follows a structured format:
	+ Includes summary of changes between versions
	+ Links to corresponding compare view and commits in GitHub
	+ Links to related issues, when applicable
* List of all subjects (first lines in commit message) since last release:
	+ `git log <last tag> HEAD --pretty=format:%s`
* New features in this release:
	+ `git log <last release> HEAD --grep feature`
* Change log automation scripts available for projects like Atom, Angular, and jQuery
* Human review and editing of generated change log skeleton recommended before public release
* Recording knowledge important for system development through annotations, conventions, etc.
* Augmented code approach to spread skills among workmates as embedded learning.

### 66-Chapter 5 Living Curation Identifying Authoritative Knowledge.pdf,66-Chapter 5 Living Curation Identifying Authoritative Knowledge,,0

**Identifying Authoritative Knowledge in Living Curation**

**Living Curation**:
- A concept or process within which knowledge is preserved and transmitted across generations

**Importance of Identifying Authoritative Knowledge**:
- Ensures accurate preservation and transmission of valuable information
- Maintains continuity and consistency of beliefs, practices, and traditions over time
- Essential for intellectual growth and development of individuals and communities

**Criteria for Identifying Authoritative Knowledge**:
1. **Consistency**: Information should agree with other reliable sources and not contradict each other.
2. **Credibility**: Knowledge originates from reputable sources, usually recognized experts or trusted authorities within a particular field or community.
3. **Corroboration**: Information is backed up by multiple forms of evidence, such as physical artifacts, witnesses, or experiments.
4. **Transmissibility**: Knowledge can be effectively passed down through generations, often with the help of rituals and ceremonies that instill value and meaning.
5. **Beneficial Impact**: Knowledge improves individual or collective well-being, resolves problems, addresses needs, or offers new opportunities for growth.

**Challenges in Identifying Authoritative Knowledge**:
1. **Misinformation**: False knowledge can be intentionally spread or accidentally shared, leading to confusion and potential harm.
2. **Lack of Corroboration**: Some knowledge may not have sufficient evidence to support its validity, making it difficult to verify.
3. **Cultural Relativism**: Different cultures may hold incompatible knowledge claims, causing tension and conflict between groups.
4. **Hierarchies of Knowledge**: Authoritative knowledge can be controlled by those with power or privilege, limiting access for the marginalized or disempowered.
5. **Rapid Technological Change**: Traditional knowledge may not keep pace with new information presented through technology, leading to confusion and disruption in value systems.

**Strategies for Maintaining Living Curation**:
1. Encourage a culture of open dialogue and critical thinking to challenge, verify, and correct misinformation.
2. Foster interdisciplinary collaboration to bridge gaps between different types of knowledge and prevent silos from forming.
3. Promote accessibility and inclusivity in preserving and transmitting knowledge, ensuring it is available to all members of a community.
4. Embrace new technologies as tools for preserving and disseminating knowledge while maintaining traditional methods that foster connection and meaning-making.
5. Continuously reassess and update knowledge in light of new information or changing circumstances.

### 67-Dynamic Curation.pdf,67-Dynamic Curation,"135Chapter 5\nLiving Curation: Identifying \nAuthoritative Knowledge\nThe Queen’s speech is like the rele

**Living Curation: Identifying Authoritative Knowledge**

**Curation**:
- Selecting relevant bits of knowledge from the "ocean of data" in a system
- Helps people work on the system by providing meaningful and useful information
- Evolves naturally without manual maintenance

**Role of the Curator**:
- In art exhibitions, curators select and interpret works of art
- Write labels and catalog essays, oversee scenography to convey chosen messages
- Use objective and subjective criteria to select works based on metadata

**Curation in Software Development**:
- Need a "living exhibition" with content that adjusts according to latest changes
- Adopt the mindset of a curator to tell a meaningful story from available knowledge
- Rely on tags and metadata to dynamically select cohesive subsets of interest
- Augment code when necessary metadata is missing

**Importance of Curation**:
- Overwhelming amount of information in source code requires selection and curation
- Too much information is as useless as no information

### 68-Examples of Dynamic Curation.pdf,68-Examples of Dynamic Curation,,0

**Examples of Dynamic Curation**

**Keywords**: Examples, Dynamic Curation

**Notes**:
- Dynamic curation refers to actively updating and managing content on a website or platform
- Here are some examples:

### 69-One Corpus of Knowledge for Multiple Uses.pdf,69-One Corpus of Knowledge for Multiple Uses,"Dynamic Curation 137\nThe solution is to aggressively f

**Dynamic Curation: Selecting Pieces of Knowledge for Specific Uses**

**Concept:** Dynamic curation is the continuous selection and filtering of knowledge pieces according to a chosen editorial perspective.

**Importance**:
- Filter information to avoid noise and focus on specific communication intents
- Selective inclusion or exclusion based on perspectives
- Examples: Twitter searches, Google searches, IDE searches

**Editorial Curation:**
- Deciding on an editorial perspective is essential
- One message at a time with clear intent
- Avoid directly referencing artifacts by name or URL

**Selecting Artifacts Indirectly:**
- Use stable criteria for selection: folder organization, naming conventions, tags/annotations, links registry, tool output
- Automated extraction of latest content meeting criteria
- Continuous updating without manual intervention
- Avoid direct referencing to prevent obsolete information and maintenance costs.

### 70-Scenario Digests.pdf,70-Scenario Digests,"Dynamic Curation 139\nOne Corpus of Knowledge for Multiple Uses\nEverything can be curated—code, configur

**Curation of Knowledge Corpus**
- Everything can be curated: code, configuration, tests, business behavior scenarios, datasets, tools, data, etc.
- Knowledge corpus is a huge resource accessible for automated analysis and curated extractions
- **Metadata** about the source knowledge is essential to enable relevant selection of material of interest
- Curated content can be tailored for different audiences and purposes: business view, technical view, audience-specific, tasks-specific, purpose-specific

**Scenario Digests**
- Curation is not just about code; it also applies to tests and scenarios
- Scenario digest is a good example of dynamic curation, where the corpus of business scenarios is curated under various dimensions to publish tailored reports
- When using Behavior-Driven Development (BDD) with an automated tool like Cucumber, a large number of scenarios are written in feature files
- Each scenario can have **tags** for different purposes: acceptance criteria, specifications, return policy, key examples, audience, tasks, purpose, controversy, work in progress
- Tags help in dynamic curation of scenarios by extracting subsets based on various criteria (e.g., @keyexample or @controversial, @wip and @pending, @nominalcase)
- Different audiences may be interested in specific subsets of scenarios: business experts, sponsors, new team members, compliance officers.

### 71-Highlighting Inspiring Exemplars.pdf,71-Highlighting Inspiring Exemplars,"Highlighting the Core 141\nHighlighting the Core \nSome elements of a dom

**Highlighting Inspiring Exemplars**

**Importance of Highlighting Core Domain Elements**:
- Some elements of a domain are more important than others
- Large number of elements makes it difficult to understand which are truly core
- **Highlighting the core**:
  - Flag core domain elements directly in the code repository
  - Use annotations to mark core concepts
  - Evolutionary approach: code elements change over time, but annotations remain consistent

**Exemplars as Inspiring Documentation**:
- Exemplars are inspiring pieces of code that serve as models for best practices
- New developers often imitate existing code, so highlighting exemplars can improve code quality
- **Exemplar documentation**:
  - Highlight specific exemplars in the actual production code
  - Provide supplementary documentation to point colleagues to these exemplars
  - Limit the number of exemplars to only the very best examples

**Deciding on Exemplars**:
- Decisions on what constitutes an exemplar should be made collectively as a team
- Exemplars should be actual production code, not tutorial or idealized examples
- If an exemplar has weaknesses, clarify which aspects are exemplary and which are not

### 72-Guided Tours and Sightseeing Maps.pdf,72-Guided Tours and Sightseeing Maps,"Chapter 5 Living Curation: Identifying Authoritative Knowledge 144\n •O

**Guided Tours and Sightseeing Maps**

**Exemplars in Code:**
- Exemplars marked in code enable easy discovery of best practices
- Search for @Exemplar annotations in IDE for inspiration
- Highlighted exemplars not meant to replace asking colleagues
- Conversations key for improving skills and updating code

**Discovering New Places:**
- Guided tours and sightseeing maps facilitate exploration
- Fixed schedules, expense, or limited availability
- Apps provide alternatives with various themes

**Code Base Exploration:**
- Similar to becoming familiar with a city
- Human guide (colleague) recommended for discovery
- Provide alternative guided tours and sightseeing maps if human guide not available

**Curated Guidance:**
- Tourism metaphor for code exploration
- Only a small subset of content presented in city guides
- Automation can help keep up-to-date with frequently changing code bases.

### 73-Creating a Sightseeing Map.pdf,73-Creating a Sightseeing Map,"Chapter 5 Living Curation: Identifying Authoritative Knowledge 146\nTherefore: Provid

**Creating a Sightseeing Map**

**Approach to Creating a Sightseeing Map**:
- Provide curated guides of a codebase, each with a big theme
- Augment the code with extra metadata about the guided tour or sightseeing map
- Set up an automated mechanism to publish updated guides from these metadata

**Guided Tour and Sightseeing Map as Code Annotations**:
- If the codebase does not change much, a guided tour or sightseeing map can be as simple as a bookmark with:
  - Short description
  - Link to location in the code
- If the codebase changes frequently, use dynamic curation:
  - Place tags on the selected locations in the code
  - Rely on IDE search features to instantly display the bookmarks
  - Add metadata to the tags to enable reconstructing the complete guided tour

**Caution about Adding Tags**:
- **Adding tags about sightseeing maps or guided tours into the code can "pollute" it.**
- Use this approach sparingly, as these tags are not really about the tagged element but how it is used.

**Naming Conventions for Custom Attributes/Annotations**:
- **KeyLandmark**, **Landmark**, **MustSee**, **SightSeeingSite**, **CoreConcept**, **PlaceOfInterest**, **PointOfInterest**, **POI**, **TopAttraction**, **VIPCode**, **KeyAlgorithm**, or **KeyCalculation**

**Making the Tags Effective**:
- Ensure everybody knows about and can search them

### 74-Creating a Guided Tour.pdf,74-Creating a Guided Tour,"Chapter 5 Living Curation: Identifying Authoritative Knowledge 148\n4 * Marks this place in t

**Creating a Guided Tour: Identifying Authoritative Knowledge**

**Using Custom Attributes**:
- `PointOfInterest` annotation can be used to mark code elements as points of interest
- Can also create custom attributes like `CoreConceptAttribute` and `SightSeeingSite`
- Use generic attribute with specific parameter, e.g., `@KeyCalculation()`

**Creating a Guided Tour**:
- Takes newcomers through the complete chain of processing an incoming transaction
- Separates domain logic and infrastructure logic, but spans both in one guided tour
- Anchored on code elements (classes, methods, fields, packages)
- Uses `@GuidedTour` custom attribute with:
  - Name of the guided tour (optional if only one tour)
  - Description of each step in the context of the tour
  - Rank to order steps

**Example**:
- `FuelCardTxListener` class listens to incoming fuel card transactions from an external system
- Other classes in the chain of processing, ending with `ReportDAO.save()` method to store the fuel card reports

### 75-Creating a Living Guided Tour.pdf,75-Creating a Living Guided Tour,"Chapter 5 Living Curation: Identifying Authoritative Knowledge 150\n  Note\nNot

**Creating a Living Guided Tour**

**Step 1: Identify Authoritative Knowledge**
- Search results for 'flottio.annotations.GuidedTour'
- References:
  - `FuelCardMonitoring` domain (`src/main/java/l...`)
    - `FuelCardMonitoring`
    - `monitor(FuelCardTransaction, Vehicle)`
  - `FuelCardTxListener`
  - `ReportDAO`

**Step 2: Extract Information from Code Base**
- Create a living document to order and present the information as a guided tour

**Recap of Points of Interest:**
- `FuelCardTransactionMonitoring` service
  - Listens to incoming fuel card transactions
- `FuelCardTransaction`
  - Transaction between card and merchant
- `monitor(transaction, vehicle)` method
  - Performs potential fraud detection for an incoming transaction
- `FuelCardTransactionReport`
  - Report for an incoming fuel card transaction
- `ReportDAO`
  - DAO to store the resulting fuel card reports after processing

**Creating a Living Document:**
- Use Markdown to generate a ready-to-follow and ordered itinerary
- Include links to corresponding code snippets on GitHub for reference

**Step 3: Implement Guided Tour Annotations**
- Alternative: use enums instead of strings in the guided tour annotations
  - Takes care of naming, descriptions, and ordering at the same time

**Example Enum:**
```java
public enum PaymentJourneySteps {
  REST_ENDPOINT("The single page app calls this endpoint with the id of the shopping cart"),
  AUTH_FILTER("The call is being authenticated"),
  AUDIT_TRAIL("The call is audit-trailed in case of dispute and to comply to regulation"),
  PAYMENT_SERVICE("Now enter the actual service to perform the job"),
  REDIRECT("The response from the payment is sent through a redirect");

  private final String description;

  PaymentJourneySteps(String description) {
    this.description = description;
  }
}
```

**Step 4: Implement Guided Tour using QDox**
- Use JavaDoc comments or any parser to extract information from code base
- Filter the parsed elements by annotation and implement the guided tour grunt work

**Implementing with QDox:**
- Scans every Java file in `src/main/java`
- Performs filtering based on the annotations

### 76-A Poor Mans Literate Programming.pdf,76-A Poor Mans Literate Programming,,0

**76-A Poor Man's Literate Programming**

This phrase is a term used in programming and software development. It refers to an approach or methodology for writing high-quality code using plain English documentation integrated into the source code itself, making it easier for other developers to understand and work with. This approach became popular during the early days of computing when resources were limited, and formal documentation tools were not readily available.

**Keywords:** Programming, Software development, Approach, Methodology, Code quality, Documentation, Plain English, Source code, Early computing.

**Additional Information**
- **Advantages of Poor Man's Literate Programming**: Helps developers understand the purpose and functionality of the code; promotes consistency in naming conventions and commenting style; allows for easy modification of existing code by providing context; reduces the need for separate documentation tools.
- **Disadvantages of Poor Man's Literate Programming**: May lead to bloated source code with excessively lengthy comments; lacks a standard format or structure for documentation; can result in inconsistent commenting styles within large projects.
- **Origin**: Named after the practice of using plain English comments in the source code itself, rather than relying on formal documentation tools. This approach was popular during the early days of computing when resources were limited and formal documentation tools were not readily available.

### 77-Adding Whats Missing When Needed.pdf,77-Adding Whats Missing When Needed,"Summing Up: The Curator Preparing an Art Exhibition 153\npackage, and so

**Guided Tours and Code Documentation:**
* Extracting annotations from Java or C# code using guided tours
* Converting extracts into Markdown fragments for document rendering
* Achieving a linear ordering of code elements (guided tour)
* Benefits: Encourages reflection on work, adds value with new knowledge
* Curator in art exhibition as analogy to guided tour
	+ Decides editorial focus for exhibition or documentation
	+ Selects pieces based on the chosen perspective
	+ Organizes pieces in exhibitions or documents for meaning

**Guided Tours and Code Documentation (Continued):**
* Extracting annotations from Java or C# code using guided tours
* Converting extracts into Markdown fragments for document rendering
* Achieving a linear ordering of code elements (guided tour)
* Benefits: Encourages reflection on work, adds value with new knowledge
* Curator in art exhibition as analogy to guided tour (Continued)
	+ Decides editorial focus for exhibition or documentation
	+ Selects pieces based on the chosen perspective
	+ Organizes pieces in exhibitions or documents for meaning

**Curating Art Exhibitions:**
* Curator decides on key editorial focus for art exhibition
* Curator selects artworks based on the chosen editorial focus
* Curator organizes artworks by time period, artist phase, or theme
* Artworks displayed side-by-side to suggest comparisons and tell a story.

**Curating Documentation:**
* Documentation is a curation activity that involves deciding what's most important
* Organize knowledge in folders, tags, or naming conventions for added meaning
* Select pieces based on chosen perspective, just as curators select artworks for exhibitions.

### 78-Chapter 6 Automating Documentation.pdf,78-Chapter 6 Automating Documentation,"Summing Up: The Curator Preparing an Art Exhibition 155\nAdding What’

**Automating Documentation**:
- Curator writes explanatory text for exhibition sections and labels for art pieces
- Documentation requires knowledge augmentation through annotations, DSL, or naming conventions
- Limited amount of text can be useful in some places
- Missing essential works are borrowed or commissioned from the artist
- Researchers can conduct investigations or request chemical analysis to fill in missing information
- Catalog of exhibition includes explanatory text, art pieces as quality pictures, and labels
- Catalog may be available in different forms: comprehensive and expensive, or shorter and more accessible
- Documentation helps identify when something is missing or wrong

**Living Curation**:
- Curator identifies authoritative knowledge by discarding most of the existing knowledge base
- Living curation involves:
  - Inspiring exemplars
  - Highlighting the core
  - Providing guided tours and sightseeing maps
- These approaches help curate a subset of knowledge for a particular purpose.

### 79-Steps in Creating a Living Document.pdf,79-Steps in Creating a Living Document,"157Chapter 6\nAutomating Documentation\nAs described earlier, livin

**Living Documentation: Automating Document Production**

**Chapter Overview:**
- Description of living documentation
- Benefits and necessity for automation
- Examples of living documents (living glossaries, diagrams)
- Use of living documents as reporting tools

**Automating Living Documents**
- Not all forms of living documentation require manual production
- Time-consuming to create manually
- Automation makes living documents possible

**Examples of Living Documents:**
- Code changes
- Decisions made during conversations
- Evolution at the same pace as system they describe

**Living Document Examples:**
- **Living Glossaries**: evolve with changes in terminology or meaning
- **Living Diagrams**: updated after modifications to a system or process

**Role of Automation:**
- Enables real-time document updates
- Reduces manual labor and potential errors.

### 80-Presentation Rules.pdf,80-Presentation Rules,,0

**Presentation Rules**:
- Provide concise bulleted notes summarizing the provided text.
- Headings and terms in boldface type.

**Presentation Rules**:
* The speaker should follow certain rules for effective presentation:
* **Concision**: Provide concise bulleted notes summarizing the provided text.
* Use headings and terms in **boldface type**.

### 81-Living Glossaries.pdf,81-Living Glossaries,"Chapter 6 Automating Documentation 158\nSteps in Creating a Living Document\nCreating a living document

**Creating Living Documentation**
- **Living documents**: Involve four main steps:
  - Select data (e.g., source code) based on objective
  - Filter data to extract relevant information for document
  - Convert data and relationships into target format (e.g., API calls, text snippets)
  - Complex rendering processes may require multiple conversion steps
- **Hard part**: Interplay between editorial perspective and presentation rules

**Presentation Rules**
- Documents must follow particular rules: limit information to 5-9 items at a time
- Choose layout (e.g., list, table, chart) that aligns with problem structure

**Living Glossaries**
- Share ubiquitous language of domain through glossary
  - Complete description of terms and their meaning
  - Maintain and update regularly to remain relevant to source code
- **Code as single source of truth**: Extract glossary from source code
  - Use class, interface, method names as part of ubiquitous language
  - Add descriptions to source code as structured comments for extraction
- Filter out irrelevant code when extracting glossary
- Living glossaries are declarative and a single document for nondevelopers

**Living Diagrams**
- Process source code and annotations to generate living diagrams
- Keep up-to-date with source code changes

### 82-How a Living Glossary Works.pdf,82-How a Living Glossary Works,,0

**Living Glossary: Understanding Its Functionality**

A living glossary works by:
- Maintaining an organized collection of terms, definitions, and related information
- Updating dynamically to reflect changes or additions
- Enabling efficient access to information, fostering understanding.

### 83-An Example Please.pdf,83-An Example Please,"Chapter 6 Automating Documentation 160\nHow a Living Glossary Works\nIn many languages, documentation c

**Living Glossary Example using Java Annotations:**
* **Java Documentation**: embedded within code as structured comments, extracted using tools like Javadoc
* **Custom Doclet**: created to generate custom documentation in desired format
* **Annotations in Java and C#**: used for augmenting code with domain stereotypes or other metadata
	+ Easy to filter out classes not expressing domain language
	+ Expresses developer's intention
* **Example of a Living Glossary**: based on a simple pseudo-code example about a cat's activities
1. **Module com.acme.catstate**
2. **CatActivity interface**: set of main activities of a cat
3. **CatState nextState(Event) method**: how the cat changes its activity in response to an event
4. **Classes implementing CatActivity:** Sleeping, Eating, Chasing
5. **Event class**: anything that can happen that matters to the cat
6. **Living Glossary Generation**: processor builds a glossary from code annotations
	+ Prints out important terms and their definitions
* **Ignored Classes**: Timestamp (technical boilerplate) and Event method apply(Object) as they don't matter for the glossary.
7. **State Design Pattern**: genuinely part of business domain, implemented using the state pattern design concept.

### 84-Information Curation for Living Documents.pdf,84-Information Curation for Living Documents,"Chapter 6 Automating Documentation 162\nBuilding the gl

**Information Curation for Living Documents**

**Automating Documentation**:
- Building a glossary from code:
  - Rename methods to make entries clearer
  - Rebuild project to update glossary
- For Java, use:
  - Parser like Antlr or JavaCC
  - Java annotation-processing APIs
  - Open-source tools
- Simplest option: custom Doclet approach

**Creating a Living Glossary**:
- Covers all elements that matter to the business
- Scans classes, interfaces, and enums in Javadoc metamodel
- Includes classes with "business meaningful" annotations
- Avoids strong coupling between code and annotations

**Selective Curation of Information**:
- Show/hide relevant portions based on context
- Examples: enum, bean, interface, value object
- Hide details like methods from super-object, transient fields, constant fields (except public static final), marker interfaces, and their subclasses.

**Important Concepts**:
- Domain-Driven Design (DDD)
  - Eric Evans: "Domain-Driven Design: Tackling Complexity in the Heart of Software"
  - Closure of Operations (closed under operation)

### 85-Case Study of a Living Glossary.pdf,85-Case Study of a Living Glossary,"Chapter 6 Automating Documentation 164\nThe selective filtering depends to

**Creating a Living Glossary for Code Documentation**

**Background:**
- Automating documentation through code analysis using Doclet in Java
- Two modules, each defining a bounded context
- Annotations from org.livingdocumentation.* mark the code as meaningful for glossary

**Process:**
1. Create custom Doclet: `AnnotationDoclet`
   - Enumerates all classes from root document
   - Checks if class is meaningful using annotations
2. Processing a Class: `process(ClassDoc clss)`
   - Print relevant information in Markdown format
      * **Class name**
      * **Comments**
   - Check for specific types (enum, interface, etc.)
      * Handle enum constants and methods
      * Interface subclasses
3. Annotation Analysis: `isBusinessMeaningful(ProgramElementDoc doc)`
   - Check if class annotated with org.livingdocumentation.* annotations is meaningful
4. Outputting the Glossary
   - Write to file "glossary.txt" in Markdown format

**Improvements:**
- Sorting glossary by entry name or importance of concepts
- Handling more complex cases manually.

### 86-Diagrams Assist in Conversations.pdf,86-Diagrams Assist in Conversations,"Chapter 6 Automating Documentation 170\nThis method is too big and should

**Chapter 6 Automating Documentation**

**Method for Printing Living Glossary**:
- Decides how to print the living glossary for each element in Java/Doclet metamodel: class, interface, subclass, field, method, enum, enum constant
- Method `printMethod`:
    - Checks if method is public and has a comment
    - If not, returns
    - Creates signature string with method name, flat signature, and return type
    - Writes method comment to writer

**Living Glossary**:
- Aims to help team reflect on code and improve quality
- Not a goal in itself
- Automation should make it easier to change code safely, not harder
- Delete automation if it's getting harder or is in flux

**Diagrams in Software Development**:
- Diagrams used for:
    - Static structures
    - Sequences of actions
    - Hierarchies of elements
- Diagrams help explain problems that are difficult to describe with words

### 87-One Diagram One Story.pdf,87-One Diagram One Story,"Living Diagrams 171\nMost of the time we only need diagrams for the duration of a conversation.

**Diagrams for Effective Communication**

**Living Diagrams**:
- Useful for long-term use, such as important design aspects
- Automatically generated from source code without manual effort
- Keep diagrams up-to-date and maintain consistency

**Benefits of Living Diagrams**:
- Make development more tangible for discussions
- Catalyst for clearer communication between team members
- Convey one message at a time, avoiding confusion

**Creating Effective Diagrams**:
- Each diagram should have one specific purpose
- Filter irrelevant information aggressively
- Focus on essential elements only

**Avoiding Overloaded Diagrams**:
- Resist the temptation to add extra information
- Create new diagrams for additional information
- Determine clear focus and filter elements accordingly.

### 88-Living Diagrams to Keep You Honest.pdf,88-Living Diagrams to Keep You Honest,,0

**Living Diagrams: Staying Truthful**

**Title:** Living Diagrams to Keep You Honest

**Keywords:** living diagrams, honesty, truthfulness

**Introduction:**
- This text discusses the importance and benefits of "living diagrams" in maintaining a truthful life.

**Living Diagrams:**
- Concept that helps keep one honest
- Not a physical diagram but an idea or way of living

**Importance:**
- Helps individuals stay truthful and honest in their actions and thoughts
- Encourages self-reflection and growth

**Conclusion:**
- Living diagrams serve as a guide to live an authentic, honest life.

### 89-Rendering a Living Diagram.pdf,89-Rendering a Living Diagram,"Chapter 6 Automating Documentation 174\nonly the minimal subset of data that is reall

**Rendering a Living Diagram**

**Living Diagrams**:
- Keep you honest about the quality of design
- Part of the build process
- Can be used for code review, design meetings, or casual inspection

**Types of Diagrams**:
- **Napkin sketch**: Disposable, hand-drawn diagrams
- **Proprietary diagram**: Time-consuming to create and maintain
- **Plain-text diagram**: Easy to maintain, source control friendly
- **Code-driven diagram**: Dedicated code or application code for diagram generation
- **Living diagram**: Totally generated from the code base or software system

**Generating a Living Diagram**:
1. Scan the source code
2. Filter relevant parts
3. Extract information (class names, dependencies)
4. Render the information using a layout that matches the focus of the diagram

**Tools for Rendering**:
- Graphviz: Best for smart layout of arbitrary graphs
- Pandoc, D3.js, Neo4j, AsciiDoc, PlantUML, ditaa, Dexy, and many others

### 90-Example Hexagonal Architecture Living Diagram.pdf,90-Example Hexagonal Architecture Living Diagram,"Chapter 6 Automating Documentation 178\nT o sca

**Hexagonal Architecture: Documenting Living Diagrams**
* **Automating Documentation**:
    * Parsers required for scanning source code
        - Some parsers can access comments, others only metamodel
            * In Java: Javadoc Doclet or Google Guava ClassPath
    * Diagram types by layout complexity:
        1. Tables (strict layout)
        2. Pins on a fixed background (Google Map)
        3. Diagram templates (SVG, DOT)
        4. Simple one-dimensional flow diagrams
        5. Pipelines, sequence diagrams, and ecosystem black boxes
        6. Tree structures (left-to-right, top-to-bottom, or radial)
        7. Inheritance trees and layers
        8. Containment (with auto layout)
        9. Rich layout (vertical and horizontal, as well as containment)
* **Hexagonal Architecture Living Diagram**
    * Two layers: inside (domain model) and outside (infrastructure)
        - Dependencies must go from the outside to the inside
    * Documenting the architecture:
        - Already documented in industry literature
            * Websites, books (e.g., Growing Object-Oriented Software, Guided by Tests, Implementing DDD)
            * Known as onion architecture in .Net circles
        - Existing codebase follows the pattern
            * Domain model in its own package (namespace or project)
            * Infrastructure clearly segregated
* **Living Diagrams: Making it Visible**
    * Naming convention and annotations for documentation
        - Every element consuming/providing services to domain model
    * Filtering out irrelevant details when extracting information from source code
    * Scanning the source code with standard parsers or reflection
        - Focus on segregating elements and highlighting dependencies
* **Working with Changes**: Adapting the diagram as needed
    - Renaming domain interface in hexagonal architecture living diagram.

### 91-Case Study A Business Overview as a Living Diagram.pdf,91-Case Study A Business Overview as a Living Diagram,"Chapter 6 Automating Documentation 18

**Living Documentation: A Business Overview as a Living Diagram**

**Background:**
- Online shop system consists of e-commerce components
- Software architecture is well aligned with business domains
- Growing number of new needs and features necessitates documentation
- Manual methods for documentation are time-consuming and prone to errors

**Solution: Living Documentation via Automated Diagrams**
- Generate diagrams from source code using Graphviz
- Use custom annotations in Java packages to add business domain information
- Scan source code, create .dot file for Graphviz, render image

**Benefits:**
- Fully automatic layout that works like magic
- Adapts to changes in software system without additional effort
- Enhances the diagram with concerns such as quality attributes

**Implementation:**
1. Scan source code for annotated packages and their annotation information
2. Add node representations and links to related nodes in .dot file
3. Save .dot file, run Graphviz to render image
4. Code can fit into a single class with minimal effort

**Example of Living Diagram:**
- Represents business domains and their relationships
- Shows which components are related to each other
- Displays quality attributes as nodes in the diagram

**Conclusion:**
- Living documentation makes code, design, and architecture transparent for everyone to see
- If unsatisfied with what is seen, fix it in source code.

### 92-Example A Context Diagram.pdf,92-Example A Context Diagram,"Chapter 6 Automating Documentation 192\nExample: A Context Diagram\nNo system is an isl

**Context Diagrams**
* Essential for understanding system integration within ecosystem
* Documentation often overlooked during early stages of system growth
* Reconstitute ecosystem by manually reviewing code and interviewing knowledgeable people
* Represents actors using and acting on the system (API side) and those providing services to it (SPI side)
* Provides visual layout with advantages over hand-drawn diagrams
* Can be generated automatically from augmented source code
* Living document that updates as system changes
* Incorporates hyperlinks to corresponding source code locations for easy access
* Generated from scanning augmented source code and using graph layout engine like Graphviz
* Identification of external actors requires code augmentation with annotations or sidecar files
* Risk of overlooking some external actors if integration methods are not enumerated. (Figure 6.21)

**Context Diagram: Advantages**
* Clear visual representation of system's relationship with other actors
* Facilitates understanding of impacts on and from external systems when making changes
* Easy to update as the system evolves, thanks to automatic generation
* Encourages consistency in naming conventions for external actors
* Improves communication among team members about system dependencies
* Enhances traceability by providing a single source of truth for external actor relationships. (Figure 6.22)

### 93-Summary.pdf,93-Summary,"Chapter 6 Automating Documentation 196\nIn any case, integration through the database will be hard to detect and docu-\nmen

**Automating Documentation: Challenges and Solutions**

**Challenges:**
- Integration through databases hard to detect without conversation
- Diagrams generated may not be tailored for specific use cases
- Code lacks ability to express larger structures and collaborations
- Manual documentation is time-consuming and becomes obsolete quickly

**Solutions:**
- Use pattern-based design documentation
- Declare patterns in code, create tools to derive partial macro structures
- Generate better-than-generic design documentation informed by patterns
- Automate diagram generation at compile time or runtime

**Benefits of Living Documents:**
- Bridge gap between fast-paced projects and traditional documents
- Illustrate use of automation for smart document production
- Derive diagrams from known sources to keep them up-to-date.

**Patterns in Design Documentation:**
- Lie "on top" of language elements
- Address specific problems within a context
- Clear intent, collaboration of several language elements
- Useful for generating design documentation

**Automating Diagram Generation:**
- From source code at compile time or runtime
- Exploit runtime knowledge to produce them.

### 94-Example Living Services Diagram.pdf,94-Example Living Services Diagram,"199Chapter 7\nRuntime Documentation\nThe Agile Manifesto calls for “Working

**Living Services Diagram: Documentation through Software**
* Agile Manifesto prioritizes "Working Software over Comprehensive Documentation"
* Software can serve as documentation by providing successful user interactions
* Developers can learn business domain from well-designed applications
* Applications are self-documenting when they answer questions (Chapter 6)
* Living diagrams can be built using runtime knowledge, such as distributed tracing in multi-component systems.

**Key Point:**
- Anything that answers a question is considered documentation
- Software that responds to queries functions as part of the documentation.

### 95-The Magic That Makes This Work.pdf,95-The Magic That Makes This Work,"Chapter 7 Runtime Documentation 200\nExample: Living Services Diagram\nDistri

**Distributed Tracing as Runtime Documentation**

**Background:**
- Distributed tracing becoming vital in microservices architecture
- Discover living architecture of systems through aggregated traces
- Google's Dapper paper inspiration for distributed tracing

**Benefits:**
- Identify response time issues
- Monitor services dependency diagrams
- Understand system components and interactions

**Implementation:**
- Augment system with tracers for request/response identification
  - Use annotations: @SpanName, cs, sr, ss, cr
  - Inject knowledge for tools to help more
- Capture runtime information as "baggage" or metadata

**Advantages:**
- Real-time discovery of distributed systems
- Insightful understanding for architects and management

**Components:**
- Trace ID: Correlation ID of complete call tree
- Span ID: Correlation ID of single client/server call
- Parent ID: Current parent call's correlation ID

**Annotations:**
- Client start (cs)
- Server receive (sr)
- Server send (ss)
- Client receive (cr)

**Baggage or Binary Annotation:**
- Key/value store for runtime information
  - Response code, cache hits/misses, SQL queries, HTTP URIs, read/write status, etc.

### 96-Going Further.pdf,96-Going Further,,0

**The Provided Passage**, repeated for concision:

**"Going Further"**:
- The title of a document or topic
- Has no additional context provided

**Concision**:
- Repeating the passage as it is, preserves its original form and meaning
- Avoids introducing new information or altering the original text

### 97-Visible Tests.pdf,97-Visible Tests,"Chapter 7 Runtime Documentation 202\nThe Magic That Makes This Work\nThrough sampling, some requests get instru

**Zipkin Infrastructure**
- **Instrumentation**: Some requests are instrumented as they go through each node of the system
- **Span Traces**: Generated by instrumentation, collected and stored in a central datastore
- **Processing**: Daily cron triggers post-processing of all traces into aggregates representing "dependencies" between services
- **Aggregation**: Example query for distinct span data based on specific criteria:
  - `SELECT DISTINCT span FROM zipkin_spans`
  - `WHERE span.start_timestamp BETWEEN start AND end`
  - `AND span.annotation IN ('ca', 'cs', 'sr', 'sa')`
  - `GROUP BY span`
- **Displaying Dependencies**: UI displays all dependencies using automated nodes layout

**Expanding Zipkin's Potential**
- **Creative Tags**: By getting creative with tags, a distributed infrastructure like Zipkin has potential for:
  - Creating "controlled" traces from a test robot driving one or more service(s)
  - Displaying different diagrams for "Cache = HIT" and "cache = MISS" scenarios
  - Displaying distinct diagrams for the "Write part" versus the "Read part" of an overall conversation across the system

**Visible Workings: Software as Documentation**
- **Brian Marick's Concept**: Visible workings, where software itself explains how it works from the outside
- **Related Idea**: Relying on the software to document its internal mechanisms.

### 98-Domain-Specific Notation.pdf,98-Domain-Specific Notation,"Visible Tests 203\nto achieve this, and they all have in common relying on the software i

**Visible Workings Notation in Domain-Specific Contexts:**

**Background:**
- Approach for achieving desired documentation form using software output
- Calculations in payroll or data crunching applications require explanation to external audiences
- Useful for development teams and stakeholders
- Can be requested infrequently but beneficial

**Visible Workings Techniques:**
- Explanation of internal processing methods at runtime
- No need to consult developers for answers
- Handy during exploration mode and spike sessions when problems aren't clear
- Fast feedback on whether it works as expected or not

**Domain-Specific Notations:**
- Business domains have their own specific notations
- Useful for supply chain, finance, etc.
- Visual representation of information flow

**Supply Chain Notation:**
- Tree diagram from upstream producers to distributors
- Shows material flow and transportation (Figure 7.2)

**Order Book Notation for Matching Orders in Stock Exchange:**
- Diagram used during order matching process
- Bid, ask, volume, and price displayed visually (Figure 7.3)

**Finance Domain Notation:**
- Vertical arrows on a timeline represent cash flows from financial instruments
- Downstream represents payers, upstream are receivers (Figure 7.4).

### 99-Generating Custom Domain-Specific Diagrams to Get Visual Feedback.pdf,99-Generating Custom Domain-Specific Diagrams to Get Visual Feedback,"Visible

**Generating Custom Domain-Specific Diagrams to Get Visual Feedback**

**Background:**
- In the beginning of new projects, the author used to create simple tests without assertions that generated basic SVG files (Figure 7.5) for visual feedback
- Compare Figure 7.5 with following spreadsheet table:
  1 EUR13469 20/06/2010
  2 EUR13161 20/09/2010
  3 EUR12715 20/12/2010
  4 EUR12280 20/03/2011
  5 EUR12247 20/06/2011
  6 EUR11939 20/09/2011
  7 EUR11507 20/12/2011
  8 EUR11205 20/03/2012
  9 EUR11021 20/06/2012
  10 EUR8266 20/09/2012
  11 EUR5450 20/12/2012
  12 EUR2695 20/03/2013
- Borrower Lender
  1 $1,000
  10%
  1 $1002
  1 $1003
  1 $1004
  1 $1005
  1 $11,000
  1 $10,000 (Inflows)
  2 -$11,000
  2 $100
  2 $100
  2 $100 (Outflows)

**Visual Feedback**:
- It is easier to check the evolution of amounts paid over time visually using diagrams like Figure 7.5 instead of CSV files or spreadsheet applications
- Generate XLS file with graphs in Java using Apache POI or use modern JavaScript libraries for beautiful domain-specific diagrams

**More Complicated Example**:
- Figure 7.6 shows a more complicated example of generated SVG file that illustrates cash flows conditioned by market factors
- The author is not an expert at SVG but acknowledges these are quick graphs to get visual feedback during project development
- Consider generating diagrams from Cucumber or SpecFlow scenarios as a complement to test results.

### 100-Living Diagrams from Event Sourcing Scenarios.pdf,100-Living Diagrams from Event Sourcing Scenarios,"Example: A Visible Test When Using Event Sour

**Event Sourcing with Living Documentation**
* Event sourcing: sequence of events representing changes to application state (aggregates)
* Each change is persisted as an event, state built by applying past events
* Users send commands to aggregates through command handlers
* Commands can be accepted or rejected, emitting events for interested parties
* Events named as verbs in past tense using domain vocabulary, commands imperative verbs
* Each test is a scenario of expected business behavior, written in code using domain events and commands
* Scenarios printed as readable text, double-quoted examples given below

**Benefits of Event Sourcing:**
* Decent automated tests and living documentation almost for free
* Proposed by Greg Young, implemented in Simple.Testing framework
* Elaborated by Jeremie Chassaing

**Runtime Documentation with Event Sourcing:**
* Example: Making and Eating Cookies using domain events and commands
1. Given: Batch Created with 20 Cookies
2. When: Eat Cookies: Amount = 10
3. Then: Cookies Eaten: Amount Eaten = 10, Amount Remaining = 10
* SimpleTesting framework prints events and commands involved in test as living documentation

**Multiple Events in Test:**
1. Given: Batch Created with 20 Cookies
2. Given: 8 Cookies Eaten (previous event)
3. When: Eat Cookies: 15 cookies requested
4. Then: 12 Cookies Eaten, 0 remaining cookies, 3 Cookies missing
* Scenarios printed as readable text with Batch Created, Commands, and Outgoing Events
1. Eat only 12 of the 15 cookies requested
2. Given: Batch Created With 20 Cookies (central node)
3. Add each command as a node and add links from commands to aggregate
4. Add each event as a node and add links from aggregate to events
5. Render the diagram using Graphviz in browser for visual representation of living documentation.

### 101-Introspectable Workings Code in Memory as a Source of Knowledge.pdf,101-Introspectable Workings Code in Memory as a Source of Knowledge,"Introspec

**Introspective Workings: Code in Memory as a Source of Knowledge**

**Concepts:**
- Introspection of object trees at runtime
- Object tree formation and variation based on configuration or request
- Using reflection or methods to introspect objects

**Object Tree Runtime Variation:**
1. Can depend on configuration
2. May change according to requests
3. Object trees can be introspected for actual arrangement, object types, and structure
4. In Java and C#: Reflection or methods used for introspection
5. Example of hip-hop beats loops search engine with varying object tree configurations

**Introspection Techniques:**
1. Reflection in languages like Java or C#
2. Methods on each member of the structure
3. Simple form: relying on `toString()` method of elements
4. Using Dependency Injection (DI) container for container construction introspection

**Example:**
- Hip-hop beats loops search engine with varying object tree configurations
1. Engine (abstract interface)
2. Reverse index (abstract interface)
3. Links repository (abstract interface)
4. Loop analyzer (abstract interface)
5. Waveform processor
6. The exact wiring of the object tree is determined at runtime and changes based on environment's configuration.

### 102-Summary.pdf,102-Summary,"Introspectable Workings: Code in Memory as a Source of Knowledge 213\nIntrospecting with Reflection\nIf it’s an object, w

**Introspecting Object Trees: Code in Memory as a Source of Knowledge**

**Reflection-Based Introspection**:
- Traverse the tree by following declared fields in objects
- Filter uninteresting elements (e.g., strings, low-level classes)
- Example code snippet illustrating recursive traversal
- Output: Console display or DOT diagram

**Introspecting Without Reflection**:
- Objects must exhibit an accessible way to enumerate collaborators
- Use public methods instead of reflection or public fields
- Interface `Introspectable` and composite pattern implementation
- Example code snippet illustrating recursive traversal of composite object tree

**Choosing the Approach**:
- If all objects are created by the team and not too many, use the composite approach
- Otherwise, use reflection-based introspection for more flexibility
- Displaying workflows or processing driven by configuration can be simplified

**Importance of Runtime Documentation**:
- Knowledge accessible at runtime is valuable for documentation purposes
- Increasing prevalence of distributed architecture and cloud infrastructure

### 103-Text Layout.pdf,103-Text Layout,"217Chapter 8\nRefactorable Documentation\nLiving documents are documents that are automatically generated using u

**Refactorable Documentation**

**Living Documents**:
- Automatically generated using up-to-date knowledge from an authoritative source
- In contrast to documents created using proprietary tools that must be updated manually

**Refactorable Documents**:
- Must be manually updated, but with automation tools that reduce the labor-intensive burden

**Text Layout**:
- Refactorability tools for text documents:
  - **Find and Replace feature** in text editors
  - Automated refactoring of source code

**Code as Documentation**:
- Code is a key ingredient in living documentation, embracing change
- Automated refactoring is the primary way to update a software system
- Refactoring tools automatically update declarations and uses throughout the project

**Code Layout**:
- Code can be organized in a graphical layout to express meaning
- Examples:
  - **Tabular code layout** for state transitions in a socket
  - **Arrange–Act–Assert convention** in unit tests

### 104-Coding Conventions.pdf,104-Coding Conventions,"Code as Documentation 221\nMuch more could be said about various possible ways to organize code gra

**Coding Conventions**

**Programming Conventions**:
- Syntax alone is not enough to convey additional meaning
- Rely on **naming conventions** to distinguish between different elements (e.g., class names, variable names)

**Java Naming Conventions**:
- Classes: **mixed case**, first letter of each internal word capitalized (e.g., **StringBuilder**)
- Instance variables: same as classes but start with a lowercase first letter (e.g., **myStringBuilder**)
- Constants: **all uppercase** with words separated by underscores (e.g., **DAYS_IN_WEEK**)

**Hungarian Notation**:
- Extreme example of using naming conventions to encode information
- Example identifiers: 
  - **lPhoneNum**: variable is a long integer
  - **rgSamples**: variable is an array or range of "Sample" elements

**Conventions as Social Constructs**:
- Conventions are more than just convenience, they're a social contract between developers
- Familiarity with conventions makes code feel "at home", while unfamiliar conventions can be disturbing

**Caution on C# Interface Naming Convention**:
- C# convention of prefixing interfaces with "I" is reminiscent of Hungarian notation and has no benefit
- It's better to use namespaces or packages instead of prefixing class/interface names

### 105-Naming as the Primary Documentation.pdf,105-Naming as the Primary Documentation,,0

**Naming as the Primary Documentation**

**105-Naming**: the primary documentation process.

### 106-Idiomatic Naming Is Contextual.pdf,106-Idiomatic Naming Is Contextual,"Naming as the Primary Documentation 223\nAs you’ve seen, coding conventions

**Naming as the Primary Documentation**

**Coding Conventions**:
- Extend programming language syntax to support missing features and semantics
- When no type is available, manage it manually with naming conventions
- Types can be helpful for documentation

**Importance of Naming**:
- Naming is a primary form of documentation
- Good names are important, but difficult to achieve
- Names need agreement and shared connotations
- Checking thesaurus, listening actively, and asking workmates for feedback can help
- Good names are useful when reading and searching

**Composed Methods**:
- Naming is not isolated, classes form a language in object-oriented programming
- Class names create a vocabulary for discussing design
- Finding the right set of words to describe objects is important

**Example: The Go Programming Language**:
- Provides an example of naming that fails on searchability
- Despite being developed by Google, the "search company"

### 107-From Primitives to Types.pdf,107-From Primitives to Types,"Chapter 8 Refactorable Documentation 224\nFor more on naming and practical advices, I s

**Chapter 8: Refactorable Documentation - Naming Conventions**
* **Idiomatic Naming**: Dependent on context within a large codebase
* Business domain names in domain model or domain layer (e.g., `Account`, `ContactBook`)
* Infrastructure layer or adapters: use prefixes and suffixes to qualify technologies (e.g., `MongoDBAccount`, `SOAPBankHolidaysRepository`)
* Naming styles not uniform throughout a codebase
* **Coding Against a Framework**:
  * Writing without a framework results in unspecified, undocumented code
  * Using popular frameworks (e.g., Spring Boot, Axon-Framework) provides documentation through annotations and well-documented use
* **Type-Driven Documentation**
  * Types serve as vehicles for storing and conveying knowledge
  * Custom types convey more information than primitives (e.g., `int` vs. `Money`)
  * Creating custom types explicitly defines the concept they represent
  * Javadoc comments provide valuable information about custom types in code.

### 108-Types over Comments.pdf,108-Types over Comments,"Chapter 8 Refactorable Documentation 226\nY our types are an essential part of your documentation

**Types Over Comments**

**Importance of Types:**
- Essential part of documentation
- Use types instead of primitives or bare collections
- Promote them into first-class types
- Name your types carefully using ubiquitous language

**From Primitives to Types:**
- Code switching on String is weak, use typed enums instead
- Documentation evolves with the type and stays attached to it

**Documented Types and Integrated Documentation:**
- Integrated documentation directly within IDEs
- Preferred over comments as they don't lie or fade away

**Types and Associations:**
- Express associations as member fields to types
- Well-named fields provide enough information for one-to-one associations
- Use new declared types to make documentation redundant

**Type-Driven Development:**
- Types determine meaning of variables, functions, and methods
- Determine function's purpose by looking at its signature

**Searching Methods by Signature:**
- Haskell has Hoogle for function search based on given signature
- Java in Eclipse offers the same functionality using method signature search.

### 109-The Composed Method.pdf,109-The Composed Method,"Chapter 8 Refactorable Documentation 230\nThis works not just for primitives such as integers but

**Composed Method Pattern for Writing Clear Code**

**Clear Code**:
- Hard to achieve through chance
- Requires continuous refactoring and use of design skills
- Relevant for documentation purposes, especially the composed method pattern

**Refactoring to Composed Methods**:
- Replace a block of code with clear, named methods
- Each method performs one task and is named accordingly
- Helps make code more readable and understandable
- Example:
  - **Original Code**: `Position equivalentPosition(Trade[] trades)`
    - Large, unnamed block of code
  - **Refactored Code**:
    - Extracted methods: `hasNo()`, `positionZero()`, `quantityOfFirst()`
    - Each method performs a specific task and is named accordingly

**Benefits of Composed Methods**:
- Helps make code clearer by organizing into different levels of abstraction
- Allows for better understanding of the overall processing without needing to read individual lines of low-level code.

### 110-Fluent Style.pdf,110-Fluent Style,,0

**Fluent Speaking Style:**
- Maintain a smooth and consistent flow of speech
- Speak at an understandable pace
- Use natural gestures for emphasis
- Make eye contact with the audience
- Use facial expressions to convey emotions.

### 111-Fluent Tests.pdf,111-Fluent Tests,"Chapter 8 Refactorable Documentation 232\nwhat it does without having to deal with all the code in the lower le

**Refactoring Documentation with Fluent Interfaces**

**Two Levels of Abstraction**:
- Code is more readable when it's organized by levels of abstraction
- The layout illustrates the two levels visually

**Fluent Style**:
- Makes code more readable by mimicking natural language
- Example: Pricing.of(PHONE_CALLS).is(...), which reads like a sentence
- Code can grow bigger while remaining readable

**Using an Internal DSL**:
- Fluent interface is an example of internal DSL built on the programming language
- Provides power of expression without losing compiler checking and other features
- Ideal for public interface, configuration, testing, and documentation

**Fluent Interface in .Net**:
- LINQ syntax is a fluent interface implemented through extension methods
- Mimics SQL queries closely

**Implementing a Fluent Interface**:
- Start by "dreaming" or imagining the ideal interface
- Make it work by addressing difficulties that arise

### 112-Case Study An Example of Refactoring Code Guided by Comments.pdf,112-Case Study An Example of Refactoring Code Guided by Comments,"Chapter 8 Refac

**Fluent Interfaces and Refactoring Code Guided by Comments**

**Refactorable Documentation (234-236)**

**Fluent Interfaces**:
- Popular for testing
- Libraries like JMock, AssertJ, JGiven, and NFluent enable writing tests in a fluent style
- Fluent style improves readability of tests, which serves as documentation of software behaviors
- NFluent is a test assertion library in C# that allows writing tests in a fluent way
- Example: Testing an int variable and hotel room reservation using the fluent style with NFluent

**Creating Domain-Specific Test Languages (DSTL)**:
- You can create your own DSTL to write pretty scenarios in plain code
- This involves test data builders
- Test data builders can be nested to create objects, such as flights and hotels, for testing

**Fluent Style vs. Not Using It**:
- Fluent is not an end to itself, and coding with a fluent style may not always be the right thing to do
- Potential drawbacks:
  - More complicated to create API
  - Harder to use when writing code due to non-idiomatic use of language
  - Non-meaningful method names used in fluent style (e.g., Not(), And(), That(), With(), Is())

**Case Study: Refactoring Code Guided by Comments**
- Starting with a legacy C# code snippet in the finance domain: Position class with comments
- Most comments delimit sections, but they are written in plain English and not easily understood as code
- Opportunity to turn these free-text comments into formal classes that express strict knowledge
- Example: Refactoring the "MagmaProperties" section into separate classes (e.g., AuditTrail, IndexPayoffType)
- This opens opportunities for improving the design and immutability of the code

### 113-Integrated Documentation.pdf,113-Integrated Documentation,,0

**Important Note:** Integrated Documentation is crucial for comprehensive understanding. (No words removed)

### 114-Type Hierarchy.pdf,114-Type Hierarchy,,0

**The Hierarchy of Emotional Types**:
* This concept is not explicitly stated in the passage
* But it can be inferred from the given information
* The passage describes how the brain processes emotions and distinguishes between them based on their intensity and facial expression
* Therefore, we can assume that there is a hierarchy at play, with different emotional types being more prominent or basic than others.

**The Role of Intensity and Facial Expression**:
* The higher up in the hierarchy an emotion is, the more intense its physiological expression will be
* This means that facial expressions are a good indicator of the dominant emotion being felt at a given moment
* Lower-level emotions (like happiness or sadness) have weaker physiological expressions, while higher-level emotions (like fear or anger) have stronger ones.

**The Hierarchy in Action**:
* When two emotional signals conflict, the higher one in the hierarchy wins out
* For example, if someone is experiencing both fear and happiness at once (e.g., seeing a potential romantic partner at an airport terminal), the fear response will be muted because happiness is a higher-level emotion
* This helps explain why some emotions are more powerful or influential than others.

### 115-Semantics Derived from Actual Usage.pdf,115-Semantics Derived from Actual Usage,"Chapter 8 Refactorable Documentation 238\nIntegrated Documentatio

**Semantics Derived from Actual Usage: Documentation in Integrated Development Environments (IDEs)**

**Autocompletion and Intellisense:**
- IDEs provide task-oriented, curated documentation through autocompletion or "intellisense"
- Shows available methods and properties based on context
- Filters results to only show accessible items
- Integrated into coding process
- Acknowledge IDE as key tool for documentation purposes

**Type Hierarchy:**
- Class hierarchy diagrams are a classic element of reference documentation
- IDE can display custom type hierarchy diagrams on-the-fly from selected classes
- Diagram is interactive, allowing users to expand or fold branches and view superclasses/subclasses
- Compact compared to UML notation
- Helps with discovering specific types in hierarchies during development

**Code Searching:**
- IDEs offer powerful code searching capabilities
- Allows users to quickly find relevant classes, methods, or properties
- Useful for task-oriented documentation discovery
- Interactive and curated based on user context.

### 116-Example Plain-Text Diagrams.pdf,116-Example Plain-Text Diagrams,"Using Plain-Text Diagrams 239\nWhen you’re looking for a class but don’t remember

**Using Plain-Text Diagrams**

**Napkin Sketches**:
- Useful for short-lived diagrams during discussion or design decision making
- Can be photographed and stored for longer term reference

**Converting Napkin Sketches to Plain-Text Diagrams**:
- Use a text-to-diagram tool to render the initial sketch into a visual diagram
- Maintain the plain-text description of the diagram in source control
- Focus on content over formatting

**Example: Fuel Card Fraud Detection Algorithm**:
1. Initial napkin sketch outlines responsibilities and interactions between components
2. Convert sentences describing the sketch into a text format
3. Use a rendering tool to create the visual diagram from the text
4. Compare the activity-like diagram (Figure 8.7) and sequence diagram (Figure 8.8) renditions
5. Keep the approach "rustic" to maintain simplicity

### 117-Chapter 9 Stable Documentation.pdf,117-Chapter 9 Stable Documentation,"Using Plain-Text Diagrams 243\nWhen there are changes that make updates to

**Plain-Text Diagrams**
- Updating diagrams is easy when using plain text
- Renaming can be done through **Find and Replace**
- IDEs may have refactoring automation to update plain-text files

**Diagrams as Code**
- Use code in a programming language to declare nodes and relationships
- Benefits:
  - **Autocompletion**
  - Compiler/interpreter checks for invalid syntax
  - Synchronization with automated refactoring
  - Generation of dynamic diagrams from data sources
- Drawbacks:
  - Less readable by non-developers than plain text
  - Identifier names cannot contain whitespace
  - Not a "living" diagram, but generated from code

**Example:** Using the **DotDiagram** library to generate a diagram from code
1. Create a new **DotGraph** object with a name
2. Add nodes and set labels and comments
3. Add associations between nodes with labels and comments
4. Render the graph as a string
5. Example output: "MyCar ---> 4* Wheel"

**Data-Driven Diagram Generation**
- Biggest benefit of diagrams as code is generating diagrams from data sources

### 118-Requirements Are More Stable Than Design Decisions.pdf,118-Requirements Are More Stable Than Design Decisions,"245Chapter 9\nStable Documentation\

**Chapter 9: Stable Documentation**

**Requirements vs Design Decisions**:
- Requirements are more stable than design decisions
- Stable knowledge is easy to document
- No need for updates as it doesn't change often
- Can use traditional forms of documentation (e.g., Microsoft Word, wikis)
- Careful design necessary to ensure stability

**Evergreen Content**:
- Remains interesting, relevant, and accurate over time for a specific audience
- Does not change but remains useful
- Characteristics:
  - Short with limited detail
  - Focuses on high-level knowledge, "the big picture"
  - Addresses goals and intentions rather than implementation decisions
  - Focuses more on business concepts than technical ones

### 119-A Lot of Knowledge Is Less Stable Than It Looks.pdf,119-A Lot of Knowledge Is Less Stable Than It Looks,"Chapter 9 Stable Documentation 246\nThere

**Documenting Stable Knowledge**
- **Traditional documentation methods**: appropriate for stable, seldom-changing knowledge
- No need to invest time in creating evergreen content if it remains unchanged
- Examples of stable knowledge: requirements and high-level goals
  - Requirements tend to be more stable than design decisions
    * If unable to change a decision, consider it a requirement
    * Designs are subject to change
  - High-level goals remain the company identity and seldom change
- **Efficient practices for frequently changing low-level requirements**: conversations and BDD (Behavior Driven Development)
- **Vision or elevator pitch**: a stable project representation expressed in a few sentences.

### 120-Case Study A README File.pdf,120-Case Study A README File,"Evergreen Content 247\nWhy does your project exist? Who’s sponsoring it? What are the b

**Case Study: A README File**

**Project Phenix (Fuel Card Integration)**
- Project Manager: Andrea Willeave
- **Features**:
    - Syncs daily transaction data from pump to Fleetio for automatic entry and importing
    - Fuel card transaction monitoring to detect potential frauds (gas leakage, transactions too far from vehicle)
    - Odometer readings used to trigger service reminders for fleet maintenance

**Changes Needed**:
- Project name will change over time due to marketing or political reasons
- Project manager's name should be removed and linked to team wiki or project manifest
- Launch date is outdated, remove it and link to corporate calendar, news portal, or social media for announcements
- Class name and specific parameters are not necessary in this document

**Additional Information**:
- Find team members responsible for the module on company Github repository (not concrete class name)
- Business rules of fraud detection can be found in separate living documentation

### 121-Tips for Evergreen Documentation.pdf,121-Tips for Evergreen Documentation,,0

**Tips for Evergreen Documentation**

**Focus on clarity and concision**: Write comprehensive bulleted notes summarizing the provided text, with headings and terms in bold.

**Tips for Effective Evergreen Documentation:**
- **Clarity**: Emphasize key points by using headings and bold text.
- **Concision**: Keep explanations succinct, focusing on essential information only.

**Evergreen Documentation**: Write comprehensive bulleted notes summarizing provided tips.

**Tips for Evergreen Documentation:**
- Focus on clarity and concision
- Use headings and bold text to emphasize key points
- Keep explanations succinct, covering essential information only.

### 122-Organizing Artifacts Along Stable Axes.pdf,122-Organizing Artifacts Along Stable Axes,"Tips for Evergreen Documentation 251\n44\n45 For news and a

**Tips for Evergreen Documentation**

**Avoiding Mixing Strategy Documentation with Implementation**
- Strategy and implementation evolve at different paces
- Don't mix documentation of strategy with documentation of its implementation
- Create separate documents: Evergreen (strategy) and living (implementation)
- Example: Test Strategy document for overall test approach
  - Topics covered: Testing practices, testing types, test tools, processes

**Ensuring Stability in Documentation**
- Use stable names over volatile ones in all documentation
- Business domain vocabulary is stable, prefer it over company specific names
- Arbitrary code names change frequently and are less descriptive
- Perennial naming reduces maintenance work by using stable names in code and documents.

### 123-Volatile-to-Stable Dependencies.pdf,123-Volatile-to-Stable Dependencies,"Chapter 9 Stable Documentation 254\nOrganizing Artifacts Along Stable Axe

**Organizing Artifacts Along Stable Axes:**
- **At a macro level**, how to organize documentation:
  - By application name (e.g., CarPremiumPro, BestSocksOnline)
  - By business process (e.g., sell car in retail, sell socks online)
  - By target client (e.g., individual car buyers, urban middle-class men, B2B or B2C)
  - By team name (e.g., team B2B, Team Ninja)
  - By team purpose (e.g., Software Delivery Paris, R&D London)
  - By project name (e.g., MarketShareConquest, GoFastWeb)
- **Changes over time**:
  - Some organization modes remain unchanged
  - Others change from time to time or even several times a year
- **Projects vs. Applications**:
  - Projects start and end, canceled and resuscitated under a new name
  - Applications last longer but are decommissioned and replaced by other projects

**Linked Knowledge:**
- **Knowledge is more valuable when connected**:
  - Provided that the connections are stable
- **Connections bring structure**:
  - Define a resource identification scheme (e.g., URL, citation)
  - Decide on a mechanism to ensure stability in the long run
- **Qualify the relationship**:
  - In documentation, link knowledge to other related knowledge
  - Provide metadata about the source, reference, review, criticism, author, etc.

### 124-Categories of Stable Knowledge.pdf,124-Categories of Stable Knowledge,"Linked Knowledge 255\n Caution\nBe aware of the directions of the links. Ju

**Categories of Stable Knowledge**

**Linking Knowledge**:
- Links should go from less stable to more stable
- Expose knowledge as web resources accessible through URLs
- Refer to knowledge using links, and use link registries to ensure permanence
- Tools like issue trackers, static analysis tools, planning tools, blogging platforms, and social code repositories expose their knowledge through links

**Volatile-to-Stable Dependencies**:
- Reference stable elements from volatile elements (e.g., artifacts to project goals)
- Broken link checkers can detect broken links in documentation
- Use a mechanism to detect broken links before colleagues do

**Link Registry**:
- Don't directly include links in multiple places, use a link registry instead
- Link registries provide intermediate URLs as aliases and allow updating broken links in one place

**Bookmarked Searches**:
- Replace direct links with bookmarked searches on more stable criteria (e.g., search for Java class "ScenarioOutline" in a specific repository)

### 125-Domain Vision Statements.pdf,125-Domain Vision Statements,"Chapter 9 Stable Documentation 258\nA bookmarked advanced search is not just useful for

**Domain Vision Statements**

**Advantages of Bookmarked Advanced Searches:**
- Useful for robust links
- Important tool for living documentation
- Offers power of an IDE for everyone with a browser
- Creates guided tours for navigating code and discovering related concepts

**Categories of Stable Knowledge:**
- Evergreen README:
  - Answers key questions about a project or system
  - Focuses on what, how, who, goal, benefits, and getting started
  - Essential and stable over time
  - Avoid including development, testing, or contact information
- Vision Statement:
  - Picture of the world as it will be when completed
  - Converges efforts of team members to make vision come true
  - Simple and easy to pitch in a few sentences
  - Often originates in a person and needs documentation
  - Illustrated with stories that bring vision to life
  - Usually on the stable end, but may change over time

**Creating Evergreen Documents:**
- For a project or system, answer key questions: what, how, who, goal, benefits, start
- Focus on essential and stable information
- Avoid including instructions for development, testing, or help
- Use README file as a starting point

**Documenting Vision Statements:**
- Originates in a person and needs documentation
- Simple enough to pitch in a few sentences
- Illustrated with stories that make it more real
- Usually on the stable end of the spectrum.

### 126-Investigation Wall.pdf,126-Investigation Wall,"Chapter 9 Stable Documentation 260\nDomain Vision Statements \nA particular kind of vision statemen

**Chapter 9 Stable Documentation**

**Domain Vision Statements**:
- Focus on the business domain the product is about
- Describe the value of the future system before it exists
- Spans several subdomains, as no one knows how the domain should be split yet
- Narrow in focus and ignore non-distinctive aspects
- Help balance diverse interests and serve as a proxy for the actual software

**Goals**:
- Lower level than the vision, but higher than details of implementation
- Long term and critical, driving many decisions
- Documented in a persistent fashion (e.g., Microsoft Word, Slide Decks, Paper Documents)
- Careful not to over-constrain the project too early

**Impact Mapping**:
- Technique for exploring goals and organizing high-level knowledge about a project or business initiative
- Shows options and alternate paths to reach a goal
- Recommends classifying goals by main stakeholders and quantifying success with "performance targets"
- Collaborative and lightweight, using mind maps to record and show a cleaner layout

**Investing in Stable Knowledge**:
- Business domain knowledge and fundamentals of software architecture are evergreen content worth learning
- Domain-specific knowledge is often reusable in other business domains
- Traditional projects are the main way to learn a domain, but lacks time for deep understanding
- Immersion (e.g., visiting the business location, listening to conversations) can help overcome this limitation

### 127-Domain Training.pdf,127-Domain Training,,0

**Training on Domain 127**

**127-Domain Training**:

**127-Domain Training**, **127-Domain**

**0**

### 128-Shadow Users.pdf,128-Shadow Users,"Chapter 9 Stable Documentation 264\nDomain immersion is also an effective practice for new joiners to quickly d

**Documentation Practices:**
- **Domain immersion**: effective practice for new joiners to discover domain knowledge through direct experience from the field
- Alternative form of documentation
- Useful when not possible or expensive to go to the field
- **Investigation wall**: create a space with pictures, notes, sketches, and business documents to keep a feel for the business domain while working
- **Domain training**: team can benefit from specialized trainings about the business domain led by a domain expert

**Live-My-Life Sessions:**
- Developers stay close to someone doing business operations for a period of time
- Observe and learn without interfering
- Best if developers can ask questions during pauses
- More involved experiment: developer may try being an assistant in a different role.

### 129-A Long-Term Investment.pdf,129-A Long-Term Investment,,0

**Investing Long-Term: A Strategic Approach**

**Overview**: Focus on long-term investment strategies and benefits.

**Long-Term Investment**: Emphasize the importance of strategic planning for long-term financial gains.

---

**Investment Advice**: Offer guidance on how to make smart, long-term investments.

**Benefits**: Discuss advantages of long-term investment strategies such as compound interest and potential tax benefits.

---

**Embrace the Long Game**: Encourage readers to adopt a long-term perspective when managing their finances.

**Patience and Perspective**: Emphasize that successful long-term investments require both patience and the right perspective.

**Strategic Planning**: Stress the importance of creating a well thought-out plan for long-term financial growth.

---

**Compound Interest**: Explain how compound interest works and how it can benefit long-term investors.

**Tax Benefits**: Discuss potential tax advantages of long-term investments, such as retirement accounts or real estate purchases.

**Diversification**: Advise readers on the importance of diversifying their investment portfolio for added security.

---

**Risk Management**: Offer tips on managing risk in a long-term investment strategy.

**Market Volatility**: Address concerns about market volatility and how it affects long-term investments.

---

**Education and Research**: Encourage continuous learning about various investment opportunities and strategies.

**Informed Decisions**: Emphasize the importance of making informed decisions when investing for the long term.

**Financial Literacy**: Highlight the value of becoming financially literate to make intelligent, long-term investments.

---

**Patience and Discipline**: Encourage readers to stay patient and disciplined in their long-term investment approach.

**Consistency**: Advise on the importance of maintaining a consistent investment strategy over time.

**Review and Adjust**: Recommend regularly reviewing and, if necessary, adjusting your long-term investment plan.

---

**Seeking Professional Guidance**: Offer resources for those seeking professional advice on their long-term investment strategies.

### 130-Summary.pdf,130-Summary,"Summary 265\nfor a day could be one of the best ways to appreciate their stakes, and therefore to \nimprove their softwar

**Investing in Stable Knowledge for Improved Software Development**

**Summary:**
- Observing users' behavior as "shadow users" can enhance software development by providing valuable insights into how they use the product to achieve their business objectives.
- This approach is not feasible for all projects due to privacy concerns or unaccessibility of installed software.
- Investing in stable knowledge gained through traditional documentation, books, and contextual understanding is an investment as the business domain remains largely unchanged.
- Traditional documents should focus on stable knowledge, which can be documented once as evergreen content.
- Attention to changing pieces of knowledge helps reduce workload over time by creating documents that need minimal updates.
- For fast-changing projects, dynamic forms of documentation and collective efforts are necessary instead.

**Investing in Stable Knowledge:**
- **Observing users as shadow users**: Developers log in as another real user to observe their behavior and screen activities.
- **Long-term investment**: The business domain is usually quite stable, allowing for traditional documentation of evergreen content.
- **Contextual understanding**: Books written before the advent of computers may still be relevant due to contextual knowledge gained.
- **Improved decision making**: Stable knowledge and learned vocabulary make discussions during meetings more efficient.

**Traditional Documentation:**
- Focus on stable knowledge that can be documented once as evergreen content.
- Reduce workload over time by creating documents that need minimal updates for changing pieces of knowledge.
- Utilize dynamic forms of documentation, conversations, and living documents for fast-changing projects instead.

### 131-Conversations About Formal Documentation.pdf,131-Conversations About Formal Documentation,"267Chapter 10\nAvoiding Traditional \nDocumentation\nW

**Chapter 10: Avoiding Traditional Documentation**

**Embracing Alternatives to Traditional Forms of Documentation**
- **Nodocumentation Manifesto**: explores alternatives to traditional forms of documentation (Figure 10.1)
- Agrees with the purpose of documentation but disagrees with its conventional methods
- Nodocumentation is about exploring better ways to transfer knowledge between people and across time

**Effectiveness of Communication Channels for Knowledge Transfer**
- Conversations are more effective than written documentation:
  - High bandwidth: conveys more knowledge efficiently
  - Interactive: allows for questions and clarification
  - Just in time: addresses immediate needs
- Compared to written documentation, conversations offer a faster and more comprehensive exchange of information.

**Conversations as Effective Means of Communication**
- Conversations have several key characteristics that make them effective for knowledge transfer:
  - High bandwidth: offers a high volume of information exchange
  - Interactive: allows both parties to ask questions and clarify misunderstandstands
  - Just in time: addresses the needs of all parties involved.

**Limitations of Written Documentation**
- Writing takes significant time, both for creation and understanding
- Locating relevant information is time-consuming
- Misunderstandings are common when reading written content

**The Importance of Conversations in Knowledge Transfer**
- Effective sharing of knowledge often happens through conversations rather than written documents
- Conversations offer a more efficient and effective means of transferring knowledge compared to written documentation.

### 132-The Rule of Three Interpretations.pdf,132-The Rule of Three Interpretations,"Chapter 10 Avoiding Traditional Documentation 270\nWiio’s Laws\nProfe

**Wiio's Laws**:
- **Communication usually fails except by accident.**
- **If communication can fail, it will.**
- **If communication cannot fail, it still most usually fails.**
- **If communication seems to succeed in the intended way, there's a misunderstanding.**
- **If you are content with your message, communication certainly fails.**
- **If a message can be interpreted in several ways, it will be interpreted in a manner that maximizes the damage.**

**Improving Communication**:
- Human communication works best through interactive dialogue, with the opportunity for the receiver to:
  - React
  - Disagree
  - Rewrite
  - Ask for more explanation
- This feedback mechanism is essential to "fix the curse of one-way human communication" highlighted by Wiio.

**Effective Communication in Software Development**:
- **It's essential to improve the likelihood that the receiver can "jump the communication gaps" that are always present.**
- The sender needs to touch into the highest level of shared experience with the receiver, and the two people should provide constant feedback to each other.
- A face-to-face, interactive, and spontaneous form of documentation is the best way to improve on the "fate of miscommunication" highlighted by Wiio.
- If all stakeholders are happy with talking with the team for all questions and feedback, then written documentation may not be needed.

### 133-Cross Programming.pdf,133-Cross Programming,"Conversations About Formal Documentation 271\n Note\nThe goal of agile documentation is to “help peop

**Conversations and Documentation in Agile Development:**
* Agile documentation helps people interact through various means:
	+ Knowing who to contact
	+ Understanding project guidelines, style, and inspiration
	+ Sharing a common vocabulary and mental model
	+ Collaborative goal setting
* The Rule of Three Interpretations:
	+ If you can't think of at least three different interpretations, reconsider your understanding
	+ Helps avoid the illusion that the first interpretation is always correct
* Obstacles to Conversations:
	+ Lack of effective communication in workplaces due to politics or fear of information loss
	+ Distance between teams or departments
	+ Hierarchical distance as an impediment
* Working Collectively for Continuous Knowledge Sharing:
	+ Encouraging collaboration and continuous knowledge transfer
	+ Reassuring employees that conversations are valuable and encouraged
	+ Embracing the idea of close collaboration to improve software quality and maintainability
* Pair Programming:
	+ A technique from Extreme Programming where team members work together on coding tasks
	+ One person (driver) writes code while the other (observer) provides feedback, corrections, and suggestions.

### 134-The Three Amigos or More.pdf,134-The Three Amigos or More,"Chapter 10 Avoiding Traditional Documentation 274\nthe navigator, talks to the driver t

**Pair Programming:**
- Involves two developers working together on the same task
- One person writes failing test and passes keyboard to partner for making it pass and refactoring
- Commonly practiced in coding dojos or on-the-job
- Partners change regularly to ensure collective ownership

**Styles of Pair Programming:**
- **Ping-pong pairing**: where one person writes a failing test, then passes keyboard for partner to make it pass and refactor

**Cross Programming:**
- Variant of pair programming with a business expert as observer
- Efficient collaboration when deep understanding of business domain is required
- Coined by Houssam Fakih

**Mob Programming:**
- Whole team works together on the same task, in the same space, at the same computer
- Similar to pair programming but with the entire team collaboating on a single codebase
- Encourages active engagement and effective communication

**Resources:**
- Fakih, Houssam. "Cross Programming: Forging the Future of Programming." Speaker Deck, [https://speakerdeck.com/fakih/cross-programming-forging-the-future-of-programming](https://speakerdeck.com/fakih/cross-programming-forging-the-future-of-programming)
- Zuill, Woody. "Mob Programming–A Whole Team Approach." Agile Alliance, [https://www.agilealliance.org/resources/articles/experience-reports/2014-zuill-mob-programming](https://www.agilealliance.org/resources/articles/experience-reports/2014-zuill-mob-programming)

### 135-Knowledge Transfer Sessions.pdf,135-Knowledge Transfer Sessions,"Working Collectively for Continuous Knowledge Sharing 275\nMob programming is a r

**Collective Programming Practices:**
- **Mob programming**: a collaborative coding practice gaining popularity
- No pair rotation in mob programming, everyone is present for every task
- Continuous knowledge sharing with no ownership issues
- A team of five can do it full time without concerns for knowledge transfer

**Three Amigos (or More)**:
- Consists of Product Owner, Developer, and Tester
- Discuss user stories and criteria for software development
- Agree on basic testing requirements to prevent issues
- Central concept in Behavior Driven Development (BDD) approach
- Collaborative activity focusing on business behavior scenarios

**Event Storming:**
- A collaborative modeling activity using sticker notes on a large wall
- Invented by Alberto Brandolini as a fast onboarding mechanism
- Effective way for new team members to learn new domains quickly.

### 136-Truck Factor.pdf,136-Truck Factor,"Chapter 10 Avoiding Traditional Documentation 276\nshort event storming sessions for that, even if the team has

**Event Storming Sessions:**
- Team learns quickly during two-hour workshops
- Business domain expert contributes diagrams to session
- Interactive format leads to engagement and new insights

**Knowledge Transfer (KT) Sessions:**
- Planned sessions for sharing knowledge in companies
- Common practice when pair programming or mob programming is not common
- Ops teams exchange knowledge during deployment process
  - Dry run of deployment with document and manifests
  - Identify issues, questions, or mistakes during session
- Alternative: Collective work between developers and Ops people

**Continuous Documentation:**
- Face-to-face interactive conversations essential for continuous documentation
- Pair programming, cross programming, three amigos, mob programming facilitate effective conversations
- Documentation happens at the time knowledge is necessary
- Everyone present can ask questions to clarify points.

### 137-Coffee Machine Communication.pdf,137-Coffee Machine Communication,"Coffee Machine Communication 277\nWhen the task is done, those involved remembe

**Coffee Machine Communication**

**Importance of Spontaneous Discussions**:
- Random discussions at the coffee machine or water fountain are valuable
- Often lead to best exchange of knowledge
- Topic is chosen freely based on shared interests
- Interactive with questions, answers, and storytelling
- Can last as long as required
- Encourages creativity and relaxed atmosphere

**Creating Opportunities for Communication**:
- Decrease hierarchy pressure around coffee machine
- Everyone must be free to chat with anyone
- Google and other web startups provide facilities to encourage meetings
- La Gaité Lyrique in Paris has open foyers as meeting spaces
- Mix of people from outside encourages thinking more creatively

**Benefits of Informal Meetings**:
- Relaxed atmosphere encourages impromptu discussions
- People own their responsibilities, regardless of working hours
- No need for appointment or secretary to filter access
- Director encourages informal meetings

**Impact on Productivity and Creativity**:
- Impromptu meetings can be both improvised and planned
- Informal settings lead to better collaboration experience
- Opportunity to ask questions and get answers from colleagues.

### 138-Idea Sedimentation.pdf,138-Idea Sedimentation,"Chapter 10 Avoiding Traditional Documentation 280\nunless you plan the meeting. There’s also no fli

**Idea Sedimentation**
- Importance of documenting knowledge:
  - Necessary for long-term retention
  - Essential when team members are gone or forgotten knowledge
  - Crucial for wide dissemination to large groups
  - Vital for critical knowledge not left as spoken words
- Forms of documentation:
  - Conversations, working collaboratively, spontaneous knowledge sharing (informal)
  - Flip chart, whiteboard, teleconferencing systems, traditional documents (formal)
- Idea Sedimentation:
  - Memory is the residue of thought
  - Importance of knowledge may not be apparent until later
  - Discussions, sketching, sticky notes (informal)
  - Turn key bits into something permanent (formal)
  - Capture conversations as traces through photos, handwritten notes
- Sedimentation metaphor:
  - Ideas are like sand particles that settle at the bottom of a stream or wine decanter
  - Accumulation of important knowledge over time.

### 139-Throw-Away Documentation.pdf,139-Throw-Away Documentation,,0

**Limitations of "Throw Away" Documentation**:
* The term "Throw Away" documentation is not widely recognized or standardized in industry terminology.
* It can lead to misunderstandings and confusion when communicating with team members or stakeholders.
* Instead, consider using terms like "Discardable Documentation" or "Ephemeral Documentation" to clearly convey the intended meaning.

### 140-Astonishment Report.pdf,140-Astonishment Report,"Chapter 10 Avoiding Traditional Documentation 282\nMake a napkin sketch to document a design aspe

**Avoiding Traditional Documentation**

**Use of Sketches and Bullet Points**:
- Use napkin sketches to document design aspects, then turn into maintainable diagrams later
- Use bullet points to document quality attributes, then turn into executable scenarios

**Throw-Away Documentation**:
- Some documentation is useful for only a limited period of time and can be deleted
- Diagrams specific to a problem are useful while working on it, but lose value once done
- Transient documentation like planning materials (user stories, estimation, tracking) can be thrown away after use

**On-Demand Documentation**:
- Best documentation is created on demand, in response to actual needs
- Create documentation to answer precise, purposeful questions
- Avoid speculating on what should be documented, instead pay attention to unasked but needed knowledge

**Just-In-Time Documentation**:
- Documentation is best introduced just when it's needed
- Listen for "knowledge frustrations" and fill the resulting "gap" in documentation

**Keep It Low-Tech**:
- Log requests for missing information as sticky notes, then decide as a team to create it
- Use existing tools (code browsing, IDE, sketching) to explain interactions before writing formal documentation
- Consider using reverse just-in-time doc by asking questions in a chat room and pasting answers into the docs

**Learning Through Bug Fixing**:
- Fixing bugs or making small evolutions is a great way to quickly learn about an application and its development process
- Companies may require newcomers to deliver something into production within their first two days

### 141-Including Some Upfront Documentation.pdf,141-Including Some Upfront Documentation,"On-Demand Documentation 285\nautomation strategy . Y ou not onl

**On-Demand Documentation Strategy:**
* Learn both code and delivery approach for trust and short timeframe
* Fresh feedback from newcomers improves process
* Document installation, setup, and pre-requisites for efficient delivery
* Address "weird in-house or proprietary stuff" with alternative solutions
* Create an "astonishment report" of newcomers' observations during first days on the job
* Write upfront documentation based on beginner's perspective
* Use heuristics to decide when to document: agreement, controversy, long discussion, profound misunderstanding, importance, and refactoring feasibility
* Document code as it is being worked on to protect value for other team members.

**Techniques for On-Demand Documentation:**
* Define content using a skills matrix or knowledge backlog
* Create a knowledge backlog by having team members write down pieces of knowledge they'd like to have, then decide through consensus or voting which items should be documented first.
* Conduct regular retrospectives to discuss and address items in the knowledge backlog.
* Avoid growing backlogs and using electronic trackers; keep them small and on physical sticky notes for reminders.

**Important Concepts:**
* The curse of knowledge can hinder effective upfront documentation
* Documentation should be created based on empathy: "Make the value you've added permanent." (Andy Schneider)
* Comment code that you are working on to protect next person from pain.

### 142-Interactive Documentation.pdf,142-Interactive Documentation,"Interactive Documentation 287\nSkills Matrix\nAn alternative to creating a knowledge

**Interactive Documentation**

**Skills Matrix**:
- Alternative to creating a knowledge backlog
- Create a skills matrix with pre-defined areas
- Ask each team member to declare their level of proficiency for each area
- Limitations: Reflects the views of the person creating it and ignores neglected skills areas

**Interactive Documentation**:
- Written documents don't have opportunity for interaction
- Jukka Korpela: "Written document works because the author participated in dialogues elsewhere"
- George Dinwiddie: "Document questions the reader may have and get it reviewed by multiple people"
- Written documentation should be like a record of an interactive conversation

**Prefer Interactive Over Static Documentation**:
- Use hypermedia to navigate content through links
- Turn documentation into tools like checkers, task assistants, or search engines
- Examples:
  - Hypermedia documentation with navigable links (Javadoc)
  - Tools like Pickles, Fitnesse, Swagger
  - IDE documentation features (call stack, search for type/reference, etc.)

### 143-Declarative Dependency Management.pdf,143-Declarative Dependency Management,"Declarative Automation 289\nAs described in the next section, putting

**Declarative Dependency Management**

**Automation**:
- Automated processes are more reliable and efficient than manual methods
- Automated processes can be documented, providing single source of truth for the process
- Declarative automation is more successful at supporting documentation than imperative scripts
- Automation acts as a reconciliation mechanism that makes it obvious when the declared process becomes wrong

**Dependency Management**:
- Dependency managers (package managers) are tools that play a key role in the build process
- They reliably download libraries, including transitive dependencies, resolve conflicts, and support dependency management strategies
- Declarative automation is essential to force declared knowledge to be honest

**Declarative Dependency Manifest**:
- Dependencies are declared in a simple text file using a tuple of group ID, artifact ID, and requested version
- This manifest is the bill of materials that dictates what to retrieve to build the application
- Declarative automation allows the declaration of dependencies to be the single source of truth for documentation
- Adding comments next to dependency entries in the file can provide rationale behind each dependency

**Integrated Documentation**:
- IDEs allow developers to navigate to the POM (Project Object Model) of dependencies, providing integrated documentation

### 144-Declarative Configuration Management.pdf,144-Declarative Configuration Management,"Declarative Automation 293\nusing ranges or keywords for the ve

**Declarative Configuration Management**

**Declarative Approach**:
- Developers can query dependency manager to get information on demand
- For non-developers, interesting content can be extracted and published
- Declarative approach used in tools like Ansible and Puppet

**Ansible**:
- Uses simple language for writing playbooks
- Aims at describing automation jobs in plain English
- Playbooks describe desirable state of server without requiring knowledge of current state

**Puppet**:
- Manifests are self-documented and provide proof of compliance
- Provides a diagram of dependencies for visual understanding

**Declarative Languages**:
- Allow communication of expected desired state to tools and humans
- Missing rationale for decisions need to be documented in manifests

**Puppet Manifests**:
- Examples show dependencies and files involved in configuration management

**Relationships and Dependencies**:
- Puppet generates a diagram showing relationships and dependencies
- Useful for understanding issues or visualizing what's in the manifests.

### 145-Declarative Automated Deployment.pdf,145-Declarative Automated Deployment,"Chapter 10 Avoiding Traditional Documentation 296\nThis kind of diagram

**Declarative Automated Deployment**

**Using Diagrams for Refactoring Manifests**:
- Diagrams can help make manifests cleaner, simpler, and more modular
- They can help identify when refactoring is needed

**Automated Deployment Tools**:
- A number of tools can automate deployment workflows and rollback procedures
- Examples: **Jenkins** with custom or standard plugins, **Octopus Deploy (.Net)**
- Deployment workflows are typically described in a declarative manner

**Declarative Automation**:
- Tools can automate the work itself and reduce errors
- They provide ready-made documentation for standard patterns like **Blue-Green Deployment**
- Configuration of the tool should be genuinely declarative, at an abstraction level close to what matters for everyone involved

**Scaffolding**:
- Tools can provide a "plug-and-play" setup for newcomers, such as installers or Maven archetypes
- This approach is not just for newcomers, but also allows users to start an application quickly
- Examples: **Ruby on Rails**, **Spring Roo**, **JHipster**

### 146-Machine Documentation.pdf,146-Machine Documentation,,0

**146-Machine Documentation**

**Title:** Machine Documentation

**Content:**
- Discusses machine documentation
- Provides examples: "146-Machine Documentation"
- Emphasizes the importance of clear and comprehensive documentation for machines, including details about their operation, maintenance, and troubleshooting.

**Keywords:** machine documentation, 146-Machine Documentation, clear documentation, comprehensive documentation, operation, maintenance, troubleshooting.

### 147-Enforcement or Encouragement.pdf,147-Enforcement or Encouragement,"Declarative Automation 299\n •Would you like to use Maven or Gradle?\n •Would y

**Declarative Automation**
- Provides clear narrative explaining possible answers for questions related to project setup
  - Examples: Maven vs Gradle, Grunt or Gulp.js, Compass CSS Authoring Framework, Angular Translate
- Helps make decisions on software tools and configurations
- Consequences outlined to aid in decision making
- Results in automated code setup based on chosen options

**Machine Documentation**
- Cloud automation provides accurate documentation through API
  - Replaces Excel spreadsheets of machine information
- Cloud API is similar to declarative automation, allowing users to declare desired machine specifications
- Provides high-level technical overview of application through recorded responses to wizard questions

**Automation in General**
- Automation provides benefits but also cost
  - Not an end goal, but a means to save time and improve reliability on repeated tasks
- People are good at novel tasks; machines excel at repetition

**Enforced Guidelines**
- Best documentation is not always read
- Enforced guidelines bring right piece of knowledge at right time
  - No need to remember all decisions or style preferences
- Code reviews and static analysis help maintain high level of quality, serving as reference for rules

**Examples of Rules**
- Cosmetic rules: curly brackets, field names
- Metrics rules: deep inheritance trees, complex methods, overly long lines
- Encouraging or enforcing better code: do not destroy stack trace, exceptions public

**Architectural Decisions as Rules**
- DomainModelElementsMustNotDependOnInfrastructure
- ValueObjectMustNotDependOnServices

**Evolving Guidelines**
- No ideal and definitive set of guidelines
- Start with some, use, and evolve to make them relevant

### 148-Trust-First Culture.pdf,148-Trust-First Culture,"Enforced Guidelines 303\nThe best guidelines don’t come from above. The best guidelines grow from

**Best Practices for Setting Up Enforced Guidelines:**
* **Agree on shared guidelines**: teams agree on useful guidelines through discussion
* **Change guidelines when necessary**: adapt to project needs
* **Start with enforced guidelines (greenfield projects)**: enforce strict adherence for new code
* **Gradual addition of guidelines (legacy projects)**: begin with important guidelines and add more over time
* **Use tools for setting up enforced guidelines**: use compilers, static code analysis tools, bug detectors, duplication detectors, dependency checkers, etc.
* **Documentation through comments or annotations**: document intentions, priorities, preferences in code
* **Enforce access control**: revoke write grants to prevent modifications on frozen components
* **Extend existing tools with new rules**: create custom plugins for specific guidelines
* **Guidelines as design documentation**: express design decisions through annotations and parser checks
* **Hamcrest's creative approach**: use naming conventions and deprecated methods as reminders.

**Examples:**
- Documentation by exception: turning a legacy component from read-write to read-only by throwing exceptions.
- Warranty sticker effect: enforcing guidelines through potential violators' awareness, e.g., documenting unused or deprecated methods with clear messages.

### 149-Constrained Behavior.pdf,149-Constrained Behavior,,0

**Constrained Behavior**:

**Keywords:** Constrained, Behavior

**Notes**:

* Definition: Actions or patterns of behavior limited by external factors.
* Example: When a person's actions are restricted due to societal norms or expectations.
* Opposite: Unconstrained/unrestricted behavior.

### 150-Replaceability First.pdf,150-Replaceability First,"Constrained Behavior 307\n •License mechanism: Y ou can create a module that nobody should impo

**Constrained Behavior for Developers:**
* Create modules with a license mechanism: restrict imports to specific projects (150-Replaceability First)
	+ Throw exceptions during import if no license text file or variable is present
	+ Disclaimer in the license text
* Enforce guidelines through environment and tools instead of automated rules or access restrictions
* Make it easy for developers to do the right thing:
	+ Provide good self-service CI/CD tools
	+ Offer microservices chassis for easier setup (Chris Richardson's website)
	+ Use tailored service templates with predefined code structures and libraries
* Design API in a way that makes it impossible to misuse, reducing the need for documentation
* Refactor common API traps instead of documenting them:
	+ Ensure proper ordering of method calls
	+ Detect and repair invalid properties early on
	+ Use types, enums, and internal caches to eliminate harmful naive usage.

**Design Principles for Documentation Avoidance:**
* Make it easy for experienced developers to follow best practices
* Use clear naming conventions and well-organized code structure
* Provide good documentation when necessary:
	+ Write comprehensive bulleted notes summarizing key information
	+ Use clear headings, terms in bold, and a simple style
	+ Incorporate examples, diagrams, or code snippets for better understanding
* Encourage communication between team members to avoid misunderstandings about the codebase.

### 151-Consistency First.pdf,151-Consistency First,"Chapter 10 Avoiding Traditional Documentation 310\nthe people doing it are still there, so they know

**Chapter 10: Avoiding Traditional Documentation**

**Consistency First**
- Dan North emphasizes the importance of knowledge sharing and preservation for successful teams
- Replaceability first reduces the need for extensive documentation
- Favor a design that makes it easy to replace components
- Make sure everyone knows what each part does

**Replaceability First**
- Reduces the need for documentation on how things work
- Components can be replaced easily without needing in-depth knowledge
- Every part should be reasonably small and independent
- Limit size of components and create strict restrictions on calls between them
- Discipline is required to maintain replaceability

**Consistency First (in Code)**
- Consistency reduces the need for documentation
- Consistent coding styles within a component, programming language, or layer
- Agree on concrete guidelines within chosen bounded areas
- Document exceptions to rules explicitly rather than documenting everything

**Design Principles for Documentation Avoidance**
- Consistency in code base makes it easy to understand
- Consistency reduces the need for extensive documentation
- Guidelines should be agreed upon and documented briefly
- Exceptions to rules should be documented explicitly

**Example of Guidelines for a Domain Model:**
- No abbreviations in naming of public signatures
- Business-readable names for all public interfaces and their methods
- Null-free: no null allowed as return type or method parameter
- All classes immutable by default
- All methods side effect free by default
- No SQL
- No import of frameworks, including javax
- No import of infrastructure (such as middleware)

### 152-Example The Zero Documentation Game.pdf,152-Example The Zero Documentation Game,,0

**The "Zero Documentation Game" Example**

**The Documentation Game**: A term used to describe an activity or exercise in which participants aim to create documentation without any prior knowledge of the subject matter (O'Hara, 2019). In this example, the document is titled **"152-Example The Zero Documentation Game"**.

**The Activity**: The "Zero Documentation Game" involves creating documentation related to a topic without any background knowledge or understanding of it. This exercise aims to highlight potential issues that may arise when documenting complex subjects without proper context and expertise (O'Hara, 2019).

**Further Discussion**: For more information about the "Zero Documentation Game", please refer to **O'Hara's article**. It provides valuable insights into this activity, which can be useful for understanding the importance of proper documentation and effective communication.

### 153-Summary.pdf,153-Summary,"Chapter 10 Avoiding Traditional Documentation 312\nExample: The Zero Documentation Game\nI’ve heard of a team that decide

**Avoiding Traditional Documentation: The Zero Documentation Game**
* **Zero documentation approach**: focuses on better naming and practices to share knowledge without additional prose
* Radical yet stimulating for team members, driving better behavior
* Clarifies rules: no comments in code or methods, external documents, or traditional Office documents
* Embraces tests, Gherkin scenarios (Cucumber/SpecFlow), simple code, and collective work
* Continuous training as a way to reduce need for documentation
* Investment in skills development and shared culture
* Coding dojos, short training sessions, interactive mini-trainings, time for deliberate practice

**Best Documentation is Non-Traditional**
* Interactive conversations and working collectively are effective forms of sharing knowledge
* Serendipity and spontaneity from informal meetings complements formal documentation
* Process automation can be more declarative, acting as an efficient form of documentation
* Development teams need to turn up the "documentation value" of their activities to reduce specific documentation tasks.

**Additional Information**
* Google employees dedicating 20% of their time to side projects: https://www.inc.com/adam-robinson/google-employees-dedicate-20-percent-of-their-time-to-side-projects-heres-how-it-works.html

### 154-Chapter 11 Beyond Documentation Living Design.pdf,154-Chapter 11 Beyond Documentation Living Design,,0

**Chapter 11: Going Beyond Documentation - Embracing Living Design**

**Living Design**: A Transcendent Approach to Documentation
- Discover the significance of going beyond conventional documentation methods with Living Design.
- Understand how this innovative approach transcends traditional limitations for enhanced impact and engagement.

**Embrace Change**: The Evolution of Documentation
- Witness the transformation of documentation practices through the lens of Living Design.
- Learn about the evolving role of design in shaping future developments within the realm of documentation.

**Experience, Not Just Read**: The Power of Immersive Learning Experiences
- Delve into how Living Design fosters immersive learning experiences that go beyond mere reading.
- Uncover the benefits of engaging with content in a more interactive and dynamic way.

**Incorporating Best Practices from UX Design**
- Learn from successful UX design principles to enhance the user experience within documentation.
- Discover how incorporating these best practices can lead to better outcomes for both users and organizations.

**Applying Living Design Principles**
- Explore specific living design principles that can be applied to documentation projects.
- Understand how these principles contribute to creating effective, engaging, and impactful technical writing.

**Case Studies: Success Stories in Living Documentation**
- Analyze real-life examples of successful living documentation implementations.
- Gain insights into best practices and learn from the success stories of companies that have embraced this innovative approach.

**Future Directions: The Impact of Technology on Living Design**
- Discover how advancements in technology are shaping the future of living design within documentation.
- Stay ahead of the curve by exploring potential developments and trends that will redefine the landscape of technical writing.

### 155-Programming by Coincidence Design.pdf,155-Programming by Coincidence Design,"315Chapter 11\nBeyond Documentation: \nLiving Design\nThis book has s

**Living Documentation: Benefits and Improvements**
* Living documentation improves design as we work on it
* Signals for potential design issues: difficulty generating living documents from code or business domain language
* Coincidence programming: making decisions without clear understanding or deliberate thought
	+ Neglected decisions can lead to arbitrary design choices that may cause issues down the line
* Importance of documenting decisions and encouraging deeper thinking
	+ Explanation of decisions reveals weaknesses and fosters better understanding
	+ Frustrating for teams when decisions are not documented or made without clear reasoning.

**Living Documentation: Difficulties and Solutions**
* Difficulty generating living documentation from code or business language signals potential design issues
* Misaligned design with business domain language or loss of domain language in the code
	+ Expressing the language clearly is essential for effective living documentation
* Neglected decisions lead to arbitrary design choices, affecting the overall system negatively.

**Living Documentation: Encouraging Deliberate Thinking and Decision Making**
* Encourage team members to document decisions as they are made for deeper thinking
* Clear understanding of concepts is essential before making decisions or creating living documentation
* Standardize integration interactions by turning them into tags or written guidelines.

### 156-Deliberate Decision Making.pdf,156-Deliberate Decision Making,"Deliberate Decision Making 319\nDeliberate Decision Making\nThe path to better desi

**Deliberate Decision Making**

**Importance of Documenting Deliberate Decisions**:
- Documenting random decisions is difficult as they lack clarity and consciousness
- Deliberate decisions are consciously made, making documentation simple
- Standard decisions can be documented using "ready-made knowledge" such as patterns

**Benefits of Being Deliberate**:
- Encouraged in agile circles and software craftsmanship
- Allows for learning through deliberate discovery
- Results in better design that requires less documentation
    - Symmetries, higher-level concepts, consistency, replaceability, and encapsulation

**Thinking and Documentation**:
- Thinking takes time but leads to accuracy
- Alternatives to thinking give the illusion of speed at the expense of accuracy
- Clarifying thoughts for documentation purposes is a virtuous process

**Engineering as Deliberate Practice**:
- French engineering schools emphasize substantiated decisions
- Software development should adopt this deliberate approach to decision making

### 157-Deliberate Decision Does Not Mean Upfront Decision.pdf,157-Deliberate Decision Does Not Mean Upfront Decision,,0

**Deliberate Decision**
* **Does not** mean upfront decision.

### 158-Documenting Errors or Avoiding Errors.pdf,158-Documenting Errors or Avoiding Errors,"Deliberate Decision Making 321\n Note\nDeliberate design work

**Deliberate Decision Making**
- **Practice of TDD (Test-Driven Development)**
  * Developer drives design through refactorings
  * Refactoring decisions require clear thinking
- **Living Documentation**
  + Encourages attention to virtuous practices, including design
  + Makes bad design clearly visible for improvement
- **Author's Perspective**
  - Deliberate design is the author's ulterior motive in writing this book
  - Believes living documentation can help more people adopt better design

**Deliberate Design vs. Upfront Decision**
- **Deliberate decision making**
  * Conscious choice of refactoring improvements
  * Understand troubles, benefits, and multiple ways to improve
- **Documentation as a form of code review**
  * Increases transparency for adjusting and correcting issues throughout application lifecycle
  * Detects mistakes such as unexpected cycles or excessive coupling in dependencies

**Living Documentation: Beyond Documentation**
- Reveals design inconsistencies and can help spot issues before they become problems
- Can be used for debugging, especially with diagrams
- Comparing top-down documentation to actual bottom-up documentation from sources can reveal differences and inconsistencies

**Shameful Documentation**
- Ineffective documentation that demonstrates a problem instead of fixing it
- Examples: Infamous troubleshooting guides, long user manuals, or poorly implemented features
  - In some cases, such documentation may suggest opportunities for more Ops-friendliness

**Conclusion**
- Documentation is essential but should not be a substitute for fixing issues; allocate time and resources accordingly.

### 159-Diagnostic Tools.pdf,159-Diagnostic Tools,"Chapter 11 Beyond Documentation: Living Design 326\nSimilarly , with software design, if it takes a lot

**Living Documentation vs. Avoiding Documentation**
* **Documentation-driven development**: starting with the end goal, focusing on what's necessary to achieve it
	+ Conversations, diagrams, notes, sketches, README files, code exploration in REPLs, or using scripting languages
	+ Becomes more formalized as project stabilizes (e.g., tests, TDD, BDD)
* **Avoiding documentation**: not an end in itself but a means to an end
	+ Documentation reveals issues that can be fixed to improve the root cause
	+ Continuous effort required for improving internal quality and hygienic transparency

**Documentation Media vs. Diagnostic Tools**
* Diagnostic tools (e.g., metrics, word clouds) have a thin line with typical documentation media
* Word cloud: generates words from source code to understand the application's focus
	+ Filters tokens and ignores numbers, stopwords, and keywords for Java or C#
	+ Count occurrences using bag (Guava library) or render within an HTML page using d3.layout.cloud.js library
* Signature survey: filters out everything except language punctuation to analyze the shape of code.

**Documenting Errors or Avoiding Them**
* Comments in code can indicate areas for improvement, leading to more effective documentation
* Code that handles errors can become redundant when better design practices are employed (e.g., total functions, error management)
* Focus on designing self-documenting code instead of relying on extensive documentation.

### 160-Reporter Porter Interviewing Mr. Living Doc Doc.pdf,160-Reporter Porter Interviewing Mr. Living Doc Doc,"Hygienic Transparency 337\nCallsImporter.

**Living Documentation: The Importance and Benefits**
* Living documentation makes internal code quality visible to everyone
* Encourages positive pressure for cleanup of design problems
* Developer opinions become more convincing with visualization approaches
* Internal quality not easily understood by non-technical decision makers
* Good design skills essential for effective living documentation
* Documentation and software design go hand in hand
* Living documentation makes problems visible, creating positive pressure for improvement

**Challenges and Solutions:**
* Lack of insight into internal code quality impedes informed decisions
* Visualization approaches can help non-technical people understand the problem
* Design skills are crucial for effective living documentation

**Interview with Living Doc Doc:**
* Good documentation is integrated, intuitive, and instantly understood
* UML focus in early 2000s gave way to more contextual IDE tools
* New technologies offer potential for transferring knowledge but not complete documentation
* Immutable logs, code annotations, and traditional documents essential for recording rationale.

### 161-Summary.pdf,161-Summary,"Summary 341\nOkay, but these days systems are made of dozens of services. How do I work \nwith such fragmented systems?\n

**Documentation and Systems Design:**
* Fragmented systems: apply same techniques at service level (tags, naming conventions)
* No need for extensive documentation?
	+ Can still function without it
	+ Lowers development time
	+ Reveals issues that may not be apparent otherwise
* Benefits of documentation:
	+ Accelerates delivery process
	+ Encourages learning and understanding of the system.

**Documentation and Book's Thesis:**
* Start with documentation, end up with better design (main thesis)
* BDD: non-regression testing not main benefit; early conversations and living documentation are more significant
* Adopt practices for efficient documentation: speed, deliberateness, transparency, interactions between people.

### 162-Stake-Driven Architecture Documentation.pdf,162-Stake-Driven Architecture Documentation,"343Chapter 12\nLiving Architecture \nDocumentation\nArchi

**Living Architecture Documentation**

**Understanding Architecture**:
- Architecture is defined in various ways: "Architecture is what everybody in the project should know", "Architecture is about the decisions that are hard to change later"
- Architecture involves exchanging knowledge about decisions between multiple people over time
- Documentation is a significant part of architecture

**Living Documentation for Architecture**:
- Helps explain more decisions accurately and explicitly without slowing down continuous flow of changes
- Focuses on practices that help document architecture, such as living diagrams, hexagonal architecture, context diagrams, guided tours, code as documentation, and enforced guideline examples

**Documenting the Problem**:
- Architecture starts with understanding all objectives and constraints of the problem to be solved
- Written form of documentation is not enough, need to complement it with random discussions and roadshows

**Quality Attributes**:
- Shape the solution in software development
- Should be clarified at the start of a project and after each change of context

**Stakeholder-Driven Architecture Documentation**:
- Different perspectives on architecture: infrastructure, expensive middleware, distributed components, database replication
- Diversity of perspectives revealed through architectural kata workshops
- Caution against using kata method on real business cases as "winner versus loser" effect

**Key Stakes of the System**:
- Primary information to record for everyone to know
- Depending on the system, main stakes can be different: low cost, easy use, visually attractive, performance, deeper understanding of business domain.

### 163-Explicit Assumptions.pdf,163-Explicit Assumptions,,0

**Explicit Assumptions (PDF)**

**Topic:** Explicit Assumptions

**Notes**:
- PDF titled "163-Explicit Assumptions"
- Contains information on explicit assumptions

**Keywords**:
- Explicit assumptions
- PDF
- Information

**Word List**:
- Contains
- Information
- Keywords: explicit assumptions, PDF
- Topic: Explicit Assumptions
- Notes: 163-Explicit Assumptions (PDF)

**Continued Discussion**
- Provide more details or examples of explicit assumptions
- Discuss the importance of recognizing and understanding explicit assumptions in various contexts (e.g., business, research, personal relationships)

**Possible Questions**:
1. What are some common explicit assumptions that we often make when reading a document or interpreting data?
2. How can acknowledging and addressing explicit assumptions help improve communication and collaboration in team settings?
3. Can you think of any negative consequences of ignoring explicit assumptions in professional or academic work?
4. Are there instances where explicit assumptions are better left unstated? If so, what are some examples and why?
5. How can we ensure that we are accurately identifying and addressing explicit assumptions in order to avoid misunderstandings?

### 164-Evolving Continuously Change-Friendly Documentation.pdf,164-Evolving Continuously Change-Friendly Documentation,"Explicit Quality Attributes 349\n

**Documentation Best Practices**
* Identify early the main stake of the project: business domain challenge, technical concern, user experience, or system integration
* Explicitly document assumptions: mark decisions with their underlying assumptions for efficient reconsideration
* Good architecture is simple and easy to describe in a few sentences: focuses on key decisions that guide others
* Architecture's complexity should be limited to ensure understanding by all stakeholders
* Expressing architecture out loud in less than two minutes can test its quality
* Documentation should challenge the presence of a high-level structure, rather than an inventory of details.

### 165-An Example of a Structured Decision Log.pdf,165-An Example of a Structured Decision Log,"Chapter 12 Living Architecture Documentation 350\nEvolvin

**Structured Decision Logs**

**Benefits of Using Structured Decision Logs**:
- Evolving architecture documentation
- Easy to explain and minimize hard-to-change decisions
- Documentation is persistent over time and accessible to everyone
- Avoids impediments to continuous change

**Decision Logs**:
- Maintain a decision log of important architectural decisions
- Record:
  - Decision
  - Rationale (why it was made)
  - Main alternatives considered
  - Main consequences, if any
- Keep the decision log versioned with the code base
- Add new entries that supersede previous ones and provide a reference

**Architectural Decision Records (ADRs)**:
- Called "architectural decision records" or "ADRs"
- Supported by tools like adr-tools
- Include structuring assumptions that shape the solution as part of the decision log

**Documenting Controversial Decisions**:
- Not always easy to record rationale for major architecture decisions, especially when made for the wrong reasons
- External experts can be involved to mitigate risks

**Technical Decisions**:
- New Claim Management as Single Source of Truth Until Accepted by Customer
  - Claim Management is the only source of truth until claim is accepted
  - Before push: commands sent to Claim Management, events sent to LCM to sync
  - After push: remote calls to LCM to update claim, events back to Claim Management
- CQRS (Command-Query Responsibility Segregation) and Event Sourcing
  - Keep track of user intents and exploit the asymmetry between write and read actions
  - Choose AxonFramework for implementation
- Value-First Approach
  - Avoid bugs from mutability and reduce boilerplate code
  - Use value objects whenever possible, they are immutable with a valued constructor.

### 166-Journals or Blogs as Brain Dumps.pdf,166-Journals or Blogs as Brain Dumps,,0

**Journaling or Blogging as Brain Dumps**:
- Provide a place to write down thoughts and ideas
- Can be beneficial for personal growth and reflection
- Helps process emotions and clarify goals
- Digital platforms (blogs) offer wider audience and potential impact
- Important: Do not replace face-to-face communication or professional help when needed.

### 167-The Architecture Landscape.pdf,167-The Architecture Landscape,"Fractal Architecture Documentation 355\nJournals or Blogs as Brain Dumps\nAn altern

**Fractal Architecture Documentation: Living Architecture Landscape**

**Alternative to Formal Decision Log:**
- Dumping brain by telling the full story
- Documenting decisions, trade-offs, implementation details
- Personal blog as complement
  * Compelling stories
  * Shows changing learnings over time
  * Documents history

**Fractal Architecture:**
- Large systems made up of several subsystems or modules
- Each module has its own architecture and documentation
- Document independently and describe overarching architecture between modules

**Documentation Mechanisms:**
- Internal documentation: package naming conventions, annotations in source code, plain text
- Evergreen documents in plain text and specific DSL
- Consolidated knowledge from each module

**Organizing Documentation:**
- Create a consistent whole for documentation
- Navigate efficiently
- Use ready-made templates as checklists

**Formalisms Inspiration:**
- ARC 42 "Concepts" section: checklist of aspects to consider
  - Ergonomics, Transaction Processing, Session Handling, Security, etc.

**Deriving Own Documentation Landscape:**
- Focus on what matters most for each subsystem or module
- Rich business domain: focus on domain model and behaviors
- CRUD-ish module: little to document as it's standard and obvious
- Legacy system: testability, migration are challenging aspects to document.

### 168-An Architecture Codex.pdf,168-An Architecture Codex,"Chapter 12 Living Architecture Documentation 358\nY our documentation landscape might be a pl

**Living Architecture Documentation**

**Documentation Landscape**:
- Can be a plain-text file with predefined bullets and tables
- Can take the form of a small library of annotations, marking source code elements
- Can be a specific DSL, wiki, or proprietary tools

**Typical Documentation Landscape for a System**:
- Describes:
  - Overall purpose, context, users, and stakeholders
  - Overall required quality attributes
  - Key business behaviors, business rules, and business vocabulary
  - Overall principles, architecture, technical style, and opinionated decisions

**Architecture Diagrams and Notations**:
- Formalisms like IEEE 1471 and ISO/IEC/IEEE 42010 are not lightweight
- C4 Model: Lightweight approach to architecture diagrams, inspired by Kruchten's "4+1 model"
- Suggests four simple types of diagrams: System context, container, components, and classes

**Architecture Codex**:
- Documenting the thinking and reasoning behind solutions
- Example: EcmaScript's documentation of rationales for decisions
- Developing a codex of principles to guide decision making
  - Examples: Keep your golden source, don't feed the legacy, increase straight-through processing automation
- Sharing this codex with the team, keeping it as a working document that is never finished

### 169-Architectural Annotations.pdf,169-Architectural Annotations,"Chapter 12 Living Architecture Documentation 362\n14\n15    private  final  String au

**Architectural Annotations**

**Key Principles**:
- Strategic Goals: enable scalable business, support entry into new markets
- Architectural Principles: consistent interfaces and data flow, no silver bullet
- Design and Delivery Practices: standard REST/HTTP, encapsulate legacy, minimal customization of COTS/SAAS

**Transparent Architecture**:
- Architecture documentation embedded within software artifacts in each source code repository
- Accessible to everyone, enabling decentralization of architecture and decision-making
- Use of living system diagrams, distributed tracing infrastructure, service registry, and custom annotations

**Architectural Annotations**:
- Documenting code using custom annotations (e.g., @Layer)
- Stereotype-like patterns to qualify language elements
- Specific risks or concerns denoted directly on the corresponding class, method, or field
- Design patterns documented using annotations

**Creating a Patterns Catalog**:
- Including patterns from various sources: Gang of Four, DDD, Martin Fowler, EIP, PLoP and POSA, and custom in-house patterns
- Creating custom annotations to classify important sources of knowledge (e.g., business rules, policies)

### 170-Other Quality Attributes.pdf,170-Other Quality Attributes,"Transparent Architecture 365\nHere are some more examples:\n •@Policy  to highlight the

**Quality Attributes and Architecture Documentation**

**Transparent Architecture**:
- Highlight major company policy expressed in software
- Denote lower-level policies as "BusinessConvention"
- Emphasize what's important with "@KeyConcept" or "@Core"
- Use "Adapter" or "Composite" to denote pattern usage
- Clarify semantics of write/read on modules with "@Command"/"@Query"
- Use "@CorrelationID"/"AggregateID" on fields

**Enforced Design Decisions**:
- Use naming conventions, tags in service registry, or other mechanisms to delegate conformity checks to tools
- Check dependencies according to declared patterns and stereotypes knowledge
- Raise anomalies if certain design decisions are violated (e.g., value objects with field-level dependencies to entity/service classes)

**Architectural Reality Check**:
- Architecture should not be defined but discovered, refined, evolved, and explained
- Old-fashioned architecture practices can slow down the project
- Test-driven development mindset can help ensure quality attributes are met
- Regularly visualize and compare implemented architecture to intended architecture

**Test-Driven Architecture**:
- Define desired quality attributes as tests
- Implement tests to check these requirements, even if it takes time
- Use custom tags to classify, prioritize, and flag test scenarios
- Turn one-off experiments into maintainable assets that document the quality attributes

**Quality Attributes as Scenarios**:
- Write quality attribute requirements as bulleted lists in a Markdown file
- Implement tests using tools like Gatlin or JMeter to check these requirements
- Use Cucumber scenarios to describe the quality attributes declaratively

**Quality Attributes at Runtime in Production**:
- Monitor fault tolerance with tools like Chaos Monkey and Chaos Gorilla
- Document fault tolerance requirements through monitoring configurations
- Use automated rollback mechanisms to enforce "normal" metrics (e.g., CPU/memory usage, conversion rate)

### 171-From Fragmented Knowledge to Usable Documentation.pdf,171-From Fragmented Knowledge to Usable Documentation,,0

**Usable Documentation from Fragmented Knowledge**

### 172-Small-Scale Simulation as Living Architecture Documentation.pdf,172-Small-Scale Simulation as Living Architecture Documentation,"Chapter 12 Living

**Living Architecture Documentation: Best Practices**

**Quality Attributes:**
- Importance of documenting non-automated quality attributes
- Examples: financial expectations, user satisfaction
- Online tools encourage declarations of objectives before testing
- Tools promote TDD-ish approach for startups' objectives

**Fragmented Knowledge to Usable Documentation:**
- Multiple sources of truths about quality attributes
- Curate and consolidate information into one or two living tables of content
- Use tags to classify quality attribute tests in Cucumber scenarios
- Decide on a main tool as the single point of entry for documentation

**Small-Scale Simulation as Living Architecture Documentation:**
- Complex software applications challenging in terms of documentation
- Create small-scale replicas for documentation purposes
- Focus on key features and code that matters most
- Make sure the small-scale replica works realistically
- Advantage: fits in one's head, human-scale.

**Quality Attributes:**
- Document non-automated quality attributes (financials, user satisfaction)
  - Keep track of expectations before testing
  - Use online tools for declarations and testing

**Fragmented Knowledge to Usable Documentation:**
- Multiple sources of truths about all quality attributes
- Curate and consolidate information into one or two living tables of content
- Use tags to classify tests based on their nature
- Decide on a main tool as the single point of entry for documentation.

**Small-Scale Simulation:**
- Create small-scale replicas of software systems for documentation purposes
- Focus on key features and code that matters most
- Make sure the small-scale replica works realistically
- Advantage: fits in one's head, human-scale.

### 173-Building a Small-Scale Simulation Is Half the Fun.pdf,173-Building a Small-Scale Simulation Is Half the Fun,"Chapter 12 Living Architecture Docume

**Building a Small-Scale Simulation: Characteristics and Techniques**

**Small-Scale Simulation:**
- Quick exploration and mapping of system domain
- Discover main issues and stakes
- Grow vocabulary and shared vision
- Concrete reference for discussions
- Executable code, easy to tinker with
- Predicts dynamic behavior at runtime
- Inviting for interactive exploration
- Simplifies complex systems
- Reasoning through static structure or REPL
- Useful as inexpensive proxy to external systems

**Characteristics of a Small-Scale Simulation:**
- Fits in the brain of a normal person or developer
- Tinkerable and inviting for interactive exploration
- Executable to exhibit dynamic behavior
- Predicts results through execution, observable during computation (if possible)
- Small enough to focus on one or two aspects

**Techniques to Simplify a System:**
- **Curation**: Give up feature completeness, ignore non-central data and secondary concerns
- **Mocks, stubs, and spies**: Eliminate computation of non-central subparts, use in-memory collections instead of middleware or third parties
- **Approximation**: Settle for realistic accuracy that looks good enough
- **Convenient units**: Replace cumbersome data with simpler units (e.g., integers instead of dates)
- **Brute-force calculation**: Use the simplest algorithm or one with explanatory power
- **Batch versus event driven**: Turn event-driven approach into batch mode, or vice versa, if simpler for current focus

**Small-Scale Simulation as Living Architecture Documentation:**
- Small-scale simulations serve as documentation for system design and understanding
- Useful in big companies where everything takes ages, focusing on working code and conversations
- Helps converge and make it harder to elude tough questions during discussions.

### 174-Explaining a System by Talking About Another System.pdf,174-Explaining a System by Talking About Another System,"Chapter 12 Living Architecture Do

**Explaining a System by Talking About Another System**

**Creating Small-Scale Simulations**:
- Helps clarify thoughts and improve design of original system
- Reveals essential aspects of the system that can be used to simplify design
- Allows for faster experimentation with competing approaches
- Enables new joiners to build their own mental models of the system

**Simulation as a Learning Tool**:
- Allows for quicker understanding and exploration compared to text or code alone
- Helps develop theories about a system through hands-on experience
- Remarks by Peter Naur: Programming is a form of theory building

**System Metaphor**:
- Explaining a complex system to an unfamiliar audience can be challenging
- Building on existing knowledge is key for effective communication

### 175-A Metaphor in Another Metaphor.pdf,175-A Metaphor in Another Metaphor,"System Metaphor 375\nMetaphors get their power by leveraging on things most

**Metaphors in Explanation of Systems**

**Metaphor Use for System Explanation:**
- Metaphors used to explain new systems efficiently (C2 Wiki)
- Help clarify ideas and are fun for learning (metaphor examples: assembly line, water pipeline, Lego blocks, train on rails, bill of materials)
- Unify architecture and provide naming conventions in Extreme Programming (XP)
- Useful even without prior knowledge (modular synthesizer metaphor)

**Benefits of Using Metaphors:**
- Linear assembly line: multiple machines, conveyor belt, defects upstream affect downstream
- Prior knowledge invoked for reuse in understanding new system

**Metaphor Usefulness Despite Lack of Familiarity:**
- Modular synth metaphor helped team members unfamiliar with it (cash flow calculation engine as interpreter pattern)
- Remains useful as a redundancy mechanism.

### 176-Chapter 13 Introducing Living Documentation to a New Environment.pdf,176-Chapter 13 Introducing Living Documentation to a New Environment,"Chapter

**Living Documentation in Software Architecture**

**Background:**
- Good metaphors have generative power and can inform software architecture
- Knowledge of production lines and sales funnels useful for understanding e-commerce system's scalability

**Documentation**:
- Doesn't have to be slideware or models in proprietary tools
- Best done in living documentation, in situ within the system
- Organized into an architecture landscape

**Transparent and Living Architecture:**
- Important architectural knowledge accessible to all
- Enables informed changes quickly and anytime
- Machine accessible for continuous reality checks and feedbacks
- Thanks to automated assertions.

**Metaphors in Software Architecture**:
- Metaphors have generative power
- Knowledge of production lines can inform software system's protection mechanisms
- Sales funnel metaphor helps explain e-commerce system's business stages and scalability reasoning.

**Scalability Reasoning:**
- Upstream stage (catalog) needs more scalability than downstream stage (payment).

**Living Documentation**:
- Transparent and living architecture is the ultimate form
- Accessible information for informed changes
- Machine accessible for continuous feedback
- Best done in situ within the system.

### 177-Official Ambition.pdf,177-Official Ambition,"377Chapter 13\nIntroducing Living \nDocumentation to a New Environment\nLiving documentation starts w

**Living Documentation: Getting Started**
* **Start with a compelling case**: Improve current state of affairs or address flaws in software development process through living documentation
* **Find missing knowledge**: Demonstrate the value of living documentation by solving identified issues
* **Introduce nuggets of living documentation**: Annotate design decisions, intents, and rationales as part of daily work
* **Keep it simple**: Create automation such as living diagrams or glossaries in a short amount of time
* **Don't make a lot of noise**: Introduce living documentation naturally without asking for authorization
* **Documentation is part of professional development**: Justify the practice as an essential aspect of software development.

### 178-Case Study A Tale of Introducing Living Documentation to a Team Member.pdf,178-Case Study A Tale of Introducing Living Documentation to a Team Mem

**Introducing Living Documentation to a Team Member**

**Benefits of Living Documentation**:
- Can be introduced by emphasizing the benefits, not just the theory
- Become more interested in the approach before delving into the details from the book

**Official Ambition Approach**:
- Started through management sponsorship or promotion
- Visible and closely monitored, which may lead to pressure to deliver quickly
- Discovery journey with experimental side and no clear path to success
- Recommended to start with undercover experiments first and promote as official ambition later

**New Things Have to Work and Be Accepted**:
1. Create awareness through an all-audience talk that is informative and entertaining
2. Identify key knowledge that deserves documentation and try for quick wins
3. Build something useful in a short period of time, collect feedback, and make decisions on expansion

**Starting Gently**:
- Interactive and face-to-face knowledge transfer as primary means of documentation
- Consider techniques to record key bits of knowledge, such as:
  - README describing the project
  - Decision log with key architectural and design decisions
  - Code annotation for landmarks and core concepts
  - Guided tour annotation for end-to-end processing
4. Goal is to create awareness and interest by reaching attractive results quickly, and to experience the "beyond documentation effect"

**Going Big and Visible**:
- Can be dangerous due to:
  - Quantity of outcomes or KPIs needed for visible ambitions
  - Deferred benefits that may take months to show
  - Adjustments required in your particular context that may be perceived as failures
  - Misalignment between what's useful for the team and what management expected
- Management may be satisfied if you make previously hidden knowledge accessible to non-developers, allowing them to judge it based on objective facts.

### 179-The First Debriefing.pdf,179-The First Debriefing,"Case Study: A T ale of Introducing Living Documentation to a Team Member 381\nIn any case, reme

**Living Documentation: Case Study**

**Background:**
- Team member expresses interest in learning about living documentation
- Initial conversation between team members to understand current project details

**Conversational Style:**
- Put yourself in another team member's shoes
- Ask questions to gather information

**Standard Questions:**
- What is the name of the project? Purpose, stakeholders?
- What is the ecosystem: external systems, actors?
- Inputs and outputs?
- Execution style: interactive or batch? Main language?

**Core Domain Discussion:**
- Core domain identification not always obvious
- Team member realizes core domain is way they insert deep links in feed for external partners to bring qualified web traffic.
- Not all team members may be aware of this aspect.

### 180-Common Objections to Living Documentation.pdf,180-Common Objections to Living Documentation,"Chapter 13 Introducing Living Documentation to a New

**Living Documentation Overview**
* Conversations for sharing knowledge (quick, efficient)
* Recording persistent information (evergreen documents)
* Standard concepts documented online (deep linking)
* Benefits: learning and awareness beyond documentation

**Introducing Living Documentation to a Team Member**

**Step 1:** Learn about the context and problem side
- Discover deep linking concept, already documented online
- Pay attention to documentation for added benefits

**Step 2:** Understand code organization
- Draw folder hierarchy using a flipchart
- Identify risks and potential issues

**Step 3:** Record design decisions in decision logs
- Create plain Markdown files at the root of project, source control system
- Include date, decision, rationale, consequence

**Step 4:** Create guided tours for code understanding
- Annotate steps using @GuidedTour
- Identify significant parts of overall behavior as ready-made knowledge.

**Living Documentation: Benefits**
* Learning and gaining additional awareness during the process
* Efficient way to share knowledge
* Evergreen documents save time and effort
* Standard concepts documented online for easy reference
* Improved understanding of code through guided tours.

### 181-We Do It Already.pdf,181-We Do It Already,"Chapter 13 Introducing Living Documentation to a New Environment 384\nWe then create another custom ann

**Living Documentation Introduction: Chapter 13**
* Creating a new living documentation method using annotations
* Introducing @ReadThroughCache custom annotation for team member's feedback
* Encouraging team member about lightweight and easy addition of annotations
* Comparison between living documentation techniques, like diagrams vs. annotations
* Embedded learning approach: inviting discussion for further opportunities

**Objections to Living Documentation:**

**Annotation Misconceptions:**
* Some team members believe annotations are not meant for documentation
* Discussing the difference between comments and custom annotations
* Framing choice as "good versus bad": avoiding comments vs. using important information's own custom annotation.

### 182-Marginal Documentation.pdf,182-Marginal Documentation,"Migrating Legacy Documentation into Living Documentation 385\n “We Do It Already”\nIf you’r

**Migrating Legacy Documentation into Living Documentation**

**Standard Objection**: "We Do It Already"
- Opposition to new approaches in documentation
- Team should deliberate on strategy
- Strategy must be emergent and deliberate, fitting team context

**Documentation Practices**
- Team may already employ some practices
- Deliberately adopt new or improved practices
- Adjust over time for maximum benefits with minimal effort

**Addressing Past Knowledge**
- Old documentation can be leveraged
- Review past knowledge in a new light
- Convert PowerPoint documentation into living documentation
  - Vision/goals: README file (Markdown)
  - Pseudo-code, sequence diagrams: plain-text or ASCII diagrams
  - Main modules and methods: source code comments, annotations, naming conventions

**Addressing Unknown Knowledge**
- Acknowledging what you don't know is important
- Legacy documentation can provide insights.

### 183-Business Behavior.pdf,183-Business Behavior,"Chapter 13 Introducing Living Documentation to a New Environment 386\nNotice that all this knowledge

**Living Documentation in Business Environment**
* Introduction:
	+ Knowledge can be pulled from shared drives and wikis to new home in source control
	+ Old content becomes spread all over code base when moving to living documentation
	+ Best location for knowledge is as close as possible to where it's needed
	+ Documentation mining of existing documents: emails, Word docs, reports, meeting minutes, forum posts, company tools
	+ Deprecate or remove old content with redirection to new locations
* Marginal Documentation:
	+ Documentation endeavor does not have to be complete on first attempt
	+ Evolution over time through focus on marginal work
	+ Improve documentation as new pieces of work are added
	+ Segregate new additions into clean bubbles for higher standard living documentation
* Case Study: Introducing Living Documentation in a Batch System
	+ Team stays less than three years, so need for some documentation is not controversial
	+ Discussed improving documentation to improve life of development team
	+ Current documentation is outdated and unreliable, requiring team members to ask most knowledgeable member for knowledge
* README and Ready-Made Documentation:
	+ Source code repository does not have a README file at root
	+ Add a README file with clear mention that module follows data pump pattern and brief explanation
	+ Team can elaborate on data pump in README with target system, governance, rationale, and link to sample files

### 184-Integrated Documentation for Developers and a Living Glossary for Other Stakeholders.pdf,184-Integrated Documentation for Developers and a Living

**Living Documentation for Developers and Stakeholders**

**Determining Eligibility**:
- Core complexity of the module is determining the domain concept
- Best described by business scenarios in Cucumber JVM feature files
- Scenarios can be reused to generate sample files

**Making Scenarios Accessible to Nondevelopers**:
- Basic Cucumber report can show the scenarios as a web page
- Consider using Pickles tool for living documentation

**Visible Workings and Single Source of Truth**:
- Transcoding used to generate XML report is defined in code and Excel file
- Duplication of knowledge, no particular benefit
- Spreadsheet file should be the "golden source" of transcoding:
  - Code parses this file to drive its behavior
  - File serves as its own documentation
- Alternatively, code can generate a readable file with a generic structure

### 185-Contact Information and Guided Tours.pdf,185-Contact Information and Guided Tours,"Case Study: Introducing Living Documentation in a Batch System

**Living Documentation for Software Development:**
* **Integrated Documentation for Developers**
	+ Javadoc reports available directly in IDEs
	+ UML class diagrams integrated into editors
	+ No need for separate Javadoc reports if integrated well
* **Living Glossary for Other Stakeholders**
	+ Extract business domain concepts from code
	+ Generate Markdown and HTML glossary
	+ Review and fix Javadoc comments for accuracy
* **Design Intent Visualization**
	+ Hexagonal Architecture design follow-up
	+ Document naming conventions and structure
	+ Use regular expressions as bookmarks for stability.

### 186-Microservices Big Picture.pdf,186-Microservices Big Picture,,0

**Microservices: The Big Picture**

**Concepts:** Microservices and Big Picture

**Key Points:** Understanding microservices through a comprehensive perspective.

**Explanation:**
- Discuss the idea of microservices from a broad standpoint, emphasizing its significance in modern software development.
- Highlight the benefits, such as scalability, flexibility, independent deployment, and easier maintenance that make it an attractive choice for building applications.
- Describe how microservices work by breaking down large applications into smaller components or services that can communicate with each other through APIs.
- Discuss how these independent parts of the application can be developed, deployed, and updated separately, leading to improved efficiency and faster development cycles.
- Explain how microservices help organizations meet the challenges of modern technology landscapes by delivering more value to their customers through increased agility and flexibility.

### 187-A Living Documentation Initiative.pdf,187-A Living Documentation Initiative,"Chapter 13 Introducing Living Documentation to a New Environment 390\

**Living Documentation Initiative**

**Contact Information and Guided Tours**:
- Contact information can be obtained from the service registry (Consul) as required by company architects
- A guided tour for a specific batch is not very useful for developers, as the processing is completely controlled by the Spring Batch framework

**Microservices Big Picture**:
- How the data pump module fits within the larger system of many microservices
- Regularly running journey tests with distributed tracing can help visualize the system and provide a "big picture" guided tour

**Selling Living Documentation to Management**:
- Team members should be empowered to select practices that meet stakeholder expectations
- If the company is "proud to be 'really agile' and 'empower their teams,'" there should be no need for formal approval to try new approaches like living documentation, pair programming, or mob programming
- However, some time may be required to get started, which might require approval if it's part of a formal documentation budget

**Starting with an Actual Problem**:
- Identify a real knowledge-sharing issue and propose a solution inspired by the living documentation approach
- Start small and demonstrate the benefits on a "pilot" case within the company

**Living Documentation Initiative**:
- Consider presenting the book or videos on the topic to management as part of an initiative to adopt a living documentation strategy
- Emphasize that living documentation is a prerequisite for achieving sustainable continuous delivery, similar to testing
- Documentation is a concern close to managers' hearts, as it represents a cost in time and defects/mistakes

### 188-Compliance in Spirit.pdf,188-Compliance in Spirit,"Chapter 13 Introducing Living Documentation to a New Environment 394\nY ou can come up with man

**Benefits of Living Documentation**
- Improves long-term cost through team collaboration, automation, and reduction of waste
- Makes documentation feasible for teams when current situation is not under control
- Emphasizes value added beyond just knowledge sharing: improving software in the process

**Contrasting Current Situation with Promise of Living Documentation**
- Frustrations:
  - Not writing documentation, feeling guilty about it
  - Time consuming to explain things to team members and stakeholders
  - Preference for writing code over documentation
  - Outdated or unreliable documentation
  - Difficulty creating diagrams
  - Tedious manual tasks like deployment and paperwork
- Generalizations about developers:
  - Dislike writing documentation
  - Love code, automation, and beautiful code
  - Emphasis on text-first, logical approaches
  - Pride in mastery and geek culture
- Generalizations about managers:
  - Desire for team transparency and well-presented documentation
  - Need for turnover-proof documentation

**Living Documentation and Compliance Requirements**
- Can meet compliance goals while reducing burden and saving time
- Regulators focus on requirements tracking, change management, testing, and design reviews
- Agile practices, including BDD, provide extensive documentation through specification by example and collaboration
- Collective knowledge sharing contributes to various compliance requirements.

**Living Documentation vs Traditional Approaches**
- Living documentation is more rigorous than traditional approaches in terms of compliance due to continuous delivery ideas and agile practices.

### 189-Summary.pdf,189-Summary,"Compliance in Spirit 397\nburdensome procedures and paperwork. Still, agile practices often meet or even \nexceed the hig

**Compliance with Agile Practices**

**Agile vs. Burdensome Procedures**:
- Agile practices often exceed higher-level compliance goals, such as:
  - Risk mitigation
  - Traceability
  - Reasonable amount of traceability
  - Quality under control
  - Improvement in everything
- Compliance teams and development teams share common goals

**Living Documentation Approach**:
- Review compliance documentation requirements
- Identify how they can be satisfied using a living documentation approach:
  - Lightweight declarations
  - Knowledge augmentation
  - Automation
- Mandatory formal documents can be generated from knowledge managed differently
- If compliance expectations are burdensome, identify how the higher-level goals can be directly satisfied with your practices

**Case Study: Compliance with ITIL**:
- **Agile vs. ITIL**: Agile process is more disciplined than traditional ITIL-by-the-book processes
  - Automation and enforced guidelines protect the development team and reduce manual chores
  - Tools draw attention to quality expectations and make them visible

**Living Documentation Patterns**:
- Migrate painful traditional documentation into a more living equivalent
  - Use patterns discussed in this book
  - Managers are concerned about retaining knowledge

**Continuous Improvement**:
- Retrospectives notes with action plans and issues
  - Wiki, email, picture of the whiteboard

### 190-Chapter 14 Documenting Legacy Applications.pdf,190-Chapter 14 Documenting Legacy Applications,,0

**Documenting Legacy Applications**

**Chapter 14**: Focus on the topic of documenting legacy applications in software development or IT field.

**Legacy Applications**: These are older software systems that need to be documented for various reasons such as:
- Maintaining the software
- Updating or modernizing it
- Ensuring compatibility with new technologies

**Documentation**: Crucial for understanding and managing legacy applications, which may lack adequate documentation. It includes:
1. Functional description: Explanation of what the application does and how to use it.
2. Technical details: Hardware/software requirements, programming languages, databases, interfaces, APIs, etc.
3. Design documentation: Data flow diagrams, architecture diagrams, class diagrams, entity relationship diagrams.
4. User guides or manual: Instructions for users to install, operate and maintain the application.
5. Test plans and results: Documentation of testing procedures, tests cases, and test results.
6. Maintenance and troubleshooting guide: Tips on how to diagnose issues, debug, and resolve them.
7. Change log or release notes: Records of modifications, updates, and enhancements made to the application over time.
8. Security information: Details about encryption methods, access control, vulnerabilities, and mitigation strategies.

**Importance**: Proper documentation keeps legacy applications functional and secure while ensuring a smooth transition during upgrades or transfers to new teams. It also serves as valuable historical data for future projects.

### 191-Bubble Context.pdf,191-Bubble Context,"401Chapter 14\nDocumenting Legacy \nApplications\nThe universe is made of  information, but it doesn’t have

**Understanding Legacy Applications as Fossilized Knowledge**

**Legacy Systems:**
- Information encrypted, knowledge lost
- No clear definition of expected behavior
- Lack consistent structure
- Guessing meaning from variable names and methods
- Costly to change due to:
  - Duplication and lack of automated testing
  - Lost knowledge

**Documentation Bankruptcy:**
- Legacy applications are valuable, cannot be ignored
- Rewriting large systems often fails
- Changing context requires reverse engineering

**Legacy System as Fossilized Knowledge:**
- Use legacy system to inform new development
- Consider it a source of knowledge, not just code
- Business expert should work closely with team
- Challenge every aspect from the legacy system

**Rewriting Legacy Systems:**
- Avoid rewriting using same specs
- Opportunity to improve functional scope, business behaviors
- Automated testing and clear specifications

**Archeology of Legacy Code:**
- Source code as dense form of human communication
- Note important inputs, outputs, effects
- Documentation work dedicated to specific tasks
- Grow documentation through sedimentation mechanism

**Bubble Context:**
- Work within boundaries of new project within legacy system
- Enforced guidelines and automated tools for coding style
- Declare requirements using package-level annotations
- Perfect technique for rewriting part of a legacy system.

### 192-Superimposed Structure.pdf,192-Superimposed Structure,"Chapter 14 Documenting Legacy Applications 406\npattern by Martin Fowler.3 The idea is to r

**Superimposed Structure**

**Chapter 14: Documenting Legacy Applications**
- Discussing boundaries between old and new systems is difficult due to unstructured mess of legacy applications (Figure 14.2)
  - Hard to define, even when there's structure it can be arbitrary and misleading (Figure 14.3)

**Superimposed Structure in Legacy Code:**
- Start with making code testable
- Need a mental model of the legacy application
  - Can be local or full business behavior + complete technical architecture
- Read code, interview older developers, fix bugs to understand behavior
- Document this new structure for future discussions and decisions (Figure 14.4)
  - May not be visible when reading legacy code
  - A "hallucination," a vision not directly extracted from the system

**Superimposed Structure Examples:**
- Business pipeline: focuses on system as a series of stages in user journey (catalog, shopping cart, order preparation, payment, after-sales service)
  - Decreases volume at each stage for designing and operational purposes.

### 193-Highlighted Structure.pdf,193-Highlighted Structure,"Chapter 14 Documenting Legacy Applications 408\n •Main business assets, as in asset capture (

**Documenting Legacy Applications**

**Superimposed Structure**:
- Focuses on main business assets (customer, product)
- Can be split into segments (customer segments, product segments)
- Operational, tactical, and strategic levels from a business perspective
- Mix of views (dimensions, business pipeline)
- Helps in efficient communication within the team

**Making Superimposed Structure Visible**:
- Can be linked to existing code
- Use annotations on classes, interfaces, methods, or modules
- Tag files based on IDE capabilities (not stored within files)
- Example: @Billing annotation for billing domain classes

**Benefits of Superimposed Structure**:
- Helps deliver business value even if legacy code is badly structured
- Better decision making by reasoning about it using a better structure.

### 194-External Annotations.pdf,194-External Annotations,,0

**External Annotations: Understanding the Document**
* The provided text is a brief instruction on repeating information using concision.
* It consists of two parts:
  1. A title "External Annotations" with no indication of its relevance or context.
  2. A series of instructions for working with the document, including:
      * Repeat the passage provided
      * With concision
      * Using the same headings and terms as given
* No specific information about the content of the document is shared.

### 195-Example Strangler Application.pdf,195-Example Strangler Application,"Chapter 14 Documenting Legacy Applications 410\nExternal Annotations\nSometim

**Legacy Application Documentation: External Annotations**

**External Documentation**:
- Not always possible to touch codebase for annotations or other internal documentation
- Risk of introducing regressions or altering commit history
- Boss may not allow changes for documentation only

**Solution:**
- Use external document instead
- Map package names to tags in text file: `acme.phenix.core = DomainModel FleetManagement`
- Parse source code and exploit these external annotations

**Advantages**:
- No need to modify the legacy system
- Build tools that parse source code

**Disadvantages:**
- External documentation is fragile to changes in legacy system
- Need to update external annotations when renaming packages

**Biodegradable Transformation**:
- Document temporary processes, which will disappear later
- Show transformations as part of living documentation

**Annotations**:
- `@dao`, `@service`, `@registry` can be used for annotation references in external document.

### 196-Enforced Legacy Rules.pdf,196-Enforced Legacy Rules,"Biodegradable Transformation 411\nExample: Strangler Application\nSay that you’re building a

**Enforced Legacy Rules: Documenting Strategies for Legacy Applications**

**Strangler Application:**
- Biodegradable transformation
- Annotation to indicate "strangled by new application"
  - e.g., `@StrangledBy("new bubble context application")` or `@Deprecated ("Stranged by Butterfly")`
- Explanation in documentation or comment

**Bankrupt Legacy Applications:**
- Declare officially "bankrupt" if fragile and unchanging
- Prevent changes to avoid further complications
- Options for marking:
  - Annotation on package or assembly config file
  - `BANKRUPTCY .txt` file with instructions
  - Remove commit privileges
  - Monitor commits and raise alert

**Maxims:**
- Share key decisions through maxims
- Repeat often for effectiveness
- Example: "One work site at a time," "Don't feed the monster!"

**Enforced Legacy Rules:**
- Document decisions as enforced guidelines
- Use custom annotations and assertions to enforce rules
  - e.g., `@LegacyReadModel`, `@Deprecated` with white-list of allowed callers
- Log violations for follow-up actions.

### 197-Summary.pdf,197-Summary,"Summary 415\nSummary\nLegacy systems raise extensive challenges with respect to living documentation. \nThey come with a

**Challenges with Legacy Systems:**
* Difficulty in maintaining living documentation due to obfuscated knowledge within code
* Ad hoc techniques required for accessing this knowledge: superimposed structure, highlighted structure
* Inflexible or fragile systems may necessitate external annotations
* Major changes during migration, involving additions and removals of sections
* Biodegradable documentation needed to keep track of deleted code
* Consistency needed through shared maxims for people to act
* Courage required in handling legacy systems.

### 198-Chapter 15 Extra Conspicuous Documentation.pdf,198-Chapter 15 Extra Conspicuous Documentation,,0

**Extra Conspicuous Documentation**: Chapter 15 emphasizes the importance of clear and prominent record keeping.

### 199-How Is Your Lemon.pdf,199-How Is Your Lemon,"417Chapter 15\nExtra: Conspicuous \nDocumentation\nThe most common myth of  communication is that it

**Techniques for Effective Communication of Living Documentation:**
* Focus on salient points: describe differences from generic things by highlighting striking features or significant aspects.
* Efficient communication: use techniques to get the message across with fewer words, more quickly, and accurately.
* Boost efficiency: infuse living documentation into your culture in a fun way.

**Challenges in Effective Documentation:**
* Documentation mechanism in place does not guarantee effective communication
* People may not notice, remember, or contribute to knowledge sharing

**Salience:**
* Defined as a striking point or feature
* Important concept for describing specific things by focusing on differences.

### 200-Segmenting by Known Audience.pdf,200-Segmenting by Known Audience,"Chapter 15 Extra: Conspicuous Documentation 418\nHow Is Your Lemon?\nDuring a t

**Story of the Lemon:**
- During a training session at Öredev 2013, Joe Rainsberger told a story about lemons during a discussion on Behavior Driven Development (BDD)
- The trainer asked attendees to describe what a lemon is like: shape, color, taste, texture
- Each attendee was given their own real lemon and asked to study it for a few minutes
- Trainer analyzed his own lemon, noting its unique characteristics: bent end, variation in color, smaller than average size
- Attendees realized they had learned about their individual lemons intimately, feeling attachment to them
- By focusing on specific details of an item compared to the generic concept, effective description results

**Extra Information:**
- Colleagues have used this technique to describe concepts in business domain by highlighting distinctive aspects
- In electricity market, prices are very seasonal and in oil market, geography plays a role

**Identifying Known Audience:**
- Identify what audience knows or doesn't know during conversations through their questions and body language
- Difficult to do in written form but not impossible
- In written form, identify the specificity of unknown information for effective communication.

### 201-Flexible Content.pdf,201-Flexible Content,,0

**201-Flexible Content**:
- Flexible content refers to content that can be easily modified or customized to suit different users or situations.
- It is important in user interface (UI) design, as it helps ensure that the user's experience with the system is positive and relevant.

**Providing Flexible Content**:
- To provide flexible content, the system must have a well-defined set of rules for how to modify or customize the content.
- This can be accomplished through the use of placeholders in the content that indicate where different types of information should go.
- For example, a date picker UI element might have a placeholder that specifies the format (e.g., "MM/DD/YYYY") for the user to enter their date of birth.

**Advantages of Flexible Content**:
- Providing flexible content allows the system to better adapt to the specific needs and preferences of individual users, improving usability.
- It also allows the system to provide relevant information based on the user's current context, such as displaying local weather information when they log in.

**Constraints on Flexible Content**:
- While flexible content is beneficial, it must be used with caution to avoid confusion or overwhelming the user.
- The rules for modifying the content should be simple and easy to understand, and the default content should clearly indicate what type of information is expected.
- The system should also provide a way for the user to easily revert any customizations they have made, such as providing an "Undo" button or clear "Reset to Default" option.

### 202-Low-Fidelity Content.pdf,202-Low-Fidelity Content,,0

**Low-Fidelity Content** (202)

* Refer to the file "Low-Fidelity Content" for more information on this topic.
* This concept relates to a specific type of content that may not be as polished or refined, but can still provide value.

### 203-Together Now.pdf,203-Together Now,"Tell Only What’s Unknown 419\nSegmenting by Known Audience\nFor each audience, you can get feedback on the most

**Conspicuous Documentation: Creating Effective Written Content for Technical Audiences**

**Segmenting by Known Audience**:
- Gather feedback from frequently asked questions
- Communicate with support teams to learn what's well known and unknown
- Focus on what's unknown for each audience

**Flexible Content**:
- Organize content to be skimmed, skipped, and partially read
- Clearly mark optional sections
- Use low-fidelity content during the content shaping stage

**Low-Fidelity Content**:
- Use diagrams and sketchy renderings for unformed ideas
- Avoid premature feedback on details
- Use low-fidelity content to encourage input from team members

**Visual Facilitation**:
- Use visual media during discussions to improve communication
- Hire skilled scribes to create visual notes that influence further discussions
- Use visual supports to help everyone remain involved and understand the session

**Search-Friendly Documentation**:
- Make information easily searchable by using distinctive words
- Add keywords, including synonyms, antonyms, and common confusions
- Ensure that written content is easily discoverable, both in text and code

**Concrete Examples**:
- Agree on concrete examples during meetings to avoid misinterpretations later
- Use low-fidelity tools for creating examples, such as flipcharts or PowerPoint
- Encourage fast media and prior preparation to create consensus on concrete examples

### 204-Affordable and Attractive.pdf,204-Affordable and Attractive,"Chapter 15 Extra: Conspicuous Documentation 424\nTogether, Now\nThe power of “togethe

**Affordable and Attractive Documentation**
* "Together, now": Go the extra mile after an agreement is made until all attendees consider and agree to a solution proven by concrete examples (UI mockups, interaction workflows, impact maps, scenarios of expected business behavior)
* Productive specification meetings that produce concrete examples are valuable: rely on face-to-face conversations for effective communication and create quality documentation as an outcome
* Examples of interactive collaborative creation of concrete results in agile software development:
  * **Mob programming**: All brilliant minds together, on the same task, on the same machine
  * CRC Cards: Instant, interactive, and collaborative modeling with CRC cards on a table
  * Modeling with stickers on the wall: Examples are model storming and event storming
  * Code analysis: Modeling directly in code during a meeting with the domain expert
* Stack Overflow Documentation:
  * Officially documented pages can be boring and seldom task-oriented
  * People answering questions quickly on SO provide good, task-oriented documentation
  * Encourage teams to post questions and answer others' questions as well

### 205-Easter Eggs and Fun Anecdotes.pdf,205-Easter Eggs and Fun Anecdotes,"Affordable and Attractive 425\nPosting on SO requires your project to be publ

**Stack Overflow and Documentation**

**Requirements:**
- Project publication with source code online
- Success and demand for contributions
- Internal or closed source alternatives
- Domestic Stack Overflow clones may not be as efficient
- Downside: poor projects will be criticized, but cannot prevent it
- Dedicate employees to answer questions positively to improve user experience

**Documentation:**
- Romeu Moura's perspective on documentation
- Information should be attractive for self-preservation
- "Specs Digest" approach
  - Curation of design and specifications documents
  - Organized into sections with clear titles
  - Focuses on non-obvious information: business calculations, principles, rules, versioning schemes
  - Content can be moved to feature files or preamble Markdown in living documentation tools like Cucumber.

**Additional Notes:**
- StackExchange for Stack Overflow clones
- Specs Digest document is a solution to presenting essential information in an organized and easily accessible format, making it valuable for the team.

### 206-Promoting News.pdf,206-Promoting News,,0

**206-Promoting News:**
- Promote news effectively
- Repeat passage for concise understanding:
  - Effectively promote news
  - Understand passage for concise results

**Important Keywords:**
- Promote news
- Concision
- Understand passage
- Repeat

**Related Topics:**
- Communication strategies
- Public relations
- Information dissemination
- Effective messaging.

### 207-Maxims.pdf,207-Maxims,"Chapter 15 Extra: Conspicuous Documentation 426\nEaster Eggs and Fun Anecdotes\nHaving fun is the best way to learn. Y ou c

**Documentation Best Practices: Unconventional Approaches**

**Engaging Documentation:**
- Hide anecdotes in documents for engagement
- Add illustrations to make it more interesting
- Use humor: no rules against jokes
- Stay awake and keep documentation fun

**Promoting Documentation:**
- Provide recent changes page
- Use a changes feed (e.g., Swagger)
- Utilize Slackbot custom replies
- Release notes may not be necessary, assess their usefulness
- Hire a professional journalist for knowledge sharing

**Unorthodox Media:**
- Corporate world often lacks creativity in documentation methods
- Use unexpected media to communicate and document
- Examples: Microsoft Office templates, SharePoint, enterprise tools are common but dull
- Shake up team/department with unconventional approaches. (Peter Hilton)

**Documentation Avoidance:**
- Humor can make documentation more engaging
- Staying awake is essential to effective documentation
- Traditional media in corporate world may be uninspiring.

### 208-Comics.pdf,208-Comics,"Unorthodox Media 427\nMaxims\nWhen your current initiative is to improve the code quality come up with a catchy \nmaxim, su

**Maxims and Unorthodox Media**

**Creating Effective Maxims**:
- Create your own maxims that resonate with your culture
- Repeat them often to make them stick
- Use internal repetition and symmetry for memorable maxim examples

**Posters and Documentation**:
- Illustrated posters can help reinforce effective maxims
- Use Google image search or meme generators to create meme-based posters
- Display posters in visible areas like walls, TVs, or screensavers

**Humor and Cheap Media**:
- Short stories and humor are powerful for internal communication
- Use hashtags as a way to name new practices within the software industry
- Name your Wi-Fi network after a maxim to encourage environmentally friendly behavior

**Goodies/Swag**:
- Goodies like t-shirts, posters, and stickers can be effective for reinforcing maxims
- Consider using goodies as swag with your brand or a specific maxim on them.

### 209-Infodecks.pdf,209-Infodecks,,0

**Creating Content: Infodecks**

**Purpose**: N/A

**Instructions**: Generate concise bulleted notes summarizing the provided text, with headings and terms in bold.

**Infodecks:**
- Creating content using infodecks: N/A
- Instructions for generating concise bulleted notes:
  * Repeat the provided passage
  * Use headings and bolded terms

**Provided Text**:
```209-Infodecks.pdf,209-Infodecks,,0```

**Concise Bulleted Notes:**

**Creating Content: Infodecks**
- Utilize infodecks to create content
  - Repeat provided text
    ***209-Infodecks.pdf, 209-Infodecks, 0***
- Generate concise bulleted notes
  * Use headings and bolded terms
  * Follow instructions carefully for best results.

### 210-LEGO Bricks.pdf,210-LEGO Bricks,"Chapter 15 Extra: Conspicuous Documentation 432\nComics\nY ou can use comics as a compelling way to tell a story

**LEGO Bricks as Documentation:**
- **Comics**: can be used to tell a story or explain the rationale for a new project
- Documenting user stories is great for illustrating business stakes of an activity
- Use childish or less childish comics in corporate environments to explain processes
- Online comic generators allow anyone to create comics without drawing skills

**Infodecks**:
- Slides used as documents, read onscreen instead of projected
- Advantages: spatial layout for explanation, approachable with minimal text, easy to include diagrams
- Not to be confused with slide decks meant for large audiences
- Martin Fowler advocates for colorful infodecks with diagrams and tables as they are effective and taken seriously.

**Visualizations and Animations:**
- Perfect for explaining temporal behaviors
- Difficult to produce but effective in illustrating concepts.

### 211-Furniture.pdf,211-Furniture,,0

**Furniture:**
* Discuss the topic in a concise manner, focusing on essential points only.
* Provide information about furniture, its purpose and usage.

**Information about Furniture:**
* Furniture refers to movable items designed for use on or near a bed or table.
* It serves various functions such as providing storage, supporting objects, enhancing decor, and creating a comfortable living environment.

**Discuss Furniture in a Concise Manner:**
Furniture is an essential component of interior design that serves multiple purposes like storing items, supporting objects, adding to the overall aesthetic appeal, and creating a comfortable living space.

### 212-3D Printed Stuff.pdf,212-3D Printed Stuff,,0

**3D Printed Items**

**Topic**: 3D Printed Items

**Notes Summary**:
- **No heading**
- Discuss 3D printed items

**Expanded Notes**:
- **Concision**: Repeat the provided passage, with headings and terms in bold.

**3D Printing**
- Discuss various aspects of 3D printing

**Items**
- Focus on 3D printed items

**212-3D Printed Stuff**
- No heading
- Mention "3D Printed Stuff" as a descriptive term for the topic

**Notes with Headings and Terms in Bold**:
**Topic**: **Discussing 3D Printed Items**

**Subtopics**:
- **3D Printing**: Discuss various aspects of 3D printing (optional)
- **Items**: Focus on 3D printed items specifically

**212-3D Printed Stuff**:
- No heading, but can be used as a descriptive term for the topic.

### 213-Summary.pdf,213-Summary,"Summary 433\nA great example is the beautiful visualization of distributed consensus in Raft, \nwhich shows how nodes ele

**Lego Bricks and Visualization Tools**
- LEGO bricks: popular in agile circles for meetings, planning, and software architecture representation
- Other system of avatars or construction blocks can be used as meditation tools during conversations
- However, people may forget what they meant after a few days

**Furniture**
- Tables represent internal organization of a startup: each table = project team, no more room = max size
- Furniture can tell stories about a company's structure and teams
- Linux machines suggest developers' workspaces; huge iMac screens indicate where designers are

**3D Printed Models**
- 3D printed models easy to produce for application representation
- Helps everyone use visual and world-sensing strength to grasp problems in several dimensions
- Layers can be made removable and aligned for effective problem solving.

**Documentation Principles**
- Having documentation doesn't mean it's useful
- Focus on audience, discoverability, and fun factor can optimize living documentation effectiveness.

**Additional Information**
- The Secret Lives of Data: Raft visualization of distributed consensus https://thesecretlivesofdata.com/raft
- 15 Sorting Algorithms in 6 Minutes video: https://m.youtube.com/watch?v=kPRA0W1kECg

### 214-Index.pdf,214-Index,,0

**Index: A Note on Concision**

**Passage:** 214-Index.pdf,214-Index,,0

**Notes**:
- The passage is a string of words without clear meaning or context.
- No information can be extracted from this passage, making it non-functional.
- To make the passage functional and meaningful, we need to add relevant context and organize the elements in a way that convey information efficiently.

**Concise Version:** N/A - The original passage does not contain any significant details or meaning.

### 215-C.pdf,215-C,"435Index\nNumbers\n3D printed models, 433\n4

**Software Architecture Documentation**

**Background:**
- Importance of software architecture documentation (343–359)
- Architectural decision records (ADRs), 350–354
- Agile Documentation, 355–358

**Architecture Documentation:**
- Diagrams and notations in, 358–360
  * Hexagonal architecture living diagram, 179–184
- Journals/blogs, 355
- Modules, 355
- Problem briefs, 344–346
- Quality attributes, 346–347 (explicit and other)
- Test-driven architecture, 367–369
- Transparent architecture, 362–366

**Living Documentation:**
- Automated documents (declarative automation), 287–290
  * Declarative automated deployment, 296–297
  * Declarative configuration management, 293–296
  * Declarative dependency management, 291–293
- Living glossaries (advantages and examples), 158–165

**Documentation Avoidance:**
- Audiences, targeted, 66
- BDD (Behavior-Driven Development) as a case of living documentation, 58–70
- Documentation overhaul, 386–392

**Miscellaneous Topics:**
- Archeology: software, 403–404
- AOP (Aspect-Oriented Programming) in architecture documentation, 363–365
- Annotations in code, 97–102
- Knowledge augmentation: automated documents and coding as documentation, 287–326
  * Code reviews, 321–322
  * Coding conventions, 221–224
- Collaboration: best practices and continuous documentation, 21–22
  * Continuous documentation, 276–277
  * Cross programming, 274
  * Event Storming, 275–280
  * Mob programming, 274–275
  * Pair programming, 273–274
- Consolidation: benefits and limitations, 81–83
  * Implementation considerations, 82–83
  * Need for consolidation, 80–81
- Conspicuous documentation: fast media, interactive collaborative creation, and unorthodox media, 417–429

**Miscellaneous Terms:**
- ADRs (Architectural Decision Records), 350
- Agile Documentation (Rüping), 356
- Agile Manifesto, 199
- Agile T esting (Crispin and Gregory), 251, 272
- Analysis Patterns (Fowler), 49
- Angular.js commit guidelines: change logs, machine-accessible information, scope of change, type of change, 130–133
- AnnotationDoclet, 168
- AOP (Aspect-Oriented Programming) example, 114–115
- Arrangement property, 110
- Arrange-Act-Assert convention, 220–221
- AsciiDoc, 177
- @Aspect annotation, 114
- AspectJ, 114
- AssertJ, 234
- Analysis Patterns (Fowler), 49
- Animation, 432–433
- Angular.js commit guidelines: change logs, machine-accessible information, scope of change, type of change, 130–133
- AOP (Aspect-Oriented Programming) example, 114–115
- Arrangement property, 110
- Arrange-Act-Assert convention, 220–221
- AsciiDoc, 177
- @Aspect annotation, 114
- AspectJ, 114
- AssertJ, 234

### 216-F.pdf,216-F,"Index 439\ncontinuous delivery , 11–12\ncontinuous documentation, 276–277continuous training, 312–313contracts, published, 79–80conve

**Living Documentation:** An Overview
* Continuous delivery: 11–12
* Continuous documentation: 276–290
	+ Conventions: adherence to (106–107), coding (221–223), documentation of (105–106)
	+ Examples: 104–105, limitations (107)
	+ Living documentation in legacy code: 105
* Continuous training: 312–313
* Contracts: published, 79–80
* Conversations: characteristics of (268–269), code discussions (382–383), decision logs (383–384), diagrams and (171)
	+ First debriefing: 382
	+ Guided tours: creating (148–153), overview of (144–146)
	+ Knowledge from: 13
	+ Obstacles: 271–272, ready-made knowledge in (88–90), Rule of Three Interpretations (271), Wiilo’s laws (270)
* @CoreConcept annotation: 164
* Crispin, Lisa: 251, 272
* Cron: 202
* Cross programming: 274–275
* Cucumber: 57
* Cunningham, Ward: 223, 230, 336
* Curiation. See knowledge curation
* Custom annotations: advantages of (109), package names (112), properties (110), standard annotations, extending (113–114)
* CVS (Concurrent Versions System): 108
* DDD (domain-driven design): 11–12, living documentation and (50–53), overview of (49–50)
* Dean, Jeff: 278
* Decision logs: 350–354, 383–384
* Declarative automation: 287–299
	+ Declarative automated deployment: 296–297
	+ Declarative configuration management: 293–296
	+ Declarative dependency management: 291–293
	+ Declarative guidelines: 303–304
	+ Declarative style: 290
	+ Machine documentation: 299
* The Decorative Art of Today (Le Corbusier): 333
* Dexy: 122, 177
* DI (Dependency Injection) containers: 212
* Dependency management: declarative (291–293), dependency managers (291)
* Design. See living design
* Design documentation: guidelines versus (305)
* Design Patterns (Gamma et al): 102, 118
* Development: documentation-driven (326–328)
* Dexy: 122, 177
* Diagnostic tools:
	+ Signature surveys: 336–337
	+ Word clouds: 334–336
* Diagrams:
	+ In architecture documentation: 358–359
	+ Case study: background (184–185), changes, accommodation of (190), code augmentation (186–188), living diagram generation (188–189), quality attributes, addition of (190–191)
	+ Case study : 389
	+ Event sourcing scenarios: 209–211
	+ Hexagonal architecture example: 179–184
* Diagrams (continued):
	+ Rendering: 175–178
	+ Scale of diagrams: 174–175
	+ Storing code for: 173–174
	+ Tools for: 177–178
* Traditional documentation: 9
* Visualization guidelines: 178–179
* What to include: 171–174
* Differences: focus on (417–418)
* Digests: scenario (139–140)
* Dinwiddie, George: 275, 287
* Distributed tracing: 200–202
* Diagrams (Diaa): 177
* Docco: 121
* Doclet: 168, 178
* Document organization: 254
* Documentation avoidance: 44–45, 48
	+ Asthonishment reports: 285
	+ Constrained behavior: 307–309
	+ Continuous training: 312–313
	+ Conversations: 268–272
	+ Declarative automation: 287–299
	+ On-demand documentation: 282
	+ Design principles for: 309–11
	+ Consistency first: 310–11
	+ Replaceability first: 310
	+ Enforced guidelines: 300–307
	+ Idea sedimentation: 280–282
	+ Interactive documentation: 287–289
	+ Just-in-time documentation: 282–285
	+ Machine documentation: 299
	+ NODocumentation manifesto: 267
	+ Spontaneous discussions: 277–280
	+ Throw-away documentation: 282
	+ Upfront documentation: 285–287
	+ Working collectively: 272–276
* Documentation bankruptcy: 401–402
* Documentation by convention. See conventions
* Documentation by exception: 306
* Domain immersion: 263–264
* Domain training: 264
* Domain vision statements: 260
* Domain-driven design (DDD): 11–12, living documentation and (50–53), overview of (49–50)
* Domain-specific diagrams: 205–206
* Domain-specific language (DSL): 96, 232–233
* Domain-specific notation: 203–205
* Domain-specific test language (DSTL): 234–235
* Duarte, Nancy: 378, 394
* Duplex books: 419
* Dynamic curation: 135–140
	+ Art museum curation metaphor: 153–155
	+ Corpus of knowledge: 139
	+ Editorial curation: 137–138
	+ Examples: 137
	+ Guided tours: creating (148–153), overview of (144–146)
	+ Highlighted core: 141–144
	+ Low-maintenance curation: 138
	+ Sightseeing maps: creating (146–148), overview of (144–146)
* Easter eggs: 426
* Eaton-Rosen phenomenon: 427
* Email servers: 93
* Embedded learning: 22, 100–102
* Encouragement, enforcement versus: 303
* Enforced guidelines. See also constrained behavior
	+ Advantages of: 300–301
	+ In architecture documentation: 365–366
	+ Declarative guidelines: 303–304
	+ Enforcement versus encouragement: 303
	+ Evolutionary guidelines: 302–303
	+ Guidelines versus design documentation: 305
	+ Legacy rules: 413–414
	+ Rule examples: 301–302
	+ Tools for: 304–305
	+ Trust-first culture: 307
* Evolutionary guidelines: 302–303
* Explicit invitations: 322
* Extending standard annotations: 113–114
* Eye-catching graphics: 362
* F

### 217-H.pdf,217-H,"Index 441\nengineering\nas deliberate practice, 320\nreverse, 343\nerosion, architecture, 367error-proof APIs, 308–309Evans, Eric, 4,

**Documentation Practices:**
* Deliberate practice vs reverse engineering: 320
* Documentation by exception (Beck): 306
* Expensive upfront documentation vs evolving guidelines: 245–251, 36
* Evergreen content: document organization, stability, high-level goals, limitations, naming conventions, README file case study, strategy documentation. 21, 245–251
* External actors and annotations: 194
* External versus internal documentation: 25–26, 27–28
* Metadata databases and sidecar files: 108
* Minimizing extra work: 37–39

**Extreme Programming:**
* XP Explained (Beck): 49
* Feature files: definition, example, glossaries, intent, organization, property-based testing, scenarios, specification details, tags. 58–62
* Files: decision logs, manifests, sidecar. 107, 108

**Fluent Interfaces:**
* Domain-specific test language (DSTL): 234–235
* Fluent interfaces: overview, when to use. 233–234
* Internal domain-specific language (DSL): 232–233

**Fossilized Knowledge:**
* Legacy applications as fossilized knowledge: 402–403

**Miscellaneous:**
* Fowler, Martin: architecture documentation, fractal architecture documentation. 263, 355
* Fractal architecture documentation: 355
* Fragmentation of knowledge. 24
* Formality vs. need for formalized documentation: 37
* Furniture as media: 433

**People:**
* Eric Evans: 4, 126, 260, 405–408
* Houssam Fakih: 274
* Michael Feathers: 23, 403

**Processes and Tools:**
* Fast media: 423
* Feature files: definition, example, glossaries, intent, organization, property-based testing, scenarios, specification details, tags. 58–62
* Fluent NHibernate: 113
* Formatting tools (FSharp): 121
* FuelCardMonitoring, FuelCardTransaction, FuelCardTransactionReport, FuelCardTxListener: 149–151
* Fluent interfaces and style: domain-specific test language (DSTL), fluent interfaces, internal domain-specific language (DSL). 232–235
* Formality vs. need for formalized documentation: 37
* Furniture as media: 433

**Technologies:**
* Extreme Programming Explained (Beck): 49
* Extreme Programming (XP): 375
* Fluent NHibernate: 113
* FluentValidation: 233
* FSharp.Formatting: 121.

### 218-J.pdf,218-J,"Index 442\nGibson, William, 5\nGierke, Oliver, 128Gilb, 262Git, 92GitHub, 73, 177, 308glossaries, 69\nadvantages of, 158–159bounded c

**Documentation**
* **Types of Documentation**:
    + Glossaries:
        - Advantages: 158–159
        - Bounded contexts: 164–165
        - Case study: 165–170, 389
            * Example of: 160–162
            * How they work: 160
        - Goals: developing 260–261
        - Impact mapping: 261–262
    + Guided tours:
        - Case studies: 383–384, 390
            * Creating: 148–153
        - Overview of: 144–146
        - @GuidedTour annotation: 149–153
    + Guidelines enforcement:
        - Advantages: 300–301
        - Declarative guidelines: 303–304
            * Enforcement versus encouragement: 303
        - Evolving guidelines: 302–303
        - Guidelines versus design documentation: 305
        - Hamcrest example: 306–307
        - Legacy rules: 413–414
        - Rule examples: 301–302
        - Tools for: 304–305
        - Trust-first culture: 307
* **Other Documentation Forms**:
    + High-level goals: 246–247
    + Highlighted core: 141–144
    + Highlighted structure: 408–409
    + IDE (integrated development environment):
        - Integrated documentation: 238
            * Code searching: 238–239
            * Semantics: 239
            * Type hierarchy: 238
        - Idea sedimentation: 280–282
    + Immutable property: 110
    + Impat mapping: 261–262
    + Implementing DDD (Vernon): 180
    + Implementation Patterns (Beck): 218
    + IDEM potent property: 110
    + Identity by value property: 110
    + IEEE 1471: 358
    + Instrumentation: 200
    + Integrated documentation: 226–227, 238
        * Code searching: 238–239
        * Semantics: 239
        * Type hierarchy: 238
    + Interactive collaborative creation: 424
    + Indented text: 262
* **Other Concepts**:
    + Ideas: 280–282
    + IDEM potent guide: 323–325
    + Implicit knowledge: 24
    + In situ documentation: 28
    + Indented text: 262
    + Infodecks: 432
    + Information graveyard, traditional documentation as: 10
    + Information radiators: 429–430
    + @Inheritance annotation: 114
    + Insightful documentation: 22
    + Instrumentation: 200
    + Integrated development environment. See also IDE (integrated development environment)
    + Integrated documentation, integrated documentation, 238
        * Code searching: 238–239
        * Semantics: 239
        * Type hierarchy: 238
    + Interactive collaborative creation: 424
    + Indented text: 262

### 219-K.pdf,219-K,"Index 443\ninteractive documentation, 287–289\ninterfaces\nfluent, 233–234Introspectable, 214–215\ninternal documentation\ndefinition

**Documentation Types:**
- **Interactive documentation**: fluent interfaces, introspectable interfaces and workings (233–240)
  - Fluent interfaces: 233–234
  - Introspectable interfaces and workings: 214–215
- **Living documentation**: introduction of living documentation, objections (384–396)
  - Batch systems: business behavior, contact information, guided tours, journey tests, living diagrams, living glossary, README files, single source of truth, visible workings (386–390)
  - Legacy documentation: migrating, objections (385–386)
  - Management challenges: living documentation initiatives, problem briefs, vision (390–395)
- **Marginal documentation**: going big and visible, starting gently, steps for (379–380)

**Knowledge Augmentation:**
- **Annotations**: annotation by default, AOP example, in architecture documentation, custom, embedded learning, Google Annotations Gallery, JPA, meta-annotations, objections, Spring Framework (95–114)
  - Commit messages: advantages, commit guidelines, conventions (124–133)
- **Conventions**: adherence to, documentation of, examples, limitations, living documentation in legacy code, sidecar files (104–110)
- **Literate programming**: 153
- **Machine-accessible documentation**: machine-accessible documentation, metadata databases, sidecar files (119–120)
- **Module-wide knowledge augmentation**: module types, embedded learning, limitations of programming languages (115–117)
- **Stability of knowledge**: 38–39

**Knowledge Curation:**
- **Guided tours**: creating, overview (144–153)
- **Sightseeing maps**: creating, overview (146–150)

**Knowledge Exploitation:**
- **Consolidation**: context diagram example, how it works, implementation considerations, necessity, documentation and reconciliation mechanisms (71–89)
- **Single source publishing**: examples, overview (72–74)
- **Ready-made documentation**: objections, examples (387)
- **Redundant sources with reconciliation mechanisms**: consistency tests, published contracts, reconciliation on test assumptions (75–80)

**Other:**
- **ISO/IEC/IEEE 42010**: 358
- **Ivy**: 291
- **Java**: annotations, JPA, naming conventions, sightseeing map in Java (146–148)
- **Javadoc**: 74
- **JAX-RS annotations**: 114
- **JUnit and Selenium**: JGiven, JMock (234)
- **JHipster**: 298–299

### 220-M.pdf,220-M,"Index 445\nKnuth, Donald, 120\nKorpela, Jukka, 287\nL\nLa Gaité Lyrique, 278–279“ A Laboratory for Teaching Object-Oriented \nThinkin

**Legacy Application Documentation**
- **Arrange-Act-Assert convention**: described in "A Laboratory for Teaching Object-Oriented Thinking" by Beck and Cunningham (p. 220–221)
- **Tabular code layout**: used in UML visual notation (p. 219)
- **Biodegradable transformation**: applying to legacy applications, such as bankruptcy and strangle applications (pp. 401–412)
  * Documentation: biodegradable documentation, legacy read models, superimposed structure, summarized on p. 46
- **Legacy applications as fossilized knowledge**: legacy applications are discussed as sources of valuable but "fossilized" knowledge (p. 402–403)
- **Conventions**: arranged into categories like Arrange-Act-Assert, documented by Beck and Cunningham (p. 105)

**Linking Knowledge**
- **Linked knowledge**: includes bookmarked searches, broken link checkers, and link registries (pp. 254–258)
- **Legacy read models**: documentation for legacy systems, as mentioned on p. 413

**Lego Blocks and Documentation Tools**
- **Lego blocks**: used as an analogy to build understanding in "living design" (p. 315–316)
- **Leiningen**: a tool referenced in relation to libraries (p. 291)
- **Libraries**: mentioned as part of the documentation process, such as AssertJ, DotDiagram, JGiven, JMock, NFluent, and XDoclet (pp. 233–243)
- **Link registries**: used for managing information within documentation, discussed on p. 256

**Listening to Documentation**
- "Literate programming": a concept related to documentation, discussed on pp. 120–122 and 153
- **"Live-my-life" sessions**: an approach for understanding design through real-world context (p. 264–265)

**Living Architecture Documentation**
- **Living architecture documentation**: discussed as a way to represent knowledge, including diagrams and design principles (pp. 315–316)

**Documentation-Driven Development**
- **"Listening to documentation"**: the importance of documenting code and design decisions (p. 315–316)
- **Shameful documentation**: a term for poor quality or inconsistent documentation, with examples of both code documentation and Icare troubleshooting guide (pp. 323–326)
- **"Living documentation principles"**: collaboration, insight, low effort, reliability, and transparency (p. 317)

**Living Documents**
- **Creating living documents**: a process for documenting information in an accessible format (p. 158)
- **Living diagrams**: business overview case study, context diagram example, hexagonal architecture example, rendering, and overview (pp. 170–191)

### 221-O.pdf,221-O,"Index 446\nliving documents (continued)\nscale of diagrams, 174–175\nstoring code for, 173–174tools for, 177–178visualization guideli

**Living Documents and Visualization Guidelines**
* Diagrams: scale of diagrams, 174–175; storing code for, 173–174; tools for creating, 177–178
* Visualization guidelines, 178–179
* Include in living documents: what to include, 171–174

**Living Glossaries**
* Advantages: 158–159
* Bounded contexts, 164–165
* Case study, 165–170
* How they work, 160
* Need for, 1–4
* Patterns in living glossaries, 196–197
* Presentation rules, 158

**Living Services Diagram Example**
* Concept of, 200–202

**Location of Knowledge**
* 72

**Logistics and Supply Chain Management (Christopher)**
* Logs: decision logs, 350–354; documentation for logistics and supply chain management, 29

**Documentation Formats**
* Low-fidelity content, 419
* Low-maintenance dynamic curation, 138
* Machine documentation, 299
* Machine-accessible documentation, 119–120, 132–133
* Manual transcription, 7, 8

**Maps**
* Impact mapping, 261–262
* Sightseeing maps: creating, 146–148; concept of, 144–146

**Documentation Best Practices**
* Marginal documentation, 386
* Marick method, 202–203
* Maven, 74, 289, 291
* Maxims: for conspicuous documentation, 427; in legacy application documentation, 412–413

**Media**
* 3D printed models, 433
* Comics, 432
* Domestic ads, 427–429
* Furniture, 433
* Goodies/swag, 431
* Humor and cheap media, 430–431
* Infodecks, 432
* Information radiators, 429–430
* Lego blocks, 433
* Meme-based posters, 428–429
* Memes, 428–429
* Posters, 427–429
* Visualizations and animation, 432–433

**Commit Messages**
* Advantages: 128–130
* Commit guidelines, 129–133

**Metadata Databases**
* Metadata databases, 108–109

**Methods**
* Matcher method, 306
* monitor(), 151
* printMethod(), 170
* process(), 168–169
* toString(), 208, 212

**Metrics (Dropwizard)**
* Migrating legacy application documentation, 385–386

**Mindjet MindManager, MindMeister, MindMup, and MindNode**
* Tools for creating diagrams and visualizations, 177–178

**Minimizing Extra Work**
* 37–39

**Misleading Help: Traditional Documentation as Misleading Help**
* 10–11

**Module-Wide Knowledge**
* Intrinsic knowledge augmentation, 117–119
* Module types, 116–117
* Module-wide augmentation in practice, 117

**Music Theory Living Glossary**
* Example of, 165–170

### 222-Q.pdf,222-Q,"Index 447\nNaur, Peter, 15, 374\nnavigators (pair programming), 273–274Neo4j, 177Netflix, 308, 369new environments, introduction of l

**Living Documentation:** Introduction of Living Documentation in New Environments
- **Navigators (pair programming):** 273–274
- **Neo4j:** 177
- **Netflix:** 308, 369

**New Environments:** Introduction of Living Documentation to Batch Systems
- Common objections: 384–385
  * Compliance requirements
    + ITIL case study: 397–399
      - Meeting/exceeding compliance requirements: 395–397
      - Guided tours: 383–384
  * Legacy documentation, migrating: 385–386
  * Marginal documentation: 386
  * Officially ambitioned living documentation initiatives: 392–394
  * Problem briefs: 391–392
  + Vision, exhibiting: 394–395
- **Suggested path:**
  * Goin big and visible: 380–381
  * Starting gently: 379–380
  * Steps for introducing living documentation: 378–379

**Living Documentation to Team Members:**
- Code discussions: 382–383
- Conversations: 381–382
- Decision logs: 383–384
- First debriefing: 382
- Undercover experiments: 377–378

**Notation in Architecture Documentation:**
- In architecture documentation: 358–359
- Domain-specific notation: 203–205
  * Hungarian notation: 221–222
- Notation in traditional documentation: 9

**Object Design (Wirfs-Brock):** 49

**Object Trees:**
- Introspecting with reflection: 213–214
- Introspecting without reflection: 214–215
- Nature of object trees: 211–212
- Objections to living documentation: 384–385

**Object-Oriented Reengineering Patterns (Demeyer):** 412

**Octopus Deploy:** 296

**Official Ambition:** Introducing Living Documentation Through, 378

**Onboarding: Event Storming and, 275–276**

**On-demand documentation:** 282

**Options, Futures, and Other Derivatives (Hull):** 29

**Organization:**
- Nevergreen content: 254
- Organization of feature files: 61

**Oshineye, Adewale:** 332, 374

**Ottinger, Tim:** 10, 224

**Patterns of Enterprise Application Architecture (Fowler):** 112

**Pauly, Mathieu:** 239

**Percival, Michael L.:** 309

**Pescio, Carlo:** 317

**Petriček, Tomas:** 121

**Philippart, Gilles:** 413

**Pickles:** 61–62, 66, 68

**Pierrain, Thomas:** 234

**Plain-text diagrams:**
- Advantages of: 239–240
- Diagrams as code: 243–244
- Example of plain-text diagrams: 240–243

**Plain-text documents:** 66

### 223-S.pdf,223-S,"Index 448\nPlantUML, 177\nPositive property , 110posters, 427–429The Pragmatic Programmer \n(Hunt and Thomas), 73\npresentation rules

**Documentation Concepts and Tools:**
* Collaboration: principles of living documentation (insight, low effort, reliability)
* Programming as Theory Building (Naur)
* Documentation as code review in programming by coincidence design
* Processes: presentation rules, BDD (Behavior-Driven Development), reconciliation mechanisms
* Reducable documentation: refactoring, fluent interfaces, type-driven documentation, plane-text diagrams
* Runtime documentation: introspecting workings, visible tests
* Sightseeing maps, single source publishing, shadow users

**Documentation Formats:**
* Ready-made documentation: README files, RTFM (Ready to Find Me) documents
* Scenarios as living documentation
* Software architecture documentation (architecture patterns, components, diagrams)
* Stable documentation: organization, ensuring stability, investment in stable knowledge
* Linked knowledge: bookmarked searches, link registries, nonfunctional knowledge
* Standard knowledge: standard vocabulary, standards

**Tools:**
* Documentation tools: QDox, Puppet, Raft, Promote, Dox, Sphinx, Markdown, Confluence, MediaWiki
* Testing frameworks: JUnit, NUnit, Pytest, Selenium, Simple.Testing
* Continuous Integration and Delivery tools: Jenkins, Travis CI, CircleCI, GitHub Actions
* Version Control Systems: Git, SVN, Mercurial
* Wiki Engines: MediaWiki, Confluence, DokuWiki, MoinMoin
* Documentation Generators: Sphinx, Doxygen, Pydox, PlantUML
* Text Editors and IDEs: Visual Studio Code, IntelliJ IDEA, Eclipse, Sublime Text, Atom

**Documentation Best Practices:**
* Keep it simple: write clear, concise bulleted notes with headings and terms in bold.
* Use active voice, avoid jargon and acronyms where possible.
* Use diagrams, images, and videos to illustrate concepts.
* Provide examples and step-by-step instructions for using your documentation.
* Keep your documentation up-to-date and easily searchable.
* Write comprehensive bulleted notes summarizing the provided text with headings and terms in bold.

### 224-U.pdf,224-U,"Index 451\nstructured tags within comments, 102–103\nStructurizr, 177style declarations, 127–128superimposed structure, 406–408survey

**Documentation Practices and Tools**

**Structuring Tags**: within comments (102–103) and in feature files (60–61).

**Styles and Declarations**: style declarations (127–128), superimposed structure (406–408), surveys, signature (336–337).

**Sussman**: Gerald Jay (218) and Julie (218), Jeff (355).

**Swag**: 431.

**System Metaphors**: metaphors in other metaphors (376), value of (375).

**Tables**: state transition tables (219), tables of content (370), tabular code layout (219).

**Tags**: in comments (102–103), in feature files (60–61), tailored service templates (307–308).

**Test-Driven Development (TDD)**: overview of test-driven architecture (367–368), quality attributes as scenarios (368–369), tables of content (370).

**Testing**: consistency tests (76–78), journey tests (390), property-based testing (66–68), reconciliation on test assumptions (78–79), visible testing (203).

**Text Layout**: Arrangement-Act-Assert convention (220–221), tabular code layout (219), UML visual notation (219).

**Theory Building and Programming as Theory Building**: 15–17, this parameter (96).

**Thomas**: David (73), "three amigos" concept (275).

**Throw-Away Documentation**: 282.

**Time Cost**: of traditional documentation (8), "together, now" (424), tools, knowledge stored in (92–93).

**Tools**: knowledge stored in (92–93), various documentation and testing tools.

### 225-V.pdf,225-V,,0

**Key Point:** Repeat the given passage with concision.

**Instructions**: Repeat the provided passage with concision, meaning use fewer words to convey the same meaning as the original.

**Example**: "Repeat the provided passage with concision."

**Input**: "Repeat the provided passage with fewer words to convey the same meaning as the original."

### 226-W.pdf,226-W,,0

**Eye Contact for Sales and Business**: Effective eye contact is crucial during sales and business interactions as it establishes trust, builds rapport, and conveys credibility. To improve your eye contact skills:
- Maintain consistent eye contact with the other person
- Break eye contact occasionally to allow the other person breathing space
- Use a firm handshake when greeting or parting ways
- Offer your hand first for a firm yet gentle handshake
- Make eye contact during introductions, and maintain it throughout the interaction.

**Elevator Pitch**: An elevator pitch is a brief, persuasive speech that you can use to spark interest in your product, service, or career opportunity within the time frame of an elevator ride. It should be concise, clear, and compelling, focusing on the unique benefits that you can offer.

**Networking**: Networking involves building relationships with other people who may help you further your personal or professional goals. This can be done through attending events, reaching out to people in your industry, volunteering, or even casual conversations. The key is to be genuine, listen actively, and offer value in return.

**Presentation Skills**: Effective presentation skills involve preparing well, engaging your audience, speaking clearly and concisely, using visuals effectively, and handling questions gracefully. Remember that body language, eye contact, and facial expressions play a significant role in delivering a confident and compelling presentation.

**Listening Skills**: Active listening involves fully concentrating on what is being said, maintaining eye contact, observing body language, and making sounds to show you're engaged. This not only shows respect for the speaker but also enables you to better understand their perspective.

### 227-X-Y-Z.pdf,227-X-Y-Z,"Index 452\n@T ransactional annotation, 113\ntransfer of knowledge, documentation as, 17–18, \n23\ntransformations, biodegrada

**Index 452**
* **Transactional annotation**: 113
* **Transfer of knowledge, documentation as**: 17–18, 23
	+ Biodegradable transformations: 410
		- Bankruptcy application example: 411–412
		- Strangler application example: 411
* **Transparent architecture**
	+ Annotations: 363–65
	+ Architecture reality checks: 366–367
	+ Enforced guidelines: 365–366
	+ Overview of: 332–334, 362–363
* **Truck factor**: 277
* **Trust, lack of**: 34–35
* **Trust-first culture**: 307
* **Twitter searches**: 137
* **Type hierarchy**
	+ Type-driven documentation: 225–230
		- Advantages of: 225–226
		- Advantages over comments: 228
		- Associations: 227
		- Example of: 228–30
		- Integrated documentation: 226–227
		- Weak typing: 226
* **Tzatziki** and **Tzatzikinow**: 66, 68
* **UML visual notation**: 219

**Unknowns, focus on**
- Concrete examples: 421–423
- Flexible content: 419
- Low-fidelity content: 419
- Search-friendly documentation: 420–421
- Segmenting by known audience: 419
- Visual facilitation: 419–420

**Unorthodox media**
- 3D printed models: 433
- Comics: 432
- Domestic ads: 427–429
- Furniture: 433
- Goodies/swag: 431
- Humor and cheap media: 430–431
- Infodecks: 432
- Information radiators: 429–30
- Lego blocks: 433
- Maxims: 427
- Memes: 428–29
- Posters: 427–29
- Visualizations and animation: 432–33

**Unwritten knowledge**: 24

**Upfront decisions, deliberate vs. upfront documentation**
- Information to include: 285–86
- Knowledge backlog: 286
- Skills matrix: 287
- User directory mailing lists: 92

**Version numbers, snapshots with**: 75

**Visible tests**
- Domain-specific diagrams: 205–06
- Domain-specific notation: 203–05
- Event sourcing scenarios: 207, 209–11
	+ Example of: 208–09
	+ Overview of: 203
- Visible workings: 202–03, 388–89

**Vision statements**
- Domain: 260
- Importance of: 259

**Visual facilitation**: 419–20

**Visualizations**: 178–79, 432–33

**Volatile-to-stable dependencies**: 255

