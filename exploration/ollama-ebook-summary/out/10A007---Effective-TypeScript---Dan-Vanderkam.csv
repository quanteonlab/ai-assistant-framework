filename,title,text,len
01-How This Book Is Organized.pdf,01-How This Book Is Organized,"Preface to the Second Edition\nIt’ s hard to believe it’ s been nearly five years since the first edition of\nEffective T ypeScript  was published. The book and its companion website\nhave both been well received and have helped countless developers\nimprove their understanding and usage of the language.\nI was surprised how quickly I began to get asked whether the book was out-\nof-date. It only took six months! Given the pace of change in T ypeScript in\nthe years leading up to the first edition, this was a real concern of mine. I\ntried to avoid printing material that would soon be out-of-date. This meant\nfocusing more on timeless topics like language fundamentals and program\ndesign, rather than on libraries and frameworks. By and lar ge, the material\nin Effective T ypeScript  has held up well.\nAs T ypeScript developed and gained new features, it didn’ t invalidate the\nfirst edition as much as it created gaps in its coverage. W riting an\n“ef fective” item requires more than just knowing how a feature works. It\nrequires experience using  that feature: time spent learning which patterns\nwork well and which ones don’ t hold up. Conditional types had only\nrecently been added to the language in 2019, so I had little experience with\nthem. They’re covered more extensively in this edition. T emplate literal\ntypes have been the biggest addition to T ypeScript in the past five years.\nThey’ve opened whole new worlds of possibilities and are covered in Item\n54 .\nMoreover , thanks to projects like the T ype Challenges , T ypeScript\ndevelopers have become much more ambitious in what they do in the type\nsystem. Generics and type-level programming were covered only lightly in\nthe first edition. Now they get an entire chapter , Chapter 6 .\nMore than eight years after I first tried T ypeScript, I continue to enjoy it and\nget excited every time I read the latest release notes or see an ambitious\nnew PR from Anders Hejlsber g making the rounds. I also continue to enjoy\nhelping other developers learn T ypeScript and improve their usage of it. I\nhope that comes across in these pages, and I hope that reading this book\nhelps you enjoy working in T ypeScript as much as I do!\nW allkill, NY\nMar ch 2024\nW h o  T h i s  B o o k  I s  F o r\nThe Effective  books are intended to be the “standard second book” on their\ntopic. Y ou’ll get the most out of Effective T ypeScript  if you have some\nprevious practical experience working with JavaScript and T ypeScript. My\ngoal with this book is not to teach you T ypeScript or JavaScript but to help\nyou advance from a beginning or intermediate user to an expert. The items\nin this book do this by helping you build mental models of how T ypeScript\nand its ecosystem work, making you aware of pitfalls and traps to avoid,\nand by guiding you toward using T ypeScript’ s many capabilities in the most\nef fective ways possible. Whereas a reference book will explain the five\nways that a language lets you do X, an Effective  book will tell you which of\nthose five to use and why .\nT ypeScript has evolved rapidly over the past few years, but my hope is that\nit has stabilized enough that the content in this book will remain valid for\nyears to come. This book focuses primarily on the language itself, rather\nthan any frameworks or build tools. Y ou won’ t find any examples of how to\nuse React or V ue with T ypeScript, or how to configure T ypeScript to work\nwith webpack or V ite. The advice in this book should be relevant to all\nT ypeScript users.\nW h y  I  W r o t e  T h i s  B o o k\nWhen I first started working at Google, I was given a copy of the third\nedition of Ef fective C++  by Scott Meyers (Addison-W esley Professional). It\nwas unlike any other programming book I’d read. It made no attempt to be\naccessible to beginners or to be a complete guide to the language. Rather\nthan telling you what the dif ferent features of C++ did, it told you how you\nshould and should not use them. It did so through dozens of short, specific\nitems motivated by concrete examples.\nThe ef fect of reading all these examples while using the language daily was\nunmistakable. I’d used C++ before, but for the first time I felt comfortable\nwith it and knew how to think about the choices it presented to me. In later\nyears I would have similar experiences reading Effective Java  by Joshua\nBloch (Addison-W esley Professional) and Effective JavaScript  by David\nHerman (Addison-W esley Professional).\nIf you’re already comfortable working in a few dif ferent programming\nlanguages, then diving straight into the odd corners of a new one can be an\nef fective way to challenge your mental models and learn what makes it\ndif ferent. I’ve learned an enormous amount about T ypeScript from writing\nthis book. I hope you’ll have the same experience reading it!\nH o w  T h i s  B o o k  I s  O r g a n i z e d\nThis book is a collection of “items,” each of which is a short technical essay\nthat gives you specific advice about some aspect of T ypeScript. The items\nare grouped thematically into chapters, but feel free to jump around and\nread whichever ones look most interesting to you.\nEach item’ s title conveys the key takeaway . These are the things you should\nremember as you’re using T ypeScript, so it’ s worth skimming the table of\ncontents to get them in your head. If you’re writing documentation, for\nexample, and have a nagging sense that you shouldn’ t be writing type\ninformation, then you’ll know to read Item 31: Don’ t Repeat T ype\nInformation in Documentation .\nThe text of the item expands on the advice in the title and backs it up with\nconcrete examples and technical ar guments. Almost every point made in\nthis book is demonstrated through example code. I tend to read technical\nbooks by looking at the examples and skimming the prose, and I assume\nyou do something similar . I hope you’ll read the prose and explanations!\nBut the main points should still come across if you skim the examples.\nAfter reading the item, you should understand why it will help you use\nT ypeScript more ef fectively . Y ou’ll also know enough to understand if it\ndoesn’ t apply to your situation. Scott Meyers, the author of Ef fective C++ ,\ngives a memorable example of this. He met a team of engineers who wrote\nsoftware that ran on missiles. They knew they could ignore his advice about\npreventing resource leaks, because their programs would always terminate\nwhen the missile hit the tar get and their hardware blew up. I’m not aware of\nany missiles with JavaScript runtimes, but the James W ebb Space T elescope\nhas one, so you never know!\nFinally , each item ends with “Things to Remember .” These are a few bullet\npoints that summarize the item. If you’re skimming through, you can read\nthese to get a sense for what the item is saying and whether you’d like to\nread more. Y ou should still read the item! But the summary will do in a\npinch.",6984
02-Conventions in TypeScript Code Samples.pdf,02-Conventions in TypeScript Code Samples,"C o n v e n t i o n s  i n  T y p e S c r i p t  C o d e  S a m p l e s\nAll code samples are T ypeScript except where it’ s clear from the context\nthat they are JSON, HTML, or some other language. Much of the\nexperience of using T ypeScript involves interacting with your editor , which\npresents some challenges in print. I’ve adopted a few conventions to make\nthis work.\nMost editors surface errors using squiggly underlines. T o see the full error\nmessage, you hover over the underlined text. T o indicate an error in a code\nsample, I put squiggles in a comment line under the place where the error\noccurs:\nlet str = 'not a number';\nlet num: number = str;\n//  ~~~ Type 'string' is not assignable to type 'number'\nI occasionally edit the error messages for clarity and brevity , but I never\nremove an error . If you copy/paste a code sample into your editor , you\nshould get exactly the errors indicated—no more, no less.\nT o draw attention to the lack of an error , I use // OK :\nlet str = 'not a number';\nlet num: number = str as any;  // OK\nY ou should be able to hover over a symbol in your editor to see what\nT ypeScript considers its type. T o indicate this in text, I use a comment with\nT woslash syntax ( ^? ):\nlet v = {str: 'hello', num: 42};\n//  ^? let v: { str: string; num: number; }\nThe comment indicates what you’d see in your editor if you moused over\nthe symbol above the caret ( ^ ). This matches the convention used on the\nT ypeScript playground. If you copy a code sample over there and drop\neverything after the ^? , T ypeScript will fill in the rest for you. What you see\non the playground ( Figure P-1 ) should precisely match what you see in\nprint.\nFigur e P-1. T woslash syntax on the T ypeScript playgr ound.\nI will occasionally introduce no-op statements to indicate the type of a\nvariable on a specific line of code:\nfunction foo(value: string | string[]) { \n  if (Array.isArray(value)) { \n    value; \n    // ^? (parameter) value: string[] \n  } else { \n    value; \n    // ^? (parameter) value: string \n  }\n}\nThe value;  lines are only there to demonstrate the type in each branch of\nthe conditional. Y ou don’ t need to (and shouldn’ t) include statements like\nthis in your own code.\nUnless otherwise noted or clear from context, code samples are intended to\nbe checked with the --strict  flag. While printed copies of a book don’ t\nchange, T ypeScript does, and it’ s inevitable that some of the types or errors\nin code samples will be dif ferent in the future. Check the Ef fective\nT ypeScript repo  for updated versions of the examples in this book. All\nsamples were verified with literate-ts  using T ypeScript 5.4.",2697
03-Using Code Examples.pdf,03-Using Code Examples,"T y p o g r a p h i c a l  C o n v e n t i o n s  U s e d  i n  T h i s\nB o o k\nThe following typographical conventions are used in this book:\nItalic\nIndicates new terms, URLs, email addresses, filenames, and file\nextensions.\nConstant width\nUsed for program listings, as well as within paragraphs to refer to\nprogram elements such as variable or function names, databases, data\ntypes, environment variables, statements, and keywords.\nConstant width bold\nShows commands or other text that should be typed literally by the user .\nConstant width italic\nShows text that should be replaced with user -supplied values or by\nvalues determined by context.\nT I P\nThis element signifies a tip or suggestion.\nN O T E\nThis element signifies a general note.\nW A R N I N G\nThis element indicates a warning or caution.",823
04-How to Contact Us.pdf,04-How to Contact Us,"U s i n g  C o d e  E x a m p l e s\nSupplemental material (code examples, exercises, etc.) is available for\ndownload at https://github.com/danvk/effective-typescript .\nThis book is here to help you get your job done. In general, if example code\nis of fered with this book, you may use it in your programs and\ndocumentation. Y ou do not need to contact us for permission unless you’re\nreproducing a significant portion of the code. For example, writing a\nprogram that uses several chunks of code from this book does not require\npermission. Selling or distributing examples from O’Reilly books does\nrequire permission. Answering a question by citing this book and quoting\nexample code does not require permission. Incorporating a significant\namount of example code from this book into your product’ s documentation\ndoes require permission.\nW e appreciate, but generally do not require, attribution. An attribution\nusually includes the title, author , publisher , and ISBN. For example:\n“ Effective T ypeScript , 2nd ed.,  by Dan V anderkam (O’Reilly). Copyright\n2024 Dan V anderkam, 978-1-492-05374-3.”\nIf you feel your use of code examples falls outside fair use or the\npermission given above, feel free to contact us at permissions@or eilly .com .\nO ’ R e i l l y  O n l i n e  L e a r n i n g\nN O T E\nFor more than 40 years, O’Reilly Media  has provided technology and business training,\nknowledge, and insight to help companies succeed.\nOur unique network of experts and innovators share their knowledge and\nexpertise through books, articles, and our online learning platform.\nO’Reilly’ s online learning platform gives you on-demand access to live\ntraining courses, in-depth learning paths, interactive coding environments,",1752
05-Acknowledgments.pdf,05-Acknowledgments,"and a vast collection of text and video from O’Reilly and 200+ other\npublishers. For more information, visit https://or eilly .com .\nH o w  t o  C o n t a c t  U s\nPlease address comments and questions concerning this book to the\npublisher:\nO’Reilly Media, Inc.\n1005 Gravenstein Highway North\nSebastopol, CA 95472\n800-889-8969 (in the United States or Canada)\n707-827-7019 (international or local)\n707-829-0104 (fax)\nsupport@or eilly .com\nhttps://www .or eilly .com/about/contact.html\nW e have a web page for this book, where we list errata, examples, and any\nadditional information. Y ou can access this page at https://or eil.ly/effective-\ntypescript-2e .\nFor news and information about our books and courses, visit\nhttp://www .or eilly .com .\nFind us on LinkedIn: https://linkedin.com/company/or eilly-media .\nW atch us on Y ouT ube: http://youtube.com/or eillymedia .\nA c k n o w l e d g m e n t s\nDespite my hopes, writing a second edition did not prove any easier or less\ntime-consuming than the first. In the process, the book has grown from 62\nitems to 83. In addition to writing 22 new items (one old item was\nconsolidated into another), I’ve reviewed and thoroughly revised all the\noriginal material. Some parts, such as Items 45  and 55 , are near complete\nrewrites.\nMany new items are based on material that first appeared on the Effective\nT ypeScript  blog , though all of these have seen significant revision.\nChapter 6  is lar gely based on my personal experiences building the\ncrosswalk  and crudely-typed  libraries for Delve at Sidewalk Labs.\nHere are the origins of the new items in the second edition:\nItem 28  is adapted from the blog post “Use Classes and Currying to\nCreate New Inference Sites” .\nItem 32  arose from code reviews. I didn’ t know this was a rule until I\nsaw it broken!\nItem 36  was inspired by feedback I’ve given on countless code\nreviews.\nItem 37  is based on personal experience and Evan Martin’ s blog post\n“Why Not Add an Option for That?” . Cory House’ s frequent tweets on\nthis topic gave me courage to include it in the book.\nItem 38  was inspired by the Alan Perlis quote, which I frequently cite,\nas well as by Scott Meyers’ s rule.\nItem 39  is based on my team’ s experience with the Jsonify  adapter ,\nwhich we were excited to adopt and then even more excited to ditch.\nThe experience led to the blog post “The T rouble with Jsonify: Unify\nT ypes Instead of Modeling Small Dif ferences” .\nItem 48  is adapted from the blog post “The Seven Sources of\nUnsoundness in T ypeScript”  with significant input from R yan\nCavanaugh.\nItem 50  was inspired by lots of thinking about what types really are,\nand a Stack Overflow answer explaining dependent types.\nItem 51  is an adaptation of the blog post “The Golden Rule of\nGenerics” , which is, in turn, an adaptation of advice in the T ypeScript\nhandbook.\nItem 53  was inspired by my work on crosswalk and crudely-typed, and\ncuriosity about all those [T]  wrappers I was seeing.\nItem 54  was inspired by my own explorations of template literal types\nafter T ypeScript 4.1 was released, which culminated in the blog post\n“T ypeScript Splits the Atom!” .\nItem 56  is the culmination of my long-standing interest in this topic.\nThis was kicked of f by T itian Cernicova-Dragomir ’ s answer to a Stack\nOverflow question about typing _.invert , followed by my own\nexperiences in crosswalk and crudely-typed, which eventually led to\nthe blog post “The Display of T ypes” .\nItem 57  was inspired by the release notes for T ypeScript 4.5, which\nadded tail recursion.\nItem 58  was inspired by experience connecting T ypeScript with\ndatabases that eventually led to my T ypeScript Congress 2022 talk:\n“T ypeScript and SQL: Six W ays to Bridge the Divide” .\nItem 59  presents a widespread trick that Jesse Hallett introduced me to\nwhile reviewing the first edition. The “pairs” variation comes from a\n2021 tweet by T om Hicks.\nItem 62  was inspired by an Artsy blog post: “Conditional T ypes in\nT ypeScript” .\nItem 63  originated with R yan Cavanaugh’ s feedback on the first\nedition, which I eventually distilled into a blog post: “Exclusive Or\nand the Optional never T rick” . Stefan Baumgartner ’ s enthusiasm for\nthis trick in the T ypeScript Cookbook  (O’Reilly) encouraged me to\ninclude it in the book.\nItem 71  was inspired by a discussion with Evan Martin on reddit and a\nfrustrating bug that came back to new Set(""string"") . This led to the\nblog post “In Defense of Interface: Using Declaration Mer ging to\nDisable ‘Bad Parts’” .\nItem 74  is a topic that comes up frequently , especially if you don’ t\nhave the right mental model of T ypeScript.\nItem 76  was inspired by countless debugging sessions that came back\nto an incorrect model of your environment.\nItem 77  was inspired by personal curiosity about this topic, a few\nStack Overflow questions, and a Gary Bernhardt talk.\nItem 78  was inspired by painful personal experience with T ypeScript\ngetting slow . It’ s based on the T ypeScript wiki and the blog post\n“What’ s T ypescript Compiling? Use a T reemap to Find Out” .\nThanks to my tech reviewers, Josh Goldber g, Stefan Baumgartner , R yan\nCavanaugh, Boris Cherny , and T itian Cernicova-Dragomir . Y our feedback\nmade this book immensely better . Thanks to my coworkers on the Delve\nexperience squad (particularly Stephanie Chew , Luda Zhao, Ha V u, and\nAmanda Meurer) for all the code reviews and for accommodating my\nboundless enthusiasm for T ypeScript. Thanks to everyone at O’Reilly who\nhelped make this book happen: Angela Rufino, Ashley Stussy , Amanda\nQuinn, Clare Laylock, Sonia Saruba. Thanks to Chris Mischaikow for the\nlast-minute proofreading. Spotify’ s Jazzy Morning playlist, starting with\nArta Porting’ s Beautiful Sunrise , provided a soundtrack for writing and\nediting.\nFinally , thanks to Alex for all her support: through a pandemic, online and\nin-person weddings, a job change, and a big move, I’m glad at least one\nthing has stayed constant!",6074
06-Acknowledgments to the First Edition.pdf,06-Acknowledgments to the First Edition,"Preface to the First Edition\n(2019)\nIn the spring of 2016, I visited my old coworker Evan Martin at Google’ s\nSan Francisco of fice and asked him what he was excited about. I’d asked\nhim this same question many times over the years because the answers were\nwide-ranging and unpredictable but always interesting: C++ build tools,\nLinux audio drivers, online crosswords, emacs scripts. This time, Evan was\nexcited about T ypeScript and V isual Studio Code.\nI was surprised! I’d heard of T ypeScript before, but I knew only that it was\ncreated by Microsoft and that I mistakenly believed it had something to do\nwith .NET . As a lifelong Linux user , I couldn’ t believe that Evan had\nhopped on team Microsoft.\nThen Evan showed me VS Code and the T ypeScript playground and I was\ninstantly converted. Everything was so fast, and the code intelligence made\nit easy to build a mental model of the type system. After years of writing\ntype annotations in JSDoc comments for the Closure Compiler , this felt like\ntyped JavaScript that really worked. And Microsoft had built a cross-\nplatform text editor on top of Chromium? Perhaps this was a language and\ntoolchain worth learning.\nI’d recently joined Sidewalk Labs and was writing our first JavaScript. The\ncodebase was still small enough that Evan and I were able to convert it all\nto T ypeScript over the next few days.\nI’ve been hooked ever since. T ypeScript is more than just a type system. It\nalso brings a whole suite of language services which are fast and easy to\nuse. The cumulative ef fect is that T ypeScript doesn’ t just make JavaScript\ndevelopment safer: it also makes it more fun!\nBr ooklyn, NY\nOctober 2019\nA c k n o w l e d g m e n t s  t o  t h e  F i r s t  E d i t i o n\nThere are many people who helped make this book possible. Thanks to\nEvan Martin for introducing me to T ypeScript and showing me how to\nthink about it. T o Douwe Osinga for connecting me with O’Reilly and\nbeing supportive of the project. T o Brett Slatkin for advice on structure and\nfor showing me that someone I knew could write an Effective  book. T o\nScott Meyers for coming up with this format and for his “Ef fective Effective\nBooks” blog post, which provided essential guidance.\nT o my reviewers, Rick Battagline, R yan Cavanaugh, Boris Cherny , Y akov\nFain, Jesse Hallett, and Jason Killian. T o all my coworkers at Sidewalk who\nlearned T ypeScript with me over the years. T o everyone at O’Reilly who\nhelped make this book happen: Angela Rufino, Jennifer Pollock, Deborah\nBaker , Nick Adams, and Jasmine Kwityn. T o the T ypeScript NYC crew ,\nJason, Orta, and Kirill, and to all the speakers. Many items were inspired by\ntalks at the Meetup, as described in the following list:\nItem 3  was inspired by a blog post of Evan Martin’ s that I found\nparticularly enlightening as I was first learning T ypeScript.\nItem 7  was inspired by Anders’ s talk about structural typing and keyof\nrelationships at TSConf 2018, and by a talk of Jesse Hallett’ s at the\nApril 2019 T ypeScript NYC Meetup.\nBoth Basarat’ s guide and helpful answers by DeeV and GPicazo on\nStack Overflow were essential in writing Item 9 .\nItem 10  builds on similar advice in Item 4 of Effective JavaScript .\nI was inspired to write Item 1 1  by mass confusion around this topic at\nthe August 2019 T ypeScript NYC Meetup.\nItem 13  was greatly aided by several questions about type  vs.\ninterface  on Stack Overflow . Jesse Hallett suggested the formulation\naround extensibility .\nJacob Baskin provided encouragement and early feedback on Item 15 .\nItem 18  was inspired by several code samples submitted to the\nr/typescript subreddit.\nItem 24  is based on my own writing on Medium and a talk I gave at\nthe October 2018 T ypeScript NYC Meetup.\nItem 29  is based on common advice in Haskell (“make illegal states\nunrepresentable”). The Air France 447 story is inspired by Jef f W ise’ s\nincredible 201 1 article in Popular Mechanics .\nItem 30  is based on an issue I ran into with the Mapbox type\ndeclarations. Jason Killian suggested the phrasing in the title.\nThe advice about naming in Item 41  is common, but this particular\nformulation was inspired by Dan North’ s short article in 97 Things\nEvery Pr ogrammer Should Know  (Kevlin, Henney , O’Reilly).\nItem 64  was inspired by Jason Killian’ s talk at the very first T ypeScript\nNYC Meetup in September 2017.\nItem 25  is based on the T ypeScript 2.1 release notes. The term\n“evolving any” is not widely used outside the T ypeScript compiler\nitself, but I find it useful to have a name for this unusual pattern.\nItem 46  was inspired by a blog post of Jesse Hallett’ s.\nItem 47  was greatly aided by feedback from T itian Cernicova-\nDragomir in T ypeScript issue #33128.\nItem 49  is based on Y ork Y ao’ s work on the type-coverage  tool. I\nwanted something like this and it existed!\nItem 66  is based on a talk I gave at the December 2017 T ypeScript\nNYC Meetup.\nItem 52  owes a debt of gratitude to David Sheldrick’ s post on the Artsy\nblog on conditional types, which greatly demystified the topic for me.\nItem 70  was inspired by a talk Steve Faulkner , aka southpolesteve,\ngave at the February 2019 Meetup.\nItem 55  is based on my own writing on Medium and work on the\ntypings-checker tool, which eventually got folded into dtslint.\nItem 72  was inspired/reinforced by Kat Busch’ s Medium post on the\nvarious types of enums in T ypeScript, as well as Boris Cherny’ s\nwritings on this topic in Pr ogramming T ypeScript  (O’Reilly).\nItem 60  was inspired by my own confusion and that of my coworkers\non this topic. The definitive explanation is given by Anders on\nT ypeScript PR #12253.\nThe MDN documentation was essential for writing Item 75 .\nChapter 10  is based on my own experience migrating the aging\ndygraphs library .\nI found many of the blog posts and talks that led to this book through the\nexcellent r/typescript subreddit. I’m particularly grateful to developers who\nprovided code samples there which were essential for understanding\ncommon issues in beginner T ypeScript. Thanks to Marius Schulz for the\nT ypeScript W eekly newsletter . While it’ s only occasionally weekly , it’ s\nalways an excellent source of material and a great way to keep up with\nT ypeScript. T o Anders, Daniel, R yan, and the whole T ypeScript team at\nMicrosoft for the talks and all the feedback on issues. Most of my issues\nwere misunderstandings, but there is nothing quite so satisfying as filing a\nbug and immediately seeing Anders Hejlsber g himself fix it!\nFinally , thanks to Alex for being so supportive during this project and so\nunderstanding of all the working vacations, mornings, evenings, and\nweekends I needed to complete it.",6798
07-1. Getting to Know TypeScript.pdf,07-1. Getting to Know TypeScript,,0
08-Item 1 Understand the Relationship Between TypeScript and JavaScript.pdf,08-Item 1 Understand the Relationship Between TypeScript and JavaScript,"Chapter 1. Getting to Know\nT ypeScript\nBefore we dive into the details, this chapter helps you understand the big\npicture of T ypeScript. What is it and how should you think about it? How\ndoes it relate to JavaScript? Are its types nullable or are they not? What’ s\nthis about any ? And ducks?\nT ypeScript is an unusual language in that it neither runs in an interpreter (as\nPython and Ruby do) nor compiles down to a lower -level language (as Java\nand C do). Instead, it compiles to another high-level language, JavaScript. It\nis this JavaScript that runs, not your T ypeScript. So understanding\nT ypeScript’ s relationship with JavaScript is essential and will help you be a\nmore ef fective T ypeScript developer .\nT ypeScript’ s type system also has some unusual aspects that you should be\naware of. Later chapters cover the type system in much greater detail, but\nthis one will hit a few of the most important highlights.\nY ou should read this chapter even if you’ve already written lots of\nT ypeScript. It will help you build correct mental models of what T ypeScript\nis and how its type system works, and it may clear up some misconceptions\nyou didn’ t realize you had.\nI t e m  1 :  U n d e r s t a n d  t h e  R e l a t i o n s h i p  B e t w e e n\nT y p e S c r i p t  a n d  J a v a S c r i p t\nIf you use T ypeScript for long, you’ll inevitably hear the phrase\n“T ypeScript is a superset of JavaScript” or “T ypeScript is a typed superset\nof JavaScript.” But what does this mean, exactly? And what is the\nrelationship between T ypeScript and JavaScript? Since these languages are\nso closely linked, a strong understanding of how they relate to each other is\nthe foundation for using T ypeScript well.\nA  is a “superset” of B  if everything in B  is also in A . T ypeScript is a superset\nof JavaScript in a syntactic sense: so long as your JavaScript program\ndoesn’ t have any syntax errors then it is also a T ypeScript program. It’ s\nquite likely that T ypeScript’ s type checker will flag some issues with your\ncode. But this is an independent problem. T ypeScript will still parse your\ncode and emit JavaScript. (This is another key part of the relationship. W e’ll\nexplore this more in Item 3 .)\nT ypeScript files  use a .ts  extension, rather than the .js  extension of a\nJavaScript file.1 This doesn’ t mean that T ypeScript is a completely dif ferent\nlanguage! Since T ypeScript is a superset of JavaScript, the code in your .js\nfiles is already T ypeScript. Renaming main.js  to main.ts  doesn’ t change\nthat.\nThis is enormously helpful if you’re migrating an existing JavaScript\ncodebase to T ypeScript. It means that you don’ t have to rewrite any of your\ncode in another language to start using T ypeScript and get the benefits it\nprovides. This would not be true if you chose to rewrite your JavaScript in a\nlanguage like Java. This gentle migration path is one of the best features of\nT ypeScript. There will be much more to say about this topic in Chapter 10 .\nAll JavaScript programs are T ypeScript programs, but the converse is not\ntrue: there are T ypeScript programs that are not JavaScript programs. This\nis because T ypeScript adds additional syntax for specifying types. (There\nare some other bits of syntax it adds, too, lar gely for historical reasons. See\nItem 72 .)\nFor instance, this is a valid T ypeScript program:\nfunction greet(who: string) { \n  console.log('Hello', who);\n}\nBut when you run this through a program like node  that expects JavaScript,\nyou’ll get an error:\nfunction greet(who: string) { \n                  ^ \n \nSyntaxError: Unexpected token :\nThe : string  is a type annotation that is specific to T ypeScript. Once you\nuse one, you’ve gone beyond plain JavaScript (see Figure 1-1 ).\nFigur e 1-1. All JavaScript is T ypeScript, but not all T ypeScript is JavaScript.\nThis is not to say that T ypeScript doesn’ t provide value for plain JavaScript\nprograms. It does! For example, this JavaScript program:\nlet city = 'new york city';\nconsole.log(city.toUppercase());\nwill throw an error when you run it:\nTypeError: city.toUppercase is not a function\nThere are no type annotations in this program, but T ypeScript’ s type\nchecker is still able to spot the problem:\nlet city = 'new york city';\nconsole.log(city.toUppercase());\n//               ~~~~~~~~~~~ Property 'toUppercase' does not exist on type\n//                           'string'. Did you mean 'toUpperCase'?\nY ou didn’ t have to tell T ypeScript that the type of city  was string : it\ninferred it from the initial value. T ype inference is a key part of T ypeScript,\nand Chapter 3  explores how to use it well.\nOne of the goals of T ypeScript’ s type system is to detect code that will\nthrow an exception at runtime, without having to run your code. When you\nhear T ypeScript described as a “static” type system, it refers to this ability .\nThe type checker cannot always spot code that will throw exceptions, but it\nwill try .\nEven if your code doesn’ t throw an exception, it still might not do what you\nintend. T ypeScript tries to catch some of these issues, too. For example, this\nJavaScript program:\nconst states = [ \n  {name: 'Alabama', capital: 'Montgomery'}, \n  {name: 'Alaska',  capital: 'Juneau'}, \n  {name: 'Arizona', capital: 'Phoenix'}, \n  // ...\n];\nfor (const state of states) { \n  console.log(state.capitol);\n}\nwill log:\nundefined \nundefined \nundefined\nWhoops! What went wrong? This program is valid JavaScript (and hence\nT ypeScript). And it ran without throwing any errors. But it clearly didn’ t do\nwhat you intended. Even without adding type annotations, T ypeScript’ s\ntype checker is able to spot the error and of fer a helpful suggestion:\nfor (const state of states) { \n  console.log(state.capitol); \n  //                ~~~~~~~ Property 'capitol' does not exist on type \n  //                        '{ name: string; capital: string; }'. \n  //                        Did you mean 'capital'?\n}\nW e did, in fact, mean capital  with an “a.” States and countries have\ncapital (“a”) cities, whereas legislatures meet in capitol (“o”) buildings.\nWhile T ypeScript can catch errors even if you don’ t provide type\nannotations, it’ s able to do a much more thorough job if you do. This is\nbecause type annotations tell T ypeScript what your intent  is, and this lets it\nspot places where your code’ s behavior does not match your intent. For\nexample, what if you’d reversed the capital /capitol  spelling mistake in\nthe previous example?\nconst states = [ \n  {name: 'Alabama', capitol: 'Montgomery'}, \n  {name: 'Alaska',  capitol: 'Juneau'}, \n  {name: 'Arizona', capitol: 'Phoenix'}, \n  // ...\n];\nfor (const state of states) { \n  console.log(state.capital); \n  //                ~~~~~~~ Property 'capital' does not exist on type \n  //                        '{ name: string; capitol: string; }'. \n  //                        Did you mean 'capitol'?\n}\nThe error that was so helpful before now gets it exactly wrong! The\nproblem is that you’ve spelled the same property two dif ferent ways, and\nT ypeScript doesn’ t know which one is right. It can guess, but it may not\nalways be correct. The solution is to clarify your intent by explicitly\ndeclaring the type of states :\ninterface State { \n  name: string; \n  capital: string;\n}\nconst states: State[] = [ \n  {name: 'Alabama', capitol: 'Montgomery'}, \n  //                ~~~~~~~ \n  {name: 'Alaska',  capitol: 'Juneau'}, \n  //                ~~~~~~~ \n  {name: 'Arizona', capitol: 'Phoenix'}, \n  //                ~~~~~~~ Object literal may only specify known properties, \n  //                        but 'capitol' does not exist in type 'State'. \n  //                        Did you mean to write 'capital'? \n  // ...\n];\nfor (const state of states) { \n  console.log(state.capital);\n}\nNow the errors match the problem and the suggested fix is correct. By\nspelling out your intent, you’ve also helped T ypeScript spot other potential\nproblems. For instance, had you only misspelled capitol  once in the array ,\nthere wouldn’ t have been an error before. But with the type annotation,\nthere is:\nconst states: State[] = [ \n  {name: 'Alabama', capital: 'Montgomery'}, \n  {name: 'Alaska',  capitol: 'Juneau'}, \n  //                ~~~~~~~ Did you mean to write 'capital'? \n  {name: 'Arizona', capital: 'Phoenix'}, \n  // ...\n];\nThis will become  a familiar dynamic as you work with the type checker: the\nmore information you give it, the more problems it will be able to find.\nIn terms of the V enn diagram, we can add in a new group of programs:\nT ypeScript programs which pass the type checker (see Figure 1-2 ).\nFigur e 1-2. All JavaScript pr ograms ar e T ypeScript pr ograms. But only some JavaScript (and\nT ypeScript) pr ograms pass the type checker .\nIf the statement that “T ypeScript is a superset of JavaScript” feels wrong to\nyou, it may be because you’re thinking of this third set of programs in the\ndiagram. In practice, this is the most relevant one to the day-to-day\nexperience of using T ypeScript. Generally when you use T ypeScript, you\ntry to keep your code passing all the type checks.\nT ypeScript’ s type system models  the runtime behavior of JavaScript. This\nmay result in some surprises if you’re coming from a language with stricter\nruntime checks. For example:\nconst x = 2 + '3';  // OK\n//    ^? const x: string\nconst y = '2' + 3;  // OK\n//    ^? const y: string\nThese statements both pass the type checker , even though they are\nquestionable and do produce runtime errors in many other languages. But\nthis does accurately model the runtime behavior of JavaScript, where both\nexpressions result in the string ""23"" .\nT ypeScript does draw the line somewhere, though. The type checker flags\nissues in all of these statements, even though they do not throw exceptions\nat runtime:\nconst a = null + 7;  // Evaluates to 7 in JS\n//        ~~~~ The value 'null' cannot be used here.\nconst b = [] + 12;  // Evaluates to '12' in JS\n//        ~~~~~~~ Operator '+' cannot be applied to types ...\nalert('Hello', 'TypeScript');  // alerts ""Hello""\n//             ~~~~~~~~~~~~ Expected 0-1 arguments, but got 2\nThe guiding principle of T ypeScript’ s type system is that it should model\nJavaScript’ s runtime behavior . But in all of these cases, T ypeScript\nconsiders it more likely that the odd usage is the result of an error than the\ndeveloper ’ s intent, so it goes beyond simply modeling the runtime behavior .\nW e saw another example of this in the capital /capitol  example, where\nthe program didn’ t throw (it logged undefined ) but the type checker still\nflagged an error .\nHow does T ypeScript decide when to model JavaScript’ s runtime behavior\nand when to go beyond it? Ultimately this is a matter of taste. By adopting\nT ypeScript you’re trusting the judgment of the team that builds it. If you\nenjoy adding null  and 7  or []  and 12 , or calling functions with superfluous\nar guments, then T ypeScript might not be for you!\nIf your program type checks, could it still throw an error at runtime? The\nanswer is “yes.” Here’ s an example:\nconst names = ['Alice', 'Bob'];\nconsole.log(names[2].toUpperCase());\nWhen you run this, it throws:\nTypeError: Cannot read properties of undefined (reading 'toUpperCase')\nT ypeScript assumed the array access would be within bounds, but it was\nnot. The result was an exception.\nUncaught errors also frequently come up when you use the any  type, which\nwe’ll discuss in Item 5  and in more detail in Chapter 5 .\nThe root cause of these exceptions is that T ypeScript’ s understanding of a\nvalue’ s type (its static type) and its actual type at runtime have diver ged. A",11815
09-Item 2 Know Which TypeScript Options Youre Using.pdf,09-Item 2 Know Which TypeScript Options Youre Using,"type system that can guarantee the accuracy of its static types is said to be\nsound . T ypeScript’ s type system is very much not sound, nor was it ever\nintended to be. Item 48  explores more ways that unsoundness can arise.\nIf soundness is important to you, you may want to look at other languages\nlike Reason, PureScript, or Dart. While these do of fer more guarantees of\nruntime safety , this comes at a cost: it takes more work to convince their\ntype checkers that your code is correct, and none of these are a superset of\nJavaScript, so migration will be more complicated.\nThings to Remember\nT ypeScript is a superset of JavaScript: all JavaScript programs are\nsyntactically valid T ypeScript programs, but not all T ypeScript\nprograms are valid JavaScript programs.\nT ypeScript adds a static type system that models JavaScript’ s runtime\nbehavior and tries to spot code that will throw exceptions at runtime.\nIt is possible for code to pass the type checker but still throw at\nruntime.\nT ypeScript disallows some legal but questionable JavaScript constructs\nsuch as calling functions with the wrong number of ar guments.\nT ype annotations tell T ypeScript your intent and help it distinguish\ncorrect and incorrect  code.\nI t e m  2 :  K n o w  W h i c h  T y p e S c r i p t  O p t i o n s\nY o u ’ r e  U s i n g\nDoes this code pass the type checker?\nfunction add(a, b) { \n  return a + b;\n}\nadd(10, null);\nW ithout knowing which options you’re using, it’ s impossible to say! The\nT ypeScript compiler has an enormous set of these, over a hundred at the\ntime of this writing.\nThey can be set via the command line:\n$ tsc --noImplicitAny program.ts\nor via a configuration file, tsconfig.json :\n{\n  ""compilerOptions"": {\n    ""noImplicitAny"": true\n  }\n}\nY ou should prefer the configuration file. It ensures that your coworkers and\ntools all know exactly how you plan to use T ypeScript. Y ou can create one\nby running tsc --init .\nMany of T ypeScript’ s configuration settings control where it looks for\nsource files and what sort of output it generates. But a few control core\naspects of the language itself. These are high-level design choices that most\nlanguages do not leave to their users. T ypeScript can feel like a very\ndif ferent language depending on how it is configured. T o use it ef fectively ,\nyou should understand the most important of these settings:\nnoImplicitAny  and strictNullChecks .\nnoImplicitAny\nnoImplicitAny  controls  what T ypeScript does when it can’ t determine the\ntype of a variable. This code is valid when noImplicitAny  is of f:\nfunction add(a, b) { \n  return a + b;\n}\nIf you mouse over the add  symbol in your editor , it will reveal what\nT ypeScript has inferred about the type of that function:\nfunction add(a: any, b: any): any\nThe any  types ef fectively disable the type checker for code involving these\nparameters. any  is a useful tool, but it should be used with caution. For\nmuch more on any , see Item 5  and Chapter 5 .\nThese are called implicit any s  because you never wrote the word “any” but\nstill wound up with dangerous any  types. This becomes an error if you set\nthe noImplicitAny  option:\nfunction add(a, b) { \n  //         ~    Parameter 'a' implicitly has an 'any' type \n  //            ~ Parameter 'b' implicitly has an 'any' type \n  return a + b;\n}\nThese errors can be fixed by explicitly writing type declarations, either :\nany  or a more specific type:\nfunction add(a: number, b: number) { \n  return a + b;\n}\nT ypeScript is the most helpful when it has type information, so you should\nbe sure to set noImplicitAny  whenever possible. Once you grow\naccustomed to all variables having types, T ypeScript without\nnoImplicitAny  feels almost like a dif ferent language.\nFor new projects, you should start with noImplicitAny  on, so that you\nwrite the types as you write your code. This will help T ypeScript spot\nproblems, improve the readability of your code, and enhance your\ndevelopment experience (see Item 6 ).\nLeaving noImplicitAny  of f is only appropriate if you’re transitioning a\nproject from JavaScript  to T ypeScript (see Chapter 10 ). Even then, this\nshould only be a temporary state and you should turn it on as soon as\npossible. T ypeScript without noImplicitAny  is surprisingly loose. Item 83\nexplores how this can lead  to trouble.\nstrictNullChecks\nstrictNullChecks  controls whether null  and undefined  are permissible\nvalues in every type.\nThis code is valid when strictNullChecks  is of f:\nconst x: number = null;  // OK, null is a valid number\nbut triggers an error when you turn strictNullChecks  on:\nconst x: number = null;\n//    ~ Type 'null' is not assignable to type 'number'\nA similar error would have occurred had you used undefined  instead of\nnull .\nIf you mean to allow null , you can fix the error by making your intent\nexplicit:\nconst x: number | null = null;\nIf you do not wish to permit null , you’ll need to track down where it came\nfrom and add either a check or an assertion:\nconst statusEl = document.getElementById('status');\nstatusEl.textContent = 'Ready';\n// ~~~~~ 'statusEl' is possibly 'null'. \n \nif (statusEl) { \n  statusEl.textContent = 'Ready';  // OK, null has been excluded\n}\nstatusEl!.textContent = 'Ready';  // OK, we've asserted that el is non-null\nUsing an if  statement in this way is known as “narrowing” or “refining” a\ntype, and this pattern is explored in Item 22 . The “! ” on the last line is\ncalled a “non-null assertion.” T ype assertions have their place in\nT ypeScript, but they can also lead to runtime exceptions. Item 9  will explain\nwhen you should and should not use a type assertion.\nstrictNullChecks  is tremendously helpful for catching errors involving\nnull  and undefined  values, but it does increase the dif ficulty of using the\nlanguage. If you’re starting a new project and you’ve used T ypeScript\nbefore, set strictNullChecks . But if  you’re new to the language or\nmigrating a JavaScript codebase, you may elect to leave  it of f. Y ou should\ncertainly set noImplicitAny  before you set strictNullChecks .\nIf you choose to work without strictNullChecks , keep an eye out for the\ndreaded “undefined is not an object” runtime error . Every one of these is a\nreminder that you should consider enabling stricter checking. Changing this\nsetting will only get harder as your project grows, so try not to wait too long\nbefore enabling it. Most T ypeScript code uses strictNullChecks , and this\nis eventually where you want to be.\nOther Options\nThere are many other settings that af fect language semantics (e.g.,\nnoImplicitThis  and strictFunctionTypes ), but  these are minor\ncompared to noImplicitAny  and strictNullChecks . T o enable all of\nthese checks, turn on the strict  setting. T ypeScript is able to catch the\nmost errors with strict , so this should be your goal.\nIf you create a project using tsc --init , you’ll be in strict  mode by\ndefault.\nThere are also a few “stricter than strict” options available. Y ou can opt into\nthese to make T ypeScript even more aggressive about finding errors in your\ncode. One of these options  is noUncheckedIndexedAccess , which helps to\ncatch errors around object and array access. For example, this code has no\ntype errors under --strict  but throws an exception at runtime:\nconst tenses = ['past', 'present', 'future'];\ntenses[3].toUpperCase();\nW ith noUncheckedIndexedAccess  set, this is an error:\nconst tenses = ['past', 'present', 'future'];\ntenses[3].toUpperCase();\n// ~~~~~~ Object is possibly 'undefined'.\nThis is not a free lunch, however . Many valid accesses will also be flagged\nas possibly undefined :\ntenses[0].toUpperCase();\n// ~~~~~~ Object is possibly 'undefined'.\nSome T ypeScript projects use this setting, while others don’ t. Y ou should at\nleast be aware that it exists. There will be more to say about this setting in\nItem 48 .\nKnow which options you’re using! If a coworker shares a T ypeScript\nexample and you’re unable to reproduce their errors, make sure your\ncompiler options are the same.\nThings to Remember\nThe T ypeScript compiler includes several settings that af fect core\naspects of the language.\nConfigure T ypeScript using tsconfig.json  rather than command-line\noptions.\nT urn on noImplicitAny  unless you are transitioning a JavaScript\nproject to T ypeScript.",8445
10-Item 3 Understand That Code Generation Is Independent of Types.pdf,10-Item 3 Understand That Code Generation Is Independent of Types,"Use strictNullChecks  to prevent “undefined is not an object”-style\nruntime errors.\nAim to enable strict  to get the most thorough checking that\nT ypeScript  can of fer .\nI t e m  3 :  U n d e r s t a n d  T h a t  C o d e  G e n e r a t i o n  I s\nI n d e p e n d e n t  o f  T y p e s\nAt a high level, tsc  (the T ypeScript compiler) does two things:\nIt converts next-generation T ypeScript/JavaScript to an older version\nof JavaScript that works in browsers or other runtimes (“transpiling”).\nIt checks your code for type errors.\nWhat’ s surprising is that these two behaviors are entirely independent of\none another . Put another way , the types in your code cannot af fect the\nJavaScript that T ypeScript emits. Since it’ s this JavaScript that gets\nexecuted, this means that your types can’ t af fect the way your code runs.\nThis has some surprising implications and should inform your expectations\nabout what T ypeScript can and cannot do for you.\nY ou Cannot Check T ypeScript T ypes at Runtime\nY ou may be tempted to write code like this:\ninterface Square { \n  width: number;\n}\ninterface Rectangle extends Square { \n  height: number;\n}\ntype Shape = Square | Rectangle; \n \nfunction calculateArea(shape: Shape) { \n  if (shape instanceof Rectangle) { \n    //                 ~~~~~~~~~ 'Rectangle' only refers to a type, \n    //                           but is being used as a value here \n    return shape.height * shape.width; \n    //           ~~~~~~ Property 'height' does not exist on type 'Shape' \n  } else { \n    return shape.width * shape.width; \n  }\n}\nThe instanceof  check happens at runtime, but Rectangle  is a type and so\nit cannot af fect the runtime behavior of the code. T ypeScript types are\n“erasable”: part of compilation to JavaScript is simply removing all the\ninterface s, type s, and type annotations from your code. This is easiest to\nsee if you look at the JavaScript that this sample compiles down to:\nfunction calculateArea(shape) { \n  if (shape instanceof Rectangle) { \n    return shape.height * shape.width; \n  } else { \n    return shape.width * shape.width; \n  }\n}\nThere’ s no mention of Rectangle  before the instanceof  check here, hence\nthe problem.2 T o ascertain the type of shape you’re dealing with, you’ll\nneed some way to reconstruct its type at runtime, i.e., some way that makes\nsense in the generated JavaScript, not just in the original T ypeScript.\nThere are several ways to do this. One is to check for the presence of a\nheight  property:\nfunction calculateArea(shape: Shape) { \n  if ('height' in shape) { \n    return shape.width * shape.height; \n    //     ^? (parameter) shape: Rectangle \n  } else { \n    return shape.width * shape.width; \n  }\n}\nThis works because the property check only involves values available at\nruntime, but still allows the type checker to refine shape ’ s type to\nRectangle .\nAnother way would be to introduce a “tag” to explicitly store the type in a\nway that’ s available at runtime:\ninterface Square { \n  kind: 'square'; \n  width: number;\n}\ninterface Rectangle { \n  kind: 'rectangle'; \n  height: number; \n  width: number;\n}\ntype Shape = Square | Rectangle; \n \nfunction calculateArea(shape: Shape) { \n  if (shape.kind === 'rectangle') { \n    return shape.width * shape.height; \n    //     ^? (parameter) shape: Rectangle \n  } else { \n    return shape.width * shape.width; \n    //     ^? (parameter) shape: Square \n  }\n}\nHere the kind  property acts as the “tag,” and we say that the Shape  type is  a\n“tagged union.” It’ s also sometimes called a “discriminated union,” in\nwhich case kind  is the “discriminant.” The terms are interchangeable.\nBecause they make it so easy to recover type information at runtime,\ntagged/discriminated unions are ubiquitous in T ypeScript.\nSome constructs introduce both a type (which is not available at runtime)\nand a value (which is). The class  keyword  is one of these. Making Square\nand Rectangle  classes would be another way to fix the error:\nclass Square { \n  width: number; \n  constructor(width: number) { \n    this.width = width; \n;\n  }\n}\nclass Rectangle extends Square { \n  height: number; \n  constructor(width: number, height: number) { \n    super(width); \n    this.height = height; \n  }\n}\ntype Shape = Square | Rectangle; \n \nfunction calculateArea(shape: Shape) { \n  if (shape instanceof Rectangle) { \n    return shape.width * shape.height; \n    //     ^? (parameter) shape: Rectangle \n  } else { \n    return shape.width * shape.width; \n    //     ^? (parameter) shape: Square \n  }\n}\nThis works because class Rectangle  introduces both a type and  a value,\nwhereas interface  only introduced a type.\nThe Rectangle  in type Shape = Square | Rectangle  refers to the type ,\nbut the Rectangle  in shape instanceof Rectangle  refers to the value , in\nthis case the constructor function. This distinction is important to\nunderstand but can be quite subtle. Item 8  shows you how to tell which is\nwhich.\nCode with T ype Errors Can Produce Output\nBecause  code output is independent of type checking, it follows that code\nwith type errors can produce output!\n$ cat test.ts \nlet x = 'hello'; \nx = 1234; \n$ tsc test.ts \ntest.ts:2:1 - error TS2322: Type '1234' is not assignable to type 'string' \n \n2 x = 1234; \n  ~ \n \n$ cat test.js \nvar x = 'hello'; \nx = 1234;\nThis can be quite surprising if you’re coming from a language like C or\nJava where type checking and output go hand in hand. Y ou can think of all\nT ypeScript errors as being similar to warnings in those languages: it’ s likely\nthat they indicate a problem and are worth investigating, but they won’ t\nstop the build.\nC O M P I L I N G  A N D  T Y P E  C H E C K I N G\nThis is likely the source of some sloppy language that is common\naround T ypeScript. Y ou’ll often hear people say that their T ypeScript\n“doesn’ t compile” as a way of saying that it has errors. But this isn’ t\ntechnically correct! Only the code generation is “compiling.” So long as\nyour T ypeScript is valid JavaScript (and often even if it isn’ t), the\nT ypeScript compiler will produce output. At the risk of sounding\npedantic, it’ s better to say that your code has errors, or that it “doesn’ t\ntype check.”\nCode emission in the presence of errors is helpful in practice. If you’re\nbuilding a web application, you may know that there are problems with a\nparticular part of it. But because T ypeScript will still generate code in the\npresence of errors, you can test the other parts of your application before\nyou fix them.\nY ou should aim for zero errors when you commit code, lest you fall into the\ntrap of having to remember what is an expected or unexpected error . If you\nwant to disable output on errors, you can use the noEmitOnError  option in\ntsconfig.json , or the equivalent in your build tool.\nT ype Operations Cannot Affect Runtime V alues\nSuppose you have a value that could be a string or a number and you’d like\nto normalize it so that it’ s always a number . Here’ s a misguided attempt that\nthe type checker accepts:\nfunction asNumber(val: number | string): number { \n  return val as number;\n}\nLooking at the generated JavaScript makes it clear what this function really\ndoes:\nfunction asNumber(val) { \n  return val;\n}\nThere is no conversion going on whatsoever . The as number  is a type\noperation, so it cannot af fect the runtime behavior of your code. T o\nnormalize the value you’ll need to check its runtime type and do the\nconversion using JavaScript constructs:\nfunction asNumber(val: number | string): number { \n  return Number(val);\n}\n“as number ” is a type assertion , sometimes  inaccurately called a “cast.”\nFor more on when it’ s appropriate to use type assertions, see Item 9 .\nRuntime T ypes May Not Be the Same as Declared T ypes\nCould this  function ever hit the final console.log ?\nfunction setLightSwitch(value: boolean) { \n  switch (value) { \n    case true: \n      turnLightOn(); \n      break; \n    case false: \n      turnLightOff(); \n      break; \n    default: \n      console.log(`I'm afraid I can't do that.`); \n  }\n}\nT ypeScript usually flags dead code, but it does not complain about this,\neven with the strict  option. How could you hit this branch?\nThe key is to remember that boolean  is the declar ed  type. Because it is a\nT ypeScript type, it goes away at runtime. In JavaScript code, a user might\ninadvertently call setLightSwitch  with a value like ""ON"" .\nThere are ways to trigger this code path in pure T ypeScript, too. Perhaps the\nfunction is called with a value that comes from a network call:\ninterface LightApiResponse { \n  lightSwitchValue: boolean;\n}\nasync function setLight() { \n  const response = await fetch('/light'); \n  const result: LightApiResponse = await response.json(); \n  setLightSwitch(result.lightSwitchValue);\n}\nY ou’ve declared that the result of the /light  request is\nLightApiResponse , but nothing enforces this. If you misunderstood the\nAPI and lightSwitchValue  is really a string , then a string will be passed\nto setLightSwitch  at runtime. Or perhaps the API changed after you\ndeployed.\nT ypeScript can get quite confusing when your runtime types don’ t match\nthe declared types, and you should avoid these so-called “unsound” types\nwhenever you can. But be aware that it’ s possible for a value to have a\nruntime type other than the one you’ve declared. For  more on soundness,\nsee Item 48 .\nY ou Cannot Overload a Function Based on T ypeScript\nT ypes\nLanguages like C++ allow you to define multiple versions of a function that\ndif fer only in the types of their parameters. This is called “function\noverloading.” Because the runtime behavior of your code is independent of\nits T ypeScript types, this construct isn’ t possible in T ypeScript:\nfunction add(a: number, b: number) { return a + b; }\n//       ~~~ Duplicate function implementation\nfunction add(a: string, b: string) { return a + b; }\n//       ~~~ Duplicate function implementation\nT ypeScript does  provide a facility for overloading functions, but it operates\nentirely at the type level. Y ou can provide multiple type signatures for a\nfunction, but only a single implementation:\nfunction add(a: number, b: number): number;\nfunction add(a: string, b: string): string; \n \nfunction add(a: any, b: any) { \n  return a + b;\n} \n \nconst three = add(1, 2);\n//    ^? const three: number\nconst twelve = add('1', '2');\n//    ^? const twelve: string\nThe first two signatures of add  only provide type information. When\nT ypeScript produces JavaScript output, they are removed, and only the\nimplementation remains. The any  parameters in the implementation aren’ t\ngreat. W e’ll explore how to handle those in Item 52 , which also covers\nsome subtleties to be aware of with T ypeScript function overloads.\nT ypeScript T ypes Have No Effect on Runtime\nPerformance\nBecause types and type operations are erased when you generate JavaScript,\nthey cannot have an ef fect on runtime performance. T ypeScript’ s static\ntypes are truly zero cost. The next time someone of fers runtime overhead as\na reason to not use T ypeScript, you’ll know exactly how well they’ve tested\nthis claim!\nThere are two caveats to this:\nWhile there is no runtime  overhead, the T ypeScript compiler will\nintroduce build time  overhead. The T ypeScript team takes compiler\nperformance seriously and compilation is usually quite fast, especially\nfor incremental builds. If the overhead becomes significant, your build\ntool may have a “transpile only” option to skip the type checking.\nThere will be more to say about compiler performance in Item 78 .\nThe code that T ypeScript emits to support older runtimes may  incur a\nperformance overhead versus native implementations. For example, if\nyou use generator functions and tar get ES5, which predates generators,\nthen tsc  will emit some helper code to make things work. This will\nincur some overhead versus a native implementation of generators.\nThis is the case for any JavaScript “transpiler ,” not just T ypeScript.\nRegardless, this has to do with the emit tar get and language levels and\nis still independent of the types .\nThings to Remember\nCode generation is independent of the type system. This means that\nT ypeScript types cannot af fect the runtime behavior of your code.\nIt is possible for a program with type errors to produce code\n(“compile”).\nT ypeScript types are not available at runtime. T o query a type at\nruntime, you need some way to reconstruct it. T agged unions and\nproperty checking are common ways to do this.\nSome constructs, such as class , introduce both a T ypeScript type and\na value that is available at runtime.",12835
11-Item 4 Get Comfortable with Structural Typing.pdf,11-Item 4 Get Comfortable with Structural Typing,"Because they are erased as part of compilation, T ypeScript types\ncannot af fect the runtime performance of your code.\nI t e m  4 :  G e t  C o m f o r t a b l e  w i t h  S t r u c t u r a l\nT y p i n g\nJavaScript encourages “duck typing”: if you pass a function a value with all\nthe right properties, it won’ t care how you made the value. It will just use it.\n(This term refers to the saying, “If it walks like a duck and talks like a duck,\nthen it probably is a duck.”)\nT ypeScript models this behavior using what’ s known as a structural type\nsystem. This can sometimes lead to surprising results because the type\nchecker ’ s understanding of a type may be broader than what you had in\nmind. Having a good grasp of structural typing will help you make sense of\nerrors and non-errors and help you write more robust code.\nSay you’re working on a physics library and have a 2D vector type:\ninterface Vector2D { \n  x: number; \n  y: number;\n}\nY ou write a function to calculate its length:\nfunction calculateLength(v: Vector2D) { \n  return Math.sqrt(v.x ** 2 + v.y ** 2);\n}\nNow you introduce the notion of a named vector:\ninterface NamedVector { \n  name: string; \n  x: number; \n  y: number;\n}\nThe calculateLength  function will work with NamedVector s because\nthey have x  and y  properties that are number s. T ypeScript is smart enough\nto figure this out:\nconst v: NamedVector = { x: 3, y: 4, name: 'Pythagoras' };\ncalculateLength(v);  // OK, result is 5\nWhat’ s interesting is that you never declared the relationship between\nVector2D  and NamedVector . And you didn’ t have to write an alternative\nimplementation of calculateLength  for NamedVector s. T ypeScript’ s type\nsystem is modeling JavaScript’ s runtime behavior ( Item 1 ). It allowed\ncalculateLength  to be called with a NamedVector  because its structur e\nwas compatible with Vector2D . This is where the term “structural typing”\ncomes from.\nBut this can also lead to trouble. Say you add a 3D vector type:\ninterface Vector3D { \n  x: number; \n  y: number; \n  z: number;\n}\nand write a function to normalize them (make their length 1):\nfunction normalize(v: Vector3D) { \n  const length = calculateLength(v); \n  return { \n    x: v.x / length, \n    y: v.y / length, \n    z: v.z / length, \n  };\n}\nIf you call this function, you’re likely to get a vector with a length greater\nthan 1:\n> normalize({x: 3, y: 4, z: 5}) \n{ x: 0.6, y: 0.8, z: 1 }\nThis vector has a length of around 1.4, not 1. So what went wrong, and why\ndidn’ t T ypeScript catch the error?\nThe bug is that calculateLength  operates on 2D vectors, but normalize\noperates on 3D vectors. So the z  component is ignored in the normalization.\nWhat’ s perhaps more surprising is that the type checker does not catch this\nissue. Why are you allowed to call calculateLength  with a 3D vector ,\ndespite its type declaration saying that it takes 2D vectors?\nWhat worked so well with named vectors has backfired here. Calling\ncalculateLength  with an {x, y, z}  object doesn’ t throw an error . So the\ntype checker doesn’ t complain either , and this behavior has led to a bug.\n(If you want this to be an error , you have some options. Item 63  presents a\ntrick to specifically prohibit the z  property , and Item 64  shows how you can\nuse “brands” to prevent this sort of structural typing altogether .)\nAs you write functions, it’ s easy to imagine that they will be called with\nar guments having the properties you’ve declared and no others . This is\nknown as  a “closed,” “sealed,” or “precise” type, and it cannot be expressed\nin T ypeScript’ s type system. Like it or not, your types are “open.”\nThis can sometimes lead to surprises:\nfunction calculateLengthL1(v: Vector3D) { \n  let length = 0; \n  for (const axis of Object.keys(v)) { \n    const coord = v[axis]; \n    //            ~~~~~~~ Element implicitly has an 'any' type because ... \n    //                    'string' can't be used to index type 'Vector3D' \n    length += Math.abs(coord); \n  } \n  return length;\n}\nWhy is this an error? Since axis  is one of the keys of v , which is a\nVector3D , it should be either ""x"" , ""y"" , or ""z"" . And according to the\ndeclaration of Vector3D , these are all number s, so shouldn’ t the type of\ncoord  be number ?\nIs this error a false positive? No! T ypeScript is correct to complain. The\nlogic in the previous paragraph assumes that Vector3D  is sealed and does\nnot have other properties. But it could:\nconst vec3D = {x: 3, y: 4, z: 1, address: '123 Broadway'};\ncalculateLengthL1(vec3D);  // OK, returns NaN\nSince v  could conceivably have any properties, the type of axis  is string .\nT ypeScript has no reason to believe that v[axis]  is a number because, as\nyou just saw , it might not be. (The vec3D  variable here avoids excess\nproperty checking, which is the subject of Item 1 1 .)\nIterating over objects can be tricky to type correctly . W e’ll return to this\ntopic in Item 60 , but in this case an implementation without loops would be\nbetter:\nfunction calculateLengthL1(v: Vector3D) { \n  return Math.abs(v.x) + Math.abs(v.y) + Math.abs(v.z);\n}\nStructural typing can also lead to surprises with class es, which are\ncompared structurally for assignability:\nclass SmallNumContainer { \n  num: number; \n  constructor(num: number) { \n    if (num < 0 || num >= 10) { \n      throw new Error(`You gave me ${num} but I want something 0-9.`) \n    } \n    this.num = num; \n  }\n} \n \nconst a = new SmallNumContainer(5);\nconst b: SmallNumContainer = { num: 2024 };  // OK!\nWhy is b  assignable to SmallNumContainer ? It has a num  property that’ s a\nnumber . So the structures match. This might lead to trouble if you write a\nfunction that assumes the validation logic in SmallNumContainer ’ s\nconstructor has run. This is less likely to happen by chance for classes with\nmore properties and methods, but it is quite dif ferent than languages like\nC++ or Java, where declaring a parameter of type SmallNumContainer\nguarantees that it will be either SmallNumContainer  or a subclass of it, and\nhence that the validation logic in the constructor will have run.\nStructural typing is beneficial when you’re writing tests. Say you have a\nfunction that runs a query on a database and processes the results:\ninterface Author { \n  first: string; \n  last: string;\n}\nfunction getAuthors(database: PostgresDB): Author[] { \n  const authorRows = database.runQuery(`SELECT first, last FROM authors`); \n  return authorRows.map(row => ({first: row[0], last: row[1]}));\n}\nT o test this, you could create a mock PostgresDB . But a simpler approach\nis to use structural typing and define a narrower interface:\ninterface DB { \n  runQuery: (sql: string) => any[];\n}\nfunction getAuthors(database: DB): Author[] { \n  const authorRows = database.runQuery(`SELECT first, last FROM authors`); \n  return authorRows.map(row => ({first: row[0], last: row[1]}));\n}\nY ou can still pass getAuthors  a PostgresDB  in production since it has a\nrunQuery  method. Because of structural typing, the PostgresDB  doesn’ t\nneed to say that it implements DB . T ypeScript will figure out that it does.\nWhen you write your tests, you can pass in a simpler object instead:\ntest('getAuthors', () => { \n  const authors = getAuthors({ \n    runQuery(sql: string) { \n      return [['Toni', 'Morrison'], ['Maya', 'Angelou']]; \n    } \n  });",7457
12-Item 5 Limit Use of the any Type.pdf,12-Item 5 Limit Use of the any Type,"expect(authors).toEqual([ \n    {first: 'Toni', last: 'Morrison'}, \n    {first: 'Maya', last: 'Angelou'} \n  ]);\n});\nT ypeScript will verify that our test DB  conforms to the interface. And your\ntests don’ t need to know anything about your production database: no\nmocking libraries necessary! By introducing an abstraction ( DB ), we’ve\nfreed our logic (and tests) from the details of a specific implementation\n(PostgresDB ).\nAnother advantage of structural typing is that it can cleanly sever\ndependencies between libraries. For more on this, see Item 70 .\nThings to Remember\nUnderstand that JavaScript is duck typed and T ypeScript uses\nstructural typing to model this: values assignable to your interfaces\nmight have properties beyond those explicitly listed in your type\ndeclarations. T ypes are not “sealed.”\nBe aware that classes also follow structural typing rules. Y ou may not\nhave an instance of the class you expect!\nUse structural typing to facilitate  unit testing.\nI t e m  5 :  L i m i t  U s e  o f  t h e  a n y  T y p e\nT ypeScript’ s type system is gradual  and optional : gradual  because you can\nadd types to your code bit by bit (with noImplicitAny ), and optional\nbecause you can disable the type checker whenever you like. The key to\nthese features is the any  type:\nlet ageInYears: number;\nageInYears = '12';\n// ~~~~~~~ Type 'string' is not assignable to type 'number'.\nageInYears = '12' as any;  // OK\nThe type checker is right to complain here, but you can silence it by typing\nas any . As you start using T ypeScript, it’ s tempting to use any  types and\ntype assertions ( as any ) when you don’ t understand an error , think the type\nchecker is incorrect, or just don’ t want to take the time to write out type\ndeclarations.\nIn some cases this may be OK, but be aware that using any  eliminates many\nof the advantages of using T ypeScript. Y ou should at least understand its\ndangers before you use it.\nThere’ s No T ype Safety with any T ypes\nIn the preceding example, the type declaration says that ageInYears  is a\nnumber . But any  lets you assign a string  to it. The type checker will\nbelieve that it’ s a number  (that’ s what you said, after all), and the chaos will\ngo uncaught:\nageInYears += 1;  // OK; at runtime, ageInYears is now ""121""\nany Lets Y ou Break Contracts\nWhen you write a function, you are specifying a contract: if the caller gives\nyou a certain type of input, you’ll produce a certain type of output. But with\nan any  type, you can break these contracts:\nfunction calculateAge(birthDate: Date): number { \n  // ...\n} \n \nlet birthDate: any = '1990-01-19';\ncalculateAge(birthDate);  // OK\nThe birth date parameter should be a Date , not a string . The any  type has\nlet you break the contract of calculateAge . This can be particularly\nproblematic because JavaScript is often willing to implicitly convert\nbetween types. A string  will sometimes work where a number  is expected,\nonly to break in other circumstances.\nThere Are No Language Services for any T ypes\nWhen a variable has a non- any  type, the T ypeScript language services are\nable to provide  intelligent autocomplete and contextual documentation (as\nshown in Figure 1-3 ).\nFigur e 1-3. The T ypeScript Language Service is able to pr ovide contextual autocomplete for symbols\nwith types.\nBut for symbols with an any  type, you’re on your own ( Figure 1-4 ).\nFigur e 1-4. Ther e is no autocomplete for pr operties on symbols with any  types.\nRenaming is another such service. If you have a Person  type and functions\nto format a person’ s name:\ninterface Person { \n  first: string; \n  last: string;\n} \n \nconst formatName = (p: Person) => `${p.first} ${p.last}`;\nconst formatNameAny = (p: any) => `${p.first} ${p.last}`;\nthen you can select first  in your editor , choose “Rename Symbol,” and\nchange it to firstName  (see Figures 1-5  and 1-6 ).\nFigur e 1-5. Renaming a symbol in VS Code.\nFigur e 1-6. Choosing the new name.\nThis changes the formatName  function but not the any  version:\ninterface Person { \n  firstName: string; \n  last: string;\n}\nconst formatName = (p: Person) => `${p.firstName} ${p.last}`;\nconst formatNameAny = (p: any) => `${p.first} ${p.last}`;\nOne of T ypeScript’ s tag lines is “JavaScript that scales.” A key part of\n“scales” is the language services, which are an essential part of the\nT ypeScript experience (see Item 6 ). Losing them will lead to a loss in\nproductivity , not just for you but for everyone else working with your code.\nany T ypes Mask Bugs When Y ou Refactor Code\nSuppose you’re building a web application in which users can select some\nsort of item. One of your components might have an onSelectItem\ncallback. W riting a type for an item seems like a hassle, so you just use any\nas a stand-in:\ninterface ComponentProps { \n  onSelectItem: (item: any) => void;\n}\nHere’ s code that manages that component:\nfunction renderSelector(props: ComponentProps) { /* ... */ } \n \nlet selectedId: number = 0;\nfunction handleSelectItem(item: any) { \n  selectedId = item.id;\n} \n \nrenderSelector({onSelectItem: handleSelectItem});\nLater you rework the selector in a way that makes it harder to pass the\nwhole item  object through to onSelectItem . But that’ s no big deal since\nyou just need the ID. Y ou change the signature in ComponentProps :\ninterface ComponentProps { \n  onSelectItem: (id: number) => void;\n}\nY ou update the component and everything passes the type checker . V ictory!\n… or is it? handleSelectItem  takes an any  parameter , so it’ s just as happy\nwith an item as it is with an ID. It produces a runtime exception, despite\npassing the type checker . Had you used a more specific type, this would\nhave been caught by the type checker .\nany Hides Y our T ype Design\nThe type definition for complex objects, like your application state, can get\nquite long. Rather than writing out types for the dozens of properties in\nyour app’ s state, you may be tempted to just use an any  type and be done\nwith it.\nThis is problematic for all the reasons listed in this item. But it’ s also\nproblematic because it hides the design of your state. As Chapter 4\nexplains, good type design is essential for writing clean, correct, and\nunderstandable code. W ith an any  type, your type design is implicit. This\nmakes it hard to know whether the design is a good one, or even what the\ndesign is at all. If you ask a coworker to review a change, they’ll have to\nreconstruct whether and how you changed the application state. Better to\nwrite it out for everyone to see.\nany Undermines Confidence in the T ype System\nEvery time you make a mistake and the type checker catches it, it boosts\nyour confidence in the type system. But when you see a type error at\nruntime that T ypeScript didn’ t catch, that confidence takes a hit. If you’re\nintroducing T ypeScript on a lar ger team, this might make your coworkers\nquestion whether T ypeScript is worth the ef fort. any  types are often the\nsource of these uncaught errors.\nT ypeScript aims to make your life easier , but T ypeScript with lots of any\ntypes can be harder to work with than untyped JavaScript because you have\nto fix type errors and  still keep track of the real types in your head. When\nyour types match reality , it frees you from the burden of having to keep type\ninformation in your head. T ypeScript will keep track of it for you.\nFor the times when you must use any , there are better and worse ways to do\nit. For much more on how to limit the downsides of any , see Chapter 5 .\nThings to Remember\nT ypeScript’ s any  type allows you to disable most forms of type\nchecking for a symbol.\nThe any  type eliminates type safety , lets you break contracts, harms\ndeveloper experience, makes refactoring error prone, hides your type\ndesign, and undermines confidence in the type system.\nA void using any  when  you can!\n1 Y ou may run across .tsx , .jsx , .mts , .mjs , and a few other extensions. These are all T ypeScript\nand JavaScript files.\n2 The best way to build an intuition for this is by using the T ypeScript playground , which\nshows your T ypeScript and the resulting JavaScript side by side.",8263
13-2. TypeScripts Type System.pdf,13-2. TypeScripts Type System,,0
14-Item 6 Use Your Editor to Interrogate and Explore the Type System.pdf,14-Item 6 Use Your Editor to Interrogate and Explore the Type System,"Chapter 2. T ypeScript’ s T ype\nSystem\nT ypeScript can generate JavaScript ( Item 3 ), but the type system is the main\nevent. This is why you’re using the language!\nThis chapter walks you through the nuts and bolts of T ypeScript’ s type\nsystem: how to think about it, how to use it, choices you’ll need to make,\nand features you should avoid. T ypeScript’ s type system is surprisingly\npowerful and able to express things you might not expect a type system to\nbe able to. The items in this chapter will give you a solid foundation to\nbuild upon as you write T ypeScript and read the rest of this book.\nI t e m  6 :  U s e  Y o u r  E d i t o r  t o  I n t e r r o g a t e  a n d\nE x p l o r e  t h e  T y p e  S y s t e m\nWhen you install T ypeScript, you get two executables:\ntsc , the T ypeScript compiler\ntsserver , the T ypeScript standalone server\nY ou’re  much more likely to run the T ypeScript compiler directly , but the\nserver is every bit as important because it provides language services .\nThese include autocomplete, inspection, navigation, and refactoring. Y ou\ntypically use these services through your editor . If yours isn’ t configured to\nprovide them, then you’re missing out! Services like autocomplete are one\nof the things that make T ypeScript such a joy to use. But beyond\nconvenience, your editor is the best place to build and test your knowledge\nof the type system. This will help you build an intuition for when\nT ypeScript is able  to infer types, which is key to writing compact, idiomatic\ncode (see Item 18 ).\nThe details will vary from editor to editor , but you can generally hover over\na symbol to see what T ypeScript considers its type (see Figure 2-1 ).\nFigur e 2-1. An editor (VS Code) showing that the inferr ed type of the num  symbol is number .\nY ou didn’ t write number  here, but T ypeScript was able to figure it out based\non the value 10.\nY ou can also inspect functions, as shown in Figure 2-2 .\nFigur e 2-2. Using an editor to r eveal the inferr ed r eturn type for a function.\nThe noteworthy bit of information is the inferred value for the return type,\nnumber . If this does not match your expectation, you should add a type\ndeclaration and track down the discrepancy (see Item 9 ).\nSeeing what T ypeScript thinks a variable’ s type is at any given point is\nessential for building an intuition around widening ( Item 20 ) and narrowing\n( Item 22 ). W atching the type of a variable change in the branch of a\nconditional is a tremendous way to build confidence in the type system (see\nFigure 2-3 ).\nFigur e 2-3. The type of message is string | null  outside the branch, but string  inside.\nY ou can inspect individual properties in a lar ger object to see what\nT ypeScript has inferred about them (see Figure 2-4 ).\nFigur e 2-4. Inspecting how T ypeScript has inferr ed types in an object.\nIf your intention was for x  to be a tuple type ( [number, number] ), then a\ntype annotation will be required.\nT o see inferred generic types in the middle of a chain of operations, inspect\nthe  method name (as shown in Figure 2-5 ).\nFigur e 2-5. Revealing inferr ed generic types in a chain of method calls.\nThe Array<string>  indicates that T ypeScript understands that split\nproduced an array of strings. While there was little ambiguity in this case,\nthis information can prove essential in writing and debugging long chains of\nfunction calls. T ypeScript has also brought up some helpful documentation\nfor the slice  method. Item 68  will explain how this works.\nSeeing type errors  in your editor can also be a great way to learn the\nnuances of the type system. For example, this function tries to get an\nHTMLElement  by its ID, or return a default one. T ypeScript flags two errors:\nfunction getElement(elOrId: string | HTMLElement | null): HTMLElement { \n  if (typeof elOrId === 'object') { \n    return elOrId; \n    // ~~~ Type 'HTMLElement | null' is not assignable to type 'HTMLElement' \n  } else if (elOrId === null) { \n    return document.body; \n  } \n  elOrId \n  // ^? (parameter) elOrId: string \n  return document.getElementById(elOrId); \n  // ~~~ Type 'HTMLElement | null' is not assignable to type 'HTMLElement'\n}\nThe intent in the first branch of the if  statement was to filter down to just\nthe objects, namely , the HTMLElement s. But oddly enough, in JavaScript\ntypeof null  is ""object"" , so elOrId  could still be null  in that branch.\nY ou can fix this by putting the null  check first. The second error is because\ndocument.getElementById  can return null , so you need to handle that\ncase as well, perhaps by throwing an exception:\nfunction getElement(elOrId: string|HTMLElement|null): HTMLElement { \n  if (elOrId === null) { \n    return document.body; \n  } else if (typeof elOrId === 'object') { \n    return elOrId; \n    //     ^? (parameter) elOrId: HTMLElement \n  } \n  const el = document.getElementById(elOrId); \n  //                                 ^? (parameter) elOrId: string \n  if (!el) { \n    throw new Error(`No such element ${elOrId}`); \n  } \n  return el; \n  //     ^? const el: HTMLElement\n}\nThe T ypeScript language service also provides refactoring tools. One of the\nsimplest but most useful of these is renaming a symbol. This is more\ncomplicated than find and replace because the same name might refer to\ndif ferent variables in dif ferent places. In this code, for example, there are\nthree distinct variables all named i :\nlet i = 0;\nfor (let i = 0; i < 10; i++) { \n  console.log(i); \n  { \n    let i = 12; \n    console.log(i); \n  }\n}\nconsole.log(i);\nIn VS Code, if you click an i  in the for  loop and hit F2, a text box will pop\nup that lets you put in a new name ( Figure 2-6 ).\nFigur e 2-6. Renaming a symbol in your editor .\nWhen you apply the refactor , only the references to the i  that you renamed\nwill change:\nlet i = 0;\nfor (let x = 0; x < 10; x++) { \n  console.log(x); \n  { \n    let i = 12; \n    console.log(i); \n  }\n}\nconsole.log(i);\nIf you rename a symbol that’ s imported from another module, those imports\nwill also update. There are many other useful refactors available, such as\nrenaming or moving a file (which updates all imports) and moving a\nsymbol into a new file. Y ou should familiarize yourself with these because\nthey can significantly increase your productivity while working with lar ge\nT ypeScript projects.\nLanguage services  can also help you navigate through both your own code\nas well as external libraries and type declarations. Suppose you see a call to\nthe global fetch  function in code and want to learn more about it. Y our\neditor should provide a “Go to Definition” option. In mine it looks like\nFigure 2-7 .\nFigur e 2-7. The T ypeScript language service pr ovides a “Go to Definition” featur e that should be\navailable in your editor .\nSelecting this option takes you into lib.dom.d.ts , the type declarations that\nT ypeScript includes for the DOM:\ndeclare function fetch( \n  input: RequestInfo | URL, init?: RequestInit\n): Promise<Response>;\nY ou can see that fetch  returns a Promise  and takes two ar guments.\nClicking through on RequestInfo  brings you here:\ntype RequestInfo = Request | string;\nfrom which you can go to Request :\ninterface Request extends Body { \n  // ...\n}\ndeclare var Request: { \n  prototype: Request; \n  new(input: RequestInfo | URL, init?: RequestInit | undefined): Request;\n};\nHere you can see that the Request  type and value are being modeled\nseparately (see Item 8 ). Y ou’ve seen RequestInfo  already . Clicking\nthrough on RequestInit  shows all the options you can use in constructing\na Request :",7700
15-Item 7 Think of Types as Sets of Values.pdf,15-Item 7 Think of Types as Sets of Values,"interface RequestInit { \n  body?: BodyInit | null; \n  cache?: RequestCache; \n  credentials?: RequestCredentials; \n  headers?: HeadersInit; \n  // ...\n}\nThere are many more types you could follow here, but you get the idea.\nT ype declarations can be challenging to read at first, but they’re an\nexcellent way to see what can be done with T ypeScript, how the library\nyou’re using is modeled, and how you might debug errors. For much more\non type declarations, see Chapter 8 .\nThings to Remember\nT ake advantage of the T ypeScript language services by using an editor\nthat supports them.\nUse your editor to build an intuition for how the type system works\nand how T ypeScript infers types.\nFamiliarize yourself with T ypeScript’ s refactoring tools, e.g., renaming\nsymbols and files.\nKnow how to jump into type declaration files to see how they model\nbehavior .\nI t e m  7 :  T h i n k  o f  T y p e s  a s  S e t s  o f  V a l u e s\nAt runtime, every variable has a single value chosen from JavaScript’ s\nuniverse of values. There are many possible values, including:\n42\nnull\nundefined\n'Canada'\n{animal: 'Whale', weight_lbs: 40_000}\n/regex/\nnew HTMLButtonElement\n(x, y) => x + y\nBut before your code runs, when T ypeScript is checking it for errors, a\nvariable just has a type . This is best thought of as a set of possible values .\nThis set is known as the domain  of the type. For instance, you can think of\nthe number  type as the set of all number values. 42  and -37.25  are in it, but\n'Canada'  is not. Depending on strictNullChecks , null  and undefined\nmay or may not be part of the set.\nN O T E\nY ou won’ t often see the term “domain” in T ypeScript documentation or literature, or\neven elsewhere in this book. T ypes are spoken of interchangeably with their sets of\nvalues. But in this item, it will be helpful to have a term to refer specifically to the set of\nvalues for a type, as opposed to the type itself.\nThe smallest set is the empty set, which contains no values. It corresponds\nto the never  type in T ypeScript. Because its domain is empty , no values are\nassignable to a variable with a never  type:\nconst x: never = 12;\n//    ~ Type 'number' is not assignable to type 'never'.\nBecause it sits at the bottom of the type hierarchy , never  is sometimes\ncalled  a “bottom type.”\nThe next  smallest sets are those that contain single values. These\ncorrespond to literal types in T ypeScript. (In other languages these are\nsometimes called “unit types.”)\ntype A = 'A';\ntype B = 'B';\ntype Twelve = 12;\nT o form  types with two or three values, you can union literal types:\ntype AB = 'A' | 'B';\ntype AB12 = 'A' | 'B' | 12;\nThe domain of a union type is the union of the domains of its constituent\ntypes, as shown in Figure 2-8 . This is what the “union” in “union type”\nrefers to.\nFigur e 2-8. V alues and types as sets of values. The boxes ar e values ( ""A"" , ""B"" , 12 ) and the r ounded\nshapes ar e types (A , B , AB , AB12 , Twelve ), which include a set of values. One type is assignable to\nanother if it’ s entir ely contained within it.\nThe word  “assignable” appears in many T ypeScript errors. In the context of\nsets of values, it means either “member of” (for a relationship between a\nvalue and a type) or “subset of” (for a relationship between two types):\nconst a: AB = 'A';  // OK, value 'A' is a member of the set {'A', 'B'}\nconst c: AB = 'C';\n//    ~ Type '""C""' is not assignable to type 'AB'\nThe type ""C""  is a literal type. Its domain consists of the single value ""C"" .\nThis is not a subset of the domain of AB  (which consists of the values ""A""\nand ""B"" ), so this is an error . At the end of the day , much of what the type\nchecker is doing is testing whether one set is a subset of another:\n// OK, {""A"", ""B""} is a subset of {""A"", ""B""}:\nconst ab: AB = Math.random() < 0.5 ? 'A' : 'B';\nconst ab12: AB12 = ab;  // OK, {""A"", ""B""} is a subset of {""A"", ""B"", 12} \n \ndeclare let twelve: AB12;\nconst back: AB = twelve;\n//    ~~~~ Type 'AB12' is not assignable to type 'AB'\n//           Type '12' is not assignable to type 'AB'\nThe sets for these types are straightforward to reason about because they are\nfinite. Y ou can compare the elements one by one. But most types that you\nwork with in practice have  infinite domains. Reasoning about these can be\nharder . Y ou can think of them as either being built by listing out their\nelements:\ntype Int = 1 | 2 | 3 | 4 | 5 // | ...\nor by describing their members:\ninterface Identified { \n  id: string;\n}\nThink of this interface as a description of the values in the domain of its\ntype. Is the value an object? Does it have an id  property whose value is\nassignable to string ? Then it’ s an Identified .\nThat’ s all  it says. As Item 4  explained, T ypeScript’ s structural typing rules\nmean that the value could have other properties, too. It could even be\ncallable! This fact can sometimes be obscured by excess property checking\n(see Item 1 1 ).\nThinking of types as sets of values helps you reason about operations on\nthem. For example:\ninterface Person { \n  name: string;\n}\ninterface Lifespan { \n  birth: Date; \n  death?: Date;\n}\ntype PersonSpan = Person & Lifespan;\nThe &  operator computes the intersection of two types. What sorts of values\nbelong to the PersonSpan  type? On first glance, the Person  and Lifespan\ninterfaces have no properties in common, so you might expect it to be the\nempty set (i.e., the never  type). But type operations apply to the sets of\nvalues (the domain of the type), not to the properties in the interface. And\nremember that values with additional properties still belong to a type. So a\nvalue that has the properties of both  Person  and  Lifespan  will belong to\nthe intersection type:\nconst ps: PersonSpan = { \n  name: 'Alan Turing', \n  birth: new Date('1912/06/23'), \n  death: new Date('1954/06/07'),\n};  // OK\nOf course, a value could have more than those three properties and still\nbelong to the type! The general rule is that the values in an intersection type\ncontain the union of properties in each of its constituents.\nThe intuition about intersecting properties is correct, but for the union  of\ntwo interfaces, rather than their intersection:\ntype K = keyof (Person | Lifespan);\n//   ^? type K = never\nThere are no keys that T ypeScript can be certain will be present on a value\nin the union type, so keyof  for the union must be the empty set ( never ). Or ,\nmore formally:\n// Disclaimer: these are relationships, not TypeScript code!\nkeyof (A&B) = (keyof A) | (keyof B)\nkeyof (A|B) = (keyof A) & (keyof B)\nIf you can build an intuition for why these equations hold, you’ll have come\na long way toward understanding T ypeScript’ s type system!\nA more idiomatic way to write the PersonSpan  type would be with\nextends :\ninterface Person { \n  name: string;\n}\ninterface PersonSpan extends Person { \n  birth: Date; \n  death?: Date;\n}\nThinking of types as sets of values, what does extends  mean? Just like\n“assignable to,” you can read it as “subset of.” Every value in PersonSpan\nmust have a name  property that is a string . And every value must also\nhave a birth  property , so it’ s a proper subset.\nWhile extends  is typically used to add fields to an interface , anything\nmatching a subset of the values of the base type will do. This lets you\nmodel more nuanced type relationships:\ninterface NullyStudent { \n  name: string; \n  ageYears: number | null;\n}\ninterface Student extends NullyStudent { \n  ageYears: number;\n}\nNot every language would let you change the type of ageYears  like this,\nbut so long as it’ s assignable to the type in the base type ( NullyStudent ),\nT ypeScript allows it. This makes sense when you think about the domains\nof these two interface s. If you try to expand the type of ageYears\ninstead, you’ll get an error:\ninterface StringyStudent extends NullyStudent { \n  //      ~~~~~~~~~~~~~~ \n  // Interface 'StringyStudent' incorrectly extends interface 'NullyStudent'. \n  ageYears: number | string;\n}\nY ou might hear the  term “subtype.” This is another way of saying that one\ntype’ s domain is a subset of the other ’ s. Thinking in terms of one-, two-,\nand three-dimensional vectors:\ninterface Vector1D { x: number; }\ninterface Vector2D extends Vector1D { y: number; }\ninterface Vector3D extends Vector2D { z: number; }\nY ou’d say that a Vector3D  is a subtype of Vector2D , which is a subtype of\nVector1D  (in the context of classes, you’d say “subclass”). This\nrelationship is usually drawn as a hierarchy , but thinking in terms of sets of\nvalues, a V enn diagram is more appropriate (see Figure 2-9 ).\nFigur e 2-9. T wo ways of thinking of type r elationships: as a hierar chy or as overlapping sets.\nW ith the V enn diagram, it’ s clear that the subset/subtype/assignability\nrelationships are unchanged if you rewrite the interfaces without extends :\ninterface Vector1D { x: number; }\ninterface Vector2D { x: number; y: number; }\ninterface Vector3D { x: number; y: number; z: number; }\nThe sets haven’ t changed, so neither has the V enn diagram.\nWhile both interpretations are workable for object types, the set\ninterpretation becomes much more intuitive when you start thinking about\nliteral types and union types.\nThe extends  keyword can also appear as a constraint in a generic type, and\nit also means “subset of” in this context ( Item 15 ):\nfunction getKey<K extends string>(val: any, key: K) { \n  // ...\n}\nWhat does it mean to extend string ? If you’re used to thinking in terms of\nobject inheritance, it’ s hard to interpret. Y ou could define a subclass of the\nobject wrapper type String  ( Item 10 ), but that seems inadvisable.\nThinking in terms of sets, on the other hand, it stands to reason that any\ntype whose domain is a subset of string  will do. This includes string literal\ntypes, unions of string literal types, template literal types ( Item 54 ), and\nstring  itself:\ngetKey({}, 'x');  // OK, 'x' extends string\ngetKey({}, Math.random() < 0.5 ? 'a' : 'b');  // OK, 'a'|'b' extends string\ngetKey({}, document.title);  // OK, string extends string\ngetKey({}, 12);\n//         ~~ Type 'number' is not assignable to parameter of type 'string'\n“extends” has turned into “assignable” in the last error , but this shouldn’ t\ntrip us up since we know to read both as “subset of.”\nThe set interpretation also makes more sense when you have types whose\nrelationship isn’ t strictly hierarchical. What’ s the relationship between\nstring|number  and string|Date , for instance? Their intersection is non-\nempty (it’ s string ), but neither is a subtype of the other . The relationship\nbetween their domains is clear , even though these types don’ t fit into a strict\nhierarchy (see Figure 2-10 ).\nFigur e 2-10. Union types may not fit into a hierar chy but can be thought of in terms of sets of values.\nThinking of types as sets can also clarify the relationships between arrays\nand  tuples. For example:\nconst list = [1, 2];\n//    ^? const list: number[]\nconst tuple: [number, number] = list;\n//    ~~~~~ Type 'number[]' is not assignable to type '[number, number]'\n//          Target requires 2 element(s) but source may have fewer\nAre there lists of numbers that are not pairs of numbers? Sure! The empty\nlist and the list [1]  are examples. It therefore makes sense that number[]  is\nnot assignable to [number, number]  since it’ s not a subset of it. (The\nreverse assignment does work.)\nIs a triple assignable to a pair? Thinking in terms of structural typing, you\nmight expect it to be. A pair has 0  and 1  keys, so mightn’ t it have others,\ntoo, like 2 ?\nconst triple: [number, number, number] = [1, 2, 3];\nconst double: [number, number] = triple;\n//    ~~~~~~ '[number, number, number]' is not assignable to '[number, \nnumber]'\n//           Source has 3 element(s) but target allows only 2.\nThe answer is “no,” and for an interesting reason. Rather than modeling a\npair of numbers as {0: number, 1: number} , T ypeScript models it as {0:\nnumber, 1: number, length: 2} . This makes sense—you can check the\nlength of a tuple—and it precludes this assignment. And that’ s probably for\nthe best!\nT ypeScript is constantly testing for assignability which, as you’ve seen\nmany times now , is a subset/subtype relationship. Interestingly , T ypeScript\nrarely checks for type equality . This makes it challenging to write tests for\ntypes, which is the subject of Item 55 .\nIf types are best thought of as sets of values, that means that two types with\nthe same sets of values are the same. And indeed this is true (with one\ncaveat, explained below). Unless two types are semantically dif ferent and\njust happen to have the same domain, there’ s no reason to define the same\ntype twice.\nAt the extreme opposite end of the spectrum from never  (the empty type) is\nunknown . The domain of this type is all values in JavaScript. Every type is\nassignable to unknown . Since it sits on top of the type hierarchy , it’ s called a\n“top type.” Item 46  explains how to use the unknown  type in your own\ncode.\nFinally , it’ s worth noting that not all sets of values correspond to T ypeScript\ntypes. There is no T ypeScript type for all the integers, or for all the objects\nthat have x  and y  properties but no others. Y ou can sometimes subtract\ntypes using Exclude , but only when it would result in a proper T ypeScript\ntype:\ntype T = Exclude<string|Date, string|number>;\n//   ^? type T = Date\ntype NonZeroNums = Exclude<number, 0>;\n//   ^? type NonZeroNums = number\nT able 2-1  summarizes the correspondence between T ypeScript terms and\nterms from set theory .\nT able 2-1. T ypeScript terms and set terms\nT ypeScript term Set term\nnever ∅  (empty set)\nLiteral type Single element set\nV alue assignable to T V alue ∈  T (member of)\nT1 assignable to T2 T1 ⊆  T2 (subset of)\nT1 extends T2 T1 ⊆  T2 (subset of)\nT1 | T2 T1 ∪  T2 (union)\nT1 & T2 T1 ∩ T2 (intersection)\nunknown Universal set\nThere’ s an important caveat to this interpretation: it works best when you\nthink of values as  immutable. For example, what’ s the dif ference between\nthese two types?\ninterface Lockbox { \n  code: number;\n}\ninterface ReadonlyLockbox { \n  readonly code: number;\n}\nThe domain of these two types is precisely the same, but they’re observably\ndif ferent:",14482
16-Item 8 Know How to Tell Whether a Symbol Is in the Type Space or Value Space.pdf,16-Item 8 Know How to Tell Whether a Symbol Is in the Type Space or Value Space,"const box: Lockbox = { code: 4216 };\nconst robox: ReadonlyLockbox = { code: 3625 };\nbox.code = 1234;  // ok\nrobox.code = 1234;\n//    ~~~~ Cannot assign to 'code' because it is a read-only property.\nFor this reason, you’ll sometimes hear a variation on this item’ s title: “types\nare sets of values and the things you can do with them .” Item 14  has more to\nsay about readonly  but, as a general rule, the type checker is more\nef fective when you work with immutable values.\nThings to Remember\nThink of types as sets of values (the type’ s domain ). These sets can\neither be finite (e.g., boolean  or literal types) or infinite (e.g., number\nor string ).\nT ypeScript types form intersecting sets (a V enn diagram) rather than a\nstrict hierarchy . T wo types can overlap without either being a subtype\nof the other .\nRemember that an object can still belong to a type even if it has\nadditional properties that were not mentioned in the type declaration.\nT ype operations apply to a set’ s domain. The domain of A | B  is the\nunion of the domains of A  and B .\nThink of “extends,” “assignable to,” and “subtype of” as synonyms for\n“subset of.”\nI t e m  8 :  K n o w  H o w  t o  T e l l  W h e t h e r  a  S y m b o l\nI s  i n  t h e  T y p e  S p a c e  o r  V a l u e  S p a c e\nA symbol in T ypeScript exists in one of two spaces:\nT ype space\nV alue space\nThis can get confusing because the same name can refer to dif ferent things\ndepending on which space it’ s in:\ninterface Cylinder { \n  radius: number; \n  height: number;\n} \n \nconst Cylinder = (radius: number, height: number) => ({radius, height});\ninterface Cylinder  introduces a symbol in type space. const Cylinder\nintroduces a symbol with the same name in value space. They have nothing\nto do with one another . Depending on the context, when you write\nCylinder , you’ll either be referring to the type or the value. Sometimes this\ncan lead to errors:\nfunction calculateVolume(shape: unknown) { \n  if (shape instanceof Cylinder) { \n    shape.radius \n    //    ~~~~~~ Property 'radius' does not exist on type '{}' \n  }\n}\nWhat’ s going on here? Y ou probably intended the instanceof  to check\nwhether the shape was of the Cylinder  type. But instanceof  is\nJavaScript’ s runtime operator , and it operates on values. So instanceof\nCylinder  refers to the function, not the type.\nIt’ s not always obvious at first glance whether a symbol is in type space or\nvalue space. Y ou have to tell from the context in which the symbol occurs.\nThis can get especially confusing because many type-space constructs look\nexactly the same as value-space constructs.\nLiteral types, for example:\ntype T1 = 'string literal';\nconst v1 = 'string literal';\ntype T2 = 123;\nconst v2 = 123;\nThe symbols after a type  or interface  are in type space, while those\nintroduced in a const  or let  declaration are values.\nOne of the best ways to build an intuition for the two spaces is through the\nT ypeScript playground , which shows you the generated JavaScript for your\nT ypeScript source. T ypes are erased during compilation ( Item 3 ), so if a\nsymbol disappears then it was in type space (see Figure 2-1 1 ).\nFigur e 2-1 1. The T ypeScript playgr ound showing generated JavaScript. The symbols on the first two\nlines go away , so they wer e in type space.\nStatements in T ypeScript can alternate between type space and value space.\nThe symbols after a type declaration ( : ) or an assertion ( as ) are in type\nspace, while everything after an =  in an assignment is in value space. For\nexample:\ninterface Person { \n  first: string; \n  last: string;\n}\nconst jane: Person = { first: 'Jane', last: 'Jacobs' };\n//    ――――           ――――――――――――――――――――――――――――――――― Values\n//          ―――――― Type\nFunction statements, in particular , can alternate repeatedly between the\nspaces:\nfunction email(to: Person, subject: string, body: string): Response { \n  //     ――――― ――          ―――――――          ――――                    Values \n  //               ――――――           ――――――        ――――――   ―――――――― Types \n  // ...\n}\nThe class  and enum  constructs  introduce both a type and a value.\nReturning to the first example, for instance, Cylinder  could have been a\nclass :\nclass Cylinder { \n  radius: number; \n  height: number; \n  constructor(radius: number, height: number) { \n    this.radius = radius; \n    this.height = height; \n  }\n} \n \nfunction calculateVolume(shape: unknown) { \n  if (shape instanceof Cylinder) { \n    shape \n    // ^? (parameter) shape: Cylinder \n    shape.radius \n    //    ^? (property) Cylinder.radius: number \n  }\n}\nThe T ypeScript type introduced by a class is based on its shape (its\nproperties and methods), while the value is the constructor .\nThere are many operators and keywords that mean dif ferent things in a type\nor value context. typeof , for instance:\ntype T1 = typeof jane;\n//   ^? type T1 = Person\ntype T2 = typeof email;\n//   ^? type T2 = (to: Person, subject: string, body: string) => Response \n \nconst v1 = typeof jane;  // Value is ""object""\nconst v2 = typeof email;  // Value is ""function""\nIn a type context, typeof  takes a value and returns its T ypeScript type. Y ou\ncan use these as part of a lar ger type expression, or use a type  statement to\ngive them a name.\nIn a value context, typeof  is JavaScript’ s runtime typeof  operator . It\nreturns a string containing the runtime type of the symbol. This is not  the\nsame as the T ypeScript type! JavaScript’ s runtime type system is much\nsimpler than T ypeScript’ s static type system. In contrast to the infinite\nvariety of T ypeScript types, JavaScript’ s typeof  operator only has eight\npossible return values: ""string"" , ""number"" , ""boolean"" , ""undefined"" ,\n""object"" , ""function"" , ""symbol"" , and ""bigint"" .\nThe []  property accessor also has an identical-looking equivalent in type\nspace. But be aware that while obj['field']  and obj.field  are\nequivalent in value space, they are not in type space. Y ou must use the\nformer to get the type of another type’ s property:\nconst first: Person['first'] = jane['first'];  // Or jane.first\n//    ―――――                    ――――――――――――― Values\n//           ―――――― ―――――――                  Types\nPerson['first']  is a type  here since it appears in a type context (after a\n: ). Y ou can put any type in the index slot, including union types or\nprimitive types:\ntype PersonEl = Person['first' | 'last'];\n//   ^? type PersonEl = string\ntype Tuple = [string, number, Date];\ntype TupleEl = Tuple[number];\n//   ^? type TupleEl = string | number | Date\nSee Item 15  for more on type operations and how to map between types.\nThere are many other constructs that have dif ferent meanings in the two\nspaces:\nthis  in value space is JavaScript’ s this  keyword ( Item 69 ). As a type,\nthis  is the T ypeScript type of this , aka “polymorphic this.” It’ s\nhelpful for implementing method chains with subclasses.\nIn value space, &  and |  are bitwise AND and OR. In type space they\nare the intersection and union operators.\nIn value space, const  introduces  a new variable, but in type space, as\nconst  changes the inferred type of a literal or literal expression ( Item\n20 ).\nIn value space, extends  defines  a subclass ( class A extends B ), but\nin type space it defines a subtype ( interface A extends B ) or a\nconstraint on a generic type ( Generic<T extends number> ).\nIn value space, "" in "" is used in for  loops (for (key in object) ),\nwhile in type space it’ s used in mapped types ( Item 15 ).\nIn value space, !  is JavaScript’ s logical not operator ( !x ), but in type\nspace it’ s a non-null type assertion ( x! ; see Item 9 ).\nIf T ypeScript doesn’ t seem to understand your code at all, it may be because\nof confusion around type and value space. For example, say you change the\nemail  function from earlier to take its ar guments in a single object\nparameter ( Item 38  explains why this is a good idea):\nfunction email(options: {to: Person, subject: string, body: string}) { \n  // ...\n}\nIn JavaScript you can use destructuring assignment to create local variables\nfor each property in the object:\nfunction email({to, subject, body}) { \n  // ...\n}\nIf you try to do the same in T ypeScript, you get some confusing errors:\nfunction email({ \n  to: Person, \n  //  ~~~~~~ Binding element 'Person' implicitly has an 'any' type \n  subject: string, \n  //       ~~~~~~ Binding element 'string' implicitly has an 'any' type \n  body: string \n  //    ~~~~~~ Binding element 'string' implicitly has an 'any' type\n}) { /* ... */ }\nThe problem is that Person  and string  are being interpreted in a value\ncontext. Y ou’re trying to create a variable named Person  and two variables\nnamed string . Instead, you should separate the types and values:\nfunction email( \n  {to, subject, body}: {to: Person, subject: string, body: string}\n) { \n  // ...\n}\nThis is significantly more verbose, but in practice you may have a named\ntype for the parameters or be able to infer them from context ( Item 24 ).\nWhile the similar constructs in type and value space can be confusing at\nfirst, they’re eventually useful as a mnemonic once you get the hang of it.\nThings to Remember\nKnow how to tell whether you’re in type space or value space while\nreading a T ypeScript expression. Use the T ypeScript playground to\nbuild an intuition for this.\nEvery value has a static type, but this is only accessible in type space.\nT ype space constructs such as type  and interface  are erased and are\nnot accessible in value space.\nSome constructs, such as class  or enum , introduce both a type and a\nvalue.",9739
17-Item 9 Prefer Type Annotations to Type Assertions.pdf,17-Item 9 Prefer Type Annotations to Type Assertions,"typeof , this , and many other operators and keywords have dif ferent\nmeanings in type space and  value space.\nI t e m  9 :  P r e f e r  T y p e  A n n o t a t i o n s  t o  T y p e\nA s s e r t i o n s\nT ypeScript seems to have two ways of assigning a value to a variable and\ngiving it a type:\ninterface Person { name: string }; \n \nconst alice: Person = { name: 'Alice' };\n//    ^? const alice: Person\nconst bob = { name: 'Bob' } as Person;\n//    ^? const bob: Person\nWhile these achieve similar ends, they are actually quite dif ferent! The first\n(alice: Person ) adds a type annotation  to the variable and ensures that\nthe value conforms to the type. The latter ( as Person ) performs a type\nassertion . This tells T ypeScript that, despite the type it inferred, you know\nbetter and would like the type to be Person .\nIn general, you should prefer type annotations to type assertions. Here’ s\nwhy:\nconst alice: Person = {};\n//    ~~~~~ Property 'name' is missing in type '{}' but required in type \n'Person'\nconst bob = {} as Person;  // No error\nThe type annotation verifies that the value conforms to the interface. Since\nit does not, T ypeScript flags an error . The type assertion silences this error\nby telling the type checker that, for whatever reason, you know better than\nit does.\nThe same thing happens if you specify an additional property:\nconst alice: Person = { \n  name: 'Alice', \n  occupation: 'TypeScript developer'\n// ~~~~~~~~~ Object literal may only specify known properties,\n//           and 'occupation' does not exist in type 'Person'\n};\nconst bob = { \n  name: 'Bob', \n  occupation: 'JavaScript developer'\n} as Person;  // No error\nWhile undeclared properties are valid from a structural typing perspective\n( Item 4 ), they are often mistakes. T ypeScript has an additional tool  known\nas excess pr operty checking  that flags extra properties in objects with\ndeclared types, but it doesn’ t apply if you use an assertion. Item 1 1  will\nhave much more to say about excess property checking.\nBecause they provide additional safety checks, you should use type\nannotations unless you have a specific reason to use a type assertion.\nN O T E\nY ou may also see code that looks like const bob = <Person>{} . This was the original\nsyntax for assertions and is equivalent to {} as Person . It is less common now because\n<Person>  is interpreted as a start tag in .tsx  files (T ypeScript + React).\nIt can be tricky to use a type annotation with arrow functions. What if you\nwanted to use the named Person  interface in this code?\nconst people = ['alice', 'bob', 'jan'].map(name => ({name}));\n// { name: string; }[]... but we want Person[]\nIt’ s tempting to use a type assertion here, and it seems to solve the problem:\nconst people = ['alice', 'bob', 'jan'].map( \n  name => ({name} as Person)\n); // Type is Person[]\nBut this suf fers from all the same issues as a more direct use of type\nassertions. For example:\nconst people = ['alice', 'bob', 'jan'].map(name => ({} as Person));\n// No error\nSo how do you use a type annotation in this context instead? The most\nstraightforward way is to declare a variable in the arrow function:\nconst people = ['alice', 'bob', 'jan'].map(name => { \n  const person: Person = {name}; \n  return person\n}); // Type is Person[]\nBut this introduces considerable noise compared to the original code. A\nmore concise way is to annotate the return type of the arrow function:\nconst people = ['alice', 'bob', 'jan'].map( \n  (name): Person => ({name})\n); // Type is Person[]\nThis performs all the same checks on the value as the previous version. The\nparentheses are significant here! (name): Person  allows the type of name\nto be inferred and specifies that the return type should be Person . But\n(name: Person)  would specify that the type of name  is Person  while\nallowing the return type to be inferred, which would produce an error . See\nItem 24  for more about how type inference works with function parameters.\nIn this case you could have also written the final desired type and let\nT ypeScript check the validity of the assignment:\nconst people: Person[] = ['alice', 'bob', 'jan'].map(name => ({name})); // OK\nBut in the context of a longer chain of function calls, it may be necessary or\ndesirable to have the named type in place earlier . And it will help flag errors\nclose to where they occur .\nSo  when should  you use a type assertion? T ype assertions make the most\nsense when you truly do know more about a type than T ypeScript does,\ntypically from context that isn’ t available to the type checker . If you’re\nworking in a browser , for instance, you may know the type of a DOM\nelement more precisely than T ypeScript does:\ndocument.querySelector('#myButton')?.addEventListener('click', e => { \n  e.currentTarget \n  // ^? (property) Event.currentTarget: EventTarget | null \n  // currentTarget is #myButton is a button element \n  const button = e.currentTarget as HTMLButtonElement; \n  //    ^? const button: HTMLButtonElement\n});\nBecause T ypeScript doesn’ t have access to the DOM of your page, it has no\nway of knowing that #myButton  is a button element. And it doesn’ t know\nthat the currentTarget  of the event should be that same button. Since you\nhave information that T ypeScript does not, a type assertion makes sense\nhere. For more on DOM types, see Item 75 .\nWhen you use a type assertion, it’ s a good idea to include an explanation of\nwhy it’ s valid in a comment. This provides the missing information for\nhuman readers and will help them evaluate whether the assertion is still\njustified.\nWhat if a variable’ s type includes null  but you know from context that this\nisn’ t possible? Y ou can use a type assertion to remove null  from a type:\nconst elNull = document.getElementById('foo');\n//    ^? const elNull: HTMLElement | null\nconst el = document.getElementById('foo') as HTMLElement;\n//    ^? const el: HTMLElement\nThis sort of type assertion is so common that it gets a special syntax and is\nknown  as a non-null assertion :\nconst el = document.getElementById('foo')!;\n//    ^? const el: HTMLElement\nUsed as a prefix, !  is JavaScript’ s logical not operator . But as a suf fix, !  is\ninterpreted as a type assertion that the value is non-null. This is an\nimprovement over as  because it allows the non-null part of the type to pass\nthrough unaltered.\nStill, you should treat !  with as much caution as any other assertion: it is\nerased during compilation, so you should only use it if you have\ninformation that the type checker lacks and can ensure that the value is non-\nnull. If you can’ t, you should use a conditional to check for the null  case.\nIf you’re accessing a property or method on an object that might be null , it\ncan be convenient to use  the “optional chaining” operator , ?. :\ndocument.getElementById('foo')?.addEventListener('click', () => { \n  alert('Hi there!');\n});\nThis has some superficial resemblance to !.  but it’ s quite dif ferent. a?.b  is\na JavaScript construct that checks if the object is null  (or undefined ) at\nruntime before continuing to evaluate the expression. a!.b  is a type-level\nconstruct that compiles to just a.b . If the object is null  at runtime, it will\nthrow an exception. a?.b  is safer than a!.b , but don’ t go too crazy with it.\nIf it’ s essential for your application to add an event listener , then you\nprobably want to know if it fails!\nT ype assertions have their limits: they don’ t let you convert between\narbitrary types. The general rule is that you can use a type assertion to\nconvert between A and B if they are “comparable” to one another . Using\nthe set terminology from Item 7 , this means that A and B must have a non-\nempty intersection. In particular , subtypes are allowed. HTMLElement  is a\nsubtype of HTMLElement | null , so this type assertion is OK. (The\nintersection of these types is HTMLElement .) HTMLButtonElement  is a\nsubtype of EventTarget , so that is OK, too. And Person  is a subtype of {} ,\nso that assertion is also fine.\nBut you can’ t convert between a Person  and an HTMLElement  since their\nintersection is empty (i.e., the never  type):\ninterface Person { name: string; }\nconst body = document.body;\nconst el = body as Person;\n//         ~~~~~~~~~~~~~~\n// Conversion of type 'HTMLElement' to type 'Person' may be a mistake because\n// neither type sufficiently overlaps with the other. If this was intentional,\n// convert the expression to 'unknown' first.\nThe error suggests an escape hatch, namely , using the unknown  type ( Item\n46 ). Every type is a subtype of unknown , so assertions involving unknown\nare always OK. This lets you convert between arbitrary types, but at least\nyou’re being explicit that you’re doing something suspicious!\nconst el = document.body as unknown as Person;  // OK\nNot every type assertion uses the keyword as . Item 22  explains “user -\ndefined type guards” ( is ), which allow you to associate some logic with a\ntype assertion to check whether it’ s valid. It’ s also possible to use generic\ntype inference to assert a type, but this is a bad idea since it’ s easy to\nconvince yourself that T ypeScript is checking your types when it’ s really\nnot. This pattern (“return-only generics”) is explored in Item 51 .\nT ype assertions are sometimes called “casts.” This terminology  is\nmisleading, however , and is best avoided. In languages like C, a cast can\nchange a value at runtime (say from an int  to a float ). T ype assertions\ncannot do this. They are type-level constructs that are erased at runtime.\nThey don’ t change a value. Rather , they “assert” something that is already\ntrue about it.\nFinally , there’ s as const . While this looks like a type assertion, it’ s more\nproperly called a “const context.” While as T  should make you suspicious,\nas const  makes types more precise and is completely safe. Item 24  shows\nhow you can use const contexts to improve type inference.",10068
18-Item 10 Avoid Object Wrapper Types String Number Boolean Symbol BigInt.pdf,18-Item 10 Avoid Object Wrapper Types String Number Boolean Symbol BigInt,"Things to Remember\nPrefer type annotations ( : Type ) to type assertions ( as Type ).\nKnow how to annotate the return type of an arrow function.\nUse type assertions and non-null assertions only when you know\nsomething about types that T ypeScript does not.\nWhen you use a type assertion, include a comment explaining why it’ s\nvalid.\nI t e m  1 0 :  A v o i d  O b j e c t  W r a p p e r  T y p e s  ( S t r i n g ,\nN u m b e r ,  B o o l e a n ,  S y m b o l ,  B i g I n t )\nIn addition  to objects, JavaScript has seven types of primitive values:\nstrings, numbers, booleans, null , undefined , symbol, and bigint. The first\nfive have been around since the beginning. The symbol primitive was added\nin ES2015, and bigint joined the family with ES2020.\nPrimitives are distinguished from objects by being immutable and not\nhaving methods. Y ou might object that strings do  have methods:\n> 'primitive'.charAt(3) \n'm'\nBut things are not quite as they seem. There’ s actually something surprising\nand subtle going on here. While a string primitive  does not have methods,\nJavaScript also defines a String  object  type that does. JavaScript freely\nconverts between these types. When you access a method like charAt  on a\nstring primitive, JavaScript wraps it in a String  object, calls the method,\nand then throws the object away .\nY ou can observe this if you monkey-patch String.prototype  ( Item 47 ):\n// Don't do this!\nconst originalCharAt = String.prototype.charAt;\nString.prototype.charAt = function(pos) { \n  console.log(this, typeof this, pos); \n  return originalCharAt.call(this, pos);\n};\nconsole.log('primitive'.charAt(3));\nThis produces the following output:\n[String: 'primitive'] object 3 \nm\nThe this  value in the method is a String  object wrapper , not a string\nprimitive. Y ou can instantiate a String  object directly and it will\nsometimes behave like a string primitive. But not always. For example, a\nString  object is only ever equal to itself:\n> ""hello"" === new String(""hello"") \nfalse \n> new String(""hello"") === new String(""hello"") \nfalse\nThe implicit conversion to object wrapper types explains an odd\nphenomenon in JavaScript—if you assign a property to a primitive, it\ndisappears:\n> x = ""hello"" \n'hello' \n> x.language = 'English' \n'English' \n> x.language \nundefined\nNow you know the explanation: x  is converted to a String  instance, the\nlanguage  property is set on that, and then the object (with its language\nproperty) is thrown away .\nThere are object wrapper types for the other primitives as well: Number  for\nnumbers, Boolean  for booleans, Symbol  for symbols, and BigInt  for\nbigints (there are no object wrappers for null  and undefined ).\nThese wrapper types exist as a convenience to provide methods on the\nprimitive values and to provide static methods (e.g.,\nString.fromCharCode ). But there’ s usually no reason to instantiate them\ndirectly .\nT ypeScript models this distinction by having distinct types for the\nprimitives and their object wrappers:\nstring  and String\nnumber  and Number\nboolean  and Boolean\nsymbol  and Symbol\nbigint  and BigInt\nIt’ s easy to inadvertently type String  (especially if you’re coming from\nJava or C#), and it even seems to work, at least initially:\nfunction getStringLen(foo: String) { \n  return foo.length;\n} \n \ngetStringLen(""hello"");  // OK\ngetStringLen(new String(""hello""));  // OK\nBut things go awry when you try to pass a String  object to a method that\nexpects a string :\nfunction isGreeting(phrase: String) { \n  return ['hello', 'good day'].includes(phrase); \n  //                                    ~~~~~~ \n  // Argument of type 'String' is not assignable to parameter of type \n'string'. \n  // 'string' is a primitive, but 'String' is a wrapper object. \n  // Prefer using 'string' when possible.\n}\nSo string  is assignable to String , but String  is not assignable to string .\nConfusing? Follow the advice in the error message and stick with string .\nAll the type declarations that ship with T ypeScript use it, as do the typings\nfor almost all other libraries.\nAnother way you can wind up with wrapper objects is if you provide an\nexplicit type annotation with a capital letter:\nconst s: String = ""primitive"";\nconst n: Number = 12;\nconst b: Boolean = true;\nThis only changes the T ypeScript types and, as Item 3  explained, this can’ t\naf fect the runtime values. They are still primitives, not objects. But\nT ypeScript permits these declarations because the primitive types are\nassignable to the object wrappers. These annotations are both misleading\nand redundant ( Item 18 ). Better to stick with the primitive types.\nAs a final note, it’ s fine  to call BigInt  and Symbol  without new , since these\ncreate primitives:\n> typeof BigInt(1234) \n'bigint' \n> typeof Symbol('sym') \n'symbol'\nThese are the BigInt  and Symbol  values , not the T ypeScript types ( Item 8 ).\nCalling them results in values of type bigint  and symbol . Y ou can\nconstruct a bigint  directly by putting an “n” at the end of a numeric literal:\n123n .\nIf you  use typescript-eslint  in your project, the ban-types  rule\nprohibits the use of object wrapper types. This is enabled with the\n@typescript-eslint/recommended  configuration.\nThings to Remember",5320
19-Item 11 Distinguish Excess Property Checking from Type Checking.pdf,19-Item 11 Distinguish Excess Property Checking from Type Checking,"A void T ypeScript object wrapper types. Use the primitive types\ninstead: string  instead of String , number  instead of Number ,\nboolean  instead of Boolean , symbol  instead of Symbol , and bigint\ninstead of BigInt .\nUnderstand how object wrapper types are used to provide methods on\nprimitive values. A void instantiating them or using them directly , with\nthe exception of Symbol  and BigInt .\nI t e m  1 1 :  D i s t i n g u i s h  E x c e s s  P r o p e r t y\nC h e c k i n g  f r o m  T y p e  C h e c k i n g\nWhen you  assign an object literal to a variable with a declared type,\nT ypeScript makes sure it has the properties of that type and no others :\ninterface Room { \n  numDoors: number; \n  ceilingHeightFt: number;\n}\nconst r: Room = { \n  numDoors: 1, \n  ceilingHeightFt: 10, \n  elephant: 'present',\n// ~~~~~~~ Object literal may only specify known properties,\n//         and 'elephant' does not exist in type 'Room'\n};\nWhile it is odd that there’ s an elephant  property , this error doesn’ t make\nmuch sense from a structural typing point of view ( Item 4 ). That constant is\nassignable to the Room  type, which you can see by introducing an\nintermediate variable:\nconst obj = { \n  numDoors: 1, \n  ceilingHeightFt: 10, \n  elephant: 'present',\n};\nconst r: Room = obj;  // OK\nThe type of obj  is inferred as { numDoors: number; ceilingHeightFt:\nnumber; elephant: string } . This type includes a subset of the values\nin the Room  type because it only permits string  elephants, whereas Room\nwould permit any type of elephant. Hence it is assignable to Room , and the\ncode passes the type checker . (If the term “subset” is unfamiliar , head over\nto Item 7  for a refresher .)\nSo what’ s dif ferent about these two examples? In the first you’ve triggered\na process known as “excess property checking,” which helps catch an\nimportant class of errors that the structural type system would otherwise\nmiss. But this process has its limits, and conflating it with regular\nassignability checks can make it harder to build an intuition for structural\ntyping. Recognizing excess property checking as a distinct process will help\nyou build a clearer mental model of T ypeScript’ s type system.\nAs Item 1  explained, T ypeScript goes beyond trying to flag code that will\nthrow exceptions at runtime. It also tries to find code that doesn’ t do what\nyou intend. Here’ s an example of the latter:\ninterface Options { \n  title: string; \n  darkMode?: boolean;\n}\nfunction createWindow(options: Options) { \n  if (options.darkMode) { \n    setDarkMode(); \n  } \n  // ...\n}\ncreateWindow({ \n  title: 'Spider Solitaire', \n  darkmode: true\n// ~~~~~~~ Object literal may only specify known properties,\n//         but 'darkmode' does not exist in type 'Options'.\n//         Did you mean to write 'darkMode'?\n});\nThis code doesn’ t throw any sort of error at runtime. But it’ s also unlikely\nto do what you intended for the exact reason that T ypeScript says: it should\nbe darkMode  (capital M), not darkmode .\nA purely structural type checker wouldn’ t be able to spot this sort of error\nbecause the Options  type is incredibly broad: it includes all objects with a\ntitle  property that’ s a string  and any other pr operties , so long as those\ndon’ t include a darkMode  property set to something other than true  or\nfalse .\nIt’ s easy to for get how expansive T ypeScript types can be. Here are a few\nmore values that are assignable to Options :\nconst o1: Options = document;  // OK\nconst o2: Options = new HTMLAnchorElement();  // OK\nBoth document  and instances of HTMLAnchorElement  have title\nproperties that are strings, so these assignments are allowed. Options  is a\nbroad type indeed!\nExcess property checking tries to rein this in without compromising the\nfundamentally structural nature of the type system. It does this by\ndisallowing unknown properties on object literals when they’re used in a\ncontext with a declared type. (It’ s sometimes called “strict object literal\nchecking” for this reason, or “freshness” because it applies to freshly\ncreated objects.)\nThis context could be an assignment to a variable with a declared type, a\nfunction ar gument, or the return value of a function with a declared return\ntype. Neither document  nor new HTMLAnchorElement  is an object literal,\nso they did not trigger excess property checking. But the {title,\ndarkmode}  object is, so it does:\nconst o: Options = { darkmode: true, title: 'Ski Free' }; \n                  // ~~~~~~~~ 'darkmode' does not exist in type 'Options'...\nThis explains why using an intermediate variable without a type annotation\nmakes the error go away:\nconst intermediate = { darkmode: true, title: 'Ski Free' };\nconst o: Options = intermediate;  // OK\nWhile the righthand side of the first line is an object literal, the righthand\nside of the second line ( intermediate ) is not, so excess property checking\ndoes not apply , and the error goes away .\nExcess property checking does not happen when you use a type assertion:\nconst o = { darkmode: true, title: 'MS Hearts' } as Options;  // OK\nThis is a good reason to prefer type annotations to assertions ( Item 9 ).\nIf you don’ t want this sort of check, you can tell T ypeScript to expect\nadditional properties using an index signature:\ninterface Options { \n  darkMode?: boolean; \n  [otherOptions: string]: unknown;\n}\nconst o: Options = { darkmode: true };  // OK\nItem 16  discusses when this is and is not an appropriate way to model your\ndata.\nA related check happens for  so-called “weak” types, which have only\noptional properties:\ninterface LineChartOptions { \n  logscale?: boolean; \n  invertedYAxis?: boolean; \n  areaChart?: boolean;\n}\nfunction setOptions(options: LineChartOptions) { /* ... */ } \n \nconst opts = { logScale: true };\nsetOptions(opts);\n//         ~~~~ Type '{ logScale: boolean; }' has no properties in common\n//              with type 'LineChartOptions'\nFrom a structural point of view , the LineChartOptions  type should include\nalmost all objects. For “weak” types like this, T ypeScript adds another\ncheck to make sure that the value type and declared type have at least one\nproperty in common. Much like excess property checking, this is ef fective\nat catching typos and isn’ t strictly structural. But unlike excess property\nchecking, it happens during all assignability checks involving weak types.\nFactoring out an intermediate variable doesn’ t bypass this check.\nN O T E\nIn T ypeScript, “weak type” is a technical term that specifically refers to interfaces with\nonly optional properties. It has nothing to do with the merits of your type, and the\nopposite of a “weak type” is not a “strong type,” a term that has no specific meaning in\nT ypeScript or programming languages in general.\nExcess property checking is an ef fective way of catching typos and other\nmistakes in property names that would otherwise be allowed by the\nstructural typing system. It’ s particularly useful with types like Options\nthat contain optional fields. But it is also very limited in scope: it only\napplies to object literals. Recognize this limitation, and distinguish between\nexcess property checking and ordinary assignability checking. This will\nhelp you build a mental model of both.\nFor a concrete example of how excess property checking can catch bugs\nand open up new design possibilities, see Item 61 .\nThings to Remember\nWhen you assign an object literal to a variable with a known type or\npass it as an ar gument to a function, it under goes excess property\nchecking.\nExcess property checking is an ef fective way to find errors, but it is\ndistinct from the usual structural assignability checks done by the\nT ypeScript type checker . Conflating these processes will make it\nharder for you to build a mental model of assignability . T ypeScript\ntypes are not “closed” ( Item 4 ).",7972
20-Item 12 Apply Types to Entire Function Expressions When Possible.pdf,20-Item 12 Apply Types to Entire Function Expressions When Possible,"Be aware of the limits of excess property checking: introducing an\nintermediate variable will remove these checks.\nA “weak type” is an object type with only optional properties. For\nthese types, assignability checks require at least one matching\nproperty .\nI t e m  1 2 :  A p p l y  T y p e s  t o  E n t i r e  F u n c t i o n\nE x p r e s s i o n s  W h e n  P o s s i b l e\nJavaScript  (and T ypeScript) distinguishes between a function statement  and\na function expr ession :\nfunction rollDice1(sides: number): number { /* ... */ }  // Statement\nconst rollDice2 = function(sides: number): number { /* ... */ };  // \nExpression\nconst rollDice3 = (sides: number): number => { /* ... */ };  // Also \nexpression\nAn advantage of function expressions in T ypeScript is that you can apply a\ntype declaration to the entire function at once, rather than specifying the\ntypes of the parameters and return type individually:\ntype DiceRollFn = (sides: number) => number;\nconst rollDice: DiceRollFn = sides => { /* ... */ };\nIf you mouse over sides  in your editor , you’ll see that T ypeScript knows\nits type is number . The function type doesn’ t provide much value in such a\nshort example, but the technique does open up a number of possibilities.\nOne is reducing repetition. If you wanted to write several functions for\ndoing arithmetic on numbers, for instance, you could write them like this:\nfunction add(a: number, b: number) { return a + b; }\nfunction sub(a: number, b: number) { return a - b; }\nfunction mul(a: number, b: number) { return a * b; }\nfunction div(a: number, b: number) { return a / b; }\nor consolidate the repeated function signatures with a single function type:\ntype BinaryFn = (a: number, b: number) => number;\nconst add: BinaryFn = (a, b) => a + b;\nconst sub: BinaryFn = (a, b) => a - b;\nconst mul: BinaryFn = (a, b) => a * b;\nconst div: BinaryFn = (a, b) => a / b;\nThis has fewer type annotations than before, and they’re separated away\nfrom the function implementations. This makes the logic more apparent.\nY ou’ve also gained a check that the return type of all the function\nexpressions is number .\nLibraries often provide types for common function signatures. For example,\nthe React typings provide a MouseEventHandler  type that you can apply to\nan entire function rather than specifying MouseEvent  as a type for the\nfunction’ s parameter . If you’re a library author , consider providing type\ndeclarations for common callbacks.\nAnother situation in which you should apply a type to a function expression\nis to match the signature of some other function. In a web browser , for\nexample, the fetch  function issues an HTTP request:\nconst response = fetch('/quote?by=Mark+Twain');\n//    ^? const response: Promise<Response>\nY ou extract data from the response via response.json()  or\nresponse.text() :\nasync function getQuote() { \n  const response = await fetch('/quote?by=Mark+Twain'); \n  const quote = await response.json(); \n  return quote;\n}\n// {\n//   ""quote"": ""If you tell the truth, you don't have to remember anything."",\n//   ""source"": ""notebook"",\n//   ""date"": ""1894""\n// }\n(See Item 27  for more on Promises and async /await .)\nThere’ s a bug here: if the request for /quote  fails, the response body is\nlikely to contain an explanation like “404 Not Found.” This isn’ t JSON, so\nresponse.json()  will return a rejected Promise with a message about\ninvalid JSON. This obscures the real error , which was a 404.\nIt’ s easy to for get that an error response with fetch  does not result in a\nrejected Promise. Let’ s write a checkedFetch  function to do the status\ncheck for us. The type declarations for fetch  in lib.dom.d.ts  look like this:\ndeclare function fetch( \n  input: RequestInfo, init?: RequestInit,\n): Promise<Response>;\nSo you can write checkedFetch  like this:\nasync function checkedFetch(input: RequestInfo, init?: RequestInit) { \n  const response = await fetch(input, init); \n  if (!response.ok) { \n    // An exception becomes a rejected Promise in an async function. \n    throw new Error(`Request failed: ${response.status}`); \n  } \n  return response;\n}\nThis works, but it can be written more concisely:\nconst checkedFetch: typeof fetch = async (input, init) => { \n  const response = await fetch(input, init); \n  if (!response.ok) { \n    throw new Error(`Request failed: ${response.status}`); \n  } \n  return response;\n}\nW e’ve changed from a function statement to a function expression and\napplied a type ( typeof fetch ) to the entire function. This allows\nT ypeScript to infer the types of the input  and init  parameters.\nThe type annotation also guarantees that the return type of checkedFetch\nwill be the same as that of fetch . Had you written return  instead of\nthrow , for example, T ypeScript would have caught the mistake:\nconst checkedFetch: typeof fetch = async (input, init) => { \n  //  ~~~~~~~~~~~~ \n  //  'Promise<Response | HTTPError>' is not assignable to 'Promise<Response>' \n  //    Type 'Response | HTTPError' is not assignable to type 'Response' \n  const response = await fetch(input, init); \n  if (!response.ok) { \n    return new Error('Request failed: ' + response.status); \n  } \n  return response;\n}\nThe same mistake in the first example would likely have led to an error , but\nin the code that called checkedFetch , rather than in the implementation. In\naddition to being more concise, typing this entire function expression\ninstead of its parameters has given you better safety .\nWhat if you want to match the parameter types of another function but\nchange the return type? This is possible using a rest parameter and the built-\nin Parameters  utility type:\nasync function fetchANumber( \n    ...args: Parameters<typeof fetch>\n): Promise<number> { \n  const response = await checkedFetch(...args); \n  const num = Number(await response.text()); \n  if (isNaN(num)) { \n    throw new Error(`Response was not a number.`); \n  } \n  return num;\n}\nIf you inspect fetchANumber  in your editor , you’ll see that args  doesn’ t\nappear at all. It’ s replaced by the parameter names for fetch , which is\nexactly what you want:\nfetchANumber\n// ^? function fetchANumber(\n//      input: RequestInfo | URL, init?: RequestInit | undefined\n//    ): Promise<number>\nThe syntax here is a bit more cumbersome than applying a type to an entire\nfunction. Use your judgment on whether it would be better to just write out\nthe parameter types. Item 62  will discuss rest parameters in the context of\ngeneric types.\nWhile you may or may not be aware of it, you benefit from this technique\nwhenever you pass a callback to another function. When you use the map  or\nfilter  method of an Array , for example, T ypeScript is able to infer a type\nfor the callback parameter , and it applies that type to your function\nexpression. For more on how context is used in  type inference, see Item 24 .\nWhen you’re writing a function that has the same type signature as another\none, or writing many functions with the same type signature, consider\nwhether you can apply a type declaration to entire functions, rather than\nrepeating types of parameters and return values. The words “many” and\n“repeating” are important here. Don’ t take this to extremes! Y ou don’ t need\nto factor out a type for every function. For the common case of a single,\nstandalone function with a distinct type signature, an old-fashioned function\nstatement is just fine. Use function types when there are many functions\nwith the same or related type signatures.\nThings to Remember\nConsider applying type annotations to entire function expressions,\nrather than to their parameters and return type.\nIf you’re writing the same type signature repeatedly , factor out a\nfunction type or look for an existing one.\nIf you’re a library author , provide types for common callbacks.\nUse typeof fn  to match the signature of another function, or\nParameters  and a rest parameter if you need to change the return type.",8064
21-Item 13 Know the Differences Between type and interface.pdf,21-Item 13 Know the Differences Between type and interface,"I t e m  1 3 :  K n o w  t h e  D i f f e r e n c e s  B e t w e e n  t y p e\na n d  i n t e r f a c e\nIf you  want to define a named type in T ypeScript, you have two options.\nY ou can use a type alias, as shown here:\ntype TState = { \n  name: string; \n  capital: string;\n};\nor define an interface :\ninterface IState { \n  name: string; \n  capital: string;\n}\n(Y ou could also use a class , but that is a JavaScript runtime concept that\nalso introduces a value. See Item 8 .)\nWhich should you use, type  or interface ? The line between these two\noptions has become increasingly blurred over the years, to the point that in\nmost situations you can use either . Y ou should be aware of the distinctions\nthat remain between type  and interface  and be consistent about which\nyou use in which situation. But you should also know how to write the same\ntypes using both, so that you’ll be comfortable reading T ypeScript that uses\neither .\nFor new code where you need to pick a style, the general rule of thumb is to\nuse interface  where possible, using type  either where it’ s required (e.g.,\nunion types) or has a cleaner syntax (e.g., function types). W e’ll get to the\nar guments for this toward the end of this item, but for now let’ s explore the\nsimilarities and dif ferences between these two constructs.\nW A R N I N G\nThe examples in this item prefix type names with I  or T  solely to indicate how they\nwere defined. Y ou should not do this in your code! Prefixing interface types with I  is\ncommon in C#, and this convention made some inroads in the early days of T ypeScript.\nBut it is considered bad style today because it’ s unnecessary , adds little value, and is not\nconsistently followed in the standard libraries.\nFirst, the similarities: the two State types are nearly indistinguishable from\none another . If you define an IState  or a TState  value with an extra\nproperty , the errors you get from excess property checking ( Item 1 1 ) are\ncharacter -by-character identical:\nconst wyoming: TState = { \n  name: 'Wyoming', \n  capital: 'Cheyenne', \n  population: 578_000 \n  // ~~~~~~~ Object literal may only specify known properties, \n  //         and 'population' does not exist in type 'TState'\n};\nY ou can use an index signature with both interface  and type :\ntype TDict = { [key: string]: string };\ninterface IDict { \n  [key: string]: string;\n}\nY ou can also define function types with either:\ntype TFn = (x: number) => string;\ninterface IFn { \n  (x: number): string;\n}\ntype TFnAlt = { \n  (x: number): string;\n}; \n \nconst toStrT: TFn = x => '' + x;  // OK\nconst toStrI: IFn = x => '' + x;  // OK\nconst toStrTAlt: TFnAlt = x => '' + x;  // OK\nThe first type alias form ( TFn ) looks more natural and is more concise for\nfunction types. This is the preferred form and is the one you’re most likely\nto encounter in type declarations. The latter two forms reflect the fact that\nfunctions in JavaScript are callable objects. They are sometimes useful with\noverloaded function signatures ( Item 52 ).\nBoth type aliases and interfaces can be generic:\ntype TBox<T> = { \n  value: T;\n};\ninterface IBox<T> { \n  value: T;\n}\nAn interface  can extend a type  (with some caveats, explained\nmomentarily), and a type  can extend an interface :\ninterface IStateWithPop extends TState { \n  population: number;\n}\ntype TStateWithPop = IState & { population: number; };\nAgain, these types are identical. The caveat is that an interface  can only\nextend object types that could have been defined with interface  (even if\nyou happened to define them with type ). Y ou can’ t extend a union type, for\nexample. If you want to do that, you’ll need to use type  and & .\nA class  can implement either an interface  or a simple type:\nclass StateT implements TState { \n  name: string = ''; \n  capital: string = '';\n}\nclass StateI implements IState { \n  name: string = ''; \n  capital: string = '';\n}\nFinally , both type  and interface  can be recursive ( Item 57 ).\nThose are the similarities. What about the dif ferences? Y ou’ve seen one\nalready—there are union type s but no union interface s:\ntype AorB = 'a' | 'b';\nAn interface  can extend some type s, but not this one. Extending union\ntypes can sometimes be useful. If you have separate types for Input  and\nOutput  variables and a mapping from name to variable:\ntype Input = { /* ... */ };\ntype Output = { /* ... */ };\ninterface VariableMap { \n  [name: string]: Input | Output;\n}\nthen you might want a type that attaches the name to the variable. This\nwould be:\ntype NamedVariable = (Input | Output) & { name: string };\nThis type cannot be expressed with interface . A type  is, in general, more\ncapable than an interface . It can be a union, and it can also take\nadvantage of fancy type-level features like mapped types ( Item 15 ) and\nconditional types ( Item 52 ).\ninterface  and extends  give a bit more error checking than type  and & :\ninterface Person { \n  name: string; \n  age: string;\n} \n \ntype TPerson = Person & { age: number; };  // no error, unusable type \n \ninterface IPerson extends Person { \n  //      ~~~~~~~ Interface 'IPerson' incorrectly extends interface 'Person'. \n  //                Types of property 'age' are incompatible. \n  //                  Type 'number' is not assignable to type 'string'. \n  age: number;\n}\nIt’ s fine to change the type of a property in a subtype, so long it’ s\ncompatible with the base type (see Item 7 ). Generally you want more safety\nchecks, so this is a good reason to use extends  with interface s.\nT ype aliases are the natural way to express tuple and array types:\ntype Pair = [a: number, b: number];\ntype StringList = string[];\ntype NamedNums = [string, ...number[]];\nAn interface  does have some abilities that a type  doesn’ t, however . One\nof these is that  an interface  can be augmented . Going back to the State\nexample, you could have added a population  field in another way:\ninterface IState { \n  name: string; \n  capital: string;\n}\ninterface IState { \n  population: number;\n}\nconst wyoming: IState = { \n  name: 'Wyoming', \n  capital: 'Cheyenne', \n  population: 578_000\n};  // OK\nThis is known  as “declaration mer ging,” and it’ s quite surprising if you’ve\nnever seen it before. This is primarily used with type declaration files\n( Chapter 8 ), and if you’re writing one, you should follow the norms and use\ninterface  to support it. The idea is that there may be gaps in your type\ndeclarations that users need to fill, and this is how they do it. ( Item 71  walks\nyou through this process.)\nT o understand why this unusual feature is useful, it’ s instructive to look at\nhow T ypeScript itself uses declaration mer ging to model the dif ferent\nversions of JavaScript’ s standard library . The Array  interface, for example,\nis defined in lib.es5.d.ts :\n// lib.es5.d.ts\ninterface Array<T> { \n  /** Gets or sets the length of the array. */ \n  length: number; \n  // ... \n  [n: number]: T;\n}\nIf you set target  to ES5 in your tsconfig.json  ( Item 2 ), then this is all you\nget. This definition includes all the properties and methods that were\navailable on arrays when ES5 was published in 2009. But if you tar get\nES2015, T ypeScript will also include lib.es2015.cor e.d.ts . This includes\nanother declaration of the Array  interface:\n// lib.es2015.core.d.ts\ninterface Array<T> { \n  /** Returns the index of the first element in the array where predicate... \n*/ \n  findIndex( \n    predicate: (value: T, index: number, obj: T[]) => unknown, \n    thisArg?: any \n  ): number; \n \n  // ... also find, fill, copyWithin\n}\nThis declaration includes just the four new Array  methods that were added\nin ES2015: find , findIndex , fill , and copyWithin . They get added to\nthe ES5 Array  interface via declaration mer ging. The net ef fect is that you\nget a single Array  type with exactly the right methods for the version of\nJavaScript that you’re tar geting.\nAs the name implies, declaration mer ging makes the most sense in\ndeclaration files. It can  happen in user code, but only if the two interface s\nare defined in the same module (i.e., the same .ts  file). This prevents\naccidental collisions with global interface s with generic-sounding names\nlike Location  and FormData .\nAnother dif ference is that T ypeScript will always try to refer to an\ninterface  by its name, whereas it takes more liberties replacing a type\nalias with its underlying definition. Y ou’ll sometimes see this in error\nmessages and type display ( Item 56 ) but it can also af fect concrete outputs\nsuch as .d.ts  files, which T ypeScript will emit if you set declaration:\ntrue  in your tsconfig.json .\nFor example, consider this function which returns an object statically typed\nusing a type alias with a limited scope:\nexport function getHummer() { \n  type Hummingbird = { name: string; weightGrams: number; }; \n  const ruby: Hummingbird = { name: 'Ruby-throated', weightGrams: 3.4 }; \n  return ruby;\n}; \n \nconst rubyThroat = getHummer();\n//    ^? const rubyThroat: Hummingbird\nIt’ s interesting that T ypeScript reports the type here using an out-of-scope\ntype name ( Hummingbird ). Even more interesting is what happens when\nyou generate a .d.ts  file for this code:\n// get-hummer.d.ts\nexport declare function getHummer(): { \n  name: string; \n  weightGrams: number;\n};\nSince there’ s no function body in which to define the type alias (this is a\ntype declaration file), T ypeScript has elected to inline the type alias. The\nname is gone and only the structure remains. Because the type system is\nstructural ( Item 4 ) this has no ef fect on the values assignable to the type.\nBut it does af fect the display , and it af fects the generated .d.ts  file. In some\ncases, this inlining behavior can cause duplication of types extreme enough\nto af fect compiler performance ( Item 78 ).\nHere’ s what happens if you use an interface  instead:\nexport function getHummer() { \n  //            ~~~~~~~~~ \n  // Return type of exported function has or is using private name \n'Hummingbird'. \n  interface Hummingbird { name: string; weightGrams: number; }; \n  const bee: Hummingbird = { name: 'Bee Hummingbird', weightGrams: 2.3 }; \n  return bee;\n};\nBecause Hummingbird  is an interface , T ypeScript wants to refer to it by\nname. But the name isn’ t available in the type declaration file, hence the\nerror .1 While the inlining behavior may initially seem preferable here, it can\nlead to massive types and, as Item 67  explains, it’ s generally better to export\nyour types anyway . The better solution here is to keep the interface  and\nmake it a top-level export .\nReturning to the question at the start of the item, should you use type  or\ninterface ? For complex types, you have no choice: you need to use a type\nalias. And for function types, tuple types, and array types, the type  syntax\nis more concise and natural than the interface  syntax. But what about\nsimpler object types that can be represented either way?\nIf you’re working in a codebase with an established style, stick with that.\nY ou probably won’ t go too wrong.\nFor a new project without an established style, prefer interface . Y our type\nname will appear more consistently in error messages and type display , and\nyou’ll get more checks that you extend other interfaces correctly . Here’ s\nwhat the of ficial T ypeScript handbook has to say:",11535
22-Item 14 Use readonly to Avoid Errors Associated with Mutation.pdf,22-Item 14 Use readonly to Avoid Errors Associated with Mutation,"For the most part, you can choose based on personal pr efer ence, and\nT ypeScript will tell you if it needs something to be the other kind of\ndeclaration. If you would like a heuristic, use interface  until you need\nto use featur es fr om type .\nIn other words, use interface  when you can and type  when you must, or\nwhen it’ s more er gonomic. But don’ t sweat it too much either way .\nY ou can enforce consistent use of type  or interface  using typescript-\neslint’ s consistent-type-definitions  rule, which is part of the\nstylistic  preset (it prefers interface  by default).\nThings to Remember\nUnderstand the dif ferences and similarities between type  and\ninterface .\nKnow how to write the same types using either syntax.\nBe aware of declaration mer ging for interface  and type inlining for\ntype .\nFor projects without an established style, prefer interface  to type  for\nobject types.\nI t e m  1 4 :  U s e  r e a d o n l y  t o  A v o i d  E r r o r s\nA s s o c i a t e d  w i t h  M u t a t i o n\nHere’ s some code to print the triangular numbers (1, 1 + 2 = 3, 1 + 2 + 3 =\n6, etc.):\nfunction printTriangles(n: number) { \n  const nums = []; \n  for (let i = 0; i < n; i++) { \n    nums.push(i); \n    console.log(arraySum(nums)); \n  }\n}\n(W e’ll get to the definition of arraySum  shortly .)\nThis code appears straightforward, if inef ficient, but here’ s what happens\nwhen you run it:\n> printTriangles(5); \n0 \n1 \n2 \n3 \n4\nWhoops! Those aren’ t the numbers we were expecting. What went wrong?\nLet’ s take a look at my implementation of arraySum :\nfunction arraySum(arr: number[]) { \n  let sum = 0, num; \n  while ((num = arr.pop()) !== undefined) { \n    sum += num; \n  } \n  return sum;\n}\nThis function does calculate the sum of the numbers in the array . But it also\nhas the side ef fect of emptying the array! T ypeScript is fine with this,\nbecause JavaScript arrays are mutable. The problem is that\nprintTriangles  made an assumption about arraySum , namely that it\ndoesn’ t modify nums .\nMutation is the root cause of many hard-to-find bugs. Mutable is the default\nin JavaScript, but T ypeScript’ s readonly  modifier can help you catch and\nprevent surprise mutations. Because it can prevent such a pernicious set of\nbugs, it’ s worth learning how to use this feature in your own code.\nJavaScript primitives are already immutable. There are no methods on\nstring , number ,  or boolean  that will mutate these values. (Y ou may\nreassign a variable declared with let  to another primitive, but you are not\nchanging the primitive value itself.)\nAs you saw with the destructive arraySum  function, arrays (and objects)\nvery much ar e  mutable. This is where T ypeScript’ s readonly  modifier\ncomes in.\nPlaced on a property in an object type, readonly  prevents assignments to\nthat property:\ninterface PartlyMutableName { \n  readonly first: string; \n  last: string;\n} \n \nconst jackie: PartlyMutableName = { first: 'Jacqueline', last: 'Kennedy' };\njackie.last = 'Onassis';  // OK\njackie.first = 'Jacky';\n//     ~~~~~ Cannot assign to 'first' because it is a read-only property.\nT ypically , you’ll want to prevent assignments to all  properties on an object.\nT ypeScript provides a generic utility type, Readonly<T> , that does just that:\ninterface FullyMutableName { \n  first: string; \n  last: string;\n}\ntype FullyImmutableName = Readonly<FullyMutableName>;\n//   ^? type FullyImmutableName = {\n//        readonly first: string;\n//        readonly last: string;\n//      }\n(Focus on the readonly s: the change from interface  to type  isn’ t\nimportant here.)\nIf a function takes an object as a parameter and doesn’ t modify it, it’ s a\ngood idea to wrap that type in Readonly  to advertise this to callers and\nenforce it in the implementation.\nThere are two important caveats to know about with the readonly  property\nmodifier and Readonly<T> . The first is that they are shallow . Just like a\nconst  declaration, a readonly  property cannot be reassigned but it can be\nmutated:\ninterface Outer { \n  inner: { \n    x: number; \n  }\n}\nconst obj: Readonly<Outer> = { inner: { x: 0 }};\nobj.inner = { x: 1 };\n//  ~~~~~ Cannot assign to 'inner' because it is a read-only property\nobj.inner.x = 1;  // OK\nY ou can create a type alias and then inspect it in your editor to see exactly\nwhat’ s happening:\ntype T = Readonly<Outer>;\n//   ^? type T = {\n//        readonly inner: {\n//          x: number;\n//        };\n//      }\nThe important thing to note is that there’ s a readonly  modifier on inner\nbut not on x . There is no built-in support for deep readonly types, but it is\npossible to write a generic type to produce them. Getting this right is tricky ,\nso I recommend using a library rather than rolling your own. The\nDeepReadonly  generic in ts-essentials  is one implementation.\nThe second caveat about Readonly  is that it only af fects properties. If you\napply it to a type with methods that mutate the underlying object, it won’ t\nremove them:\nconst date: Readonly<Date> = new Date();\ndate.setFullYear(2037);  // OK, but mutates date!\nIf you want both a mutable and immutable version of a class, you’ll\ngenerally need to separate them yourself. A great example of this in the\nstandard library is the Array  and ReadonlyArray  interfaces. Here’ s what\nArray<T>  looks like (in lib.es5.d.ts ):\ninterface Array<T> { \n  length: number; \n  // (non-mutating methods) \n  toString(): string; \n  join(separator?: string): string; \n  // ... \n  // (mutating methods) \n  pop(): T | undefined; \n  shift(): T | undefined; \n  // ... \n  [n: number]: T;\n}\nAnd here’ s the corresponding immutable version, ReadonlyArray<T> :\ninterface ReadonlyArray<T> { \n  readonly length: number; \n  // (non-mutating methods) \n  toString(): string; \n  join(separator?: string): string; \n  // ... \n  readonly [n: number]: T;\n}\nThe key dif ferences are that the mutating methods (such as pop  and shift )\naren’ t defined on ReadonlyArray , and the two properties, length  and the\nindex type ( [n: number]: T ), have readonly  modifiers. This prevents\nresizing the array and assigning to elements in the array . (number  as an\nindex type isn’ t something you should use in your own code; see Item 17 .)\nSince both Array<T>  and ReadonlyArray<T>  are so common, they get a\nspecial syntax: T[]  and readonly T[] . Because T[]  is strictly more\ncapable than readonly T[] , it follows that T[]  is a subtype of readonly\nT[] . (It’ s easy to get this backwards—remember Item 7 !)\nSo you can assign a mutable array to a readonly  array , but not vice versa:\nconst a: number[] = [1, 2, 3];\nconst b: readonly number[] = a;\nconst c: number[] = b;\n//    ~ Type 'readonly number[]' is 'readonly' and cannot be\n//      assigned to the mutable type 'number[]'\nThis makes sense: the readonly  modifier wouldn’ t be much use if you\ncould get rid of it without even a type assertion.\nNow we have the tools we need to improve the printTriangles  and\narraySum  functions. If printTriangles  wants to prevent arraySum  from\nmutating the nums  array , it can pass it a readonly  view:\nfunction printTriangles(n: number) { \n  const nums = []; \n  for (let i = 0; i < n; i++) { \n    nums.push(i); \n    console.log(arraySum(nums as readonly number[])); \n    //                   ~~~~~~~~~~~~~~~~~~~~~~~~~ \n    // The type 'readonly number[]' is 'readonly' and cannot be \n    // assigned to the mutable type 'number[]'. \n  }\n}\nW e can’ t declare that nums  is readonly number[]  since we  still need to\nmutate it. W e just want to make sure that arraySum  doesn’ t. Since it’ s\ndeclared to take a mutable array , we get a type error .\nY ou can fix this by making it take a readonly  array instead. Now we get a\ntype error in arraySum :\nfunction arraySum(arr: readonly number[]) { \n  let sum = 0, num; \n  while ((num = arr.pop()) !== undefined) { \n    //              ~~~ 'pop' does not exist on type 'readonly number[]' \n    sum += num; \n  } \n  return sum;\n}\nThis error message makes sense in light of the Array  and ReadonlyArray\ninterfaces that we saw earlier . pop  exists on Array  but not ReadonlyArray .\nW e can fix the type error in arraySum  by not mutating the array:\nfunction arraySum(arr: readonly number[]) { \n  let sum = 0; \n  for (const num of arr) { \n    sum += num; \n  } \n  return sum;\n}\nNow printTriangles  does what you expect:\n> printTriangles(5) \n0 \n1 \n3 \n6 \n10\nWhen you give a parameter a read-only type (either readonly  for an array\nor Readonly  for an object type), a few things happen:\nT ypeScript checks that the parameter isn’ t mutated in the function\nbody .\nY ou advertise to callers that your function doesn’ t mutate the\nparameter .\nCallers may pass your function a readonly  array or Readonly  object.\nIf your function does not mutate its parameters, then you should declare\nthem readonly . There’ s relatively little downside: users will be able to call\nthem with a broader set of types ( Item 30 ), and inadvertent mutations will\nbe caught.\n(Note that you can still r eassign  readonly  parameters. They’re like\nvariables declared with let  rather than const . Reassignment isn’ t visible to\nthe function’ s caller , whereas mutation is.)\nOne problem is that you may need to call functions that haven’ t marked\ntheir parameters readonly . If these functions don’ t mutate their parameters\nand are in your control, make them readonly ! readonly  tends to be\ncontagious: once you mark one function with readonly , you’ll also need to\nmark many of the functions that it calls. This is a good thing since it leads\nto clearer contracts and better type safety . But if you’re calling a function in\nanother library , you may not be able to change its type declarations. In this\ncase, you’ll have to either resort to a type assertion ( param as number[] )\nor patch the type declarations ( Item 71 ).\nThere is often an assumption in JavaScript (and T ypeScript) that functions\ndon’ t mutate their parameters unless explicitly noted. But as we’ll see time\nand again in this book (particularly Items 31  and 33 ), these sorts of implicit\nunderstandings can lead to trouble with type checking. Better to make them\nexplicit, both for human readers and for tsc .\nThings to Remember\nIf your function does not modify its parameters, declare them\nreadonly  (arrays) or Readonly  (object types). This makes the\nfunction’ s contract clearer and prevents inadvertent mutations in its\nimplementation.\nUnderstand that readonly  and Readonly  are shallow , and that\nReadonly  only af fects properties, not methods.\nUse readonly  to prevent errors with mutation and to find the places in\nyour code where mutations occur .\nUnderstand the dif ference between const  and readonly : the former\nprevents reassignment, the latter prevents  mutation.",10937
23-Item 15 Use Type Operations and Generic Types to Avoid Repeating Yourself.pdf,23-Item 15 Use Type Operations and Generic Types to Avoid Repeating Yourself,"I t e m  1 5 :  U s e  T y p e  O p e r a t i o n s  a n d  G e n e r i c\nT y p e s  t o  A v o i d  R e p e a t i n g  Y o u r s e l f\nThis script prints the dimensions, surface areas, and volumes of a few\ncylinders:\nconsole.log( \n  'Cylinder r=1 × h=1', \n  'Surface area:', 6.283185 * 1 * 1 + 6.283185 * 1 * 1, \n  'Volume:', 3.14159 * 1 * 1 * 1\n);\nconsole.log( \n  'Cylinder r=1 × h=2', \n  'Surface area:', 6.283185 * 1 * 1 + 6.283185 * 2 * 1, \n  'Volume:', 3.14159 * 1 * 2 * 1\n);\nconsole.log( \n  'Cylinder r=2 × h=1', \n  'Surface area:', 6.283185 * 2 * 1 + 6.283185 * 2 * 1, \n  'Volume:', 3.14159 * 2 * 2 * 1\n);\nIs this code uncomfortable to look at? It should be. It’ s extremely repetitive,\nas though the same line was copied and pasted, then modified. It repeats\nboth values and constants. This has allowed an error to creep in (did you\nspot it?).\nMuch better would be to factor out some functions, a constant, and a loop:\ntype CylinderFn = (r: number, h: number) => number;\nconst surfaceArea: CylinderFn = (r, h) => 2 * Math.PI * r * (r + h);\nconst volume: CylinderFn = (r, h) => Math.PI * r * r * h; \n \nfor (const [r, h] of [[1, 1], [1, 2], [2, 1]]) { \n  console.log( \n    `Cylinder r=${r} × h=${h}`, \n    `Surface area: ${surfaceArea(r, h)}`, \n    `Volume: ${volume(r, h)}`);\n}\nW ith the formulas written out clearly , the bug is gone (the last example had\nan r*h  for the surface area instead of an r*r ). This is the DR Y principle:\ndon’ t repeat yourself. It’ s the closest thing to universal advice that you’ll\nfind in software development. Y et developers who assiduously avoid\nrepetition in code may not think twice about it in types:\ninterface Person { \n  firstName: string; \n  lastName: string;\n} \n \ninterface PersonWithBirthDate { \n  firstName: string; \n  lastName: string; \n  birth: Date;\n}\nDuplication in types has many of the same problems as duplication in code.\nWhat if you decide to add an optional middleName  field to Person ? Now\nPerson  and PersonWithBirthDate  have diver ged.\nOne reason that duplication is more common in types is that the\nmechanisms for factoring out shared patterns are less familiar than they are\nwith code: what’ s the type system equivalent of factoring out a helper\nfunction? By learning how to map between types, you can bring the benefits\nof DR Y to your type definitions.\nThe simplest way to reduce repetition is by naming your types. Rather than\nwriting a distance function this way:\nfunction distance(a: {x: number, y: number}, b: {x: number, y: number}) { \n  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n}\ncreate a name for the type and use it:\ninterface Point2D { \n  x: number; \n  y: number;\n}\nfunction distance(a: Point2D, b: Point2D) { /* ... */ }\nThis is the type system equivalent of factoring out a constant instead of\nwriting it repeatedly . Duplicated types aren’ t always so easy to spot.\nSometimes they can be obscured by syntax.\nIf several functions share the same type signature, for instance:\nfunction get(url: string, opts: Options): Promise<Response> { /* ... */ }\nfunction post(url: string, opts: Options): Promise<Response> { /* ... */ }\nthen you can follow the advice of Item 12  and factor out a named type for\nthis signature:\ntype HTTPFunction = (url: string, opts: Options) => Promise<Response>;\nconst get: HTTPFunction = (url, opts) => { /* ... */ };\nconst post: HTTPFunction = (url, opts) => { /* ... */ };\nThe CylinderFn  type from the beginning of this item is another example of\nthis.\nWhat about the Person  / PersonWithBirthDate  example? Y ou can\neliminate the repetition by making one interface extend the other:\ninterface Person { \n  firstName: string; \n  lastName: string;\n} \n \ninterface PersonWithBirthDate extends Person { \n  birth: Date;\n}\nNow you only need to write the additional fields. If the two interfaces share\na subset of their fields, then you can factor out a base interface with just\nthese common fields. For example, rather than defining independent types\nfor birds and mammals:\ninterface Bird { \n  wingspanCm: number; \n  weightGrams: number; \n  color: string; \n  isNocturnal: boolean;\n}\ninterface Mammal { \n  weightGrams: number; \n  color: string; \n  isNocturnal: boolean; \n  eatsGardenPlants: boolean;\n}\nyou might factor out a Vertebrate  class with some of the shared\nproperties:\ninterface Vertebrate { \n  weightGrams: number; \n  color: string; \n  isNocturnal: boolean;\n}\ninterface Bird extends Vertebrate { \n  wingspanCm: number;\n}\ninterface Mammal extends Vertebrate { \n  eatsGardenPlants: boolean;\n}\nNow if you change the base properties or add TSDoc comments to them\n( Item 68 ), the changes will be reflected in both Bird  and Mammal .\nContinuing the analogy with code duplication, this is akin to writing PI  and\n2*PI  instead of 3.141593  and 6.283185 .\nY ou can also use the  intersection operator ( & ) to extend an existing type,\nthough this is somewhat less common:\ntype PersonWithBirthDate = Person & { birth: Date };\nThis technique is most useful when you want to add some additional\nproperties to a union type (which you cannot extend ). For more on this, see\nItem 13 .\nY ou can also go the other direction. What if you have a type, State , which\nrepresents the state of an entire application, and another , TopNavState ,\nwhich represents just a part?\ninterface State { \n  userId: string; \n  pageTitle: string; \n  recentFiles: string[]; \n  pageContents: string;\n}\ninterface TopNavState { \n  userId: string; \n  pageTitle: string; \n  recentFiles: string[]; \n  // omits pageContents\n}\nRather than building up State  by extending TopNavState , you’d like to\ndefine TopNavState  as a subset of the fields in State . This way you can\nkeep a single interface defining the state for the entire app.\nY ou can remove duplication in the types of the properties by indexing into\nState :\ninterface TopNavState { \n  userId: State['userId']; \n  pageTitle: State['pageTitle']; \n  recentFiles: State['recentFiles'];\n};\nWhile it’ s longer , this is  progress: a change in the type of pageTitle  in\nState  will get reflected in TopNavState . But it’ s still repetitive. Y ou can do\nbetter with a mapped type :\ntype TopNavState = { \n  [K in 'userId' | 'pageTitle' | 'recentFiles']: State[K]\n};\nMousing over TopNavState  shows that this definition is, in fact, exactly the\nsame as the previous one (see Figure 2-12 ).\nFigur e 2-12. Showing the expanded version of a mapped type in your text editor . This is the same as\nthe initial definition, but with less duplication.\nMapped types are the type system equivalent of looping over the fields in\nan array . This particular pattern is so common that it’ s part of the standard\nlibrary , where  it’ s called Pick :\ntype Pick<T, K> = { [k in K]: T[k] };\n(This definition isn’ t quite  complete. W e’ll revisit it in Item 50 .) Y ou use it\nlike this:\ntype TopNavState = Pick<State, 'userId' | 'pageTitle' | 'recentFiles'>;\nPick  is an example of a generic type . Continuing the analogy to removing\ncode duplication, using Pick  is the equivalent of calling a function. Pick\ntakes two types, T  and K , and returns a third, much as a function might take\ntwo values and return a third. Chapter 6  is all about programming at the\ntype level, and Item 50  explores the idea of generic types as “functions on\ntypes.”\nAnother form of duplication can arise with  tagged unions. What if you want\na type for just the tag?\ninterface SaveAction { \n  type: 'save'; \n  // ...\n}\ninterface LoadAction { \n  type: 'load'; \n  // ...\n}\ntype Action = SaveAction | LoadAction;\ntype ActionType = 'save' | 'load';  // Repeated types!\nY ou can define ActionType  without repeating yourself by indexing into the\nAction  union:\ntype ActionType = Action['type'];\n//   ^? type ActionType = ""save"" | ""load""\nAs you add more types to the Action  union, ActionType  will incorporate\nthem automatically . This type is distinct from what you’d get using Pick ,\nwhich would give you an interface with a type  property:\ntype ActionRecord = Pick<Action, 'type'>;\n//   ^? type ActionRecord = { type: ""save"" | ""load""; }\nIf you’re defining a class that can be initialized and later updated, the type\nfor the parameter to the update method might optionally include most of the\nsame parameters as the constructor:\ninterface Options { \n  width: number; \n  height: number; \n  color: string; \n  label: string;\n}\ninterface OptionsUpdate { \n  width?: number; \n  height?: number; \n  color?: string; \n  label?: string;\n}\nclass UIWidget { \n  constructor(init: Options) { /* ... */ } \n  update(options: OptionsUpdate) { /* ... */ }\n}\nY ou can construct OptionsUpdate  from Options  using a mapped type and\nkeyof :\ntype OptionsUpdate = {[k in keyof Options]?: Options[k]};\nkeyof  takes a type and gives you a union of the types of its keys:\ntype OptionsKeys = keyof Options;\n//   ^? type OptionsKeys = keyof Options\n//      (equivalent to ""width"" | ""height"" | ""color"" | ""label"")\nThe mapped type ( [k in keyof Options] ) iterates over these and looks\nup the corresponding value type in Options . The ?  makes each property\noptional. This pattern is also very common and is included in the standard\nlibrary as Partial :\nclass UIWidget { \n  constructor(init: Options) { /* ... */ } \n  update(options: Partial<Options>) { /* ... */ }\n}\nMapped types have a few other tricks up their sleeve. Y ou can include an as\nclause in them to rename the keys. There are many uses for this, but one is\nto invert the keys and values in a mapping:\ninterface ShortToLong { \n  q: 'search'; \n  n: 'numberOfResults';\n}\ntype LongToShort = { [k in keyof ShortToLong as ShortToLong[k]]: k };\n//   ^? type LongToShort = { search: ""q""; numberOfResults: ""n""; }\nThis works particularly well  with template literal types , which let you\nmanipulate string literal types at the type level. These are the subject of\nItem 54 .\nIf the index clause in your mapped type is of the form K in keyof T  or a\nfew variants on it, then T ypeScript treats it as a “homomorphic” mapped\ntype. This means that modifiers (like readonly  and ?  for optional) and\ndocumentation are transferred over to the new type:\ninterface Customer { \n  /** How the customer would like to be addressed. */ \n  title?: string; \n  /** Complete name as entered in the system. */ \n  readonly name: string;\n} \n \ntype PickTitle = Pick<Customer, 'title'>;\n//   ^? type PickTitle = { title?: string; }\ntype PickName = Pick<Customer, 'name'>;\n//   ^? type PickName = { readonly name: string; }\ntype ManualName = { [K in 'name']: Customer[K]; };\n//   ^? type ManualName = { name: string; }\nIn this case, Pick  is a homomorphic mapped type and preserves the\noptional and readonly  modifiers. The ManualName  mapped type does not\nuse a keyof  expression, so it is not homomorphic and it does not transfer\nmodifiers. If you define a value using one of the homomorphic types, you’ll\nsee that the documentation has been transferred over as well ( Figure 2-13 ).\nFigur e 2-13. The TSDoc documentation has been copied over to the homomorphic mapped type.\nAnother curious behavior of homomorphic mapped types is that they allow\nprimitive (nonobject) types to pass through unmodified:\ntype PartialNumber = Partial<number>;\n//   ^? type PartialNumber = number\nThis looks a bit odd, but it can be convenient when you’re building generic\ntypes of your own, as we’ll see in Item 56 .\nAs you define mapped types, think about whether they are homomorphic\nand whether you would like them  to be.\nY ou may also find yourself wanting to define a type that matches the shape\nof a value :\nconst INIT_OPTIONS = { \n  width: 640, \n  height: 480, \n  color: '#00FF00', \n  label: 'VGA',\n};\ninterface Options { \n  width: number; \n  height: number; \n  color: string; \n  label: string;\n}\nY ou can do so with typeof :\ntype Options = typeof INIT_OPTIONS;\nThis intentionally looks like JavaScript’ s runtime typeof  operator , but it\noperates at the level of T ypeScript types and is much more precise. For\nmore on typeof , see Item 8 . Be careful about deriving types from values,\nhowever . It’ s typically better to define types first and declare that values are\nassignable to them. This makes your types more explicit and less subject to\nthe vagaries of widening ( Item 20 ).\nThe canonical use case for typeof  is if you have a single value that you’d\nlike to be the source of truth for a type (perhaps it’ s some kind of schema or\nAPI specification). By making the value the source of truth, you avoid\nduplication in defining the  type.\nSimilarly , you may want to create a named type for the inferred return value\nof a function or method:\nfunction getUserInfo(userId: string) { \n  // ... \n  return { \n    userId, \n    name, \n    age, \n    height, \n    weight, \n    favoriteColor, \n  };\n}\n// Return type inferred as { userId: string; name: string; age: number, ... }\nDoing this directly requires conditional types (see Item 52 ). But, as we’ve\nseen before, the standard library defines generic types for common patterns\nlike this one. In this case the ReturnType  generic does exactly what you\nwant:\ntype UserInfo = ReturnType<typeof getUserInfo>;\nNote that ReturnType  operates on typeof getUserInfo , the function’ s\ntype , rather than getUserInfo , the function’ s value . As with typeof , use\nthis technique judiciously . Don’ t get mixed up about your source of truth.\nAs you factor out repetition in your types, don’ t go overboard. Just because\ntwo type declarations share the same characters in source code doesn’ t\nnecessarily mean they’re the same thing. For example, these two types\nshare some common properties:\ninterface Product { \n  id: number; \n  name: string; \n  priceDollars: number;\n}\ninterface Customer { \n  id: number; \n  name: string; \n  address: string;\n}\nBut this wouldn’ t be a wise refactor:\n// Don't do this!\ninterface NamedAndIdentified { \n  id: number; \n  name: string;\n}\ninterface Product extends NamedAndIdentified { \n  priceDollars: number;\n}\ninterface Customer extends NamedAndIdentified { \n  address: string;\n}\nThis is because while the id  and name  properties happen to have the same\nname and type, they’re not referring to the same thing. In the future you\nmight change one id  to be a string  but not the other . Or you might split\nthe customer name  into firstName  and lastName , which wouldn’ t make\nsense for a product. In this case, factoring out the common base interface is\na premature abstraction which may make it harder for the two types to\nevolve independently in the future.\nA good rule of thumb is that if it’ s hard to name a type (or a function), then\nit may not be a useful abstraction. In this case, NamedAndIdentified  just\ndescribes the structure of the type, not what it is . The Vertebrate  type\nfrom before, on the other hand, is meaningful on its own. Remember ,\n“duplication is far cheaper than the wrong abstraction.”2\nRepetition and copy/paste coding are just as bad in type space as they are in\nvalue space. The constructs you use to avoid repetition in type space may\nbe less familiar than those used for program logic, but they are worth the\nef fort to learn. Don’ t repeat yourself!\nThings to Remember",15432
24-Item 16 Prefer More Precise Alternatives to Index Signatures.pdf,24-Item 16 Prefer More Precise Alternatives to Index Signatures,"The DR Y (don’ t repeat yourself) principle applies to types as much as\nit applies to logic.\nName types rather than repeating them. Use extends  to avoid\nrepeating fields in interfaces.\nBuild an understanding of the tools provided by T ypeScript to map\nbetween types. These include keyof , typeof , indexing, and mapped\ntypes.\nGeneric types are the equivalent of functions for types. Use them to\nmap between types instead of repeating type-level operations.\nFamiliarize yourself with generic types defined in the standard library ,\nsuch as Pick , Partial , and ReturnType .\nA void over -application of DR Y : make sure the properties and types\nyou’re sharing are really  the same thing.\nI t e m  1 6 :  P r e f e r  M o r e  P r e c i s e  A l t e r n a t i v e s  t o\nI n d e x  S i g n a t u r e s\nOne of the best features of JavaScript is its convenient syntax for creating\nobjects:\nconst rocket = { \n  name: 'Falcon 9', \n  variant: 'Block 5', \n  thrust: '7,607 kN',\n};\nObjects in JavaScript map string (or symbol) keys to values of any type.\nT ypeScript lets you represent flexible mappings like this by specifying an\nindex signatur e  on the type:\ntype Rocket = {[property: string]: string};\nconst rocket: Rocket = { \n  name: 'Falcon 9', \n  variant: 'v1.0', \n  thrust: '4,940 kN',\n};  // OK\nThe [property: string]: string  is the index signature. It specifies\nthree things:\nA name for the keys\nThis is purely for documentation; it is not used by the type checker in\nany way .\nA type for the key\nThis needs to be a subtype of string | number | symbol  (aka\nPropertyKey ). T ypically it’ s string  or a subtype of string  such as a\nunion of string literals. number  indexes are best avoided, as you’ll see in\nItem 17 . symbol  is rare in application code.\nA type for the values\nThis can be anything.\nWhile this code does type check, it has a few downsides:\nIt allows any keys, including incorrect ones. Had you written Name\ninstead of name , it would have still been a valid Rocket  type.\nIt doesn’ t require any specific keys to be present. {}  is also a valid\nRocket .\nIt cannot have distinct types for dif ferent keys. For example, we might\nwant thrust  to be a number  rather than a string .\nT ypeScript’ s language services can’ t help you with types like this. As\nyou’re typing name: , there’ s no autocomplete because the key could be\nanything.\nIn short, index signatures are not very precise. There are almost always\nbetter alternatives to them. In this case, Rocket  could be an interface :\ninterface Rocket { \n  name: string; \n  variant: string; \n  thrust_kN: number;\n}\nconst falconHeavy: Rocket = { \n  name: 'Falcon Heavy', \n  variant: 'v1', \n  thrust_kN: 15200,\n};\nNow thrust_kN  is a number  and T ypeScript will check for the presence of\nall required fields. All the great language services that T ypeScript provides\nare available: autocomplete, jump to definition, and rename.\nWhat should you use index signatures for? Historically , they were the best\nway to model truly dynamic data. This might come from a CSV file, for\ninstance, where you have a header row and want to represent data rows as\nobjects mapping column names to values:\nfunction parseCSV(input: string): {[columnName: string]: string}[] { \n  const lines = input.split('\n'); \n  const [headerLine, ...rows] = lines; \n  const headers = headerLine.split(','); \n  return rows.map(rowStr => { \n    const row: {[columnName: string]: string} = {}; \n    rowStr.split(',').forEach((cell, i) => { \n      row[headers[i]] = cell; \n    }); \n    return row; \n  });\n}\nThere’ s no way to know in advance what the column names are in such a\ngeneral setting, so there’ s no way to get a more precise type. If the user of\nparseCSV  knows more about what the columns are in a particular context,\nthey could use an assertion to get more specific:\ninterface ProductRow { \n  productId: string; \n  name: string; \n  price: string;\n} \n \ndeclare let csvData: string;\nconst products = parseCSV(csvData) as unknown[] as ProductRow[];\nOf course, there’ s no guarantee that the columns at runtime will actually\nmatch your expectation. Y ou can guard against this possibility by changing\nthe value type to string|undefined  or by setting the\nnoUncheckedIndexedAccess  compiler option (see Item 48 ).\nBut a better way to model dynamic data is by using a Map  type, also known\nas an associative array . Here’ s how you might implement parseCSV  using a\nMap :\nfunction parseCSVMap(input: string): Map<string, string>[] { \n  const lines = input.split('\n'); \n  const [headerLine, ...rows] = lines; \n  const headers = headerLine.split(','); \n  return rows.map(rowStr => { \n    const row = new Map<string, string>(); \n    rowStr.split(',').forEach((cell, i) => { \n      row.set(headers[i], cell); \n    }); \n    return row; \n  });\n}\nNow the fields have to be accessed using the get  method, and the result\nalways includes undefined  as a possibility:\nconst rockets = parseCSVMap(csvData);\nconst superHeavy = rockets[2];\nconst thrust_kN = superHeavy.get('thrust_kN');  // 74,500\n//    ^? const thrust_kN: string | undefined\nIf you want to get an object type out of a Map , you’ll need to write some\nparsing code:\nfunction parseRocket(map: Map<string, string>): Rocket { \n  const name = map.get('name'); \n  const variant = map.get('variant'); \n  const thrust_kN = Number(map.get('thrust_kN')); \n  if (!name || !variant || isNaN(thrust_kN)) { \n    throw new Error(`Invalid rocket: ${map}`); \n  } \n  return {name, variant, thrust_kN};\n}\nconst rockets = parseCSVMap(csvData).map(parseRocket);\n//    ^? const rockets: Rocket[]\nWhile this may feel tedious, it does ensure that your data actually has the\nshape you expect. This will flag errors when you load your data, rather than\nat some later point when you try to use it. This pattern of doing data\nvalidation on a broad type ( Map<string, string> ) to get a more specific\none (Rocket ) is common in T ypeScript. Item 74  will explore more\nsystematic ways of doing runtime type validation.\nIn addition to being a better model of dynamic data, Map s work around\nsome famous gotchas involving the prototype chain.\nIf your type has a limited set of possible fields, don’ t model this with an\nindex signature. For instance, if you know your data will have keys like A,\nB, C, D, but you don’ t know how many of them there will be, you could\nmodel the type either with optional fields or a union:\ninterface Row1 { [column: string]: number }  // Too broad\ninterface Row2 { a: number; b?: number; c?: number; d?: number }  // Better\ntype Row3 = \n    | { a: number; } \n    | { a: number; b: number; } \n    | { a: number; b: number; c: number;  } \n    | { a: number; b: number; c: number; d: number };  // Also better\nThe last form is the most precise, but it may be less convenient to work\nwith. See Item 29  for more on crafting types to disallow invalid states.\nIf the problem with using an index signature is that string  is too broad,\nthen you can use a Record . This is a generic type that gives you more\nflexibility in the key type. In particular , you can pass in subsets of string :\ntype Vec3D = Record<'x' | 'y' | 'z', number>;\n//   ^? type Vec3D = {\n//        x: number;\n//        y: number;\n//        z: number;\n//      }\nRecord  is a built-in wrapper around a mapped type ( Item 15 ).\nFinally , you can use an index type to disable excess property checking ( Item\n1 1 ). For example, you might define a few known properties on a\nButtonProps  type but still want to allow it to have any others:\ndeclare function renderAButton(props: ButtonProps): void;\ninterface ButtonProps { \n  title: string; \n  onClick: () => void;\n} \n \nrenderAButton({ \n  title: 'Roll the dice', \n  onClick: () => alert(1 + Math.floor(6 * Math.random())), \n  theme: 'Solarized',\n// ~~~~ Object literal may only specify known properties…\n});\nAdding an index signature makes this error go away:\ninterface ButtonProps { \n  title: string; \n  onClick: () => void; \n  [otherProps: string]: unknown;\n} \n \nrenderAButton({ \n  title: 'Roll the dice', \n  onClick: () => alert(1 + Math.floor(20 * Math.random())), \n  theme: 'Solarized',  // ok\n});",8290
25-Item 17 Avoid Numeric Index Signatures.pdf,25-Item 17 Avoid Numeric Index Signatures,"Crucially , both title  and onClick  still have the same types as before.\nPassing a number  as the title  will result in a type error .\nY ou can also constrain these additional properties to match a certain pattern.\nFor example, some web components allow arbitrary properties but only if\nthey start with ""data-"" . Y ou can model this using an index signature and a\ntemplate literal type. Item 54  will show you how .\nIn conclusion, think twice before you add an index signature to your data\ntype. Is there a more precise alternative available? Could you use an\ninterface  without an index type? Could you use a Map  instead? A mapped\ntype? If nothing else, can you at least constrain the type of the keys?\nThings to Remember\nUnderstand the drawbacks of index signatures: much like any , they\nerode type safety and reduce the value of language services.\nPrefer more precise types to index signatures when possible:\ninterface s, Map , Record s, mapped types, or index signatures with a\nconstrained key space.\nI t e m  1 7 :  A v o i d  N u m e r i c  I n d e x  S i g n a t u r e s\nJavaScript is  a famously quirky language. Some of the most notorious\nquirks involve implicit type coercions:\n> ""0"" == 0 \ntrue\nThese can usually be avoided by using ===  and !==  instead of their more\ncoercive cousins.\nJavaScript’ s object model also has its quirks, and these are more important\nto understand because some of them are modeled by T ypeScript’ s type\nsystem. Y ou’ve already seen one such quirk in Item 10 , which discussed\nobject wrapper types. This item discusses another .\nWhat is an object? In JavaScript it’ s a collection of key/value pairs. The\nkeys are usually strings (in ES2015 and later they can also be symbols). The\nvalues can be anything.\nThis is more restrictive than what you find in many other languages.\nJavaScript does not have a notion of “hashable” objects like you find in\nPython or Java. If you try to use a more complex object as a key , it is\nconverted into a string by calling its toString  method:\n> x = {} \n{} \n> x[[1, 2, 3]] = 2 \n2 \n> x \n{ '1,2,3': 2 } \nIn particular , numbers  cannot be used as keys. If you try to use a number as\na property name, the JavaScript runtime will convert it to a string:\n> { 1: 2, 3: 4} \n{ '1': 2, '3': 4 }\nSo what are arrays, then? They are certainly objects:\n> typeof [] \n'object'\nAnd yet it’ s quite normal to use numeric indices with them:\n> x = [1, 2, 3] \n[ 1, 2, 3 ] \n> x[0] \n1\nAre these being converted into strings? In one of the oddest quirks of all,\nthe answer is “yes.” Y ou can also access the elements of an array using\nstring keys:\n> x['1'] \n2\nIf you use Object.keys  to list the keys of an array , you get strings back:\n> Object.keys(x) \n[ '0', '1', '2' ]\nT ypeScript models this by allowing numeric keys and distinguishing\nbetween these and strings. If you dig into the type declarations for Array\n( Item 6 ), you’ll find this in lib.es5.d.ts :\ninterface Array<T> { \n  // ... \n  [n: number]: T;\n}\nThis is purely a fiction—string keys are accepted at runtime as the\nECMAScript standard dictates that they must—but it is a helpful one that\ncan catch mistakes:\nconst xs = [1, 2, 3];\nconst x0 = xs[0];  // OK\nconst x1 = xs['1'];  // stringified numeric constants are also OK \n \nconst inputEl = document.getElementsByTagName('input')[0];\nconst xN = xs[inputEl.value];\n//            ~~~~~~~~~~~~~ Index expression is not of type 'number'.\nIn this case, inputEl.valueAsNumber  would be more appropriate and\nwould fix the type error .\nWhile the fiction of numeric keys is helpful, it’ s important to remember that\nit is just a fiction. Like all aspects of T ypeScript’ s type system, it is erased\nat runtime ( Item 3 ). This means that constructs like Object.keys  still\nreturn strings:\nconst keys = Object.keys(xs);\n//    ^? const keys: string[]\nThe pattern here is that a number  index signature means that what you put\nin generally has to be a number , but what you get out is a string .\nIf this sounds confusing, it’ s because it is! As a general rule, there’ s not\nmuch reason to use number  as the index signature of a type. If you want to\nspecify something that will be indexed using numbers, you probably want\nto use an Array  or tuple type instead. Using number  as an index type can\ncreate the misconception that numeric properties are a real thing in\nJavaScript, either for yourself or for readers of your code.\nIf you object to accepting an Array  type because they have many other\nproperties (from their prototype) that you might not use, such as push  and\nconcat , then that’ s good—you’re thinking structurally! (If you need a\nrefresher on this, refer to Item 4 .) If you truly want to accept tuples of any\nlength or any array-like construct, T ypeScript has  an ArrayLike  type you\ncan use:\nfunction checkedAccess<T>(xs: ArrayLike<T>, i: number): T { \n  if (i >= 0 && i < xs.length) { \n    return xs[i]; \n  } \n  throw new Error(`Attempt to access ${i} which is past end of array.`)\n}\n(T ypeScript also has a noUncheckedIndexedAccess  option you can set for\nsafe array access. See Item 48 .)\nArrayLike  has just a length  and numeric index signature. As the name\nimplies, this allows array-like structures such as a NodeList  to be passed\nin. In the rare cases that this is what you want, you should use it instead of a\nnormal array . But remember that the keys are still really strings!\nconst tupleLike: ArrayLike<string> = { \n  '0': 'A', \n  '1': 'B', \n  length: 2,\n};  // OK\nIf you just need something you can iterate over , you can use the Iterable\ntype instead, which allows you to pass generator expressions to your\nfunction (see Item 30 ).\nObject keys in JavaScript (and T ypeScript) are either strings or symbols.\nNumeric index types are best thought of as a concession to make the Array\ntype convenient to use in T ypeScript. But remember that numeric indices\naren’ t real. A void using them in your own types.\nThings to Remember\nUnderstand that arrays are objects, so their keys are strings, not\nnumbers. number  as an index signature is a purely T ypeScript\nconstruct designed to help catch bugs.\nPrefer Array , tuple, ArrayLike , or Iterable  types to using number  in\nan index signature yourself.\n1 If you don’ t see this error , make sure to set declaration: true  set in your tsconfig.json .\n2 Sandi Metz, “All the Little Things” , RailsConf 2014.",6469
26-Item 18 Avoid Cluttering Your Code with Inferable Types.pdf,26-Item 18 Avoid Cluttering Your Code with Inferable Types,"Chapter 3. T ype Inference and\nControl Flow Analysis\nFor programming languages used in industry , “statically typed” and\n“explicitly typed” have traditionally been synonymous. C, C++, Java: they\nall made you write out your types. But academic languages never conflated\nthese two things: languages like ML and Haskell have long had\nsophisticated type inference systems, and this has begun to work its way\ninto industry languages. C++ has added auto , and Java has added var .\nNewer languages like Rust and Swift have had type inference from the start.\nT ypeScript makes extensive use of  type inference. Used well, this can\ndramatically reduce the number of type annotations your code requires to\nget full type safety . One of the easiest ways to tell a T ypeScript beginner\nfrom a more experienced developer is by the number of type annotations.\nAn experienced T ypeScript developer will use relatively few annotations\n(but use them to great ef fect), while a beginner may drown their code in\nredundant type annotations.\nIn most languages, a variable has a type and it never changes. T ypeScript is\na bit dif ferent. A variable has a type at a location  in your code. The process\nby which its type changes due to surrounding code is known as contr ol flow\nanalysis .\nThis chapter teaches you how to think about type inference and control flow\nanalysis, shows you some of the problems that can arise with them, and tells\nyou how to fix them. After reading it, you should have a good\nunderstanding of how T ypeScript infers types, when you still need to write\nexplicit type annotations, and when it’ s still a good idea to write type\nannotations even when a type can be inferred.\nI t e m  1 8 :  A v o i d  C l u t t e r i n g  Y o u r  C o d e  w i t h\nI n f e r a b l e  T y p e s\nThe first  thing that many new T ypeScript developers do when they convert\na codebase from JavaScript is fill it with type annotations. T ypeScript is\nabout types , after all! But in T ypeScript, many annotations are unnecessary .\nDeclaring types for all your variables is counterproductive and is\nconsidered poor style.\nDon’ t write:\nlet x: number = 12;\nInstead, just write:\nlet x = 12;\nIf you mouse over x  in your editor , you’ll see that its type has been inferred\nas number  (as shown in Figure 3-1 ).\nFigur e 3-1. A text editor showing that the inferr ed type of x  is number .\nThe explicit type annotation is redundant. W riting it just adds noise. If\nyou’re unsure of the type, you can check it in your editor .\nT ypeScript  will also infer the types of more complex objects. Instead of:\nconst person: { \n  name: string; \n  born: { \n    where: string; \n    when: string; \n  }; \n  died: { \n    where: string; \n    when: string; \n  }\n} = { \n  name: 'Sojourner Truth', \n  born: { \n    where: 'Swartekill, NY', \n    when: 'c.1797', \n  }, \n  died: { \n    where: 'Battle Creek, MI', \n    when: 'Nov. 26, 1883' \n  }\n};\nyou can just write:\nconst person = { \n  name: 'Sojourner Truth', \n  born: { \n    where: 'Swartekill, NY', \n    when: 'c.1797', \n  }, \n  died: { \n    where: 'Battle Creek, MI', \n    when: 'Nov. 26, 1883' \n  }\n};\nAgain, the types are exactly the same. W riting the type in addition to the\nvalue just adds noise here. ( Item 20  will explain how T ypeScript infers\ntypes for object literals.)\nWhat’ s true for objects is also true for arrays. T ypeScript has no trouble\nfiguring out the return type of this function based on its inputs and\noperations:\nfunction square(nums: number[]) { \n  return nums.map(x => x * x);\n}\nconst squares = square([1, 2, 3, 4]);\n//    ^? const squares: number[]\nT ypeScript may infer something more precise than what you expected. This\nis generally a good thing. For example:\nconst axis1: string = 'x';\n//    ^? const axis1: string\nconst axis2 = 'y';\n//    ^? const axis2: ""y""\n""y""  is a more precise type for the axis2  variable. The explicit string\nannotation on axis1  adds noise and reduces type safety .\nAllowing types  to be inferred can also facilitate refactoring. Say you have a\nProduct  type and a function to log it:\ninterface Product { \n  id: number; \n  name: string; \n  price: number;\n} \n \nfunction logProduct(product: Product) { \n  const id: number = product.id; \n  const name: string = product.name; \n  const price: number = product.price; \n  console.log(id, name, price);\n}\nAt some point you learn that product IDs might have letters in them in\naddition to numbers. So you change the type of id  in Product :\ninterface Product { \n  id: string; \n  name: string; \n  price: number;\n}\nBecause you included explicit annotations on all the variables in\nlogProduct , this produces an error:\nfunction logProduct(product: Product) { \n  const id: number = product.id; \n     // ~~ Type 'string' is not assignable to type 'number' \n  const name: string = product.name; \n  const price: number = product.price; \n  console.log(id, name, price);\n}\nHad you left of f all the annotations in the logProduct  function body , the\ncode would have passed the type checker without modification (and worked\ncorrectly at runtime, too).\nHere’ s a better implementation of logProduct  that allows the types of all\nlocal variables to be inferred (it also switches to destructuring assignment):\nfunction logProduct(product: Product) { \n  const {id, name, price} = product; \n  console.log(id, name, price);\n}\nThe corresponding version with explicit type annotations is repetitive and\ncluttered:\nfunction logProduct(product: Product) { \n  const {id, name, price}: {id: string; name: string; price: number } = \nproduct; \n  console.log(id, name, price);\n}\nY ou can’ t put type annotations directly inside the destructuring because, as\nItem 8  explained, they would be interpreted as renaming directives in value\nspace. Destructuring assignment is a great way to make your code more\nconcise. It encourages consistent naming and it works much better with\ninferred types.\nExplicit type annotations are still required in some situations where\nT ypeScript doesn’ t have enough context to determine a type on its own.\nY ou have seen one of these before: function parameters.\nSome  languages will infer types for parameters based on their eventual\nusage, but T ypeScript does not. In T ypeScript, a variable’ s type is generally\ndetermined when it is first introduced. ( Item 25  discusses an important\nexception to this rule.)\nIdeal T ypeScript code includes type annotations for function/method\nsignatures but not for the local variables created in their bodies. This keeps\nnoise to a minimum and lets readers focus on the implementation logic.\nThere are some situations where you can leave the type annotations of f of\nfunction parameters, too. When there’ s a default value, for example:\nfunction parseNumber(str: string, base=10) { \n  //                              ^? (parameter) base: number \n  // ...\n}\nHere the type of base  is inferred as number  because of the default value of\n10 .\nParameter types can usually be inferred when the function is used as a\ncallback for a library with type declarations. The declarations on request\nand response  in this example using the express HTTP server library are\nnot required:\n// Don't do this:\napp.get('/health', (request: express.Request, response: express.Response) => { \n  response.send('OK');\n}); \n \n// Do this:\napp.get('/health', (request, response) => { \n  //                ^? (parameter) request: Request<...> \n  response.send('OK'); \n  // ^? (parameter) response: Response<...>\n});\nItem 24  has more to say about how context is used in type inference.\nThere are a few situations where you may still want to specify a type even\nwhere it can be inferred.\nOne is when you define an object literal:\nconst elmo: Product = { \n  name: 'Tickle Me Elmo', \n  id: '048188 627152', \n  price: 28.99,\n};\nWhen you specify a type on a definition like this, you enable excess\nproperty checking ( Item 1 1 ). This can help catch errors, particularly for\ntypes with optional fields.\nY ou also increase the odds that an error will be reported in the right place. If\nyou leave of f the annotation, a mistake in the object’ s definition will result\nin a type error where it’ s used, rather than where it’ s defined:\nconst furby = { \n  name: 'Furby', \n  id: 630509430963, \n  price: 35,\n};\nlogProduct(furby);\n//         ~~~~~ Argument ... is not assignable to parameter of type 'Product'\n//               Types of property 'id' are incompatible\n//               Type 'number' is not assignable to type 'string'\nIn a lar ger codebase, this type error could appear in a dif ferent file with no\nclear connection to the object definition. W ith an annotation, you get a more\nconcise error in the exact place where the mistake was made:\nconst furby: Product = { \n   name: 'Furby', \n   id: 630509430963,\n// ~~ Type 'number' is not assignable to type 'string' \n   price: 35,\n};\nlogProduct(furby);\nSimilar considerations apply  to a function’ s return type. Y ou may still want\nto annotate this even when it can be inferred to ensure that implementation\nerrors don’ t leak out into uses of the function. This is particularly important\nfor exported functions that are part of a public API.\nSay you have a function that retrieves a stock quote:\nfunction getQuote(ticker: string) { \n  return fetch(`https://quotes.example.com/?q=${ticker}`) \n      .then(response => response.json());\n}\nY ou decide to add a cache to avoid duplicating network requests:\nconst cache: {[ticker: string]: number} = {};\nfunction getQuote(ticker: string) { \n  if (ticker in cache) { \n    return cache[ticker]; \n  } \n  return fetch(`https://quotes.example.com/?q=${ticker}`) \n      .then(response => response.json()) \n      .then(quote => { \n        cache[ticker] = quote; \n        return quote as number; \n      });\n}\nThere’ s a mistake in this implementation, which you can see if you look at\nthe inferred return type for getQuote :\ngetQuote;\n// ^? function getQuote(ticker: string): number | Promise<number>\nY ou should really be returning Promise.resolve(cache[ticker])  so that\ngetQuote  always returns a Promise. The mistake will most likely produce\nan error…but in the code that calls getQuote , rather than in getQuote\nitself:\ngetQuote('MSFT').then(considerBuying);\n//               ~~~~ Property 'then' does not exist on type\n//                    'number | Promise<number>'\nHad you annotated the intended return type ( Promise<number> ), the error\nwould have been reported in the correct place:\nconst cache: {[ticker: string]: number} = {};\nfunction getQuote(ticker: string): Promise<number> { \n  if (ticker in cache) { \n    return cache[ticker]; \n    // ~~~ Type 'number' is not assignable to type 'Promise<number>' \n  } \n  // ...\n}\nWhen you annotate the return type, it keeps implementation errors from\nmanifesting as errors in user code. This is a particularly good idea for\nfunctions like getQuote  that have multiple return  statements. If you want\nT ypeScript to check that all the return s return the same type, you’ll need to\nprovide a type annotation to tell it your intent.\n( Item 27  explains how async functions are an ef fective way to avoid this\nparticular mistake.)\nW riting out the return type may also help you think more clearly about your\nfunction: you should know what its input and output types are befor e you\nimplement it . While the implementation may shift around a bit, the\nfunction’ s contract (its type signature) generally should not. This is similar\nin spirit to test-driven development (TDD),  in which you write the tests that\nexercise a function before you implement it. W riting the full type signature\nfirst helps get you the function you want, rather than the one the\nimplementation makes expedient.\nAnother reason to annotate return types is if you want to use a named type.\nY ou might choose not to write a return type for this function, for example:\ninterface Vector2D { x: number; y: number; }\nfunction add(a: Vector2D, b: Vector2D) { \n  return { x: a.x + b.x, y: a.y + b.y };\n}\nT ypeScript infers the return type as { x: number; y: number; } . This is\ncompatible with Vector2D , but it may be surprising to users of your code\nwhen they see Vector2D  as a type of the input and not of the output\n( Figure 3-2 ).\nFigur e 3-2. The parameters to the add  function have named types, but the inferr ed r eturn value does\nnot.\nIf you annotate the return type, the presentation is more straightforward.\nAnd if you’ve written documentation on the type ( Item 68 ), it will be\nassociated with the returned value as well. As the complexity of the inferred\nreturn type increases, it becomes increasingly helpful to provide a name.\nFinally , annotating your return types means that T ypeScript has less work to\ndo figuring them out. For lar ge codebases, this can have an impact on\ncompiler performance. Item 78  has more guidance on what to do when your\nbuild gets slow .\nSo should you annotate return types? T o reduce code and facilitate\nrefactoring, the default answer is “no.” But it shouldn’ t take much to tip you\nover to “yes.”. If the function has multiple return  statements, if it’ s part of\na public API, or if you want to use a named return type, then  add the\nannotation.\nIf you are using a linter , the typescript-eslint rule no-inferrable-types\n(note the variant spelling) can help ensure that all your type annotations are\nreally necessary .\nThings to Remember\nA void writing type annotations when T ypeScript can infer the same\ntype.\nIdeal T ypeScript code has type annotations in function/method\nsignatures but not on local variables in their bodies.\nConsider using explicit annotations for object literals to enable excess\nproperty checking and ensure errors are reported close to where they\noccur .",13965
27-Item 19 Use Different Variables for Different Types.pdf,27-Item 19 Use Different Variables for Different Types,"Don’ t annotate function return types unless the function has multiple\nreturns, is part of a public API, or you want it to return  a named type.\nI t e m  1 9 :  U s e  D i f f e r e n t  V a r i a b l e s  f o r  D i f f e r e n t\nT y p e s\nIn JavaScript,  it’ s no problem to reuse a variable to hold a dif ferently typed\nvalue for a dif ferent purpose:\nlet productId = ""12-34-56"";\nfetchProduct(productId);  // Expects a string \n \nproductId = 123456;\nfetchProductBySerialNumber(productId);  // Expects a number\nIn T ypeScript, this results in two errors:\nlet productId = ""12-34-56"";\nfetchProduct(productId); \n \nproductId = 123456;\n// ~~~~~~ Type 'number' is not assignable to type 'string'\nfetchProductBySerialNumber(productId);\n//                         ~~~~~~~~~\n// Argument of type 'string' is not assignable to parameter of type 'number'\nHovering over the first productId  in your editor gives a hint as to what’ s\ngoing on (see Figure 3-3 ).\nFigur e 3-3. The inferr ed type of productId  is string .\nBased on the value ""12-34-56"" , T ypeScript has inferred productId ’ s type\nas string . Y ou can’ t assign a number  to a string , hence the error .\nThis leads us to a key insight about variables in T ypeScript: while a\nvariable’ s value can change, its type generally does not . The one common\nway a type can change is to narrow ( Item 22 ), but this involves a type\ngetting smaller , not expanding to include new values. Item 25  presents a\nnotable exception to this rule, but it is an exception and not the rule.\nHow can you use this idea to fix the example? For productId ’ s type to not\nchange, it must be broad enough to encompass both string s and number s.\nThis is the very definition of the  union type, string|number :\nlet productId: string | number = ""12-34-56"";\nfetchProduct(productId); \n \nproductId = 123456;  // OK\nfetchProductBySerialNumber(productId);  // OK\nThis fixes the errors. It’ s interesting that T ypeScript has been able to\ndetermine that id  is really a string  in the first call and really a number  in\nthe second. It has narrowed the union type based on the assignment.\nWhile a union type does work, it may create more issues down the road.\nUnion types are harder to work with than simple types like string  or\nnumber  because you usually have to check what they are before you do\nanything with them.\nThe better solution is to introduce a new variable:\nconst productId = ""12-34-56"";\nfetchProduct(productId); \n \nconst serial = 123456;  // OK\nfetchProductBySerialNumber(serial);  // OK\nIn the previous version, the first and second productId  were not\nsemantically related to one another . They were only related by the fact that\nyou reused a variable. This was confusing for the type checker and would\nbe confusing for a human reader , too.\nThe version with two variables is better for a number of reasons:\nIt disentangles two unrelated concepts (ID and serial number).\nIt allows you to use more specific variable names.\nIt improves type inference. No type annotations are needed.\nIt results in simpler types (string and number literals, rather than\nstring| number ).\nIt lets you declare the variables const  rather than let . This makes\nthem easier for people and the type checker to reason about.\nThe general theme, which will come up repeatedly in this chapter , is that\nmutation makes it harder for the type checker to follow along with your\ncode. T ry to avoid type-changing variables. If you can use dif ferent names\nfor dif ferent concepts, it will make your code clearer both to human readers\nand to the type checker . Y ou should have far more const  than let .\nThis is not to be confused with “shadowed” variables, as in this example:\nconst productId = ""12-34-56"";\nfetchProduct(productId); \n \n{ \n  const productId = 123456;  // OK \n  fetchProductBySerialNumber(productId);  // OK\n}\nWhile these two productId s share a name, they are actually two distinct\nvariables with no relationship to one another . It’ s fine for them to have\ndif ferent types. While T ypeScript is not confused by this, your human\nreaders might be. In general it’ s better to use dif ferent names for dif ferent\nconcepts. Many teams choose to disallow this sort of shadowing via linter\nrules such as eslint’ s no-shadow .",4319
28-Item 20 Understand How a Variable Gets Its Type.pdf,28-Item 20 Understand How a Variable Gets Its Type,"This item focused on scalar values, but similar considerations apply to\nobjects. For more on that, see Item 21 .\nThings to Remember\nWhile a variable’ s value can change, its type generally does not.\nT o avoid confusion, both for human readers and for the type checker ,\navoid reusing variables for dif ferently typed values.\nI t e m  2 0 :  U n d e r s t a n d  H o w  a  V a r i a b l e  G e t s  I t s\nT y p e\nAs Item 7  explained, at runtime every variable has a single value. But at\nstatic analysis time, when T ypeScript is checking your code, a variable has\na set of possible  values, namely , its type. When you initialize a variable\nwith a constant but don’ t provide a type, the type checker needs to decide\non one. In other words, it needs to decide on a set of possible values from\nthe single value that you specified. In T ypeScript, this process is known as\nwidening . Understanding it will help you make sense of errors and make\nmore ef fective use of type annotations.\nSuppose you’re writing a library to work with vectors. Y ou write out a type\nfor a 3D vector and a function to get the value of any of its components:\ninterface Vector3 { x: number; y: number; z: number; }\nfunction getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') { \n  return vector[axis];\n}\nBut when you try to use it, T ypeScript flags an error:\nlet x = 'x';\nlet vec = {x: 10, y: 20, z: 30};\ngetComponent(vec, x);\n//                ~ Argument of type 'string' is not assignable\n//                  to parameter of type '""x"" | ""y"" | ""z""'\nThis code runs fine, so why the error?\nThe issue is that x ’ s type is inferred as string , whereas the getComponent\nfunction expected a more specific type for its second ar gument. This is\nwidening at work, and here it has led to a type error .\nW idening is ambiguous in the sense that there are many possible types for\nany given value. In this statement, for example:\nconst mixed = ['x', 1];\nwhat should the type of mixed  be? Here are a few possibilities:\n('x' | 1)[]\n['x', 1]\n[string, number]\nreadonly [string, number]\n(string|number)[]\nreadonly (string|number)[]\n[any, any]\nany[]\nW ithout more context, T ypeScript has no way to know which one is “right.”\nIt has to guess at your intent. (In this case, it guesses (string|number)[] .)\nAnd smart as it is, T ypeScript can’ t read your mind. It won’ t get this right\n100% of the time. The result is inadvertent errors like the one we just saw .\nIn the initial example, the type of x  is inferred as string  because\nT ypeScript chooses to allow code like this:\nlet x = 'x';\nx = 'a';\nx = 'Four score and seven years ago...';\nBut it would also be valid JavaScript to write:\nlet x = 'x';\nx = /x|y|z/;\nx = ['x', 'y', 'z'];\nIn inferring the type of x  as string , T ypeScript attempts to strike a balance\nbetween specificity and flexibility . A variable’ s type won’ t change to\nsomething completely dif ferent after it’ s declared ( Item 19 ), so string\nmakes more sense than string|RegExp  or string|string[]  or any .\nThe general rule for primitive values assigned with let  is that they expand\nto their “base type”: ""x""  expands to string , 39  expands to number , true\nexpands to boolean  and so on. ( null  and undefined  are handled\ndif ferently , see Item 25 .)\nT ypeScript gives you a few ways to control the process of widening. One is\nconst . If you declare a variable with const  instead of let , it gets a\nnarrower type. In fact, using const  fixes the error in our original example:\nconst x = 'x';\n//    ^? const x: ""x""\nlet vec = {x: 10, y: 20, z: 30};\ngetComponent(vec, x);  // OK\nBecause x  cannot be reassigned, T ypeScript is able to infer a more precise\ntype without risk of inadvertently flagging errors on subsequent\nassignments. And because the string literal type ""x""  is assignable to\n""x""|""y""|""z"" , the code passes the type checker .\nconst  isn’ t a panacea, however . For objects and arrays, there is still\nambiguity . The mixed  example illustrated the issue for arrays: should\nT ypeScript infer a tuple type? What type should it infer for the elements?\nSimilar issues arise with objects. This code is fine in JavaScript:\nconst obj = { \n  x: 1,\n};\nobj.x = 3;\nobj.x = '3';\nobj.y = 4;\nobj.z = 5;\nobj.name = 'Pythagoras';\nThe type of obj  could be inferred anywhere along the spectrum of\nspecificity . At the specific end is {readonly x: 1} . More general is {x:\nnumber} . More general still would be {[key: string]: number} , object\nor , most general of all, any , or unknown .\nIn the case of objects, T ypeScript infers what it calls  the “best common\ntype.” It determines this by treating each property as though it were\nassigned with let . So the type of obj  comes out as {x: number} . This lets\nyou reassign obj.x  to a dif ferent number , but not to a string . And it\nprevents you from adding other properties via direct assignment. (This is a\ngood reason to build objects all at once, as explained in Item 21 .)\nSo the last four statements are errors:\nconst obj = { \n  x: 1,\n};\nobj.x = 3;  // OK\nobj.x = '3';\n//  ~ Type 'string' is not assignable to type 'number'\nobj.y = 4;\n//  ~ Property 'y' does not exist on type '{ x: number; }'\nobj.z = 5;\n//  ~ Property 'z' does not exist on type '{ x: number; }'\nobj.name = 'Pythagoras';\n//  ~~~~ Property 'name' does not exist on type '{ x: number; }'\nAgain, T ypeScript is trying to strike a balance between specificity and\nflexibility . It needs to infer a specific enough type to catch errors, but not\nsuch a specific type that it creates false positives. It does this by inferring a\ntype of number  for a property initialized to a value like 1 .\nIf you know better , there are a few ways to override T ypeScript’ s default\nbehavior . One is to supply an  explicit type annotation:\nconst obj: { x: string | number } = { x: 1 };\n//    ^? const obj: { x: string | number; }\nAnother is to provide additional context to the type checker , e.g., by passing\nthe value as an ar gument to a function ( Item 24 ).\nA third way is with  a const  assertion. This is not to be confused with let\nand const , which introduce symbols in value space. This is a purely type-\nlevel construct. Look at the dif ferent inferred types for these variables:\nconst obj1 = { x: 1, y: 2 };\n//    ^? const obj1: { x: number; y: number; } \n \nconst obj2 = { x: 1 as const, y: 2 };\n//    ^? const obj2: { x: 1; y: number; } \n \nconst obj3 = { x: 1, y: 2 } as const;\n//    ^? const obj3: { readonly x: 1; readonly y: 2; }\nWhen you write as const  after a value, T ypeScript will infer the narrowest\npossible type for it. There is no  widening. For true constants, this is\ntypically what you want. Y ou can also use as const  with arrays to infer a\ntuple type:\nconst arr1 = [1, 2, 3];\n//    ^? const arr1: number[]\nconst arr2 = [1, 2, 3] as const;\n//    ^? const arr2: readonly [1, 2, 3]\nDespite the similar syntax, a const  assertion should not be confused with a\ntype assertion ( as T ). While type assertions are best avoided ( Item 9 ), a\nconst  assertion doesn’ t compromise type safety and is always OK.\nThere’ s a handy trick if you want T ypeScript to infer a tuple type instead of\nan array type, but still allow the type of each element in the tuple to widen\nto its base type / best common type:\nfunction tuple<T extends unknown[]>(...elements: T) { return elements; } \n \nconst arr3 = tuple(1, 2, 3);\n//    ^? const arr3: [number, number, number]\nconst mix = tuple(4, 'five', true);\n//    ^? const mix: [number, string, boolean]\nThe tuple  function here serves no purpose at runtime, but guides\nT ypeScript toward inferring the type you want. Another function that can\nguide inference is  JavaScript’ s Object.freeze :\nconst frozenArray = Object.freeze([1, 2, 3]);\n//    ^? const frozenArray: readonly number[]\nconst frozenObj = Object.freeze({x: 1, y: 2});\n//    ^? const frozenObj: Readonly<{ x: 1; y: 2; }>\nLike a const  assertion, Object.freeze  has introduced some readonly\nmodifiers into the inferred types (though it displays dif ferently , the type of\nfrozenObj  is exactly the same as obj3 ). Unlike a const  assertion, the\n“freeze” will be enforced by your JavaScript runtime. But it’ s a shallow\nfreeze/readonly , whereas a const  assertion is deep. Item 14  discusses\nreadonly  and how it can help prevent mistakes.\nFinally , a fourth way to control widening is the satisfies  operator . This\nensures that a value, well, satisfies the requirements of a type and guides\ninference by preventing T ypeScript from inferring a wider type. Here’ s how\nit works:\ntype Point = [number, number];\nconst capitals1 = { ny: [-73.7562, 42.6526], ca: [-121.4944, 38.5816] };\n//    ^? const capitals1: { ny: number[]; ca: number[]; } \n \nconst capitals2 = { \n  ny: [-73.7562, 42.6526], ca: [-121.4944, 38.5816]\n} satisfies Record<string, Point>;\ncapitals2\n// ^? const capitals2: { ny: [number, number]; ca: [number, number]; }\nLeft to its own devices, T ypeScript takes the keys from the object literal and\nwidens the values to number[] , just as it would with let . W ith satisfies ,\nwe prevent the values from being widened beyond the Point  type.\nCompare this to what you get from an annotation using the same type:\nconst capitals3: Record<string, Point> = capitals2;\ncapitals3.pr;  // undefined at runtime\n//        ^? Point\ncapitals2.pr;\n//        ~~ Property 'pr' does not exist on type '{ ny: ...; ca: ...; }'\nThe type coming from satisfies  has precise keys, which helps to catch\nerrors.\nThe satisfies  operator will report an error if part of the object isn’ t\nassignable to the type:\nconst capitalsBad = { \n    ny: [-73.7562, 42.6526, 148],\n//  ~~ Type '[number, number, number]' is not assignable to type 'Point'. \n    ca: [-121.4944, 38.5816, 26],\n//  ~~ Type '[number, number, number]' is not assignable to type 'Point'.\n} satisfies Record<string, Point>;\nThis is an improvement over a const  assertion because it will report the\nerror where you define the object, rather than where you use it.\nIf you’re getting incorrect errors that you think are due to widening,\nconsider changing let  to const , adding some explicit type annotations,\nusing a helper function like tuple  or Object.freeze , or using a const\nassertion or a satisfies  clause. As always, inspecting types in your editor\nis the key to building an intuition for how this  works (see Item 6 ).\nThings to Remember\nUnderstand how T ypeScript infers a type from a literal by widening it.",10586
29-Item 21 Create Objects All at Once.pdf,29-Item 21 Create Objects All at Once,"Familiarize yourself with the ways you can af fect this behavior: const ,\ntype annotations, context, helper  functions, as const , and satisfies .\nI t e m  2 1 :  C r e a t e  O b j e c t s  A l l  a t  O n c e\nAs Item 19  explained, while a variable’ s value may change, its type in\nT ypeScript generally does not. This makes some JavaScript patterns easier\nto model in T ypeScript than others. In particular , it means that you should\nprefer creating objects all at once, rather than piece by piece.\nHere’ s one way to create an object representing a two-dimensional point in\nJavaScript:\nconst pt = {};\npt.x = 3;\npt.y = 4;\nIn T ypeScript, this will produce errors on each assignment:\nconst pt = {};\n//    ^? const pt: {}\npt.x = 3;\n// ~ Property 'x' does not exist on type '{}'\npt.y = 4;\n// ~ Property 'y' does not exist on type '{}'\nThis is because the type of pt  on the first line is inferred based on its value\n{} , and you may only assign to known properties.\nY ou get the opposite problem if you define a Point  interface:\ninterface Point { x: number; y: number; }\nconst pt: Point = {}; \n   // ~~ Type '{}' is missing the following properties from type 'Point': x, y\npt.x = 3;\npt.y = 4;\nA type assertion seems to of fer a solution:\nconst pt = {} as Point;\n//    ^? const pt: Point\npt.x = 3;\npt.y = 4;  // OK\nThe problem with this pattern is that T ypeScript won’ t check that you’ve\nassigned all the  properties to pt  before using it. If you dropped the\nassignment to pt.y , for example,  the code would still pass the type checker\nbut might lead to NaN s or runtime  exceptions. As Item 9  explained, type\nassertions shouldn’ t be the first tool you reach for .\nThe best solution is to define the object all at once with a  type declaration:\nconst pt: Point = { \n  x: 3, \n  y: 4,\n};\nIf you need to build a lar ger object from smaller ones, avoid doing it in\nmultiple steps:\nconst pt = {x: 3, y: 4};\nconst id = {name: 'Pythagoras'};\nconst namedPoint = {};\nObject.assign(namedPoint, pt, id);\nnamedPoint.name; \n        // ~~~~ Property 'name' does not exist on type '{}'\nY ou can build the lar ger object all at once instead using object spr ead\nsyntax , ... :\nconst namedPoint = {...pt, ...id};\n//    ^? const namedPoint: { name: string; x: number; y: number; }\nnamedPoint.name;  // OK\n//         ^? (property) name: string\nY ou can also use object spread syntax to build up objects field by field in a\ntype-safe way . The key is to use a new variable on every update so that each\ngets a new type ( Item 19 ):\nconst pt0 = {};\nconst pt1 = {...pt0, x: 3};\nconst pt: Point = {...pt1, y: 4};  // OK\nThe type declaration on the final line ensures that we’ve added all the\nnecessary properties. While this is a roundabout way to build up such a\nsimple object, it can be a useful technique for adding properties to an object\nand allowing T ypeScript to infer a new type.\nT o conditionally add a property in a type-safe way , you can use spread\nsyntax with {}  or any falsy value ( null , undefined , false , etc.), which\nadd no properties:\ndeclare let hasMiddle: boolean;\nconst firstLast = {first: 'Harry', last: 'Truman'};\nconst president = {...firstLast, ...(hasMiddle ? {middle: 'S'} : {})};\n//    ^? const president: {\n//         middle?: string;\n//         first: string;\n//         last: string;\n//       }\n// or: const president = {...firstLast, ...(hasMiddle && {middle: 'S'})};\nAs you can see, the inferred type has an optional property .\nY ou can also use spread syntax to add multiple fields conditionally:\ndeclare let hasDates: boolean;\nconst nameTitle = {name: 'Khufu', title: 'Pharaoh'};\nconst pharaoh = { ...nameTitle, ...(hasDates && {start: -2589, end: -2566})};\n//    ^? const pharaoh: {\n//         start?: number;\n//         end?: number;\n//         name: string;\n//         title: string;\n//       }\nIn this case, both start  and end  have become optional fields. If you read\nstart  of f this type, you’ll have to consider the possibility that it’ s\nundefined :",4072
30-Item 22 Understand Type Narrowing.pdf,30-Item 22 Understand Type Narrowing,"const {start} = pharaoh;\n//     ^? const start: number | undefined\nSometimes you want to build an object or array by transforming another\none. In this case, the equivalent of “building objects all at once” is using\nbuilt-in functional constructs or utility libraries  like Lodash rather than\nloops. See Item 26  for more on this.\nThings to Remember\nPrefer to build objects all at once rather than piecemeal.\nUse multiple objects and object spread syntax ( {...a, ...b} ) to add\nproperties in a type-safe way .\nKnow how to conditionally add properties to an object.\nI t e m  2 2 :  U n d e r s t a n d  T y p e  N a r r o w i n g\nNarrowing, or “refinement,” is the process by which T ypeScript goes from\na broad type to a more specific one. Perhaps the most common example of\nthis is  null checking:\nconst elem = document.getElementById('what-time-is-it');\n//    ^? const elem: HTMLElement | null\nif (elem) { \n  elem.innerHTML = 'Party Time'.blink(); \n  // ^? const elem: HTMLElement\n} else { \n  elem \n  // ^? const elem: null \n  alert('No element #what-time-is-it');\n}\nIf elem  is null , then the code in the first branch won’ t execute. So\nT ypeScript is able to exclude null  from the union type within this block,\nresulting in a narrower type which is much easier to work with. Because the\ncompiler is following the paths of execution of your code, this is also\nknown as control flow analysis. The type checker is generally quite good at\nfollowing your logic and narrowing types in conditionals like these, though\nit can occasionally be thwarted by aliasing ( Item 23 ).\nNotice how the same symbol, elem , has dif ferent static types at dif ferent\nlocations in your code. This is a somewhat unusual ability amongst\nprogramming languages: in C++ , Java, and Rust, for example, a variable\nhas a single type for its entire lifetime. If you want to narrow its type, you\nalso need to create a new variable. But in T ypeScript, a symbol has a type at\na location . Learn to take advantage of this and you’ll write more concise,\nidiomatic T ypeScript.\nThere are many ways that you can narrow a type. Throwing or returning\nfrom a branch will narrow a variable’ s type for the rest of a block:\nconst elem = document.getElementById('what-time-is-it');\n//    ^? const elem: HTMLElement | null\nif (!elem) throw new Error('Unable to find #what-time-is-it');\nelem.innerHTML = 'Party Time'.blink();\n// ^? const elem: HTMLElement\nY ou can also use instanceof :\nfunction contains(text: string, search: string | RegExp) { \n  if (search instanceof RegExp) { \n    return !!search.exec(text); \n    //       ^? (parameter) search: RegExp \n  } \n  return text.includes(search); \n  //                   ^? (parameter) search: string\n}\nA property check also works:\ninterface Apple { isGoodForBaking: boolean; }\ninterface Orange { numSlices: number; }\nfunction pickFruit(fruit: Apple | Orange) { \n  if ('isGoodForBaking' in fruit) { \n    fruit \n    // ^? (parameter) fruit: Apple \n  } else { \n    fruit \n    // ^? (parameter) fruit: Orange \n  } \n  fruit \n  // ^? (parameter) fruit: Apple | Orange\n}\nSome built-in functions  such as Array.isArray  are also able to narrow\ntypes:\nfunction contains(text: string, terms: string | string[]) { \n  const termList = Array.isArray(terms) ? terms : [terms]; \n  //    ^? const termList: string[] \n  // ...\n}\nT ypeScript is generally quite good at tracking types through conditionals.\nThink twice before adding a type assertion—it might be on to something\nthat you’re not! For example, this is the wrong way to exclude null  from a\nunion type:\nconst elem = document.getElementById('what-time-is-it');\n//    ^? const elem: HTMLElement | null\nif (typeof elem === 'object') { \n  elem; \n  // ^? const elem: HTMLElement | null\n}\nBecause typeof null  is ""object""  in JavaScript, you have not, in fact,\nexcluded null  with this check!1 Similar surprises can come from falsy\nprimitive values:\nfunction maybeLogX(x?: number | string | null) { \n  if (!x) { \n    console.log(x); \n    //          ^? (parameter) x: string | number | null | undefined \n  }\n}\nBecause the empty string and 0  are both falsy , x  could still be a string  or\nnumber  in that branch. T ypeScript is right!\nAnother common way to help the type checker narrow your types is by\nputting an explicit “tag” on them:\ninterface UploadEvent { type: 'upload'; filename: string; contents: string }\ninterface DownloadEvent { type: 'download'; filename: string; }\ntype AppEvent = UploadEvent | DownloadEvent; \n \nfunction handleEvent(e: AppEvent) { \n  switch (e.type) { \n    case 'download': \n      console.log('Download', e.filename); \n      //                      ^? (parameter) e: DownloadEvent \n      break; \n    case 'upload': \n      console.log('Upload', e.filename, e.contents.length, 'bytes'); \n      //                    ^? (parameter) e: UploadEvent \n      break; \n  }\n}\nThis is known as a “tagged union” or “discriminated union,” and it is\nubiquitous in T ypeScript. Chapter 4  will revisit this pattern. When you write\nswitch  statements, it’ s a good idea to test that you’ve covered all\npossibilities. Item 59  shows you how .\nIf T ypeScript isn’ t able to figure out a type, you can introduce a special\nfunction to help it out:\nfunction isInputElement(el: Element): el is HTMLInputElement { \n  return 'value' in el;\n} \n \nfunction getElementContent(el: HTMLElement) { \n  if (isInputElement(el)) { \n    return el.value; \n    //     ^? (parameter) el: HTMLInputElement \n  } \n  return el.textContent; \n  //     ^? (parameter) el: HTMLElement\n}\nThis is known as a “user -defined type guard,” and the el is\nHTMLInputElement  clause is called a “type predicate.” As a return type,\nthis type tells the type checker that it can narrow the type of the parameter if\nthe function returns true.\nSome functions are able to use type guards to narrow types in arrays or\nobjects, notably the filter  method on Array s:\nconst formEls = document.querySelectorAll('.my-form *');\nconst formInputEls = [...formEls].filter(isInputElement);\n//    ^? const formInputEls: HTMLInputElement[]\nIt’ s important to note user -defined type guards are no safer than a type\nassertion ( el as HTMLInputElement ): there’ s nothing checking that the\nbody of a type guard corresponds to the type predicate it returns. (In this\ncase, in fact, there are a few Element s with a value  property that are not\nHTMLInputElement s.)\nY ou can often rework your code slightly to help T ypeScript follow along.\nThis code using a Map  is correct but produces a type error:\nconst nameToNickname = new Map<string, string>();\ndeclare let yourName: string;\nlet nameToUse: string;\nif (nameToNickname.has(yourName)) { \n  nameToUse = nameToNickname.get(yourName); \n  // ~~~~~~ Type 'string | undefined' is not assignable to type 'string'.\n} else { \n  nameToUse = yourName;\n}\nThe issue is that T ypeScript doesn’ t understand the relationship between the\nhas  and get  methods of a Map . It doesn’ t know that checking has\neliminates the possibility of undefined  in a subsequent lookup with get . A\nslight change eliminates the type error (and preserves the behavior):\nconst nickname = nameToNickname.get(yourName);\nlet nameToUse: string;\nif (nickname !== undefined) { \n  nameToUse = nickname;\n} else { \n  nameToUse = yourName;\n}\nThis pattern is common and can be written more concisely using the\n“nullish coalescing” operator ( ?? ):\nconst nameToUse = nameToNickname.get(yourName) ?? yourName;\nIf you find yourself fighting with the type checker in a conditional, think\nabout whether you can rework it to help T ypeScript follow along.\nIt’ s also helpful to understand when types don’ t  narrow . One notable\nexample is in callbacks:\nfunction logLaterIfNumber(obj: { value: string | number }) { \n  if (typeof obj.value === ""number"") { \n    setTimeout(() => console.log(obj.value.toFixed())); \n    //                                     ~~~~~~~ \n    // Property 'toFixed' does not exist on type 'string | number'. \n  }\n}\nW e’ve done a typeof  check which should narrow the type of obj.value .\nSo why did it revert back to the union type, which produced a type error?\nIt’ s because the calling code might look like this:\nconst obj: { value: string | number } = { value: 123 };\nlogLaterIfNumber(obj);\nobj.value = 'Cookie Monster';\nBy the time the callback runs, the type of obj.value  has changed,\ninvalidating the refinement. This code throws an exception at runtime, and\nT ypeScript is right to warn you about it.\nUnderstanding how types narrow will help you build an intuition for how\ntype inference works, make sense of errors, and generally have a more\nproductive relationship with the type checker .",8820
31-Item 23 Be Consistent in Your Use of Aliases.pdf,31-Item 23 Be Consistent in Your Use of Aliases,"Things to Remember\nUnderstand how T ypeScript narrows types based on conditionals and\nother types of control flow .\nUse tagged/discriminated unions and user -defined type guards to help\nthe process of narrowing.\nThink about whether code can be refactored to let T ypeScript follow\nalong more easily .\nI t e m  2 3 :  B e  C o n s i s t e n t  i n  Y o u r  U s e  o f  A l i a s e s\nWhen you introduce a new name for a value:\nconst place = {name: 'New York', latLng: [41.6868, -74.2692]};\nconst loc = place.latLng;\nyou have created an alias . Changes to properties on the alias will be visible\non the original value as well:\n> loc[0] = 0; \n0 \n> place.latLng \n[ 0, -74.2692 ]\nIf you’ve used a language that has pointer or reference types, this is the\nsame idea. There are two variables that point to the same underlying object.\nAliases are the bane of compiler writers in all languages because they make\ncontrol flow analysis dif ficult. If you’re deliberate in your use of aliases,\nT ypeScript will be able to understand your code better and help you find\nmore real errors.\nSuppose you have a data structure that represents a polygon:\ninterface Coordinate { \n  x: number; \n  y: number;\n} \n \ninterface BoundingBox { \n  x: [number, number]; \n  y: [number, number];\n} \n \ninterface Polygon { \n  exterior: Coordinate[]; \n  holes: Coordinate[][]; \n  bbox?: BoundingBox;\n}\nThe geometry of the polygon is specified by the exterior  and holes\nproperties. (The holes  array lets you represent doughnut shapes, which\nhave holes in the interior .) The bbox  property is an optimization that may or\nmay not be present. Y ou can use it to speed up a point-in-polygon check:\nfunction isPointInPolygon(polygon: Polygon, pt: Coordinate) { \n  if (polygon.bbox) { \n    if (pt.x < polygon.bbox.x[0] || pt.x > polygon.bbox.x[1] || \n        pt.y < polygon.bbox.y[0] || pt.y > polygon.bbox.y[1]) { \n      return false; \n    } \n  } \n \n  // ... more complex check\n}\nThis code works (and type checks) but is a bit repetitive: polygon.bbox\nappears five times in three lines! Here’ s an attempt to factor out an\nintermediate variable to reduce duplication:\nfunction isPointInPolygon(polygon: Polygon, pt: Coordinate) { \n  const box = polygon.bbox; \n  if (polygon.bbox) { \n    if (pt.x < box.x[0] || pt.x > box.x[1] || \n        //     ~~~                ~~~  'box' is possibly 'undefined' \n        pt.y < box.y[0] || pt.y > box.y[1]) { \n        //     ~~~                ~~~  'box' is possibly 'undefined' \n      return false; \n    } \n  } \n  // ...\n}\nThis code still works, so why the error? By factoring out the box  variable,\nyou’ve created an alias for polygon.bbox , and this has thwarted the control\nflow analysis that quietly worked in the first example.\nY ou can inspect the types of box  and polygon.bbox  to see what’ s\nhappening:\nfunction isPointInPolygon(polygon: Polygon, pt: Coordinate) { \n  polygon.bbox \n  //      ^? (property) Polygon.bbox?: BoundingBox | undefined \n  const box = polygon.bbox; \n  //    ^? const box: BoundingBox | undefined \n  if (polygon.bbox) { \n    console.log(polygon.bbox); \n    //                  ^? (property) Polygon.bbox?: BoundingBox \n    console.log(box); \n    //          ^? const box: BoundingBox | undefined \n  }\n}\nThe property check refines the type of polygon.bbox  but not the type of\nbox , hence the errors. This leads us to the golden rule of aliasing: if you\nintr oduce an alias, use it consistently .\nUsing box  in the property check fixes the error:\nfunction isPointInPolygon(polygon: Polygon, pt: Coordinate) { \n  const box = polygon.bbox; \n  if (box) { \n    if (pt.x < box.x[0] || pt.x > box.x[1] || \n        pt.y < box.y[0] || pt.y > box.y[1]) {  // OK \n      return false; \n    } \n  } \n  // ...\n}\nThe type checker is happy now , but there’ s an issue for human readers.\nW e’re using two names for the same thing: box  and bbox . This is a\ndistinction without a dif ference ( Item 41 ).\nObject destructuring syntax rewards consistent naming by letting us write\nmore concise code. Y ou can even use it on arrays and nested structures:\nfunction isPointInPolygon(polygon: Polygon, pt: Coordinate) { \n  const {bbox} = polygon; \n  if (bbox) { \n    const {x, y} = bbox; \n    if (pt.x < x[0] || pt.x > x[1] || pt.y < y[0] || pt.y > y[1]) { \n      return false; \n    } \n  } \n  // ...\n}\nA few other points:\nThis code would have required more property checks if the x  and y\nproperties had been optional, rather than the whole bbox  property . W e\nbenefited from following the advice of Item 33 , which discusses the\nimportance of pushing null values to the perimeter of your types.\nAn optional property was appropriate for bbox  but would not have\nbeen appropriate for holes . If holes  was optional, then it would be\npossible for it to be either missing or an empty array ( [] ). This would\nbe a distinction without a dif ference. An empty array is a fine way to\nindicate “no holes.”\nIn your interactions with the type checker , don’ t for get that aliasing can\nintroduce confusion at runtime, too:\nconst {bbox} = polygon;\nif (!bbox) { \n  calculatePolygonBbox(polygon);  // Fills in polygon.bbox \n  // Now polygon.bbox and bbox refer to different values!\n}\nT ypeScript’ s control flow analysis tends to be quite good for local variables.\nBut for properties you should be on guard:\nfunction expandABit(p: Polygon) { /* ... */ } \n \npolygon.bbox\n//      ^? (property) Polygon.bbox?: BoundingBox | undefined\nif (polygon.bbox) { \n  polygon.bbox \n  //      ^? (property) Polygon.bbox?: BoundingBox \n  expandABit(polygon); \n  polygon.bbox \n  //      ^? (property) Polygon.bbox?: BoundingBox\n}\nThe call to expandABit(polygon)  could very well un-set polygon.bbox ,\nso it would be safer for the type to revert to BoundingBox | undefined .\nBut this would get frustrating: you’d have to repeat your property checks\nevery time you called a function. So T ypeScript makes the pragmatic choice\nto assume the function does not invalidate its type refinements. Item 48\ndiscusses other situations like this where T ypeScript trades safety for\nconvenience.\nIf you’d factored out a local bbox  variable instead of using polygon.bbox ,\nthe type of bbox  would remain accurate, but it might no longer be the same\nvalue as polygon.bbox .  If you’re concerned about these sorts of side\nef fects, the best option is to pass a read-only version of polygon  to the\nfunction ( Item 14 ). By preventing mutation, we also improve type safety .\nThis is a concern specifically for object types (including arrays) because\nthey are mutable. Primitive values (numbers, strings, etc.) are already\nimmutable.\nThings to Remember\nAliasing can prevent T ypeScript from narrowing types. If you create\nan alias for a variable, use it consistently .",6891
32-Item 24 Understand How Context Is Used in Type Inference.pdf,32-Item 24 Understand How Context Is Used in Type Inference,"Be aware of how function calls can invalidate type refinements on\nproperties. T rust refinements on local variables more than on\nproperties.\nI t e m  2 4 :  U n d e r s t a n d  H o w  C o n t e x t  I s  U s e d  i n\nT y p e  I n f e r e n c e\nT ypeScript doesn’ t just infer types based on values. It also considers the\ncontext in which the value occurs. This usually works well but can\nsometimes lead to surprises. Understanding how context is used in type\ninference will help you identify and work around these surprises when they\ndo occur .\nIn JavaScript, you can factor out an expression into a constant without\nchanging the behavior of your code (so long as you don’ t alter execution\norder). In other words, these two statements are equivalent:\n// Inline form\nsetLanguage('JavaScript'); \n \n// Reference form\nlet language = 'JavaScript';\nsetLanguage(language);\nIn T ypeScript, this refactor still works:\nfunction setLanguage(language: string) { /* ... */ } \n \nsetLanguage('JavaScript');  // OK \n \nlet language = 'JavaScript';\nsetLanguage(language);  // OK\nNow suppose you take to heart the advice of Item 35  and replace the string\ntype with a more precise union of string literal types:\ntype Language = 'JavaScript' | 'TypeScript' | 'Python';\nfunction setLanguage(language: Language) { /* ... */ } \n \nsetLanguage('JavaScript');  // OK \n \nlet language = 'JavaScript';\nsetLanguage(language);\n//          ~~~~~~~~ Argument of type 'string' is not assignable\n//                   to parameter of type 'Language'\nWhat went wrong? W ith the inline form, T ypeScript knows from the\nfunction declaration that the parameter is supposed to be of type Language .\nThe string literal 'JavaScript'  is assignable to this type, so this is OK.\nBut when you factor out a variable, T ypeScript must infer its type at the\ntime of assignment. It applies the usual algorithm ( Item 20 ) and infers\nstring , which is not assignable to Language . Hence the error .\nN O T E\nSome languages are able to infer types for variables based on their eventual usage. But\nthis can also be confusing. Anders Hejlsber g, the creator of T ypeScript, refers to it as\n“spooky action at a distance.” By and lar ge, T ypeScript determines the type of a variable\nwhen it is first introduced. For a notable exception to this rule, see Item 25 .\nThere are two good ways to solve this problem. One is to constrain the\npossible values of language  with a type annotation:\nlet language: Language = 'JavaScript';\nsetLanguage(language);  // OK\nThis also has the benefit of flagging an error if there’ s a typo in the\nlanguage—for example 'Typescript'  (it should be a capital “S”).\nThe other solution is to make the variable constant:\nconst language = 'JavaScript';\n//    ^? const language: ""JavaScript""\nsetLanguage(language);  // OK\nBy using const , we’ve told the type checker that this variable cannot\nchange. So T ypeScript can infer a more precise type for language , namely\nthe string literal type ""JavaScript"" .  This is assignable to Language  so the\ncode type checks. Of course, if you do need to reassign language , then\nyou’ll need to use the type annotation.\nThe fundamental issue here is that we’ve separated the value from the\ncontext in which it’ s used. Sometimes this is OK, but often it is not. The\nrest of this item walks through a few cases where this loss of context can\ncause errors and shows you how to fix them.\nT uple T ypes\nIn addition to string literal types, problems can come up with tuple types.\nSuppose you’re working with a map visualization that lets you\nprogrammatically pan the map:\n// Parameter is a (latitude, longitude) pair.\nfunction panTo(where: [number, number]) { /* ... */ } \n \npanTo([10, 20]);  // OK \n \nconst loc = [10, 20];\n//    ^? const loc: number[]\npanTo(loc);\n//    ~~~ Argument of type 'number[]' is not assignable to\n//        parameter of type '[number, number]'\nAs before, you’ve separated a value from its context. In the first instance,\n[10, 20]  is assignable to the tuple type [number, number] . In the second,\nT ypeScript infers the type of loc  as number[]  (i.e., an array of numbers of\nunknown length). This is not assignable to the tuple type, since many arrays\nhave the wrong number of elements.\nSo how can you fix this error without resorting to any ? Y ou’ve already\ndeclared it const , so that won’ t help. But you can still provide a type\nannotation to let T ypeScript know precisely what you mean:\nconst loc: [number, number] = [10, 20];\npanTo(loc);  // OK\nAs Item 20  explained, another way is to provide a “const context.” This\ntells T ypeScript that you intend the value to be deeply constant, rather than\nthe shallow constant that const  gives:\nconst loc = [10, 20] as const;\n//    ^? const loc: readonly [10, 20]\npanTo(loc);\n//    ~~~ The type 'readonly [10, 20]' is 'readonly'\n//        and cannot be assigned to the mutable type '[number, number]'\nThe type of loc  is now inferred as readonly [10, 20] , rather than\nnumber[] . Unfortunately this is too  precise! The type signature of panTo\nmakes no promises that it won’ t modify the contents of its where  parameter .\nSince the loc  parameter has a readonly  type, this won’ t do.\nThe best solution here is to add a readonly  annotation to the panTo\nfunction:\nfunction panTo(where: readonly [number, number]) { /* ... */ }\nconst loc = [10, 20] as const;\npanTo(loc);  // OK\nIf the type signature is outside your control, then you’ll need to use an\nannotation. ( Item 14  has more to say about readonly  and type safety .)\nconst  contexts can neatly solve issues around losing context in inference,\nbut they do have an unfortunate downside: if you make a mistake in the\ndefinition (say you add a third element to the tuple), then the error will be\nflagged at the call site, not at the definition. This may be confusing,\nespecially if the error occurs in a deeply nested object that’ s used far from\nwhere it’ s defined:\nconst loc = [10, 20, 30] as const;  // error is really here.\npanTo(loc);\n//    ~~~ Argument of type 'readonly [10, 20, 30]' is not assignable to\n//        parameter of type 'readonly [number, number]'\n//          Source has 3 element(s) but target allows only 2.\nFor this reason, it’ s preferable to use the inline form or apply a type\ndeclaration.\nObjects\nThe problem of separating a value from its context also comes up when you\nfactor out a constant from a lar ger object that contains some string literals\nor tuples. For example:\ntype Language = 'JavaScript' | 'TypeScript' | 'Python';\ninterface GovernedLanguage { \n  language: Language; \n  organization: string;\n} \n \nfunction complain(language: GovernedLanguage) { /* ... */ } \n \ncomplain({ language: 'TypeScript', organization: 'Microsoft' });  // OK \n \nconst ts = { \n  language: 'TypeScript', \n  organization: 'Microsoft',\n};\ncomplain(ts);\n//       ~~ Argument of type '{ language: string; organization: string; }'\n//            is not assignable to parameter of type 'GovernedLanguage'\n//          Types of property 'language' are incompatible\n//            Type 'string' is not assignable to type 'Language'\nIn the ts  object, the type of language  is inferred as string . As before, the\nsolution is to add a type annotation ( const ts: GovernedLanguage =\n... ), use a const assertion ( as const ), or the satisfies  operator ( Item\n20 ).\nCallbacks\nWhen you pass a callback to another function, T ypeScript uses context to\ninfer the parameter types of the callback:\nfunction callWithRandomNumbers(fn: (n1: number, n2: number) => void) { \n  fn(Math.random(), Math.random());\n} \n \ncallWithRandomNumbers((a, b) => { \n  //                   ^? (parameter) a: number \n  console.log(a + b); \n  //              ^? (parameter) b: number\n});\nThe types of a  and b  are inferred as number  because of the type declaration\nfor callWithRandomNumbers . If you factor the callback out into a constant,\nyou lose that context and get noImplicitAny  errors:\nconst fn = (a, b) => { \n  //        ~    Parameter 'a' implicitly has an 'any' type \n  //           ~ Parameter 'b' implicitly has an 'any' type \n  console.log(a + b);\n}\ncallWithRandomNumbers(fn);\nThe solution is either to add type annotations to the parameters:\nconst fn = (a: number, b: number) => { \n  console.log(a + b);\n}\ncallWithRandomNumbers(fn);\nor to apply a type declaration to the entire function expression if one is\navailable (see Item 12 ). If the function is only used in one place, prefer the\ninline form since it reduces the need for annotations.\nThings to Remember\nBe aware of how context is used in type inference.",8719
33-Item 25 Understand Evolving Types.pdf,33-Item 25 Understand Evolving Types,"If factoring out a variable introduces a type error , maybe add a type\nannotation.\nIf the variable is truly a constant, use a const assertion ( as const ). But\nbe aware that this may result in errors surfacing at use, rather than\ndefinition.\nPrefer inlining values where it’ s practical to reduce the need for type\nannotations.\nI t e m  2 5 :  U n d e r s t a n d  E v o l v i n g  T y p e s\nIn T ypeScript, a variable’ s type is generally determined when it is declared.\nAfter this, it can be narr owed  (by checking if it is null , for instance; see\nItem 22 ), but it cannot expand to include new values. There is one notable\nexception to this, however , and that is “evolving types.” Understanding how\nthese work will reduce the need for type annotations in your code and help\nyou read T ypeScript code that uses this convenient pattern.\nIn  JavaScript, you might write a function to generate a range of numbers,\nlike this:\nfunction range(start, limit) { \n  const nums = []; \n  for (let i = start; i < limit; i++) { \n    nums.push(i); \n  } \n  return nums;\n}\nWhen you convert this to T ypeScript, it works exactly as you’d expect:\nfunction range(start: number, limit: number) { \n  const nums = []; \n  for (let i = start; i < limit; i++) { \n    nums.push(i); \n  } \n  return nums; \n  //     ^? const nums: number[]\n}\nUpon closer inspection, however , it’ s surprising that this works! How does\nT ypeScript know that the type of nums  is number[]  when it’ s initialized as\n[] , which could be an array of any type? Clearly T ypeScript is not\nfollowing its usual rules for deriving a type from a literal value ( Item 20 ).\nInspecting each of the three occurrences of nums  to reveal its inferred type\nstarts to tell the story:\nfunction range(start: number, limit: number) { \n  const nums = []; \n  //    ^? const nums: any[] \n  for (let i = start; i < limit; i++) { \n    nums.push(i); \n    // ^? const nums: any[] \n  } \n  return nums; \n  //     ^? const nums: number[]\n}\nThe type of nums  starts as any[] , an undif ferentiated array . But after we\npush number  values onto it, its type “evolves” to become number[] .\nThis is distinct from narrowing (aka “refinement”). An empty array’ s type\ncan expand by pushing dif ferent elements onto it:\nconst result = [];\n//    ^? const result: any[]\nresult.push('a');\nresult\n// ^? const result: string[]\nresult.push(1);\nresult\n// ^? const result: (string | number)[]\nW ith conditionals, the type can even vary across branches. Here you can see\nthe same behavior with a simple value, rather than an array:\nlet value;\n//  ^? let value: any\nif (Math.random() < 0.5) { \n  value = /hello/; \n  value \n  // ^? let value: RegExp\n} else { \n  value = 12; \n  value \n  // ^? let value: number\n}\nvalue\n// ^? let value: number | RegExp\nN O T E\nThis behavior can be confusing to follow in your editor since the type is only “evolved”\nafter  you assign or push an element. Inspecting the type on the line with the assignment\nstill shows any  or any[] .\nThis construct is a convenient way to reduce the need for type annotations.\nY ou can use it in your own code, and you should recognize it in code that\nyou read. It’ s sometimes known as “evolving any” because the variable\nimplicitly has an any  type, but this is not a dangerous any  (more on that\nmomentarily). It’ s also sometimes called “evolving let ” or “evolving\narrays.”\nAnother case that triggers this “evolving” behavior is if a variable is\ninitially set to null  or undefined . This often comes up when you set a\nvalue in a try /catch  block:\nlet value = null;\n//  ^? let value: any\ntry { \n  value = doSomethingRiskyAndReturnANumber(); \n  value \n  // ^? let value: number\n} catch (e) { \n  console.warn('alas!');\n}\nvalue\n// ^? let value: number | null\nIf you try to use an evolving type before you set it or push values onto it,\nyou’ll get an  implicit any  error:\nfunction range(start: number, limit: number) { \n  const nums = []; \n  //    ~~~~ Variable 'nums' implicitly has type 'any[]' in some \n  //         locations where its type cannot be determined \n  if (start === limit) { \n    return nums; \n    //     ~~~~ Variable 'nums' implicitly has an 'any[]' type \n  } \n  for (let i = start; i < limit; i++) { \n    nums.push(i); \n  } \n  return nums;\n}\nPut another way , evolving types are only any  when you write  to them. If\nyou try to r ead  from them while they’re still any , you’ll get an error . This\nisn’ t the scary any  that Item 5  warned you about. It won’ t spread through\nyour application like other any  types.\nImplicit any  types do not evolve through function calls. The arrow function\nhere trips up inference:\nfunction makeSquares(start: number, limit: number) { \n  const nums = []; \n  //    ~~~~ Variable 'nums' implicitly has type 'any[]' in some locations \n  range(start, limit).forEach(i => { \n    nums.push(i * i); \n  }); \n  return nums; \n  //     ~~~~ Variable 'nums' implicitly has an 'any[]' type\n}\nImproved type inference is a good reason to prefer for-of  loops to\nforEach  loops in T ypeScript. For this specific case, though, it would be\nbetter to use the built-in array map  method to transform the array in a single",5266
34-Item 26 Use Functional Constructs and Libraries to Help Types Flow.pdf,34-Item 26 Use Functional Constructs and Libraries to Help Types Flow,"statement, avoiding iteration and evolving types entirely . See Item 26  for\nmore on how functional constructs can help types flow .\nEvolving types come with all the usual caveats about type inference. Is the\ncorrect type for your array really (string|number)[] ? Or should it be\nnumber[]  and you incorrectly pushed a string ? Y ou may still want to\nprovide an explicit type annotation to get better error checking instead of\nusing an evolving type, or at least annotate the return type of your function\nto make sure that implementation errors don’ t escape into the type signature\n( Item 18 ).\nWhen you build an array by push ing elements onto it or set a value\nconditionally , consider whether you can use the evolving type construct to\nreduce the need for type annotations and to help types flow through your\ncode.\nThings to Remember\nWhile T ypeScript types typically only r efine , the types of values\ninitialized to null , undefined , or []  are allowed to evolve .\nRecognize and understand this construct where it occurs, and use it to\nreduce the need for type annotations in your own code.\nFor better error checking, consider providing an explicit type\nannotation instead of using evolving types.\nI t e m  2 6 :  U s e  F u n c t i o n a l  C o n s t r u c t s  a n d\nL i b r a r i e s  t o  H e l p  T y p e s  F l o w\nJavaScript has never included the sort of standard library you find in\nPython, C, or Java. Over the years, many libraries have tried to fill the gap.\njQuery provided helpers not just for interacting with the DOM but also for\niterating and mapping over objects and arrays. Underscore focused more on\nproviding general utility functions, and Lodash built on this ef fort. T oday\nlibraries like Ramda continue to bring ideas from functional programming\ninto the JavaScript world.\nSome features from these libraries, such as map , flatMap , filter , and\nreduce , have made it into the JavaScript language itself. While these\nconstructs (and the other ones provided by Lodash) are helpful in JavaScript\nand often preferable to a hand-rolled loop, this advantage tends to get even\nmore lopsided when you add T ypeScript to the mix. This is because their\ntype declarations ensure that types flow through these constructs. W ith\nhand-rolled loops, you’re responsible for the types yourself.\nFor example, consider parsing some CSV data. Y ou could do it in plain\nJavaScript in a somewhat imperative style:\nconst csvData = ""..."";\nconst rawRows = csvData.split('\n');\nconst headers = rawRows[0].split(','); \n \nconst rows = rawRows.slice(1).map((rowStr) => { \n  const row = {}; \n  rowStr.split("","").forEach((val, j) => { \n    row[headers[j]] = val; \n  }); \n  return row;\n});\nMore functionally minded JavaScripters might prefer to build the row\nobjects with reduce :\nconst rows = rawRows.slice(1) \n  .map((rowStr) => \n    rowStr \n      .split("","") \n      .reduce((row, val, i) => ((row[headers[i]] = val), row), {}) \n  );\nThis version saves a few characters but may be more cryptic depending on\nyour sensibilities. Lodash’ s zipObject  function, which forms an object by\n“zipping” up arrays of keys and values, can tighten it even further:\nimport _ from 'lodash';\nconst rows = rawRows.slice(1) \n    .map(rowStr => _.zipObject(headers, rowStr.split(',')));\nPersonally , I find this the clearest of all. But is it worth the cost of adding a\ndependency on a third-party library to your project and requiring all your\ncoworkers to learn how to use it?\nWhen you add T ypeScript to the mix, it starts to tip the balance more\nstrongly in favor of the Lodash solution.\nBoth vanilla JavaScript versions of the CSV parser produce the same error\nin T ypeScript:\nconst rowsImperative = rawRows.slice(1).map(rowStr => { \n  const row = {}; \n  rowStr.split(',').forEach((val, j) => { \n    row[headers[j]] = val; \n    // ~~~~~~~~~~~~ No index signature with a parameter of \n    //              type 'string' was found on type '{}' \n  }); \n  return row;\n});\nconst rowsFunctional = rawRows.slice(1) \n  .map((rowStr) => \n    rowStr \n      .split("","") \n      .reduce( \n        (row, val, i) => ((row[headers[i]] = val), row), \n        //                 ~~~~~~~~~~~~~~~ No index signature with a parameter \nof \n        //                                 type 'string' was found on type \n'{}' \n        {} \n      ) \n  );\nThe solution in each case is to provide a type annotation for {} , either\n{[column: string]: string}  or Record<string, string> .\nThe Lodash version, on the other hand, passes the type checker without\nmodification:\nconst rowsLodash = \n  rawRows.slice(1).map(rowStr => _.zipObject(headers, rowStr.split(',')));\nrowsLodash\n// ^? const rowsLodash: _.Dictionary<string>[]\nDictionary  is a Lodash type alias. Dictionary<string>  is the same as\n{[key: string]: string}  or Record<string, string> . The important\nthing here is that the type of rows  is exactly correct, no type annotations\nneeded.\nThese advantages get more pronounced as your data munging gets more\nelaborate. For example, suppose you have an object containing a list of the\nplayers on each team in the NBA:\ninterface BasketballPlayer { \n  name: string; \n  team: string; \n  salary: number;\n}\ndeclare const rosters: {[team: string]: BasketballPlayer[]};\nT o build a flat list using a loop, you might use concat  with an array . This\ncode runs fine but does not type check:\nlet allPlayers = [];\n//  ~~~~~~~~~~ Variable 'allPlayers' implicitly has type 'any[]'\n//             in some locations where its type cannot be determined\nfor (const players of Object.values(rosters)) { \n  allPlayers = allPlayers.concat(players); \n  //           ~~~~~~~~~~ Variable 'allPlayers' implicitly has an 'any[]' type\n}\n(The concat  method does not trigger the “evolving” behavior described in\nItem 25 .)\nT o fix the error you need to add a type annotation to allPlayers :\nlet allPlayers: BasketballPlayer[] = [];\nfor (const players of Object.values(rosters)) { \n  allPlayers = allPlayers.concat(players);  // OK\n}\nBut a better solution is to use Array.prototype.flat :\nconst allPlayers = Object.values(rosters).flat(); // OK\n//    ^? const allPlayers: BasketballPlayer[]\nThe flat  method flattens a multidimensional array . Its type signature is\nsomething like T[][] => T[] .2 This version is the most concise and\nrequires no type annotations. As an added bonus you can use const  instead\nof let  to prevent future mutations to the allPlayers  variable.\nSay you want to start with allPlayers  and make a list of the highest-paid\nplayers on each team, ordered by salary .\nHere’ s a solution without Lodash. It requires a type annotation wherever\nyou don’ t use functional constructs:\nconst teamToPlayers: {[team: string]: BasketballPlayer[]} = {};\nfor (const player of allPlayers) { \n  const {team} = player; \n  teamToPlayers[team] = teamToPlayers[team] || []; \n  teamToPlayers[team].push(player);\n} \n \nfor (const players of Object.values(teamToPlayers)) { \n  players.sort((a, b) => b.salary - a.salary);\n} \n \nconst bestPaid = Object.values(teamToPlayers).map(players => players[0]);\nbestPaid.sort((playerA, playerB) => playerB.salary - playerA.salary);\nconsole.log(bestPaid);\nHere’ s the output:\n[ \n  { team: 'GSW', salary: 51915615, name: 'Stephen Curry' }, \n  { team: 'PHO', salary: 47649433, name: 'Kevin Durant' }, \n  { team: 'DEN', salary: 47607350, name: 'Nikola Jokić' }, \n  { team: 'PHI', salary: 47607350, name: 'Joel Embiid' }, \n  { team: 'LAL', salary: 47607350, name: 'LeBron James' }, \n  ... \n]\nHere’ s the equivalent with Lodash:\nconst bestPaid = _(allPlayers) \n  .groupBy(player => player.team) \n  .mapValues(players => _.maxBy(players, p => p.salary)!) \n  .values() \n  .sortBy(p => -p.salary) \n  .value();\nconsole.log(bestPaid.slice(0, 10));\n//          ^? const bestPaid: BasketballPlayer[]\nIn addition to being half the length, this code only requires a single non-null\nassertion (the type checker doesn’ t know that the players  array passed to\n_.maxBy  is non-empty). It makes use of a “chain,” a concept in Lodash and\nUnderscore that lets you write a sequence of operations in a more natural\norder . Instead of writing:\n_.c(_.b(_.a(v)))\nyou write:\n_(v).a().b().c().value()\nThe _(v)  “wraps” the value, and the .value()  “unwraps” it.\nY ou can inspect each function call in the chain to see the type of the\nwrapped value. It’ s always correct.\nIt’ s not a coincidence that types flow so well through built-in functional\nconstructs and those in libraries like Lodash. By avoiding mutation and\nreturning new values from every call, they are able to produce new types as\nwell ( Item 19 ). T o a lar ge extent, the development of T ypeScript has been\ndriven by an attempt to accurately model the behavior of JavaScript\nlibraries in the wild. T ake advantage of all this work and use them!\nThings to Remember",8968
35-Item 27 Use async Functions Instead of Callbacks to Improve Type Flow.pdf,35-Item 27 Use async Functions Instead of Callbacks to Improve Type Flow,"Use built-in functional constructs and those in utility libraries like\nLodash instead of hand-rolled constructs to improve type flow ,\nincrease legibility , and reduce the need for explicit type annotations.\nI t e m  2 7 :  U s e  a s y n c  F u n c t i o n s  I n s t e a d  o f\nC a l l b a c k s  t o  I m p r o v e  T y p e  F l o w\nClassic JavaScript modeled asynchronous behavior using callbacks. This\nled to the infamous “pyramid of doom”:\ndeclare function fetchURL( \n  url: string, callback: (response: string) => void\n): void; \n \nfetchURL(url1, function(response1) { \n  fetchURL(url2, function(response2) { \n    fetchURL(url3, function(response3) { \n      // ... \n      console.log(1); \n    }); \n    console.log(2); \n  }); \n  console.log(3);\n});\nconsole.log(4); \n \n// Logs:\n// 4\n// 3\n// 2\n// 1\nThis code is heavily nested and, as you can see from the logs, the execution\norder is the opposite of the code order . This makes callback code hard to\nread. It gets even more confusing if you want to run the requests\nconcurrently or bail when an error occurs.\nES2015 introduced the concept of a Promise to break the pyramid of doom.\nA Promise represents something that will be available in the future (they’re\nalso sometimes called “futures”). Here’ s the same code using Promises:\nconst page1Promise = fetch(url1);\npage1Promise.then(response1 => { \n  return fetch(url2);\n}).then(response2 => { \n  return fetch(url3);\n}).then(response3 => { \n  // ...\n}).catch(error => { \n  // ...\n});\nNow there’ s less nesting, and the execution order more directly matches the\ncode order . It’ s also easier to consolidate error handling and use higher -\norder tools like Promise.all .\nES2017 introduced the async  and await  keywords to make things even\nmore concise:\nasync function fetchPages() { \n  const response1 = await fetch(url1); \n  const response2 = await fetch(url2); \n  const response3 = await fetch(url3); \n  // ...\n}\nThe await  keyword pauses execution of the fetchPages  function until\neach Promise resolves. W ithin an async  function, await ing a Promise that\nrejects will throw an exception. This lets you use the usual try/catch\nmachinery:\nasync function fetchPages() { \n  try { \n    const response1 = await fetch(url1); \n    const response2 = await fetch(url2); \n    const response3 = await fetch(url3); \n    // ... \n  } catch (e) { \n    // ... \n  }\n}\nJust like exceptions, Promise rejections in T ypeScript are untyped.\nasync  and await  are supported by all recent JavaScript runtimes, but even\nif you tar get ES5 or earlier , the T ypeScript compiler will perform some\nelaborate transformations to make async  and await  work. In other words,\nwhatever your runtime, with T ypeScript you can use async /await .\nThere are a few good reasons to prefer Promises or async /await  to\ncallbacks:\nPromises are easier to compose than callbacks.\nT ypes are able to flow through Promises more easily than callbacks.\nIf you want to fetch the pages concurrently , for example, you can compose\nPromises with Promise.all :\nasync function fetchPages() { \n  const [response1, response2, response3] = await Promise.all([ \n    fetch(url1), fetch(url2), fetch(url3) \n  ]); \n  // ...\n}\nUsing destructuring assignment with await  is particularly nice in this\ncontext.\nT ypeScript is able to infer the types of each of the three response  variables\nas Response . The equivalent code to issue the requests concurrently with\ncallbacks requires more machinery and a type annotation:\nfunction fetchPagesWithCallbacks() { \n  let numDone = 0; \n  const responses: string[] = []; \n  const done = () => { \n    const [response1, response2, response3] = responses; \n    // ... \n  }; \n  const urls = [url1, url2, url3]; \n  urls.forEach((url, i) => { \n    fetchURL(url, r => { \n      responses[i] = url; \n      numDone++; \n      if (numDone === urls.length) done(); \n    }); \n  });\n}\nExtending this to include error handling or to be as generic as Promise.all\nis challenging.\nT ype inference also works well with Promise.race , which resolves when\nthe first of its input Promises resolves. Y ou can use this to add timeouts to\nPromises in a general way:\nfunction timeout(timeoutMs: number): Promise<never> { \n  return new Promise((resolve, reject) => { \n     setTimeout(() => reject('timeout'), timeoutMs); \n  });\n} \n \nasync function fetchWithTimeout(url: string, timeoutMs: number) { \n  return Promise.race([fetch(url), timeout(timeoutMs)]);\n}\nThe return type of fetchWithTimeout  is inferred as Promise<Response> ,\nno type annotations required. It’ s interesting to dig into why this works: the\nreturn type of Promise.race  is the union of the types of its inputs, in this\ncase Promise<Response | never> . But taking a union with never  (the\nempty set) is a no-op, so this gets simplified  to Promise<Response> . When\nyou work with Promises, all of T ypeScript’ s type inference machinery\nworks to get you the right types.\nY ou may occasionally need to use raw Promises, notably when you are\nwrapping a callback API like setTimeout . But if you have a choice, you\nshould generally prefer async /await  to raw Promises for two reasons:\nIt typically produces more concise and straightforward code.\nIt enforces that async  functions always return Promises.\nThis latter property helps avoid a confusing class of bugs. By definition, an\nasync  function always returns a Promise . This is true even if it doesn’ t\nawait  anything. T ypeScript can help you build an intuition for this:\nasync function getNumber() { return 42; }\n//             ^? function getNumber(): Promise<number>\nY ou can also create async  arrow functions:\nconst getNumber = async () => 42;\n//    ^? const getNumber: () => Promise<number>\nThe raw Promise equivalent is:\nconst getNumber = () => Promise.resolve(42);\n//    ^? const getNumber: () => Promise<number>\nWhile it may seem odd to return a Promise for an immediately available\nvalue, this actually helps enforce an important rule: a function should either\nalways be run synchronously or always be run asynchronously . It should\nnever mix the two.\nT o see how breaking this rule can lead to chaos, let’ s try to add a cache to\nthe fetchURL  function:\n// Don't do this!\nconst _cache: {[url: string]: string} = {};\nfunction fetchWithCache(url: string, callback: (text: string) => void) { \n  if (url in _cache) { \n    callback(_cache[url]); \n  } else { \n    fetchURL(url, text => { \n      _cache[url] = text; \n      callback(text); \n    }); \n  }\n}\nWhile invoking the callback immediately may seem like an optimization,\nthe function is now extremely dif ficult for a client to use:\nlet requestStatus: 'loading' | 'success' | 'error';\nfunction getUser(userId: string) { \n  fetchWithCache(`/user/${userId}`, profile => { \n    requestStatus = 'success'; \n  }); \n  requestStatus = 'loading';\n}\nWhat will the value of requestStatus  be after calling getUser ? It depends\nentirely on whether the profile is cached. If it’ s not, requestStatus  will be\nset to “success.” If it is, it’ll get set to “success” and then set back to\n“loading.” Oops!\nUsing async  for both functions enforces consistent behavior:\nconst _cache: {[url: string]: string} = {};\nasync function fetchWithCache(url: string) { \n  if (url in _cache) { \n    return _cache[url]; \n  } \n  const response = await fetch(url); \n  const text = await response.text(); \n  _cache[url] = text; \n  return text;\n} \n \nlet requestStatus: 'loading' | 'success' | 'error';\nasync function getUser(userId: string) { \n  requestStatus = 'loading'; \n  const profile = await fetchWithCache(`/user/${userId}`); \n  requestStatus = 'success';\n}\nNow it’ s completely transparent that requestStatus  will end in “success.”\nIt’ s easy to accidentally produce half-synchronous code with callbacks or\nraw Promises, but dif ficult with async .3",7963
36-Item 28 Use Classes and Currying to Create New Inference Sites.pdf,36-Item 28 Use Classes and Currying to Create New Inference Sites,"Note that if you return a Promise from an async  function, it will not get\nwrapped in another Promise: the return type will be Promise<T>  rather than\nPromise <Promise<T>> . Again, T ypeScript will help you build an intuition\nfor this:\nasync function getJSON(url: string) { \n  const response = await fetch(url); \n  const jsonPromise = response.json(); \n  return jsonPromise; \n  //     ^? const jsonPromise: Promise<any>\n}\ngetJSON\n// ^? function getJSON(url: string): Promise<any>\nThings to Remember\nPrefer Promises to callbacks for better composability and type flow .\nPrefer async  and await  to raw Promises when possible. They produce\nmore concise, straightforward code and eliminate whole classes of\nerrors.\nIf a function returns a Promise, declare it async .\nI t e m  2 8 :  U s e  C l a s s e s  a n d  C u r r y i n g  t o  C r e a t e\nN e w  I n f e r e n c e  S i t e s\nSuppose you define an API using a T ypeScript interface :\nexport interface SeedAPI { \n  '/seeds': Seed[]; \n  '/seed/apple': Seed; \n  '/seed/strawberry': Seed; \n  // ...\n}\nThis says that our API has a /seeds  endpoint that returns an array of Seed\nobjects. The /seed/apple  and /seed/strawberry  endpoints return one\nSeed  object.\nLet’ s write a function that issues requests to our API endpoints. This\nfunction should check that the endpoints exist, and it should return the\ncorrect type of data. This will be extremely helpful for making safe API\ncalls from the client.\nHere’ s how that function should work:\n// Correct usage:\nconst berry = await fetchAPI<SeedAPI>('/seed/strawberry'); // OK, returns Seed \n \n// Incorrect usage; these should be errors:\nfetchAPI<SeedAPI>('/seed/chicken');  // endpoint doesn't exist\nconst seed: Seed = await fetchAPI<SeedAPI>('/seeds'); // wrong return type\nHere’ s how you might declare fetchAPI  (we’re not concerned about the\nimplementation here, just the types):\ndeclare function fetchAPI< \n  API, Path extends keyof API\n>(path: Path): Promise<API[Path]>;\nUnfortunately , when you try to use this, you’ll get an error:\nfetchAPI<SeedAPI>('/seed/strawberry');\n//       ~~~~~~~ Expected 2 type arguments, but got 1.\nThe problem is that type inference in T ypeScript is an all or nothing af fair:\neither you can let T ypeScript infer all  the type parameters from usage, or\nyou can specify all of them explicitly . There’ s no in-between. (Y ou can\nprovide a default value for a type parameter , but this can only reference\nother type parameters; it can’ t be inferred from usage.)\nThe API  type parameter could be anything: since we’d like fetchAPI  to\nwork with any API, it can’ t possibly be inferred. It has to be specified\nexplicitly . So it would seem the only solution here is to write the Path  type\nexplicitly , too:\nconst berry = fetchAPI<SeedAPI, '/seed/strawberry'>('/seed/strawberry');  // \nok\n//    ^? const berry: Promise<Seed>\nThis works, but it’ s frustratingly repetitive. Surely there’ s a better way . W e\nneed to somehow separate the place where we explicitly write the API  type\nparameter from the place where we infer the Path  type parameter .\nThere are two standard ways to do this: classes and currying.\nClasses\nClasses are very good at capturing bits of state. They spare you from having\nto repeatedly pass the same state to a set of related functions (the class’ s\nmethods). In T ypeScript, it turns out that classes are also very good at\ncapturing types .\nHere’ s how you can define a class to solve this problem:\ndeclare class ApiFetcher<API> { \n  fetch<Path extends keyof API>(path: Path): Promise<API[Path]>;\n}\nAnd here’ s how you use it:\nconst fetcher = new ApiFetcher<SeedAPI>();\nconst berry = await fetcher.fetch('/seed/strawberry'); // OK\n//    ^? const berry: Seed \n \nfetcher.fetch('/seed/chicken');\n//            ~~~~~~~~~~~~~~~\n// Argument of type '""/seed/chicken""' is not assignable to type 'keyof \nSeedAPI' \n \nconst seed: Seed = await fetcher.fetch('/seeds');\n//    ~~~~ Seed[] is not assignable to Seed\nThis produces exactly the errors we were hoping for . (Y ou also need to\nimplement the class, of course! W e’re just focusing on the types here.)\nWhat used to be a function that needed two generic type parameters is now\na class with one generic type parameter that you specify explicitly , and a\nmethod with one generic type parameter that’ s inferred. T ypeScript is\nperfectly happy to let you bind the API  type parameter when you call the\nclass’ s constructor ( new ApiFetcher <See dAPI>() ) and then infer Path\nwhen you call the fetch  method.\nUsing classes to create a distinct binding site is particularly ef fective when\nyou have multiple methods that all require the same type parameter .\nCurrying\nFun fact: programming languages don’ t really need functions with more\nthan one parameter . Instead of:\ndeclare function getDate(mon: string, day: number): Date;\ngetDate('dec', 25);\nyou could write a function that returns another function:\ndeclare function getDate(mon: string): (day: number) => Date;\ngetDate('dec')(25);\nNote the slightly dif ferent syntax to call the second version. This practice is\nknown as currying , after the logician Haskell Curry , who always disavowed\nhaving come up with the technique.\nCurrying gives us the flexibility we need to introduce as many inference\nsites as we like. Each function call can infer new type parameters.\nHere’ s how you can rework fetchAPI  using functions that return functions:\ndeclare function fetchAPI<API>(): \n  <Path extends keyof API>(path: Path) => Promise<API[Path]>;\nNow fetchAPI  takes no  parameters, but it returns a function that takes one.\nHere’ s how you use it:\nconst berry = await fetchAPI<SeedAPI>()('/seed/strawberry'); // OK\n//    ^? const berry: Seed \n \nfetchAPI<SeedAPI>()('/seed/chicken');\n//                  ~~~~~~~~~~~~~~~\n// Argument of type '""/seed/chicken""' is not assignable to type 'keyof \nSeedAPI'\n//\nconst seed: Seed = await fetchAPI<SeedAPI>()('/seeds');\n//    ~~~~ Seed[] is not assignable to Seed\nJust like the class solution, this works in the case where we want it to and\nproduces the desired error in the others. Y ou can use an intermediate\nvariable to separate out the two function calls to reduce repetition:\nconst fetchSeedAPI = fetchAPI<SeedAPI>();\nconst berry = await fetchSeedAPI('/seed/strawberry');\n//    ^? const berry: Seed\nThe currying approach isn’ t as distinct from the class approach as it might\ninitially appear . If you use a dif ferent name and return an object type instead\nof a function, they look nearly identical:\ndeclare function apiFetcher<API>(): { \n  fetch<Path extends keyof API>(path: Path): Promise<API[Path]>;\n} \n \nconst fetcher = apiFetcher<SeedAPI>();\nfetcher.fetch('/seed/strawberry');  // ok\nThe only dif ference in usage between this and the class example is the\nkeyword new .\nIf you want to specify some generic parameters explicitly while allowing\nothers to be inferred, classes and currying are your two options.\nSo which one should you prefer? Ultimately it’ s up to you. Whichever one\nfeels most comfortable and produces the API you find most convenient is\nthe way to go. The currying approach does have at least one advantage in\nthe context of T ypeScript, however: it creates a scope in which you can\ndefine local type aliases:\nfunction fetchAPI<API>() { \n  type Routes = keyof API & string;  // local type alias \n \n  return <Path extends Routes>( \n    path: Path \n  ): Promise<API[Path]> => fetch(path).then(r => r.json());\n}\nY ou can’ t do this with just a declaration: only the implementation\nintroduces a new scope. Local type aliases like Routes  can cut down on\nrepetition involving complex type expressions. There is no equivalent of\nthis for classes.\nThings to Remember\nFor functions with multiple type parameters, inference is all or\nnothing: either all type parameters are inferred or all must be specified\nexplicitly .\nT o get partial inference, use either classes or currying to create a new\ninference site.\nPrefer the currying approach if you’d like to create a local type alias.\n1 Why this quirk? The original JavaScript implementation represented objects with a type tag\nand a value. The tag for objects was 0, and null  was represented as a null pointer ( 0x0 ), hence\nits type tag was 0 , and typeof null  was ""object"" . The standards committee attempted to fix\nthis bug in 201 1 but it broke too many websites.\n2 The flat  method also takes a depth  parameter which complicates the type declarations.\n3 There’ s still a more subtle bug in this version: if you call fetchWithCache  twice in a row\nwith the same URL, it will issue two requests. How would you fix this?",8754
37-4. Type Design.pdf,37-4. Type Design,,0
38-Item 29 Prefer Types That Always Represent Valid States.pdf,38-Item 29 Prefer Types That Always Represent Valid States,"Chapter 4. T ype Design\nShow me your flowcharts and conceal your tables, and I shall continue to\nbe mystified. Show me your tables, and I won’ t usually need your\nflowcharts; they’ll be obvious.\n— Fred Brooks, The Mythical Man Month  (Addison-\nW esley Professional)\nThe language in Fred Brooks’ s quote is dated, but the sentiment remains\ntrue: code is dif ficult to understand if you can’ t see the data or data types on\nwhich it operates. This is one of the great advantages of a type system: by\nwriting out types, you make them visible to readers of your code. And this\nmakes your code understandable.\nOther chapters cover the nuts and bolts of T ypeScript types: using them,\ninferring them, transforming them, and writing declarations with them. This\nchapter discusses the design of the types themselves. The examples in this\nchapter are all written with T ypeScript in mind, but most of the ideas are\nmore broadly applicable.\nIf you write your types well, then with any luck your flowcharts will be\nobvious, too.\nI t e m  2 9 :  P r e f e r  T y p e s  T h a t  A l w a y s  R e p r e s e n t\nV a l i d  S t a t e s\nIf you design your types well, your code should be straightforward to write.\nBut if you design your types poorly , no amount of cleverness or\ndocumentation will save you. Y our code will be confusing and prone to\nbugs.\nA key to ef fective type design is crafting types that can only represent a\nvalid state. This item walks through a few examples of how this can go\nwrong and shows you how to fix them.\nSuppose you’re building a web application that lets you select a page, loads\nthe content of that page, and then displays it. Y ou might write the state like\nthis:\ninterface State { \n  pageText: string; \n  isLoading: boolean; \n  error?: string;\n}\nWhen you write your code to render the page, you need to consider all of\nthese fields:\nfunction renderPage(state: State) { \n  if (state.error) { \n    return `Error! Unable to load ${currentPage}: ${state.error}`; \n  } else if (state.isLoading) { \n    return `Loading ${currentPage}...`; \n  } \n  return `<h1>${currentPage}</h1>\n${state.pageText}`;\n}\nIs this right, though? What if isLoading  and error  are both set? What\nwould that mean? Is it better to display the loading message or the error\nmessage? It’ s hard to say! There’ s not enough information available.\nOr what if you’re writing a changePage  function? Here’ s an attempt:\nasync function changePage(state: State, newPage: string) { \n  state.isLoading = true; \n  try { \n    const response = await fetch(getUrlForPage(newPage)); \n    if (!response.ok) { \n      throw new Error(`Unable to load ${newPage}: ${response.statusText}`); \n    } \n    const text = await response.text(); \n    state.isLoading = false; \n    state.pageText = text; \n  } catch (e) { \n    state.error = '' + e; \n  }\n}\nThere are many problems with this! Here are a few:\nW e for got to set state.isLoading  to false  in the error case.\nW e didn’ t clear out state.error , so if the previous request failed,\nthen you’ll keep seeing that error message instead of a loading\nmessage or the new page.\nIf the user changes pages again while the page is loading, who knows\nwhat will happen. They might see a new page and then an error , or the\nfirst page and not the second, depending on the order in which the\nresponses come back.\nThe problem is that the state includes both too little information (which\nrequest failed? which is loading?) and too much: the State  type allows\nboth isLoading  and error  to be set, even though this represents an invalid\nstate. This makes both render()  and changePage()  impossible to\nimplement well.\nHere’ s a better way to represent the application state:\ninterface RequestPending { \n  state: 'pending';\n}\ninterface RequestError { \n  state: 'error'; \n  error: string;\n}\ninterface RequestSuccess { \n  state: 'ok'; \n  pageText: string;\n}\ntype RequestState = RequestPending | RequestError | RequestSuccess; \n \ninterface State { \n  currentPage: string; \n  requests: {[page: string]: RequestState};\n}\nThis uses a  tagged union (also known as a “discriminated union”) to\nexplicitly model the dif ferent states that a network request can be in. This\nversion of the state is three to four times longer , but it has the enormous\nadvantage of not admitting invalid states. The current page is modeled\nexplicitly , as is the state of every request that you issue. As a result, the\nrenderPage  and changePage  functions are easy to implement:\nfunction renderPage(state: State) { \n  const {currentPage} = state; \n  const requestState = state.requests[currentPage]; \n  switch (requestState.state) { \n    case 'pending': \n      return `Loading ${currentPage}...`; \n    case 'error': \n      return `Error! Unable to load ${currentPage}: ${requestState.error}`; \n    case 'ok': \n      return `<h1>${currentPage}</h1>\n${requestState.pageText}`; \n  }\n} \n \nasync function changePage(state: State, newPage: string) { \n  state.requests[newPage] = {state: 'pending'}; \n  state.currentPage = newPage; \n  try { \n    const response = await fetch(getUrlForPage(newPage)); \n    if (!response.ok) { \n      throw new Error(`Unable to load ${newPage}: ${response.statusText}`); \n    } \n    const pageText = await response.text(); \n    state.requests[newPage] = {state: 'ok', pageText}; \n  } catch (e) { \n    state.requests[newPage] = {state: 'error', error: '' + e}; \n  }\n}\nThe ambiguity from the first implementation is entirely gone: it’ s clear what\nthe current page is, and every request is in exactly one state. If the user\nchanges the page after a request has been issued, that’ s no problem either .\nThe old request still completes, but it doesn’ t af fect the UI.\nFor a simpler but more dire example, consider the fate of Air France Flight\n447, an Airbus 330 that disappeared over the Atlantic on June 1, 2009. The\nAirbus was a fly-by-wire aircraft, meaning that the pilots’ control inputs\nwent through a computer system before af fecting the physical control\nsurfaces of the plane. In the wake of the crash, many questions were raised\nabout the wisdom of relying on computers to make such life-and-death\ndecisions. T wo years later when the black box recorders were recovered\nfrom the bottom of the ocean, they revealed many factors that led to the\ncrash. A key factor was bad state design.\nThe cockpit of the Airbus 330 had a separate set of controls for the pilot and\ncopilot. The “side sticks” controlled the angle of attack. Pulling back would\nsend the airplane into a climb, while pushing forward would make it dive.\nThe Airbus 330 used a system called “dual input” mode, which let the two\nside sticks move independently . Here’ s how you might model its state in\nT ypeScript:\ninterface CockpitControls { \n  /** Angle of the left side stick in degrees, 0 = neutral, + = forward */ \n  leftSideStick: number; \n  /** Angle of the right side stick in degrees, 0 = neutral, + = forward */ \n  rightSideStick: number;\n}\nSuppose you were given this data structure and asked to write a\ngetStickSetting  function that computed the current stick setting. How\nwould you do it?\nOne way would be to assume that the pilot (who sits on the left) is in\ncontrol:\nfunction getStickSetting(controls: CockpitControls) { \n  return controls.leftSideStick;\n}\nBut what if the copilot has taken control? Maybe you should use whichever\nstick is away from zero:\nfunction getStickSetting(controls: CockpitControls) { \n  const {leftSideStick, rightSideStick} = controls; \n  if (leftSideStick === 0) { \n    return rightSideStick; \n  } \n  return leftSideStick;\n}\nBut there’ s a problem with this implementation: we can only be confident\nreturning the left setting if the right one is neutral. So you should check for\nthat:\nfunction getStickSetting(controls: CockpitControls) { \n  const {leftSideStick, rightSideStick} = controls; \n  if (leftSideStick === 0) { \n    return rightSideStick; \n  } else if (rightSideStick === 0) { \n    return leftSideStick; \n  } \n  // ???\n}\nWhat do you do if they’re both non-zero? Hopefully they’re about the same,\nin which case you could just average them:\nfunction getStickSetting(controls: CockpitControls) { \n  const {leftSideStick, rightSideStick} = controls; \n  if (leftSideStick === 0) { \n    return rightSideStick; \n  } else if (rightSideStick === 0) { \n    return leftSideStick; \n  } \n  if (Math.abs(leftSideStick - rightSideStick) < 5) { \n    return (leftSideStick + rightSideStick) / 2; \n  } \n  // ???\n}\nBut what if they’re not? Can you throw an error? Not really: the wing flaps\nneed to be set at some angle!\nOn Air France 447, the copilot silently pulled back on his side stick as the\nplane entered a storm. It gained altitude but eventually lost speed and\nentered a stall, a condition in which the plane is moving too slowly to\nef fectively generate lift. It began to drop.\nT o escape a stall, pilots are trained to push the controls forward to make the\nplane dive and regain speed. This is exactly what the pilot did. But the\ncopilot was still silently pulling back on his side stick. And the Airbus\nfunction looked like this:\nfunction getStickSetting(controls: CockpitControls) { \n  return (controls.leftSideStick + controls.rightSideStick) / 2;\n}\nEven though the pilot pushed the stick fully forward, it averaged out to\nnothing. He had no idea why the plane wasn’ t diving. By the time the\ncopilot revealed what he’d done, the plane had lost too much altitude to\nrecover and it crashed into the ocean, killing all 228 people on board.\nThe point of all this is that there is no good way to implement\ngetStickSetting  given that input! The function has been set up to fail. In\nmost planes the two sets of controls are mechanically connected. If the\ncopilot pulls back, the pilot’ s controls will also pull back. The state of these\ncontrols is simple to express:\ninterface CockpitControls { \n  /** Angle of the stick in degrees, 0 = neutral, + = forward */ \n  stickAngle: number;\n}\nAnd now , as in the Fred Brooks quote from the start of the chapter , our\nflowcharts are obvious. Y ou don’ t need a getStickSetting  function at all.\nAs you design your types, take care to think about which values you are\nincluding and which you are excluding. If you only allow values that\nrepresent valid states, your code will be easier to write and T ypeScript will\nhave an easier time checking it. This is a very general principle, and several\nof the other items in this chapter will cover specific manifestations of it.\nThings to Remember",10681
39-Item 30 Be Liberal in What You Accept and Strict in What You Produce.pdf,39-Item 30 Be Liberal in What You Accept and Strict in What You Produce,"T ypes that represent both valid and invalid states are likely to lead to\nconfusing and error -prone code.\nPrefer types that only represent valid states. Even if they are longer or\nharder to express, they will save you time and pain in the  end!\nI t e m  3 0 :  B e  L i b e r a l  i n  W h a t  Y o u  A c c e p t  a n d\nS t r i c t  i n  W h a t  Y o u  P r o d u c e\nThis idea is known as the r obustness principle  or Postel’ s Law , after Jon\nPostel, who wrote it in the context of the TCP networking protocol:\nTCP implementations should follow a general principle of r obustness: be\nconservative in what you do, be liberal in what you accept fr om others.\nA similar rule applies to the contracts for functions. It’ s fine for your\nfunctions to be broad in what they accept as inputs, but they should\ngenerally be more specific in what they produce as outputs.\nAs an example, a 3D mapping API might provide a way to position the\ncamera and calculate a viewport for a bounding box:\ndeclare function setCamera(camera: CameraOptions): void;\ndeclare function viewportForBounds(bounds: LngLatBounds): CameraOptions;\nIt is convenient that the result of viewportForBounds  can be passed\ndirectly to setCamera  to position the camera.\nLet’ s look at the definitions of these types:\ninterface CameraOptions { \n  center?: LngLat; \n  zoom?: number; \n  bearing?: number; \n  pitch?: number;\n}\ntype LngLat = \n  { lng: number; lat: number; } | \n  { lon: number; lat: number; } | \n  [number, number];\nThe fields in CameraOptions  are all optional because you might want to set\njust the center or zoom without changing the bearing or pitch. The LngLat\ntype also makes setCamera  liberal in what it accepts: you can pass in a\n{lng, lat}  object, a {lon, lat}  object, or a [lng, lat]  pair if you’re\nconfident you got the order right. These accommodations make the function\neasy to call.\nThe viewportForBounds  function takes in another “liberal” type:\ntype LngLatBounds = \n  {northeast: LngLat, southwest: LngLat} | \n  [LngLat, LngLat] | \n  [number, number, number, number];\nY ou can specify the bounds either using named corners, a pair of lat /lng s,\nor a four -tuple if you’re confident you got the order right. Since LngLat\nalready accommodates three forms, there are no fewer than 19 possible\nforms for LngLatBounds  (3 × 3 + 3 × 3 + 1). Liberal indeed!\nNow let’ s write a function that adjusts the viewport to accommodate a\nGeoJSON feature and stores the new viewport in the URL (we’ll assume\nwe have a helper function to calculate the bounding box of a GeoJSON\nfeature):\nfunction focusOnFeature(f: Feature) { \n  const bounds = calculateBoundingBox(f); // helper function \n  const camera = viewportForBounds(bounds); \n  setCamera(camera); \n  const {center: {lat, lng}, zoom} = camera; \n               // ~~~      Property 'lat' does not exist on type ... \n               //      ~~~ Property 'lng' does not exist on type ... \n  zoom; \n  // ^? const zoom: number | undefined \n  window.location.search = `?v=@${lat},${lng}z${zoom}`;\n}\nWhoops! Only the zoom  property exists, but its type is inferred as\nnumber|undefined , which is also problematic. The issue is that the type\ndeclaration for viewportForBounds  indicates that it is liberal not just in\nwhat it accepts but also in what it pr oduces .  The only type-safe way to use\nthe camera  result is to introduce a code branch for each component of the\nunion type.\nThe return type with lots of optional properties and union types makes\nviewportForBounds  dif ficult to use. Its broad parameter type is\nconvenient, but its broad return type is not. A more convenient API would\nbe strict in what it produces.\nOne way to do this is to distinguish a canonical format for coordinates.\nFollowing JavaScript’ s convention of distinguishing “array” and “array-\nlike” ( Item 17 ), you can draw a distinction between LngLat  and\nLngLatLike . Y ou can also distinguish between a fully defined Camera  type\nand the partial version accepted by setCamera :\ninterface LngLat { lng: number; lat: number; };\ntype LngLatLike = LngLat | { lon: number; lat: number; } | [number, number]; \n \ninterface Camera { \n  center: LngLat; \n  zoom: number; \n  bearing: number; \n  pitch: number;\n}\ninterface CameraOptions extends Omit<Partial<Camera>, 'center'> { \n  center?: LngLatLike;\n}\ntype LngLatBounds = \n  {northeast: LngLatLike, southwest: LngLatLike} | \n  [LngLatLike, LngLatLike] | \n  [number, number, number, number]; \n \ndeclare function setCamera(camera: CameraOptions): void;\ndeclare function viewportForBounds(bounds: LngLatBounds): Camera;\nThe loose CameraOptions  type adapts the stricter Camera  type. Using\nPartial <Cam era>  as the parameter type in setCamera  would not work\nhere since you do want to allow LngLatLike  objects for the center\nproperty . And you can’ t write ""Camera Op tions extends\nPartial<Camera> "" since LngLatLike  is a supertype of LngLat , not a\nsubtype. (If this feels backwards, head over to Item 7  for a refresher .)\nIf this seems too complicated, you could also write the type out explicitly at\nthe cost of some repetition:\ninterface CameraOptions { \n  center?: LngLatLike; \n  zoom?: number; \n  bearing?: number; \n  pitch?: number;\n}\nIn either case, with these new type declarations the focusOnFeature\nfunction passes the type checker:\nfunction focusOnFeature(f: Feature) { \n  const bounds = calculateBoundingBox(f); \n  const camera = viewportForBounds(bounds); \n  setCamera(camera); \n  const {center: {lat, lng}, zoom} = camera;  // OK \n  //                         ^? const zoom: number \n  window.location.search = `?v=@${lat},${lng}z${zoom}`;\n}\nThis time the type of zoom  is number , rather than number|undefined . The\nviewportForBounds  function is now much easier to use. If there were any\nother functions that produced bounds, you would also need to introduce a\ncanonical form and a distinction between LngLatBounds  and\nLngLatBoundsLike .\nIs allowing 19 possible forms of bounding box a good design? Perhaps not.\nBut if you’re writing type declarations for a library that does this, you need\nto model its behavior . Just don’ t have 19 return types!\nOne of the most common applications of this pattern is to functions that\ntake arrays as parameters. For example, here’ s a function that sums the\nelements of an array:\nfunction sum(xs: number[]): number { \n  let sum = 0; \n  for (const x of xs) { \n    sum += x; \n  } \n  return sum;\n}\nThe return type of number  is quite strict. Great! But what about the\nparameter type of number[] ? W e’re not using many of its capabilities, so it\ncould be looser . Item 17  discussed the ArrayLike  type, and\nArrayLike<number>  would work well here. Item 14  discussed readonly\narrays, and readonly number[]  would also work well as a parameter type.\nBut if you only need to iterate over the parameter , then Iterable  is the\nbroadest type of all:\nfunction sum(xs: Iterable<number>): number { \n  let sum = 0; \n  for (const x of xs) { \n    sum += x; \n  } \n  return sum;\n}\nThis works as you’d expect with an array:\nconst six = sum([1, 2, 3]);\n//    ^? const six: number\nThe advantage of using Iterable  here instead of Array  or ArrayLike  is\nthat it also allows generator expressions:\nfunction* range(limit: number) { \n  for (let i = 0; i < limit; i++) { \n    yield i; \n  }\n}",7435
40-Item 31 Dont Repeat Type Information in Documentation.pdf,40-Item 31 Dont Repeat Type Information in Documentation,"const zeroToNine = range(10);\n//    ^? const zeroToNine: Generator<number, void, unknown>\nconst fortyFive = sum(zeroToNine);  // ok, result is 45\nIf your function just needs to iterate over its parameter , use Iterable  to\nmake it work with generators as well. If you’re using for-of  loops then\nyou won’ t need to change a single line of  your code.\nThings to Remember\nInput types tend to be broader than output types. Optional properties\nand union types are more common in parameter types than return\ntypes.\nA void broad return types since these will be awkward for clients to\nuse.\nT o reuse types between parameters and return types, introduce a\ncanonical form (for return types) and a looser form (for parameters).\nUse Iterable<T>  instead of T[]  if you only need to iterate over your\nfunction parameter .\nI t e m  3 1 :  D o n ’ t  R e p e a t  T y p e  I n f o r m a t i o n  i n\nD o c u m e n t a t i o n\nWhat’ s wrong with this code?\n/**\n * Returns a string with the foreground color.\n * Takes zero or one arguments. With no arguments, returns the\n * standard foreground color. With one argument, returns the foreground color\n * for a particular page.\n */\nfunction getForegroundColor(page?: string) { \n  return page === 'login' ? {r: 127, g: 127, b: 127} : {r: 0, g: 0, b: 0};\n}\nThe code and the comment disagree! W ithout more context it’ s hard to say\nwhich is right, but something is clearly amiss. As a professor of mine used\nto say , “when your code and your comments disagree, they’re both wrong!”\nLet’ s assume that the code represents the desired behavior . There are a few\nissues with this comment:\nIt says that the function returns the color as a string  when it actually\nreturns an {r, g, b}  object.\nIt explains that the function takes zero or one ar guments, which is\nalready clear from the type signature.\nIt’ s needlessly wordy: the comment is longer than the function\ndeclaration and  implementation!\nT ypeScript’ s type annotation system is designed to be compact, descriptive,\nand readable. Its developers are language experts with decades of\nexperience. It’ s almost certainly a better way to express the types of your\nfunction’ s inputs and outputs than your prose!\nAnd because your type annotations are checked by the T ypeScript compiler ,\nthey’ll never get out of sync with the implementation. Perhaps\ngetForegroundColor  used to return a string but was later changed to\nreturn an object. The person who made the change might have for gotten to\nupdate the long comment.\nNothing stays in sync unless it’ s forced to. W ith type annotations,\nT ypeScript’ s type checker is that force! If you put type information in\nannotations rather than documentation, you greatly increase your\nconfidence that it will remain correct as the code evolves.\nA better comment might look like this:\n/** Get the foreground color for the application or a specific page. */\nfunction getForegroundColor(page?: string): Color { \n  // ...\n}\nIf you want to describe a particular parameter , use an @param  JSDoc\nannotation. See Item 68  for more on this.\nComments about a lack of mutation are also suspect:\n/** Sort the strings by numeric value (i.e. ""2"" < ""10""). Does not modify nums. \n*/\nfunction sortNumerically(nums: string[]): string[] { \n  return nums.sort((a, b) => Number(a) - Number(b));\n}\nThe comment says  that this function doesn’ t modify its parameter , but the\nsort  method on Arrays operates in place, so it very much does. Claims in\ncomments don’ t count for much.\nIf you declare the parameter readonly  instead ( Item 14 ), then you can let\nT ypeScript enforce the contract:\n/** Sort the strings by numeric value (i.e. ""2"" < ""10""). */\nfunction sortNumerically(nums: readonly string[]): string[] { \n  return nums.sort((a, b) => Number(a) - Number(b)); \n  //          ~~~~  ~  ~ Property 'sort' does not exist on 'readonly \nstring[]'.\n}\nA correct implementation of this function would either copy the array or\nuse the immutable toSorted  method:\n/** Sort the strings by numeric value (i.e. ""2"" < ""10""). */\nfunction sortNumerically(nums: readonly string[]): string[] { \n  return nums.toSorted((a, b) => Number(a) - Number(b));  // ok\n}\nWhat’ s true for comments is also true for variable names. A void putting\ntypes in them: rather than naming a variable ageNum , name it age  and make\nsure it’ s really a number .\nAn exception to this is for numbers with units. If it’ s not clear what the\nunits are, you may want to include them in a variable or property name. For\ninstance, timeMs  is a much clearer name than just time , and temperatureC",4647
41-Item 32 Avoid Including null or undefined in Type Aliases.pdf,41-Item 32 Avoid Including null or undefined in Type Aliases,"is a much clearer name than temperature . Item 64  describes “brands,”\nwhich provide a more type-safe approach to modeling units.\nThings to Remember\nA void repeating type information in comments and variable names. In\nthe best case it is duplicative of type declarations, and in the worst case\nit will lead to conflicting information.\nDeclare parameters readonly  rather than saying that you don’ t mutate\nthem.\nConsider including units in variable names if they aren’ t clear from the\ntype (e.g., timeMs  or temperatureC ).\nI t e m  3 2 :  A v o i d  I n c l u d i n g  n u l l  o r  u n d e f i n e d  i n\nT y p e  A l i a s e s\nIn this code,  is the optional chain ( ?. ) necessary? Could user  ever be\nnull ?\nfunction getCommentsForUser(comments: readonly Comment[], user: User) { \n  return comments.filter(comment => comment.userId === user?.id);\n}\nEven assuming strictNullChecks , it’ s impossible to say without seeing\nthe definition of User . If it’ s a type alias that allows null  or undefined ,\nthen the optional chain is needed:\ntype User = { id: string; name: string; } | null;\nOn the other hand, if it’ s a simple object type, then it’ s not:\ninterface User { \n  id: string; \n  name: string;\n}\nAs a general rule, it’ s better to avoid type aliases that allow null  or\nundefined  values. While the type checker won’ t be confused if you break\nthis rule, human readers of your code will be. When we read a type name\nlike User , we assume that it represents a user , rather than maybe\nrepresenting a user .\nIf you must include null  in a type alias for some reason, do readers of your\ncode a favor and use a name that’ s unambiguous:\ntype NullableUser = { id: string; name: string; } | null;\nBut why do that when User|null  is a more succinct and universally\nrecognizable syntax?\nfunction getCommentsForUser(comments: readonly Comment[], user: User | null) { \n  return comments.filter(comment => comment.userId === user?.id);\n}\nThis rule is about the top level of type aliases. It’ s not concerned with a\nnull  or undefined  (or optional) property in a lar ger object:\ntype BirthdayMap = { \n  [name: string]: Date | undefined;\n};\nJust don’ t do this:\ntype BirthdayMap = { \n  [name: string]: Date | undefined;\n} | null;\nThere are also reasons to avoid null  values and optional fields in object\ntypes, but that’ s a topic for Items 33  and 37 . For now , avoid type aliases that",2437
42-Item 33 Push Null Values to the Perimeter of Your Types.pdf,42-Item 33 Push Null Values to the Perimeter of Your Types,"will be confusing to readers of your code. Prefer type aliases that represent\nsomething, rather than representing something or  null  or undefined .\nThings to Remember\nA void defining type aliases that include null  or undefined .\nI t e m  3 3 :  P u s h  N u l l  V a l u e s  t o  t h e  P e r i m e t e r  o f\nY o u r  T y p e s\nWhen you  first turn on strictNullChecks , it may seem as though you\nhave to add scores of if  statements checking for null  and undefined\nvalues throughout your code. This is often because the relationships\nbetween null and non-null values are implicit: when variable A is non-null,\nyou know that variable B is also non-null and vice versa. These implicit\nrelationships are confusing both for human readers of your code and for the\ntype checker .\nV alues are easier to work with when they’re either completely null or\ncompletely non-null, rather than a mix. Y ou can model this by pushing the\nnull values out to the perimeter of your structures.\nSuppose you want to calculate the min and max of a list of numbers. W e’ll\ncall this the “extent.” Here’ s an attempt:\n// @strictNullChecks: false\nfunction extent(nums: Iterable<number>) { \n  let min, max; \n  for (const num of nums) { \n    if (!min) { \n      min = num; \n      max = num; \n    } else { \n      min = Math.min(min, num); \n      max = Math.max(max, num); \n    } \n  } \n  return [min, max];\n}\nThe code type checks (without strictNullChecks ) and has an inferred\nreturn type of number[] , which seems fine. But it has a bug and a design\nflaw:\nIf the min or max is zero, it may get overridden. For example,\nextent([0, 1, 2])  will return [1, 2]  rather than [0, 2] .\nIf the nums  array is empty , the function will return [undefined,\nundefined] .\nThis sort of object with several undefined s will be dif ficult for clients to\nwork with and is exactly the sort of type that this item discourages. W e\nknow from reading the source code that either both min  and max  will be\nundefined  or neither will be, but that information isn’ t represented in the\ntype system.\nT urning on strictNullChecks  makes the issue with undefined  more\napparent:\nfunction extent(nums: Iterable<number>) { \n  let min, max; \n  for (const num of nums) { \n    if (!min) { \n      min = num; \n      max = num; \n    } else { \n      min = Math.min(min, num); \n      max = Math.max(max, num); \n      //             ~~~ Argument of type 'number | undefined' is not \n      //                 assignable to parameter of type 'number' \n    } \n  } \n  return [min, max];\n}\nThe return type of extent  is now inferred as (number | undefined)[] ,\nwhich makes the design flaw more apparent. This is likely to manifest as a\ntype error wherever you call extent :\nconst [min, max] = extent([0, 1, 2]);\nconst span = max - min;\n//           ~~~   ~~~ Object is possibly 'undefined'\nThe error in the implementation of extent  comes about because you’ve\nexcluded undefined  as a value for min  but not max . The two are initialized\ntogether , but this information isn’ t present in the type system. Y ou could\nmake it go away by adding a check for max , too, but this would be doubling\ndown on the bug.\nA better solution is to put min  and max  in the same object and make this\nobject either fully null  or fully non- null :\nfunction extent(nums: Iterable<number>) { \n  let minMax: [number, number] | null = null; \n  for (const num of nums) { \n    if (!minMax) { \n      minMax = [num, num]; \n    } else { \n      const [oldMin, oldMax] = minMax; \n      minMax = [Math.min(num, oldMin), Math.max(num, oldMax)]; \n    } \n  } \n  return minMax;\n}\nThe return type is now [number, number] | null , which is easier for\nclients to work with. min  and max  can be retrieved with either a non-null\nassertion:\nconst [min, max] = extent([0, 1, 2])!;\nconst span = max - min;  // OK\nor a single check:\nconst range = extent([0, 1, 2]);\nif (range) { \n  const [min, max] = range; \n  const span = max - min;  // OK\n}\nBy using a single object to track the extent, we’ve improved our design,\nhelped T ypeScript understand the relationship between null values, and\nfixed the bug: the if (!minMax)  check is now problem free.\n(A next step might be to prevent passing non-empty lists to extent , which\nwould remove the possibility of returning null  altogether . Item 64  presents\na way you might represent a non-empty list in T ypeScript’ s type system.)\nA mix of null and non-null values can also lead to problems in classes. For\ninstance, suppose you have a class that represents both a user and their\nposts on a forum:\nclass UserPosts { \n  user: UserInfo | null; \n  posts: Post[] | null; \n \n  constructor() { \n    this.user = null; \n    this.posts = null; \n  } \n \n  async init(userId: string) { \n    return Promise.all([ \n      async () => this.user = await fetchUser(userId), \n      async () => this.posts = await fetchPostsForUser(userId) \n    ]); \n  } \n \n  getUserName() { \n    // ...? \n  }\n}\nWhile the two network requests are loading, the user  and posts  properties\nwill be null . At any time, they might both be null , one might be null , or\nthey might both be non- null . There are four possibilities. This complexity\nwill seep into every method on the class. This design is almost certain to\nlead to confusion, a proliferation of null  checks, and bugs.\nA better design would wait until all the data used by the class is available:\nclass UserPosts { \n  user: UserInfo; \n  posts: Post[]; \n \n  constructor(user: UserInfo, posts: Post[]) { \n    this.user = user; \n    this.posts = posts; \n  } \n \n  static async init(userId: string): Promise<UserPosts> { \n    const [user, posts] = await Promise.all([ \n      fetchUser(userId), \n      fetchPostsForUser(userId) \n    ]); \n    return new UserPosts(user, posts); \n  } \n \n  getUserName() { \n    return this.user.name; \n  }\n}\nNow the UserPosts  class is fully non- null , and it’ s easy to write correct\nmethods on it. Of course, if you need to perform operations while data is\npartially loaded, then you’ll need to deal with the multiplicity  of null  and\nnon-null  states.\nDon’ t be tempted to replace nullable properties with Promises. This tends to\nlead to even more confusing code and forces all your methods to be async.\nPromises clarify the code that loads data but tend to have the opposite ef fect\non the class that uses that data.\nThings to Remember\nA void designs in which one value being null  or not null  is implicitly\nrelated to another value being null  or not null .\nPush null  values to the perimeter of your API by making lar ger\nobjects either null  or fully non- null . This will make code clearer",6752
43-Item 34 Prefer Unions of Interfaces to Interfaces with Unions.pdf,43-Item 34 Prefer Unions of Interfaces to Interfaces with Unions,"both for human readers and for the type checker .\nConsider creating a fully non- null  class and constructing it when all\nvalues are available.\nI t e m  3 4 :  P r e f e r  U n i o n s  o f  I n t e r f a c e s  t o\nI n t e r f a c e s  w i t h  U n i o n s\nIf you create an interface whose properties are union types, you should ask\nwhether the type would make more sense as a union of more precise\ninterfaces.\nSuppose you’re building a vector drawing program and want to define an\ninterface for layers with specific geometry types:\ninterface Layer { \n  layout: FillLayout | LineLayout | PointLayout; \n  paint: FillPaint | LinePaint | PointPaint;\n}\nThe layout  field controls how and where the shapes are drawn (rounded\ncorners? straight?), while the paint  field controls styles (is the line blue?\nthick? thin? dashed?).\nThe intention is that a Layer  will have matching layout  and paint\nproperties. A FillLayout  should go with a FillPaint , and a LineLayout\nshould go with a LinePaint . But this version of the Layer  type also allows\na FillLayout  with a LinePaint . This possibility makes using the library\nmore error prone and makes this interface dif ficult to work with.\nA better way to model this is with separate interfaces for each type of layer:\ninterface FillLayer { \n  layout: FillLayout; \n  paint: FillPaint;\n}\ninterface LineLayer { \n  layout: LineLayout; \n  paint: LinePaint;\n}\ninterface PointLayer { \n  layout: PointLayout; \n  paint: PointPaint;\n}\ntype Layer = FillLayer | LineLayer | PointLayer;\nBy defining Layer  in this way , you’ve excluded the possibility of mixed\nlayout  and paint  properties. This is an example of following Item 29 ’ s\nadvice to prefer types that only represent valid states.\nBy far the most common example of this pattern is  the “tagged union” (or\n“discriminated union”). In this case, one of the properties is a union of\nstring literal types:\ninterface Layer { \n  type: 'fill' | 'line' | 'point'; \n  layout: FillLayout | LineLayout | PointLayout; \n  paint: FillPaint | LinePaint | PointPaint;\n}\nAs before, would it make sense to have type: 'fill'  but then a\nLineLayout  and PointPaint ? Certainly not. Convert Layer  to a union of\ninterfaces to exclude this possibility:\ninterface FillLayer { \n  type: 'fill'; \n  layout: FillLayout; \n  paint: FillPaint;\n}\ninterface LineLayer { \n  type: 'line'; \n  layout: LineLayout; \n  paint: LinePaint;\n}\ninterface PointLayer { \n  type: 'paint'; \n  layout: PointLayout; \n  paint: PointPaint;\n}\ntype Layer = FillLayer | LineLayer | PointLayer;\nThe type  property is the “tag” or “discriminant.” It can be accessed at\nruntime and gives T ypeScript just enough information to determine which\nelement of the union type you’re working with. Here, T ypeScript is able to\nnarrow the type of Layer  in an if  statement based on the tag:\nfunction drawLayer(layer: Layer) { \n  if (layer.type === 'fill') { \n    const {paint} = layer; \n    //     ^? const paint: FillPaint \n    const {layout} = layer; \n    //     ^? const layout: FillLayout \n  } else if (layer.type === 'line') { \n    const {paint} = layer; \n    //     ^? const paint: LinePaint \n    const {layout} = layer; \n    //     ^? const layout: LineLayout \n  } else { \n    const {paint} = layer; \n    //     ^? const paint: PointPaint \n    const {layout} = layer; \n    //     ^? const layout: PointLayout \n  }\n}\nBy correctly modeling the relationship between the properties in this type,\nyou help T ypeScript check your code’ s correctness. The same code\ninvolving the initial Layer  definition would have been cluttered with type\nassertions.\nBecause they work so well with T ypeScript’ s type checker , tagged unions\nare ubiquitous in T ypeScript code. Recognize this pattern and apply it when\nyou can. If you can represent a data type in T ypeScript with a tagged union,\nit’ s usually a good idea to do so.\nIf you think of optional fields as a union of their type and undefined , then\nthey fit the “interface of unions” pattern as well. Consider this type:\ninterface Person { \n  name: string; \n  // These will either both be present or not be present \n  placeOfBirth?: string; \n  dateOfBirth?: Date;\n}\nAs Item 31  explained, the comment with type information is a strong sign\nthat there might be a problem. There is a relationship between the\nplaceOfBirth  and dateOfBirth  fields that you haven’ t told T ypeScript\nabout.\nA better way to model this is to move both of these properties into a single\nobject. This is akin to moving null  values to the perimeter ( Item 33 ):\ninterface Person { \n  name: string; \n  birth?: { \n    place: string; \n    date: Date; \n  }\n}\nNow T ypeScript complains about values with a place but no date of birth:\nconst alanT: Person = { \n  name: 'Alan Turing', \n  birth: {\n// ~~~~ Property 'date' is missing in type\n//      '{ place: string; }' but required in type\n//      '{ place: string; date: Date; }' \n    place: 'London' \n  }\n}\nAdditionally , a function that takes a Person  object only needs to do a single\ncheck:\nfunction eulogize(person: Person) { \n  console.log(person.name); \n  const {birth} = person; \n  if (birth) { \n    console.log(`was born on ${birth.date} in ${birth.place}.`); \n  }\n}\nIf the structure of the type is outside your control (perhaps it’ s coming from\nan API), then you can still model the relationship between these fields using\na now-familiar union of interfaces:\ninterface Name { \n  name: string;\n} \n \ninterface PersonWithBirth extends Name { \n  placeOfBirth: string; \n  dateOfBirth: Date;\n} \n \ntype Person = Name | PersonWithBirth;\nNow you get some of the same benefits as with the nested object:\nfunction eulogize(person: Person) { \n  if ('placeOfBirth' in person) { \n    person \n    // ^? (parameter) person: PersonWithBirth \n    const {dateOfBirth} = person;  // OK \n    //     ^? const dateOfBirth: Date \n  }\n}\nIn both cases, the type definition makes the relationship between the\nproperties more clear .\nWhile optional properties are often useful, you should think twice before\nadding one to an interface. Item 37  explores more of the downsides of\noptional fields.\nThings to Remember\nInterfaces with multiple properties that are union types are often a\nmistake because they obscure the relationships between these\nproperties.",6397
44-Item 35 Prefer More Precise Alternatives to String Types.pdf,44-Item 35 Prefer More Precise Alternatives to String Types,"Unions of interfaces are more precise and can be understood by\nT ypeScript.\nUse tagged unions to facilitate control flow analysis. Because they are\nso well supported, this pattern is ubiquitous in T ypeScript code.\nConsider whether multiple optional properties could be grouped to\nmore accurately model your data.\nI t e m  3 5 :  P r e f e r  M o r e  P r e c i s e  A l t e r n a t i v e s  t o\nS t r i n g  T y p e s\nRecall  from Item 7  that the domain  of a type is the set of values assignable\nto that type. The domain of the string  type is enormous: ""x""  and ""y""  are\nin it, but so is the complete text of Moby Dick  (it starts with ""Call me\nIshmael…""  and is about 1.2 million characters long). When you declare a\nvariable of type string , you should ask whether a narrower type would be\nmore appropriate.\nSuppose you’re building a music collection and want to define a type for an\nalbum. Here’ s an attempt:\ninterface Album { \n  artist: string; \n  title: string; \n  releaseDate: string;  // YYYY-MM-DD \n  recordingType: string;  // E.g., ""live"" or ""studio""\n}\nThe prevalence of string  types and the type information in comments\n( Item 31 ) are strong indications that this interface  isn’ t quite right. Here’ s\nwhat can go wrong:\nconst kindOfBlue: Album = { \n  artist: 'Miles Davis', \n  title: 'Kind of Blue', \n  releaseDate: 'August 17th, 1959',  // Oops! \n  recordingType: 'Studio',  // Oops!\n};  // OK\nThe releaseDate  field is incorrectly formatted (according to the comment)\nand 'Studio'  is capitalized where it should be lowercase. But these values\nar e  both strings, so this object is assignable to Album  and the type checker\ndoesn’ t complain.\nThese broad string  types can mask errors for valid Album  objects, too. For\nexample:\nfunction recordRelease(title: string, date: string) { /* ... */ }\nrecordRelease(kindOfBlue.releaseDate, kindOfBlue.title);  // OK, should be \nerror\nThe parameters are reversed in the call to recordRelease  but both are\nstrings, so the type checker doesn’ t complain. Because of the prevalence of\nstring  types, code like this is sometimes called “stringly typed.” ( Item 38\nexplores how repeated positional parameters of any  type can be\nproblematic, not just string .)\nCan you make the types narrower to prevent these sorts of issues? While the\ncomplete text of Moby Dick  would be a ponderous artist name or album\ntitle, it’ s at least plausible. So string  is appropriate for these fields. For the\nreleaseDate  field, it’ s better to use a Date  object and avoid issues around\nformatting. Finally , for the recordingType  field, you can define a union\ntype with just two values (you could also use an enum , but I generally\nrecommend avoiding these; see Item 72 ):\ntype RecordingType = 'studio' | 'live'; \n \ninterface Album { \n  artist: string; \n  title: string; \n  releaseDate: Date; \n  recordingType: RecordingType;\n}\nW ith these changes, T ypeScript is able to do a more thorough check for\nerrors:\nconst kindOfBlue: Album = { \n  artist: 'Miles Davis', \n  title: 'Kind of Blue', \n  releaseDate: new Date('1959-08-17'), \n  recordingType: 'Studio'\n// ~~~~~~~~~~~~ Type '""Studio""' is not assignable to type 'RecordingType'\n};\nThere are advantages to this approach beyond stricter checking. First,\nexplicitly defining the type ensures that its meaning won’ t get lost as it’ s\npassed around. If you wanted to find albums of just a certain recording type,\nfor instance, you might define a function like this:\nfunction getAlbumsOfType(recordingType: string): Album[] { \n  // ...\n}\nHow does the caller of this function know what recordingType  is expected\nto be? It’ s just a string . The comment explaining that it’ s 'studio'  or\n'live'  is hidden in the definition of Album , where the user might not think\nto look.\nSecond, explicitly defining a type allows you to attach documentation to it\n(see Item 68 ):\n/** What type of environment was this recording made in? */\ntype RecordingType = 'live' | 'studio';\nWhen you change getAlbumsOfType  to take a RecordingType , the caller is\nable to click through and see the documentation (see Figure 4-1 ).\nFigur e 4-1. Using a named type instead of string  makes it possible to attach documentation to the\ntype that is surfaced in your editor .\nAnother common  misuse of string  is in function parameters. Say you want\nto write a function that pulls out all the values for a single field in an array .\nThe Underscore and Ramda utility libraries call this pluck :\nfunction pluck(records, key) { \n  return records.map(r => r[key]);\n}\nHow would you type this? Here’ s an initial attempt:\nfunction pluck(records: any[], key: string): any[] { \n  return records.map(r => r[key]);\n}\nThis type checks but isn’ t great. The any  types are problematic, particularly\non the return value (see Item 43 ). The first step to improving the type\nsignature is introducing a generic type parameter:\nfunction pluck<T>(records: T[], key: string): any[] { \n  return records.map(r => r[key]); \n  //                      ~~~~~~ Element implicitly has an 'any' type \n  //                             because type '{}' has no index signature\n}\nT ypeScript is now complaining that the string  type for key  is too broad.\nAnd it’ s right to do so: if you pass in an array of Album s then there are only\nfour valid values for key  (“artist,” “title,” “releaseDate,” and\n“recordingT ype”), as opposed to the vast set of strings. This is precisely\nwhat the keyof Album  type is:\ntype K = keyof Album;\n//   ^? type K = keyof Album\n//      (equivalent to ""artist"" | ""title"" | ""releaseDate"" | ""recordingType"")\nSo the fix is to replace string  with keyof T :\nfunction pluck<T>(records: T[], key: keyof T) { \n  return records.map(r => r[key]);\n}\nThis passes the type checker . W e’ve also let T ypeScript infer the return\ntype. How does it do? If you mouse over pluck  in your editor , the inferred\ntype is:\nfunction pluck<T>(record: T[], key: keyof T): T[keyof T][];\nT[keyof T]  is the type of any possible value in T . If you’re passing in a\nsingle string as the key , this is too broad. For example:\nconst releaseDates = pluck(albums, 'releaseDate');\n//    ^? const releaseDates: (string | Date)[]\nThe type should be Date[] , not (string | Date)[] . While keyof T  is\nmuch narrower than string , it’ s still  too broad. T o narrow it further , we\nneed to introduce a second type parameter that is a subtype of keyof T\n(probably a single value):\nfunction pluck<T, K extends keyof T>(records: T[], key: K): T[K][] { \n  return records.map(r => r[key]);\n}\nThe type signature is now completely correct. W e can check this by calling\npluck  in a few dif ferent ways:\nconst dates = pluck(albums, 'releaseDate');\n//    ^? const dates: Date[]\nconst artists = pluck(albums, 'artist');\n//    ^? const artists: string[]\nconst types = pluck(albums, 'recordingType');\n//    ^? const types: RecordingType[]\nconst mix = pluck(albums, Math.random() < 0.5 ? 'releaseDate' : 'artist');\n//    ^? const mix: (string | Date)[]\nconst badDates = pluck(albums, 'recordingDate');\n//                             ~~~~~~~~~~~~~~~\n// Argument of type '""recordingDate""' is not assignable to parameter of type \n...\nThe language service is even able to of fer autocomplete on the keys of\nAlbum  (as shown in Figure 4-2 ).\nFigur e 4-2. Using a parameter type of keyof Album  instead of string  r esults in better autocomplete\nin your editor .\nstring  has some of the same problems as any : when used inappropriately ,\nit permits invalid values and hides relationships between types. This thwarts\nthe type checker and can hide real bugs. T ypeScript’ s ability to define\nsubsets of string  is a powerful way to bring type safety to JavaScript code.\nUsing more precise types will both catch errors and improve the readability\nof your code.\nThis item focused on finite sets of string s, but T ypeScript also lets you\nmodel infinite sets, for example, all the string s that start with “http:”. For\nthese, you’ll want to use template literal types, which are the subject of Item\n54 .\nThings to Remember\nA void “stringly typed” code. Prefer more appropriate types where not\nevery string  is a possibility .\nPrefer a union of string literal types to string  if that more accurately\ndescribes the domain of a variable. Y ou’ll get stricter type checking\nand improve the development experience.\nPrefer keyof T  to string  for function parameters that are expected to\nbe properties of an object.",8580
45-Item 36 Use a Distinct Type for Special Values.pdf,45-Item 36 Use a Distinct Type for Special Values,"I t e m  3 6 :  U s e  a  D i s t i n c t  T y p e  f o r  S p e c i a l\nV a l u e s\nJavaScript’ s string split  method is a handy way to break a string around a\ndelimiter:\n> 'abcde'.split('c') \n[ 'ab', 'de' ] \nLet’ s write something like split , but for arrays. Here’ s an attempt:\nfunction splitAround<T>(vals: readonly T[], val: T): [T[], T[]] { \n  const index = vals.indexOf(val); \n  return [vals.slice(0, index), vals.slice(index+1)];\n}\nThis works as you’d expect:\n> splitAround([1, 2, 3, 4, 5], 3) \n[ [ 1, 2 ], [ 4, 5 ] ]\nIf you try to splitAround  an element that’ s not in the list, however , it does\nsomething quite unexpected:\n> splitAround([1, 2, 3, 4, 5], 6) \n[ [ 1, 2, 3, 4 ], [ 1, 2, 3, 4, 5 ] ]\nWhile it’ s not entirely clear what the function should  do in this case, it’ s\ndefinitely not that! How did such simple code result in such strange\nbehavior?\nThe root issue is that indexOf  returns -1  if it can’ t find the element in the\narray . This is a special value: it indicates a failure rather than success. But\n-1  is just an ordinary number . Y ou can pass it to the Array slice  method\nand you can do arithmetic on it. When you pass a negative number to\nslice , it interprets it as counting back from the end of the array . And when\nyou add 1  to -1 , you get 0 . So this evaluates as:\n[vals.slice(0, -1), vals.slice(0)]\nThe first slice  returns all but the last element of the array , and the second\nslice  returns a complete copy of the array .\nThis behavior is a bug. Moreover , it’ s unfortunate that T ypeScript wasn’ t\nable to help us find this problem. The root issue was that indexOf  returned\n-1  when it couldn’ t find the element, rather than, say null . Why is that?\nW ithout hopping in a time machine and visiting the Netscape of fices in\n1995, it’ s hard to know the answer for sure. But we can speculate!\nJavaScript was heavily influenced by Java, and its indexOf  has this same\nbehavior . In Java (and C), a function can’ t return a primitive or  null. Only\nobjects (or pointers) are nullable. So this behavior may derive from a\ntechnical limitation in Java that JavaScript does not share.\nIn JavaScript (and T ypeScript), there’ s no problem having a function return\na number  or null . So we can wrap indexOf :\nfunction safeIndexOf<T>(vals: readonly T[], val: T): number | null { \n  const index = vals.indexOf(val); \n  return index === -1 ? null : index;\n}\nIf we plug that into our original definition of splitAround , we immediately\nget two type errors:\nfunction splitAround<T>(vals: readonly T[], val: T): [T[], T[]] { \n  const index = safeIndexOf(vals, val); \n  return [vals.slice(0, index), vals.slice(index+1)]; \n  //                    ~~~~~              ~~~~~ 'index' is possibly 'null'\n}\nThis is exactly what we want! There are always two cases to consider with\nindexOf . W ith the built-in version, T ypeScript can’ t distinguish them, but\nwith the wrapped version, it can. And it sees here that we’ve only\nconsidered the case where the array contained the value.\nThe solution is to handle the other case explicitly:\nfunction splitAround<T>(vals: readonly T[], val: T): [T[], T[]] { \n  const index = safeIndexOf(vals, val); \n  if (index === null) { \n    return [[...vals], []]; \n  } \n  return [vals.slice(0, index), vals.slice(index+1)];  // ok\n}\nWhether this is the right behavior is debatable, but at least T ypeScript has\nforced us to have that debate!\nThe root problem with the first implementation was that indexOf  had two\ndistinct cases, but the return value in the special case ( -1 ) had the same type\nas the return value in the regular case ( number ). This meant that from\nT ypeScript’ s perspective there was just a single case, and it wasn’ t able to\ndetect that we didn’ t check for -1 .\nThis situation comes up frequently when you’re designing types. Perhaps\nyou have a type for describing merchandise:\ninterface Product { \n  title: string; \n  priceDollars: number;\n}\nThen you realize that some products have an unknown price. Making this\nfield optional or changing it to number|null  might require a migration and\nlots of code changes, so instead you introduce a special value:\ninterface Product { \n  title: string; \n  /** Price of the product in dollars, or -1 if price is unknown */ \n  priceDollars: number;\n}\nY ou ship it to production. A week later your boss is irate and wants to know\nwhy you’ve been crediting money to customer cards. Y our team works to\nroll back the change and you’re tasked with writing the postmortem. In\nretrospect, it would have been much easier to deal with those type errors!\nChoosing in-domain special values like -1 , 0 , or """"  is similar in spirit to\nturning of f strictNullChecks . When strictNullChecks  is of f, you can\nassign null  or undefined  to any type:\n// @strictNullChecks: false\nconst truck: Product = { \n  title: 'Tesla Cybertruck', \n  priceDollars: null,  // ok\n};\nThis lets a huge class of bugs slip through the type checker because\nT ypeScript doesn’ t distinguish between number  and number|null . null  is\na valid value in all types. When you enable strictNullChecks , T ypeScript\ndoes  distinguish between these types and it’ s able to detect a whole host of\nnew problems. When you choose an in-domain special value like -1 , you’re\nef fectively carving out a non-strict niche in your types. Expedient, yes, but\nultimately not the best choice.\nnull  and undefined  may not always be the right way to represent special\ncases since their exact meaning may be context dependent. If you’re\nmodeling the state of a network request, for example, it would be a bad idea\nto use null  to mean an error state and undefined  to mean a pending state.\nBetter to use a tagged union to represent these special states more explicitly .\nItem 29  explores this example in more detail.\nThings to Remember\nA void special values that are assignable to regular values in a type.\nThey will reduce T ypeScript’ s ability to find bugs in your code.\nPrefer null  or undefined  as a special value instead of 0 , -1 , or """" .\nConsider using a tagged union rather than null  or undefined  if the\nmeaning of those values isn’ t clear .",6239
46-Item 37 Limit the Use of Optional Properties.pdf,46-Item 37 Limit the Use of Optional Properties,"I t e m  3 7 :  L i m i t  t h e  U s e  o f  O p t i o n a l  P r o p e r t i e s\nAs your types evolve, you’ll inevitably want to add new properties to them.\nT o avoid invalidating existing code or data, you might choose to make these\nproperties optional. While this is sometimes the right choice, optional\nproperties do come at a cost and you should think twice before adding\nthem.\nImagine you have a UI component that displays numbers with a label and\nunits. Think “Height: 12 ft” or “Speed: 10 mph”:\ninterface FormattedValue { \n  value: number; \n  units: string;\n}\nfunction formatValue(value: FormattedValue) { /* ... */ }\nY ou build a big web application using this component. Perhaps part of it\ndisplays formatted information about a hike you’ve taken (“5 miles at 2\nmph”):\ninterface Hike { \n  miles: number; \n  hours: number;\n}\nfunction formatHike({miles, hours}: Hike) { \n  const distanceDisplay = formatValue({value: miles, units: 'miles'}); \n  const paceDisplay = formatValue({value: miles / hours, units: 'mph'}); \n  return `${distanceDisplay} at ${paceDisplay}`;\n}\nOne day you learn about the metric system and decide to support it. T o\nsupport both metric and imperial, you add a corresponding option to\nFormattedValue . If needed, the component will do a unit conversion\nbefore displaying the value. T o minimize changes to existing code and tests,\nyou decide to make the property optional:\ntype UnitSystem = 'metric' | 'imperial';\ninterface FormattedValue { \n  value: number; \n  units: string; \n  /** default is imperial */ \n  unitSystem?: UnitSystem;\n}\nT o let the user configure this, we’ll also want to specify a unit system in our\napp-wide configuration:\ninterface AppConfig { \n  darkMode: boolean; \n  // ... other settings ... \n  /** default is imperial */ \n  unitSystem?: UnitSystem;\n}\nNow we can update formatHike  to support the metric system:\nfunction formatHike({miles, hours}: Hike, config: AppConfig) { \n  const { unitSystem } = config; \n  const distanceDisplay = formatValue({ \n    value: miles, units: 'miles', unitSystem \n  }); \n  const paceDisplay = formatValue({ \n    value: miles / hours, units: 'mph'  // forgot unitSystem, oops! \n  }); \n  return `${distanceDisplay} at ${paceDisplay}`;\n}\nW e set unitSystem  in one call to formatValue  but not the other . This is a\nbug that means our metric users will see a mix of imperial and metric units.\nIn fact, our design is a recipe for exactly this sort of bug. In every place that\nwe use the formatValue  component, we need to remember to pass in a\nunitSystem . Whenever we don’ t, metric users will see confusing imperial\nunits like yards, acres, or foot-pounds.\nIt would be nice if there were a way to automatically find every place where\nwe for got to pass in a unitSystem . This is exactly the sort of thing that type\nchecking is good at, but we’ve kept it from helping us by making the\nunitSystem  property optional.\nIf you make it required instead, you’ll get a type error everywhere you\nfor got to set it. Y ou’ll have to fix these one by one, but it’ s much better to\nhave T ypeScript find these mistakes than to hear about them from confused\nusers!\nThe “default is imperial” documentation comment is also worrisome. In\nT ypeScript, the default value of an optional property on an object is always\nundefined . T o implement an alternative default, our code is likely to be\nlittered with lines like this:\ndeclare let config: AppConfig;\nconst unitSystem = config.unitSystem ?? 'imperial';\nEvery one of these is an opportunity for a bug. Perhaps another developer\non your team for gets that imperial is the default (why is it the default\nanyway?) and assumes it should be metric:\nconst unitSystem = config.unitSystem ?? 'metric';\nOnce again the result will be inconsistent display .\nIf you need to support old values of the AppConfig  interface (perhaps\nthey’re saved as JSON on disk or in a database) then you can’ t make the\nnew field required. What you can do instead is split the type in two: one\ntype for un-normalized configurations read from disk, and another with\nfewer optional properties for use in your app:\ninterface InputAppConfig { \n  darkMode: boolean; \n  // ... other settings ... \n  /** default is imperial */ \n  unitSystem?: UnitSystem;\n}\ninterface AppConfig extends InputAppConfig { \n  unitSystem: UnitSystem;  // required\n}\nIf changing an optional property to required in a subtype feels strange, see\nItem 7 . Y ou could also use Required<InputAppConfig>  here.\nY ou’ll want to add some normalization code:\nfunction normalizeAppConfig(inputConfig: InputAppConfig): AppConfig { \n  return { \n    ...inputConfig, \n    unitSystem: inputConfig.unitSystem ?? 'imperial', \n  };\n}\nThis split solves a few problems:\n1 . It allows the config to evolve and maintain backward compatibility\nwithout adding complexity throughout the application.\n2 . It centralizes the application of default values.\n3 . It makes it hard to use an InputAppConfig  where an AppConfig  is\nexpected.\nThese sorts of “under construction” types come up frequently with network\ncode. See UserPosts  in Item 33  for another example.\nAs you add more optional properties to an interface , you’ll run into a new\nproblem: if you have N  optional properties then there are 2N possible\ncombinations of them. That’ s a lot of possibilities! If you have 10 optional\nproperties, have you tested all 1,024 combinations? Do all the combinations\neven make sense? It’ s likely that there’ s some structure to these options,\nperhaps some that are mutually exclusive. If so, then your state should\nmodel this (see Item 29 ). This is a problem with options in general, not just\noptional properties.\nFinally , optional properties are a possible source of unsoundness in\nT ypeScript. Item 48  discusses this in more detail.\nAs you’ve seen, there are lots of reasons to avoid optional properties. So\nwhen should  you use them? They’re lar gely unavoidable when describing\nexisting APIs or evolving APIs while maintaining backward compatibility .",6115
47-Item 38 Avoid Repeated Parameters of the Same Type.pdf,47-Item 38 Avoid Repeated Parameters of the Same Type,"For huge configurations, it may be prohibitively expensive to fill in all\noptional fields with default values. And some properties truly are optional:\nnot everyone has a middle name, so an optional middleName  property on a\nPerson  type is an accurate model. But be aware of the many drawbacks of\noptional properties, know how to mitigate them, and think twice before\nadding an optional property if there’ s a valid alternative.\nThings to Remember\nOptional properties can prevent the type checker from finding bugs\nand can lead to repeated and possibly inconsistent code for filling in\ndefault values.\nThink twice before adding an optional property to an interface.\nConsider whether you could make it required instead.\nConsider creating distinct types for un-normalized input data and\nnormalized data for use in your code.\nA void a combinatorial explosion of options.\nI t e m  3 8 :  A v o i d  R e p e a t e d  P a r a m e t e r s  o f  t h e\nS a m e  T y p e\nWhat does this function call do?\ndrawRect(25, 50, 75, 100, 1);\nW ithout looking at the function’ s parameter list, it’ s impossible to say . Here\nare a few possibilities:\nIt draws a 75 × 100 rectangle with its top left at (25, 50) with an\nopacity of 1.0.\nIt draws a 50 × 50 rectangle with corners at (25, 50) and (75, 100),\nwith a stroke width of one pixel.\nW ithout more context, it’ s hard to know whether this function is being\ncalled correctly . And because all the parameters are of the same type,\nnumber , the type checker won’ t be able to help you if you mix up the order\nor pass in a width and height instead of a second coordinate.\nSuppose this was the function declaration:\nfunction drawRect(x: number, y: number, w: number, h: number, opacity: number) \n{ \n  // ...\n}\nAny function that takes consecutive parameters of the same type is error\nprone because the type checker won’ t be able to catch incorrect invocations.\nOne way to improve the situation would be to take in distinct Point  and\nDimension  types:\ninterface Point { \n  x: number; \n  y: number;\n}\ninterface Dimension { \n  width: number; \n  height: number;\n}\nfunction drawRect(topLeft: Point, size: Dimension, opacity: number) { \n  // ...\n}\nBecause the function now takes three parameters with three dif ferent types,\nthe type checker is able to distinguish between them. An incorrect\ninvocation that passes in two points will be an error:\ndrawRect({x: 25, y: 50}, {x: 75, y: 100}, 1.0);\n//                        ~\n// Argument ... is not assignable to parameter of type 'Dimension'.\nAn alternative fix would be to combine all the parameters into a single\nobject:\ninterface DrawRectParams extends Point, Dimension { \n  opacity: number;\n}\nfunction drawRect(params: DrawRectParams) { /* ... */ } \n \ndrawRect({x: 25, y: 50, width: 75, height: 100, opacity: 1.0});\nRefactoring a function to take an object rather than positional parameters\nimproves clarity for human readers. And, by associating names with each\nnumber , it helps the type checker catch incorrect invocations as well.\nAs your code evolves, functions may be modified to take more and more\nparameters. Even if positional parameters worked well at first, at some\npoint they will become a problem. As the saying goes, “If you have a\nfunction with 10 parameters, you probably missed some.” Once a function\ntakes more than three or four parameters, you should refactor it to take\nfewer . (typescript-eslint’ s max-params  rule can enforce this.)\nWhen the types of the parameters are the same, you should be even more\nwary of positional parameters. Even two parameters might be a problem.\nThere are a few exceptions to this rule:\nIf the ar guments are commutative (the order doesn’ t matter), then\nthere’ s no problem. max(a, b)  and isEqual(a, b) , for example, are\nunambiguous.\nIf there’ s a “natural” order to the parameters, then the potential for\nconfusion is reduced. array.slice(start, stop)  makes more sense\nthan stop , start , for example. Be careful with this, though:\ndevelopers might not always agree what a “natural” order is. (Is it year ,\nmonth, day? Month, day , year? Day , month, year?)\nAs Scott Meyers wrote in Effective C++ , “Make interfaces easy to use\ncorrectly and hard to use incorrectly .” It’ s hard to ar gue with that!\nThings to Remember",4339
48-Item 39 Prefer Unifying Types to Modeling Differences.pdf,48-Item 39 Prefer Unifying Types to Modeling Differences,"A void writing functions that take consecutive parameters with the\nsame T ypeScript type.\nRefactor functions that take many parameters to take fewer parameters\nwith distinct types, or a single object  parameter .\nI t e m  3 9 :  P r e f e r  U n i f y i n g  T y p e s  t o  M o d e l i n g\nD i f f e r e n c e s\nT ypeScript’ s type system gives you powerful tools to map between types.\nItem 15  and Chapter 6  explain how to use many of them. Once you realize\nthat you can model a transformation using the type system, you may feel an\noverwhelming ur ge to do so. And this will feel productive. So many types!\nSo much safety!\nIf it’ s available to you, though, a better option than modeling  the dif ference\nbetween two types is to eliminate  the dif ference between those two types.\nThen no type-level machinery is required, and the cognitive burden of\nkeeping track of which version of a type you’re working with goes away .\nT o make this more concrete, imagine you have an interface that derives\nfrom a database table. Databases typically use snake_case for column\nnames, so this is how your data comes out:\ninterface StudentTable { \n  first_name: string; \n  last_name: string; \n  birth_date: string;\n}\nT ypeScript code typically uses camelCase property names. T o make the\nStudent  type more consistent with the rest of your code, you might\nintroduce an alternate version of Student :\ninterface Student { \n  firstName: string; \n  lastName: string; \n  birthDate: string;\n}\nY ou can write a function to convert between these two types. More\ninterestingly , you can use template literal types to type  this function. Item\n54  walks through how to do this, but the end result is that you can generate\none type from the other:\ntype Student = ObjectToCamel<StudentTable>;\n//   ^? type Student = {\n//        firstName: string;\n//        lastName: string;\n//        birthDate: string;\n//      }\nAmazing! After the thrill of finding a compelling use case for fancy type-\nlevel programming wears of f, you may find yourself running into lots of\nerrors from passing one version of the type to a function that’ s expecting the\nother:\nasync function writeStudentToDb(student: Student) { \n  await writeRowToDb(db, 'students', student); \n  //                                 ~~~~~~~ \n  // Type 'Student' is not assignable to parameter of type 'StudentTable'.\n}\nIt’ s not obvious from the error message, but the problem is that you’ve\nfor gotten to call your conversion code:\nasync function writeStudentToDb(student: Student) { \n  await writeRowToDb(db, 'students', objectToSnake(student));  // ok\n}\nWhile it’ s helpful that T ypeScript flagged this mistake before it caused a\nruntime error , it would be simpler to have just a single version of the\nStudent  type in your code so that this error is impossible to make.\nThere are two versions of the Student  type. Which should you choose?\nT o adopt the camelCase version, you’ll need to set up some kind of\nadapter to make sure your database returns camelCased version of the\ncolumns. Y ou’ll also need to make sure that whatever tool you use to\ngenerate T ypeScript types from your database knows about this\ntransformation. The advantage of this approach is that your database\ninterfaces will look just like all your other types.\nT o adopt the snake_case version, you don’ t need to do anything at all.\nY ou just need to accept a superficial inconsistency in the naming\nconvention for a deeper consistency in your types.\nEither of these approaches is feasible, but the latter is simpler .\nThe general principle is that you should prefer unifying types to modeling\nsmall dif ferences between them. That being said, there are some caveats to\nthis rule.\nFirst, unification isn’ t always an option. Y ou may need the two types if the\ndatabase and the API aren’ t under your control. If this is the case, then\nmodeling these sorts of dif ferences systematically in the type system will\nhelp you find bugs in your transformation code. It’ s better than creating\ntypes ad hoc and hoping they stay in sync.\nSecond, don’ t unify types that aren’ t actually representing the same thing!\n“Unifying” the dif ferent types in a tagged union would be\ncounterproductive, for example, because they presumably represent\ndif ferent states that you want to keep separate.\nThings to Remember\nHaving distinct variants of the same type creates cognitive overhead\nand requires lots of conversion code.\nRather than modeling slight variations on a type in your code, try to\neliminate the variation so that you can unify to a single type.\nUnifying types may require some adjustments to runtime code.",4698
49-Item 40 Prefer Imprecise Types to Inaccurate Types.pdf,49-Item 40 Prefer Imprecise Types to Inaccurate Types,"If the types aren’ t in your control, you may need to model the\nvariations.\nDon’ t unify types that aren’ t representing the same thing.\nI t e m  4 0 :  P r e f e r  I m p r e c i s e  T y p e s  t o  I n a c c u r a t e\nT y p e s\nIn writing type declarations you’ll inevitably find situations where you can\nmodel behavior in a more precise or less precise way . Precision in types is\ngenerally a good thing  because it will help your users catch bugs and take\nadvantage of the tooling that T ypeScript provides. But take care as you\nincrease the precision of your type declarations: it’ s easy to make mistakes,\nand incorrect types can be worse than no types at all.\nSuppose you are writing type declarations for GeoJSON, a format we’ve\nseen before in Item 33 . A GeoJSON geometry can be one of a few types,\neach of which has dif ferently shaped coordinate arrays:\ninterface Point { \n  type: 'Point'; \n  coordinates: number[];\n}\ninterface LineString { \n  type: 'LineString'; \n  coordinates: number[][];\n}\ninterface Polygon { \n  type: 'Polygon'; \n  coordinates: number[][][];\n}\ntype Geometry = Point | LineString | Polygon;  // Also several others\nThis is fine, but number[]  for a coordinate is a bit imprecise. Really these\nare latitudes and longitudes, so perhaps a tuple type would be better:\ntype GeoPosition = [number, number];\ninterface Point { \n  type: 'Point'; \n  coordinates: GeoPosition;\n}\n// Etc.\nY ou publish your more precise types to the world and wait for the adulation\nto roll in. Unfortunately , a user complains that your new types have broken\neverything. Even though you’ve only ever used latitude and longitude, a\nposition in GeoJSON is allowed to have a third element, an elevation, and\npotentially more. In an attempt to make the type declarations more precise,\nyou’ve gone too far and made the types inaccurate! T o continue using your\ntype declarations, your user will have to introduce type assertions or silence\nthe type checker entirely with as any . Perhaps they’ll give up and start\nwriting their own  declarations.\nAs another example, consider trying to write type declarations for a Lisp-\nlike language defined in JSON:\n12\n""red""\n[""+"", 1, 2]  // 3\n[""/"", 20, 2]  // 10\n[""case"", ["">"", 20, 10], ""red"", ""blue""]  // ""red""\n[""rgb"", 255, 0, 127]  // ""#FF007F""\nThe Mapbox library uses a system like this to determine the appearance of\nmap features across many devices. There’ s a whole spectrum of precision\nwith which you could try to type this:\n1 . Allow anything.\n2 . Allow strings, numbers, and arrays.\n3 . Allow strings, numbers, and arrays starting with known function\nnames.\n4 . Make sure each function gets the correct number of ar guments.\n5 . Make sure each function gets the correct type of ar guments.\nThe first two options are straightforward:\ntype Expression1 = any;\ntype Expression2 = number | string | any[];\nA type system is said to be “complete” if it allows all valid programs. These\ntwo types will  allow all valid Mapbox expressions. There will be no false\npositive errors. But with such simple types there will be many false\nnegatives: invalid expressions that aren’ t flagged as such. In other words,\nthe types are not very precise.\nLet’ s see if we can improve the precision without losing the completeness\nproperty . T o avoid regressions, we should introduce a test set of expressions\nthat are valid and expressions that are not. ( Item 55  is all about testing\ntypes.)\nconst okExpressions: Expression2[] = [ \n  10, \n  ""red"", \n  [""+"", 10, 5], \n  [""rgb"", 255, 128, 64], \n  [""case"", ["">"", 20, 10], ""red"", ""blue""],\n];\nconst invalidExpressions: Expression2[] = [ \n  true,\n// ~~~ Type 'boolean' is not assignable to type 'Expression2' \n  [""**"", 2, 31],  // Should be an error: no ""**"" function \n  [""rgb"", 255, 0, 127, 0],  // Should be an error: too many values \n  [""case"", ["">"", 20, 10], ""red"", ""blue"", ""green""],  // (Too many values)\n];\nT o go to the next level of precision, you can use a union of string literal\ntypes as the first element of a tuple:\ntype FnName = '+' | '-' | '*' | '/' | '>' | '<' | 'case' | 'rgb';\ntype CallExpression = [FnName, ...any[]];\ntype Expression3 = number | string | CallExpression; \n \nconst okExpressions: Expression3[] = [ \n  10, \n  ""red"", \n  [""+"", 10, 5], \n  [""rgb"", 255, 128, 64], \n  [""case"", ["">"", 20, 10], ""red"", ""blue""],\n];\nconst invalidExpressions: Expression3[] = [ \n  true, \n  // Error: Type 'boolean' is not assignable to type 'Expression3' \n  [""**"", 2, 31], \n  // ~~ Type '""**""' is not assignable to type 'FnName' \n  [""rgb"", 255, 0, 127, 0],  // Should be an error: too many values \n  [""case"", ["">"", 20, 10], ""red"", ""blue"", ""green""],  // (Too many values)\n];\nThere’ s one new caught error and no regressions. Pretty good! One\ncomplication is that our type declarations have become more closely related\nto our Mapbox version. If Mapbox adds a new function, then the type\ndeclarations need to add it, too. These types are more precise, but they’re\nalso higher maintenance.\nWhat if you want to make sure that each function gets the correct number of\nar guments?  This gets trickier since the types now need to be  recursive to\nreach down into all the function calls. T ypeScript allows this, though we do\nneed to take some care to convince the type checker that our recursion isn’ t\ninfinite. There are a few ways to do this. One is to define CaseCall  (which\nmust be an array of even length) with an interface  rather than a type .\nThis is possible, if a bit awkward:\ntype Expression4 = number | string | CallExpression; \n \ntype CallExpression = MathCall | CaseCall | RGBCall; \n \ntype MathCall = [ \n  '+' | '-' | '/' | '*' | '>' | '<', \n  Expression4, \n  Expression4,\n]; \n \ninterface CaseCall { \n  0: 'case'; \n  [n: number]: Expression4; \n  length: 4 | 6 | 8 | 10 | 12 | 14 | 16; // etc.\n} \n \ntype RGBCall = ['rgb', Expression4, Expression4, Expression4];\nLet’ s see how we’ve done:\nconst okExpressions: Expression4[] = [ \n  10, \n  ""red"", \n  [""+"", 10, 5], \n  [""rgb"", 255, 128, 64], \n  [""case"", ["">"", 20, 10], ""red"", ""blue""],\n];\nconst invalidExpressions: Expression4[] = [ \n  true,\n// ~~~ Type 'boolean' is not assignable to type 'Expression4' \n  [""**"", 2, 31],\n// ~~~~ Type '""**""' is not assignable to type '""+"" | ""-"" | ""/"" | ... \n  [""rgb"", 255, 0, 127, 0], \n  //                   ~ Type 'number' is not assignable to type 'undefined'. \n  [""case"", ["">"", 20, 10], ""red"", ""blue"", ""green""], \n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n  // Types of property 'length' are incompatible. \n  //    Type '5' is not assignable to type '4 | 6 | 8 | 10 | 12 | 14 | 16'.\n];\nNow all the invalid expressions produce errors. And it’ s interesting that you\ncan express something like “an array of even length” using a T ypeScript\ninterface . But some of these error messages are a bit confusing,\nparticularly the one about Type '5' .\nIs this an improvement over the previous, less precise types? The fact that\nyou get errors for more incorrect usages is definitely a win, but confusing\nerror messages will make this type more dif ficult to work with. As Item 6\nexplained, language services are as much a part of the T ypeScript\nexperience as type checking, so it’ s a good idea to look at the error\nmessages resulting from your type declarations and try autocomplete in\nsituations where it should work. If your new type declarations are more\nprecise but break autocomplete, then they’ll make for a less enjoyable\nT ypeScript development experience.\nThe complexity of this type declaration has also increased the odds that a\nbug will creep in. For example, Expression4  requires that all math\noperators take two parameters, but the Mapbox expression spec says that +\nand *  can take more. Also, -  can take a single parameter , in which case it\nnegates its input. Expression4  incorrectly flags errors in all of these:\nconst moreOkExpressions: Expression4[] = [ \n  ['-', 12], \n  // ~~~~~~ Type '[""-"", number]' is not assignable to type 'MathCall'. \n  //          Source has 2 element(s) but target requires 3. \n  ['+', 1, 2, 3], \n  //          ~ Type 'number' is not assignable to type 'undefined'. \n  ['*', 2, 3, 4], \n  //          ~ Type 'number' is not assignable to type 'undefined'.\n];\nOnce again, in trying to be more precise we’ve overshot and become\ninaccurate. These inaccuracies can be corrected, but you’ll want to expand\nyour test set to convince yourself that you haven’ t missed anything else.\nComplex code generally requires more tests, and the same is true of types.\nAs you refine types, it can be helpful to think of the “uncanny valley”\nmetaphor . As a cartoonish drawing becomes more true to life, we tend to\nperceive it as becoming more realistic. But only up to a point. If it goes for\ntoo much realism, we tend to hyperfocus on the few remaining inaccuracies.\nIn the same way , refining very imprecise types like any  is almost always\nhelpful. Y ou and your coworkers will perceive this as an improvement to\ntype safety and productivity . But as your types get more precise, the\nexpectation that they’ll also be accurate increases. Y ou’ll start to trust the\ntypes to catch most errors, and so the inaccuracies will stand out more\nstarkly . If you spend hours tracking down a type error , only to find that the\ntypes are inaccurate, it will undermine confidence in your type declarations\nand perhaps T ypeScript itself. It certainly won’ t boost your productivity!\nThings to Remember\nA void the uncanny valley of type safety: complex but inaccurate types\nare often worse than simpler , less precise types. If you cannot model a\ntype accurately , do not model it inaccurately! Acknowledge the gaps\nusing any  or unknown .",9824
50-Item 41 Name Types Using the Language of Your Problem Domain.pdf,50-Item 41 Name Types Using the Language of Your Problem Domain,"Pay attention to error messages and autocomplete as you make typings\nincreasingly precise. It’ s not just about correctness: developer\nexperience matters, too.\nAs your types grow more complex, your test suite for them should\nexpand.\nI t e m  4 1 :  N a m e  T y p e s  U s i n g  t h e  L a n g u a g e  o f\nY o u r  P r o b l e m  D o m a i n\nTher e ar e only two har d pr oblems in Computer Science: cache\ninvalidation and naming  things.\n— Phil Karlton\nThis book has had much to say about the shape  of types and the sets of\nvalues in their domains, but much less about what you name  your types. But\nthis is an important part of type design, too. W ell-chosen type, property , and\nvariable names can clarify intent and raise the level of abstraction of your\ncode and types. Poorly chosen types can obscure your code and lead to\nincorrect mental models.\nSuppose you’re building out a database of animals. Y ou create an interface\nto represent one:\ninterface Animal { \n  name: string; \n  endangered: boolean; \n  habitat: string;\n} \n \nconst leopard: Animal = { \n  name: 'Snow Leopard', \n  endangered: false, \n  habitat: 'tundra',\n};\nThere are a few issues here:\nname  is a very general term. What sort of name are you expecting? A\nscientific name? A common name?\nThe boolean endangered  field is also ambiguous. What if an animal is\nextinct? Is the intent here “endangered or worse”? Or does it literally\nmean endangered?\nThe habitat  field is very ambiguous, not just because of the overly\nbroad string  type ( Item 35 ), but also because it’ s unclear what’ s\nmeant by “habitat.”\nThe variable name is leopard , but the value of the name  property is\n“Snow Leopard.” Is this distinction meaningful?\nHere’ s a type declaration and value with less ambiguity:\ninterface Animal { \n  commonName: string; \n  genus: string; \n  species: string; \n  status: ConservationStatus; \n  climates: KoppenClimate[];\n}\ntype ConservationStatus = 'EX' | 'EW' | 'CR' | 'EN' | 'VU' | 'NT' | 'LC';\ntype KoppenClimate = | \n  'Af' | 'Am' | 'As' | 'Aw' | \n  'BSh' | 'BSk' | 'BWh' | 'BWk' | \n  'Cfa' | 'Cfb' | 'Cfc' | 'Csa' | 'Csb' | 'Csc' | 'Cwa' | 'Cwb' | 'Cwc' | \n  'Dfa' | 'Dfb' | 'Dfc' | 'Dfd' | \n  'Dsa' | 'Dsb' | 'Dsc' | 'Dwa' | 'Dwb' | 'Dwc' | 'Dwd' | \n  'EF' | 'ET';\nconst snowLeopard: Animal = { \n  commonName: 'Snow Leopard', \n  genus: 'Panthera', \n  species: 'Uncia', \n  status: 'VU',  // vulnerable \n  climates: ['ET', 'EF', 'Dfd'],  // alpine or subalpine\n};\nThis makes a number of improvements:\nname  has been replaced with more specific terms: commonName , genus ,\nand species .\nendangered  has become status , a ConservationStatus  type that\nuses a standard classification system from the IUCN.\nhabitat  has become climates  and uses another standard taxonomy ,\nthe Köppen climate classification.\nIf you needed more information about the fields in the first version of this\ntype, you’d have to go find the person who wrote them and ask. In all\nlikelihood, they’ve left the company or don’ t remember . W orse yet, you\nmight run git blame  to find out who wrote these lousy types, only to find\nthat it was you!\nThe situation is much improved with the second version. If you want to\nlearn more about the Köppen climate classification system or track down\nwhat the precise meaning of a conservation status is, then there are a myriad\nof resources online to help you.\nEvery domain has specialized vocabulary to describe its subject. Rather\nthan inventing your own terms, try to reuse terms from the domain of your\nproblem. These vocabularies have often been honed over years, decades, or\ncenturies and are well understood by people in the field. Using these terms\nwill help you communicate with users and increase the clarity of your types.\nT ake care to use domain vocabulary accurately: co-opting the language of a\ndomain to mean something dif ferent is even more confusing than inventing\nyour own.\nThese same considerations apply to other labels as well, such as function\nparameter names, tuple labels, and index type labels.\nHere are a few other rules to keep in mind as you name types, properties,\nand variables:\nMake distinctions meaningful. In writing and speech it can be tedious\nto use the same word over and over . W e introduce synonyms to break",4335
51-Item 42 Avoid Types Based on Anecdotal Data.pdf,51-Item 42 Avoid Types Based on Anecdotal Data,"the monotony . This makes prose more enjoyable to read, but it has the\nopposite ef fect on code. If you use two dif ferent terms, make sure\nyou’re drawing a meaningful distinction. If not, you should use the\nsame term.\nA void vague, meaningless names like “data,” “info,” “thing,” “item,”\n“object,” or the ever -popular “entity .” If Entity has a specific meaning\nin your domain, fine. But if you’re using it because you don’ t want to\nthink of a more meaningful name, then you’ll eventually run into\ntrouble: there may be multiple distinct types called “Entity” in your\nproject, and can you remember what’ s an Item and what’ s an Entity?\nName things for what they are, not for what they contain or how they\nare computed. Directory  is more meaningful than INodeList . It\nallows you to think about a directory as a concept, rather than in terms\nof its implementation. Good names can increase your level of\nabstraction and decrease your risk of inadvertent collisions.\nThings to Remember\nReuse names from the domain of your problem where possible to\nincrease the readability and level of abstraction of your code. Make\nsure you use domain terms accurately .\nA void using dif ferent names for the same thing: make distinctions in\nnames meaningful.\nA void vague names like “Info” or “Entity .” Name types for what they\nare, rather than for their shape.\nI t e m  4 2 :  A v o i d  T y p e s  B a s e d  o n  A n e c d o t a l\nD a t a\nThe other items in this chapter have discussed the many benefits of good\ntype design and shown what can go wrong without it. A well-designed type\nmakes T ypeScript a pleasure to use, while a poorly designed one can make\nit miserable to use. But this does put quite a bit of pressure on type design.\nW ouldn’ t it be nice if you didn’ t have to do this yourself?\nAt least some of your types are likely to come from outside your program:\nspecifications, file formats, APIs, or database schemas. It’ s tempting to\nwrite declarations for these types yourself based on the data you’ve seen,\nperhaps the rows in your test database or the responses you’ve seen from a\nparticular API endpoint.\nResist this ur ge! It’ s far better to import types from another source or\ngenerate them from a specification. When you write types yourself based on\nanecdotal data, you’re only considering the examples you’ve seen. Y ou\nmight be missing important edge cases that could break your program.\nWhen you use more of ficial types, T ypeScript will help ensure that this\ndoesn’ t happen.\nIn Item 30  we used a function that calculated the bounding box of a\nGeoJSON feature. Here’ s what a definition might look like:\nfunction calculateBoundingBox(f: GeoJSONFeature): BoundingBox | null { \n  let box: BoundingBox | null = null; \n \n  const helper = (coords: any[]) => { \n    // ... \n  }; \n \n  const {geometry} = f; \n  if (geometry) { \n    helper(geometry.coordinates); \n  } \n \n  return box;\n}\nHow would you define the GeoJSONFeature  type? Y ou could look at some\nGeoJSON features in your repo and sketch out an interface :\ninterface GeoJSONFeature { \n  type: 'Feature'; \n  geometry: GeoJSONGeometry | null; \n  properties: unknown;\n}\ninterface GeoJSONGeometry { \n  type: 'Point' | 'LineString' | 'Polygon' | 'MultiPolygon'; \n  coordinates: number[] | number[][] | number[][][] | number[][][][];\n}\nThe function passes the type checker with this definition. But is it really\ncorrect? This check is only as good as our homegrown type declarations.\nA better approach would be to use the formal GeoJSON spec.1 Fortunately\nfor us, there are already T ypeScript type declarations for it on\nDefinitelyT yped. Y ou can add these in the usual way:2\n$ npm install --save-dev @types/geojson \n+ @types/geojson@7946.0.14\nW ith these declarations, T ypeScript flags an error:\nimport {Feature} from 'geojson'; \n \nfunction calculateBoundingBox(f: Feature): BoundingBox | null { \n  let box: BoundingBox | null = null; \n \n  const helper = (coords: any[]) => { \n    // ... \n  }; \n \n  const {geometry} = f; \n  if (geometry) { \n    helper(geometry.coordinates); \n    //              ~~~~~~~~~~~ \n    //   Property 'coordinates' does not exist on type 'Geometry' \n    //     Property 'coordinates' does not exist on type 'GeometryCollection' \n  } \n \n  return box;\n}\nThe problem is that this code assumes that a geometry will have a\ncoordinates  property . This is true for many geometries, including points,\nlines, and polygons. But a GeoJSON geometry can also be a\nGeometryCollection , a heterogeneous collection of other geometries.\nUnlike the other geometry types, it does not have a coordinates  property .\nIf you call calculateBoundingBox  on a feature whose geometry is a\nGeometry Col lec tion , it will throw an error about not being able to read\nproperty 0  of undefined .  This is a real bug! And we caught it by sourcing\ntypes from the community .\nOne option for fixing the bug is to explicitly disallow\nGeometryCollection s:\nconst {geometry} = f;\nif (geometry) { \n  if (geometry.type === 'GeometryCollection') { \n    throw new Error('GeometryCollections are not supported.'); \n  } \n  helper(geometry.coordinates);  // OK\n}\nT ypeScript is able to refine the type of geometry  based on the check, so the\nreference to geometry.coordinates  is allowed. If nothing else, this results\nin a clearer error message for the user .\nBut the better solution is to support GeometryCollection s! Y ou can do\nthis by pulling out another helper function:\nconst geometryHelper = (g: Geometry) => { \n  if (g.type === 'GeometryCollection') { \n    g.geometries.forEach(geometryHelper); \n  } else { \n    helper(g.coordinates);  // OK \n  }\n} \n \nconst {geometry} = f;\nif (geometry) { \n  geometryHelper(geometry);\n}\nOur handwritten GeoJSON types were based only on our own experience\nwith the format, which did not include GeometryCollection s. This led to a\nfalse sense of security about our code’ s correctness. Using community types\nbased on a spec gives you confidence that your code will work with all\nvalues, not just the ones you happen  to have seen.\nSimilar considerations apply to API calls. If there’ s an of ficial T ypeScript\nclient for the API you’re working with, use that! But even if not, you may\nbe able to generate T ypeScript types from an of ficial source.\nIf you’re using a GraphQL API, for example, it includes a schema that\ndescribes all its queries and mutations, as well as all the types. There are\nmany tools available to add T ypeScript types to GraphQL queries. Head to\nyour favorite search engine and you’ll quickly be on the path to type safety .\nMany REST APIs publish an OpenAPI schema. This is a file that describes\nall the endpoints, HTTP verbs (GET , POST , etc.), and types using JSON\nSchema.\nSay we’re using an API that lets us post comments on a blog. Here’ s what\nan OpenAPI schema might look like:\n// schema.json\n{\n  ""openapi"": ""3.0.3"",\n  ""info"": { ""version"": ""1.0.0"", ""title"": ""Sample API"" },\n  ""paths"": {\n    ""/comment"": {\n      ""post"": {\n        ""requestBody"": { ""content"": { ""application/json"": {\n          ""schema"": { ""$ref"": ""#/components/schemas/Comment"" }\n        }}}\n      },\n      ""responses"": {\n        ""200"": { /* ... */ }\n      }\n    }\n  },\n  ""components"": {\n    ""schemas"": {\n      ""CreateCommentRequest"": {\n        ""properties"": {\n            ""body"": { ""type"": ""string"" },\n            ""postId"": { ""type"": ""string"" },\n            ""title"": { ""type"": ""string"" }\n        },\n        ""type"": ""object"",\n        ""required"": [""postId"", ""title"", ""body""]\n      }\n    }\n  }\n}\nThe paths  section defines the endpoints and associates them with types,\nwhich are found in the components/schemas  section. All the information\nwe need to generate types is here. There are many ways to get types out of\nan OpenAPI Schema. One is to extract the schemas and run them  through\njson-schema-to-typescript :\n$ jq .components.schemas.CreateCommentRequest schema.json > comment.json \n$ npx json-schema-to-typescript comment.json > comment.ts \n$ cat comment.ts \n// .... \nexport interface CreateCommentRequest { \n  body: string; \n  postId: string; \n  title: string; \n} \nThis results in nice, clean interface s that will help you interact with this\nAPI in a type-safe way . T ypeScript will flag type errors in your request\nbodies and the response types will flow through your code. The important\nthing is that you didn’ t write the types yourself. Rather , they’re generated\nfrom a reliable source of truth. If a field is optional or can be null ,\nT ypeScript will know about it and force you to handle that possibility .\nA next step here would be to add runtime validation and connect the types\ndirectly to the endpoints with which they’re associated. There are many\ntools that can help you with this, and Item 74  will return to this example.\nWhen you generate types, you do need to ensure that they stay in sync with\nthe API schema. Item 58  discusses strategies for handling this.\nWhat if there’ s no spec or of ficial schema available? Then you’ll have to\ngenerate types from data. T ools like quicktype  can help with this. But be\naware that your types may not match reality: there may be edge cases that\nyou’ve missed. (An exception would be if your data set is finite, for\nexample, a directory of 1,000 JSON files. Then you know that you haven’ t\nmissed anything!)\nEven if you’re not aware of it, you are already benefiting from code\ngeneration. T ypeScript’ s type declarations for the browser DOM API,\nwhich are explored in Item 75 , are generated from the API descriptions on\nMDN. This ensures that they correctly model a complicated system and\nhelps T ypeScript catch errors and misunderstandings in your own code.\nThings to Remember\nA void writing types by hand based on data that you’ve seen. It’ s easy\nto misunderstand a schema or get nullability wrong.\nPrefer types sourced from of ficial clients or the community . If these\ndon’ t exist, generate T ypeScript types from schemas.\n1 GeoJSON is also known as RFC 7946. The very readable spec is at http://geojson.or g .\n2 The unusually lar ge major version number matches the RFC number . This was cute at the\ntime but has proven a nuisance in practice.",10335
52-5. Unsoundness and the any Type.pdf,52-5. Unsoundness and the any Type,,0
53-Item 43 Use the Narrowest Possible Scope for any Types.pdf,53-Item 43 Use the Narrowest Possible Scope for any Types,"Chapter 5. Unsoundness and\nthe any T ype\nT ype systems were traditionally binary af fairs: either a language had a fully\nstatic type system or a fully dynamic one. T ypeScript blurs the line, because\nits type system is optional  and gradual . Y ou’re free to add types to parts of\nyour program but not others.\nThis is essential for migrating existing JavaScript codebases to T ypeScript\nbit by bit ( Chapter 10 ). Key to this is the any  type, which ef fectively\ndisables type checking for parts of your code. It is both powerful and prone\nto abuse. Learning to use any  wisely is essential for writing ef fective\nT ypeScript. This chapter walks you through how to limit the downsides of\nany  while still retaining its benefits.\nThe any  type is just the most extreme example of the more general problem\nof unsoundness : when a symbol’ s static type does not match its runtime\ntype. Even if you eliminate all the any s from your code, you may still fall\ninto soundness traps. Item 48  presents a few of these and shows you how to\navoid them.\nI t e m  4 3 :  U s e  t h e  N a r r o w e s t  P o s s i b l e  S c o p e\nf o r  a n y  T y p e s\nConsider  this code:\ndeclare function getPizza(): Pizza;\nfunction eatSalad(salad: Salad) { /* ... */ } \n \nfunction eatDinner() { \n  const pizza = getPizza(); \n  eatSalad(pizza); \n  //       ~~~~~ \n  // Argument of type 'Pizza' is not assignable to parameter of type 'Salad' \n  pizza.slice();\n}\nIf you somehow know that this call to eatSalad  is OK, the best way\nforward is to adjust your types so that T ypeScript understands that, too. (An\narugula pizza with parmesan and lemon is kind of like a salad!) But if, for\nwhatever reason, you can’ t do that, you can use any  to force T ypeScript to\naccept this code in two ways:\nfunction eatDinner1() { \n  const pizza: any = getPizza();  // Don't do this \n  eatSalad(pizza);  // ok \n  pizza.slice();  // This call is unchecked!\n} \n \nfunction eatDinner2() { \n  const pizza = getPizza(); \n  eatSalad(pizza as any);  // This is preferable \n  pizza.slice();  // this is safe\n}\nOf these, the second form is vastly preferable. Why? Because the any  type\nis scoped to a single expression in a function ar gument. It has no ef fect\noutside this ar gument or this line. When code after the eatSalad  call\nreferences pizza , its type is still Pizza , and it can still trigger type errors;\nwhereas in the first example, its type is any  for its entire lifetime until it\ngoes out of scope at the end of the function. This means that the\npizza.slice()  call is completely unchecked. A spelling mistake or\nincorrect parameter type will pass the type checker but throw an exception\nwhen you run it.\nIt would also have been bad to make eatSalad  accept an any  type. While\nthis would have left pizza  with a Pizza  type in eatDinner , it would have\nprevented type checking on this parameter for all calls to eatSalad  in your\nprogram, not just this one.\nThe stakes become significantly higher if you r eturn  pizza  from\neatDinner . Look what happens:\nfunction eatDinner1() { \n  const pizza: any = getPizza(); \n  eatSalad(pizza); \n  pizza.slice(); \n  return pizza;  // unsafe pizza!\n} \n \nfunction spiceItUp() { \n  const pizza = eatDinner1(); \n  //    ^? const pizza: any \n  pizza.addRedPepperFlakes();  // This call is also unchecked!\n}\nAn any  return type is “contagious” in that it can spread throughout a\ncodebase. As a result of our changes to eatDinner1 , an any  type has\nquietly appeared in spiceItUp . This would not have happened with the\nmore narrowly scoped any  in eatDinner2 .\nThis is a good reason to consider including  explicit return type annotations,\neven when the return type can be inferred. It prevents an any  type from\ninadvertently “escaping.” Y ou’d have to explicitly write any . See Item 18\nfor more on the pros and cons of annotating return types. There are a few\nfunctions in the standard library that return an any  type, notably\nJSON.parse . These are quite dangerous! Item 71  explores ways to protect\nyourself.\nW e used any  here to suppress an error that we believed to be incorrect.\nAnother way to do this is with @ts-ignore  or @ts-expect-error :\nfunction eatDinner1() { \n  const pizza = getPizza(); \n  // @ts-ignore \n  eatSalad(pizza); \n  pizza.slice();\n} \n \nfunction eatDinner2() { \n  const pizza = getPizza(); \n  // @ts-expect-error \n  eatSalad(pizza); \n  pizza.slice();\n}\nThese silence an error on the next line, leaving the type of pizza\nunchanged. Of these two forms, @ts-expect-error  is preferable because if\nthe error goes away later (perhaps the signature of eatSalad  changed),\nT ypeScript will tell you, and you’ll be able to remove the directive.\nBecause they’re explicitly scoped to one line, @ts-ignore  and @ts-\nexpect-error  aren’ t “contagious” in the way that any  can be. Still, try not\nto lean too heavily on these directives: the type checker usually has a good\nreason to complain and, if the error on the next line changes to something\nmore problematic, you’ll have prevented T ypeScript from letting you know .\nAnd if a second error appears on the same line, you’ll never find out about\nit.\nY ou may also run into situations where you get a type error for just one\nproperty in a lar ger object:\nconst config: Config = { \n  a: 1, \n  b: 2, \n  c: { \n    key: value \n // ~~~ Property ... missing in type 'Bar' but required in type 'Foo' \n  }\n};\nY ou can silence errors like this by throwing an as any  around the whole\nconfig  object:\nconst config: Config = { \n  a: 1, \n  b: 2, \n  c: { \n    key: value \n  }\n} as any;  // Don't do this!\nBut this has the side ef fect of disabling type checking for the other\nproperties ( a  and b ) as well. Using a more narrowly scoped any  limits the\ndamage:\nconst config: Config = { \n  a: 1, \n  b: 2,  // These properties are still checked \n  c: { \n    key: value as any \n  }\n};\nIf the first example involved limiting the scope of any  in time, this is\nlimiting the scope in space. In both cases the goal is the same: if you must\nuse any , reduce its scope as much as you possibly can to avoid collateral\ndamage.\nIf you adopt typescript-eslint’ s recommended-type-checked  preset, you’ll\nenable a set of rules such as no-unsafe-assignment  and no-unsafe-\nreturn  that help to highlight the spread of any  types.\nThings to Remember\nMake your uses of any  as narrowly scoped as possible to avoid\nundesired loss of type safety elsewhere in your code.\nNever return an any  type from a function. This will silently lead to the\nloss of type safety for code that calls the function.\nUse as any  on individual properties of a lar ger object instead of the\nwhole object.",6776
54-Item 44 Prefer More Precise Variants of any to Plain any.pdf,54-Item 44 Prefer More Precise Variants of any to Plain any,"I t e m  4 4 :  P r e f e r  M o r e  P r e c i s e  V a r i a n t s  o f  a n y\nt o  P l a i n  a n y\nThe any  type encompasses all values that can be expressed in JavaScript.\nThis is a vast domain! It includes not just all numbers and strings, but all\narrays, objects, regular expressions, functions, classes, and DOM elements,\nnot to mention null  and undefined .  When you use an any  type, ask\nwhether you really had something more specific in mind. W ould it be OK to\npass in a regular expression or a function?\nOften the answer is “no,” in which case you might be able to retain some\ntype safety by using a more specific type:\nfunction getLengthBad(array: any) {  // Don't do this! \n  return array.length;\n} \n \nfunction getLength(array: any[]) {  // This is better \n  return array.length;\n}\nThe latter version, which  uses any[]  instead of any , is better in three ways:\nThe reference to array.length  in the function body is type checked.\nThe function’ s return type is inferred as number  instead of any .\nCalls to getLength  will be checked to ensure that the parameter is an\narray:\ngetLengthBad(/123/);  // No error, returns undefined\ngetLength(/123/);\n//        ~~~~~\n// Argument of type 'RegExp' is not assignable to parameter of type 'any[]'. \n \ngetLengthBad(null);  // No error, throws at runtime\ngetLength(null);\n//        ~~~~\n// Argument of type 'null' is not assignable to parameter of type 'any[]'.\nIf you expect a parameter to be an array of arrays but don’ t care about the\ntype, you can use any[][] .\nIf you expect some sort of object but don’ t know what the values will be,\nyou can use {[key: string]: any}  or Record<string, any> :\nfunction hasAKeyThatEndsWithZ(o: Record<string, any>) { \n  for (const key in o) { \n    if (key.endsWith('z')) { \n      console.log(key, o[key]); \n      return true; \n    } \n  } \n  return false;\n}\nY ou could also use the object  type in this situation, which includes all\nnonprimitive types. This is slightly dif ferent in that, while you can still\nenumerate keys, you can’ t access the values of any of them:\nfunction hasAKeyThatEndsWithZ(o: object) { \n  for (const key in o) { \n    if (key.endsWith('z')) { \n      console.log(key, o[key]); \n      //               ~~~~~~ Element implicitly has an 'any' type \n      //                      because type '{}' has no index signature \n      return true; \n    } \n  } \n  return false;\n}\nIterating over object types is particularly tricky in T ypeScript. Item 60  goes\ninto much more detail about how to work around this particular issue.\nA void using any  if you expect a function type. Y ou have several options\nhere depending on how specific you want to get:\ntype Fn0 = () => any;  // any function callable with no params\ntype Fn1 = (arg: any) => any;  // With one param\ntype FnN = (...args: any[]) => any;  // With any number of params \n                                     // same as ""Function"" type",2972
55-Item 45 Hide Unsafe Type Assertions in Well-Typed Functions.pdf,55-Item 45 Hide Unsafe Type Assertions in Well-Typed Functions,"All of these are more precise than any  and hence preferable to it. Note the\nuse of any[]  as the type for the rest parameter in the last example. any\nwould also work here but would be less precise:\nconst numArgsBad = (...args: any) => args.length;\n//    ^? const numArgsBad: (...args: any) => any\nconst numArgsBetter = (...args: any[]) => args.length;\n//    ^? const numArgsBetter: (...args: any[]) => number\nNote the dif fering return types. Rest parameters are perhaps the most\ncommon use of the any[]  type.\nIf you want an array but don’ t care about the type of the elements, you may\nbe able to use unknown[]  instead of any[] . This is preferable because it is\nsafer . See Item 46  for more on the unknown  type.\nThings to Remember\nWhen you use any , think about whether any JavaScript value is truly\npermissible.\nPrefer more precise forms of any  such as any[]  or {[id: string]:\nany}  or () => any  if they more accurately model your data.\nI t e m  4 5 :  H i d e  U n s a f e  T y p e  A s s e r t i o n s  i n\nW e l l - T y p e d  F u n c t i o n s\nIn an  ideal world, your functions have exactly the type signatures you want\nand their implementations (also in T ypeScript) pass the type checker ,\ncontain no type assertions  or any  types, and don’ t fall into any other\nsoundness traps ( Item 48 ). Fortunately ,  this is the case for most functions\nyou’ll write. But this is the chapter on any  and unsoundness, so you won’ t\nbe surprised to hear that things aren’ t always ideal.\nIf you have to choose between a safe, assertion-free function\nimplementation and the type signature that you want, choose the type\nsignature. It’ s the public API of your function, and it’ s visible to the rest of\nyour code and your users. The function’ s implementation is a detail that’ s\nhidden from your users. Y our assertions and any  types will be hidden from\nview there. Much better to have an unsafe (but well-tested) implementation\nthan to adopt a type signature that makes life hard for your users.\nT o see how this might come up, consider this code that fetches information\nabout mountain peaks:\ninterface MountainPeak { \n  name: string; \n  continent: string; \n  elevationMeters: number; \n  firstAscentYear: number;\n} \n \nasync function checkedFetchJSON(url: string): Promise<unknown> { \n  const response = await fetch(url); \n  if (!response.ok) { \n    throw new Error(`Unable to fetch! ${response.statusText}`); \n  } \n  return response.json();\n} \n \nexport async function fetchPeak(peakId: string): Promise<MountainPeak> { \n  return checkedFetchJSON(`/api/mountain-peaks/${peakId}`);\n// ~~~~~ Type 'unknown' is not assignable to type 'MountainPeak'.\n}\nThe checkedFetchJSON  wrapper provides two services here. First, it\nchecks whether the fetch succeeded and throws (thus rejecting the Promise)\nif it did not. Second, it gives the JSON response an unknown  type ( Item 46 )\nwhich is safer than the any  type that you’d get by default.\nUnfortunately , there’ s a type error because unknown  is not assignable to\nMountainPeak . If you want to avoid type assertions or any  types in your\nfetchPeak  implementation, you’ll have to change the return type to match:\nexport async function fetchPeak(peakId: string): Promise<unknown> { \n  return checkedFetchJSON(`/api/mountain-peaks/${peakId}`);  // ok\n}\nThis passes the type checker and contains no unsafe assertions (good!), but\nthis comes at a significant cost. The fetchPeak  function is now extremely\nhard to use:\nconst sevenPeaks = [ \n  'aconcagua', 'denali', 'elbrus', 'everest', 'kilimanjaro', 'vinson', \n'wilhelm'\n];\nasync function getPeaksByHeight(): Promise<MountainPeak[]> { \n  const peaks = await Promise.all(sevenPeaks.map(fetchPeak)); \n  return peaks.toSorted( \n  // ~~~ Type 'unknown' is not assignable to type 'MountainPeak'. \n    (a, b) => b.elevationMeters - a.elevationMeters \n    //        ~                   ~ 'b' and 'a' are of type 'unknown' \n  );\n}\nAny code that calls it will likely have to use a type assertion:\nasync function getPeaksByDate(): Promise<MountainPeak[]> { \n  const peaks = await Promise.all(sevenPeaks.map(fetchPeak)) as \nMountainPeak[]; \n  return peaks.toSorted((a, b) => b.firstAscentYear - a.firstAscentYear);\n}\nThis will result in type assertions scattered throughout your code whenever\nyou call fetchPeak . This is duplicative, tedious, and introduces the\npossibility that you’ll assert dif ferent types in dif ferent places.\nRather than changing the return type of fetchPeak  to placate the type\nchecker , a better approach would be to keep the type signature as it was and\nadd an assertion in the function body:\nexport async function fetchPeak(peakId: string): Promise<MountainPeak> { \n  return checkedFetchJSON( \n    `/api/mountain-peaks/${peakId}`, \n  ) as Promise<MountainPeak>;\n}\nW ith the type assertion hidden away in the function implementation, calling\ncode can be written cleanly without any knowledge of our unsafe secret:\nasync function getPeaksByContinent(): Promise<MountainPeak[]> { \n  const peaks = await Promise.all(sevenPeaks.map(fetchPeak));  // no \nassertion! \n  return peaks.toSorted((a, b) => a.continent.localeCompare(b.continent));\n}\nBy localizing the type assertion, we’ve also made it easier to increase its\nsafety . Here’ s a version that checks at least some of the shape of the\nresponse:\nexport async function fetchPeak(peakId: string): Promise<MountainPeak> { \n  const maybePeak = checkedFetchJSON(`/api/mountain-peaks/${peakId}`); \n  if ( \n    !maybePeak || \n    typeof maybePeak !== 'object' || \n    !('firstAscentYear' in maybePeak) \n  ) { \n    throw new Error(`Invalid mountain peak: ${JSON.stringify(maybePeak)}`); \n  } \n  return checkedFetchJSON( \n    `/api/mountain-peaks/${peakId}`, \n  ) as Promise<MountainPeak>;\n}\nY ou’re unlikely to do this sort of shape checking at every single call site,\nbut it’ s easy enough to do with the type assertion in one place. (If you find\nyourself writing this sort of validation code often, Item 74  introduces some\nmore systematic approaches for validating T ypeScript types at runtime. All\nthese approaches hide type assertions in well-typed functions!)\nAnother way to hide a type assertion is by providing a single overload of\nthe function:\nexport async function fetchPeak(peakId: string): Promise<MountainPeak>;\nexport async function fetchPeak(peakId: string): Promise<unknown> { \n  return checkedFetchJSON(`/api/mountain-peaks/${peakId}`);  // OK\n} \n \nconst denali = fetchPeak('denali');\n//    ^? const denali: Promise<MountainPeak>\nIn this case, the overload presents a dif ferent type signature to callers of the\nfunction than the one used in the implementation. There is some safety\nhere: T ypeScript will check that the two signatures are compatible. But this\nisn’ t fundamentally any dif ferent than a type assertion, and you’d still be\nwell served to do some kind of data validation.\nY ou might also find yourself pushed into using a type assertion because\nT ypeScript’ s type checker can’ t follow along with your code. For example,\nthis function checks if two objects are shallowly equal to each other:\nfunction shallowObjectEqual(a: object, b: object): boolean { \n  for (const [k, aVal] of Object.entries(a)) { \n    if (!(k in b) || aVal !== b[k]) { \n      //                      ~~~~ Element implicitly has an 'any' type \n      //                           because type '{}' has no index signature \n      return false; \n    } \n  } \n  return Object.keys(a).length === Object.keys(b).length;\n}\nIt’ s a bit surprising that T ypeScript complains about the b[k]  access despite\nyour having just checked that k in b  is true. But it does, so you’ll need to\nresort to either @ts-expect-error  or an any  type.\nThis would be the wrong way to fix the type error:\nfunction shallowObjectEqualBad(a: object, b: any): boolean { \n  for (const [k, aVal] of Object.entries(a)) { \n    if (!(k in b) || aVal !== b[k]) {  // ok \n      return false; \n    } \n  } \n  return Object.keys(a).length === Object.keys(b).length;\n}\nBy changing b ’ s type to any , we allow code that will crash at runtime:\nshallowObjectEqual({x: 1}, null)\n//                         ~~~~ Type 'null' is not assignable to type \n'object'.\nshallowObjectEqualBad({x: 1}, null);  // ok, throws at runtime\nBetter to hide the any  type inside the function implementation:\nfunction shallowObjectEqualGood(a: object, b: object): boolean { \n  for (const [k, aVal] of Object.entries(a)) { \n    if (!(k in b) || aVal !== (b as any)[k]) { \n      // `(b as any)[k]` is OK because we've just checked `k in b` \n      return false; \n    } \n  } \n  return Object.keys(a).length === Object.keys(b).length;\n}\nThis any  is narrowly scoped ( Item 43 ), does not af fect the type signature of\nthe function, and even includes a comment explaining why it’ s valid. This is\na fine use of an any  type and a type assertion. Y our code is correct, the type\nsignature is clear , and your users will be none the wiser .\nY ou should unit test all your code, of course, but this is especially true when\nit uses type assertions. Since you’ve told T ypeScript to trust you,\neverything’ s OK, and the burden of proof is on you to show that. Comments\nexplaining why a type assertion is valid are helpful, but thorough tests are\nan even better demonstration of correctness.\nThings to Remember\nSometimes unsafe type assertions and any  types are necessary or\nexpedient. When you need to use one, hide it inside a function with a\ncorrect signature.\nDon’ t compromise a function’ s type signature to fix type errors in the\nimplementation.\nMake sure you explain why your type assertions are valid, and  unit test\nyour code thoroughly .",9826
56-Item 46 Use unknown Instead of any for Values with an Unknown Type.pdf,56-Item 46 Use unknown Instead of any for Values with an Unknown Type,"I t e m  4 6 :  U s e  u n k n o w n  I n s t e a d  o f  a n y  f o r\nV a l u e s  w i t h  a n  U n k n o w n  T y p e\nSuppose you want to write a Y AML parser (Y AML can represent the same\nset of values as JSON but allows a superset of JSON’ s syntax). What should\nthe return type of your parseYAML  method be? It’ s tempting to make it any\n(like JSON.parse ):\nfunction parseYAML(yaml: string): any { \n  // ...\n}\nBut this flies in the face of Item 43 ’ s advice to avoid “contagious” any\ntypes, specifically by not returning them from functions. ( Item 71  will\nexplore how to “fix” JSON.parse  so that it doesn’ t return any .)\nIdeally , you’d like your users to immediately assign the result to another\ntype:\ninterface Book { \n  name: string; \n  author: string;\n}\nconst book: Book = parseYAML(`\n  name: Wuthering Heights\n  author: Emily Brontë\n`);\nW ithout the type annotation, though, the book  variable would quietly get an\nany  type, thwarting type checking wherever it’ s used:\nconst book = parseYAML(`\n  name: Jane Eyre\n  author: Charlotte Brontë\n`);\nconsole.log(book.title);  // No error, logs ""undefined"" at runtime\nbook('read');  // No error, throws ""book is not a function"" at runtime\nA safer alternative would be to have parseYAML  return an unknown  type:\nfunction safeParseYAML(yaml: string): unknown { \n  return parseYAML(yaml);\n}\nconst book = safeParseYAML(`\n  name: The Tenant of Wildfell Hall\n  author: Anne Brontë\n`);\nconsole.log(book.title);\n//          ~~~~ 'book' is of type 'unknown'\nbook(""read"");\n// Error: 'book' is of type 'unknown'\nT o understand the unknown  type, it helps to think about any  in terms of\nassignability . The power and danger of any  come from two properties:\nAll types are assignable to the any  type.\nThe any  type is assignable to all other types.1\nIf we “think of types as sets of values” ( Item 7 ), the first property means\nthat any  is a supertype of all other types, while the second means that it is a\nsubtype. This is strange! It means that any  doesn’ t fit into the type system,\nsince a set can’ t simultaneously be both a subset and a superset of all other\nsets. This is the source of any ’ s power but also the reason it’ s problematic.\nSince the type checker is set based, the use of any  ef fectively disables it.\nThe unknown  type is an alternative to any  that does  fit into the type system.\nIt has the first property (any type is assignable to unknown ) but not the\nsecond (unknown  is only assignable to unknown  and, of course, any ). It’ s\nknown as a “top” type since it’ s at the top of the type hierarchy . The never\ntype is the opposite: it has the second property (can be assigned to any other\ntype) but not the first (no other type can be assigned to never ). It’ s known\nas a “bottom” type.\nAttempting to access a property on a value with the unknown  type is an\nerror . So is attempting to call it or do arithmetic with it. Y ou can’ t do much\nof anything with unknown , which is exactly the point. The errors about an\nunknown  type will encourage you to pick something more specific:\nconst book = safeParseYAML(`\n  name: Villette\n  author: Charlotte Brontë\n`) as Book;\nconsole.log(book.title);\n//               ~~~~~ Property 'title' does not exist on type 'Book'\nbook('read');\n// Error: This expression is not callable\nThese errors are more sensible. Since unknown  is not assignable to other\ntypes, you’ll need a type assertion. But it is also appropriate: we really do\nknow more about the type of the resulting object than T ypeScript does.\nunknown  is appropriate whenever you know that there will be a value but\nyou either don’ t know or don’ t care about its type. The result of parseYAML\nis one example, but there are others. In the  GeoJSON spec, for example, the\nproperties  property of a feature is a grab bag of anything JSON\nserializable. So unknown  makes sense:\ninterface Feature { \n  id?: string | number; \n  geometry: Geometry; \n  properties: unknown;\n}\nIf you write a function to check if an array has fewer than 10 elements, you\ndon’ t particularly care about the type of the elements. So unknown  makes\nsense here, too:\nfunction isSmallArray(arr: readonly unknown[]): boolean { \n  return arr.length < 10;\n}\nAs you’ve seen, you can get a more specific type from unknown  using a\ntype assertion. But this isn’ t the only way . An instanceof  check will do:\nfunction processValue(value: unknown) { \n  if (value instanceof Date) { \n    value \n    // ^? (parameter) value: Date \n  }\n}\nY ou can also use a user -defined type guard:\nfunction isBook(value: unknown): value is Book { \n  return ( \n      typeof(value) === 'object' && value !== null && \n      'name' in value && 'author' in value \n  );\n}\nfunction processValue(value: unknown) { \n  if (isBook(value)) { \n    value; \n    // ^? (parameter) value: Book \n  }\n}\nT ypeScript requires quite a bit of proof to narrow an unknown  type: in order\nto avoid errors on the in  checks, you first have to demonstrate that val  is\nan object type and that it is non- null  (since typeof null === 'object' ).\nAs with any user -defined type guard, remember that it’ s no safer than a type\nassertion. Nothing checks that you’ve implemented the guard correctly or\nkept it in sync with your type. ( Item 74  discusses solutions to this\nconundrum.)\nY ou’ll sometimes see a type parameter used instead of unknown . Y ou could\nhave declared the safeParseYAML  function this way:\nfunction safeParseYAML<T>(yaml: string): T { \n  return parseYAML(yaml);\n}\nThis is generally considered bad style in T ypeScript, however . It looks\ndif ferent than a type assertion, but it is no safer and is functionally the same.\nBetter to just return unknown  and force your users to use an assertion, or\nnarrow to the type they want. This is a common example of an unnecessary\nuse of generics, which is the subject of Item 51 .\nunknown  can also be used instead of any  in “double assertions”:\ndeclare const foo: Foo;\nlet barAny = foo as any as Bar;\nlet barUnk = foo as unknown as Bar;\nThese are functionally equivalent, but the unknown  version prevents the\nvisceral reaction you and your coworkers might have at seeing as any .\nAs a final note, you may see code that uses object  or {}  in a similar way to\nhow unknown  has been described in this item. They are also broad types but\nare slightly narrower than unknown :\nThe {}  type consists of all values except null  and undefined .\nThe Object  type (capital “O”) is the nearly the same as {} . Strings,\nnumbers, booleans, and other primitives are assignable to Object .\nThe object  type (lowercase “o”) consists of all nonprimitive types.\nThis doesn’ t include true  or 12  or ""foo"" , but does include objects,\narrays, and functions.\nIt’ s quite rare that you really want to permit any value except null  and\nundefined , so unknown  is generally preferable to {}  or Object .\nThings to Remember\nThe unknown  type is a type-safe alternative to any . Use it when you\nknow you have a value but do not know or do not care what its type is.\nUse unknown  to force your users to use a type assertion or other form\nof narrowing.\nA void return-only type parameters, which can create a false sense of\nsecurity .\nUnderstand the dif ference between {} , object , and unknown .",7380
57-Item 47 Prefer Type-Safe Approaches to Monkey Patching.pdf,57-Item 47 Prefer Type-Safe Approaches to Monkey Patching,"I t e m  4 7 :  P r e f e r  T y p e - S a f e  A p p r o a c h e s  t o\nM o n k e y  P a t c h i n g\nOne of the  most famous features of JavaScript is that its objects and classes\nare “open” in the sense that you can add arbitrary properties to them. This is\noccasionally used to create  global variables on web pages by assigning to\nwindow  or document :\nwindow.monkey = 'Tamarin';\ndocument.monkey = 'Howler';\nor to attach data to DOM elements:\nconst el = document.getElementById('colobus');\nel.home = 'tree';\nAdding properties to built-in objects at runtime is known as “monkey\npatching” and is particularly common with code that uses jQuery or D3.\nY ou can even attach properties to the prototypes of built-ins, with\nsometimes surprising results:\n>  RegExp.prototype.monkey = 'Capuchin'\n'Capuchin'\n> /123/.monkey\n'Capuchin'\nThese approaches are generally not good designs. When you attach data to\nwindow  or a DOM node, you are essentially turning it into a global variable.\nThis makes it easy to inadvertently introduce dependencies between far -\nflung parts of your program, and means that you have to think about side\nef fects whenever you call a function. Outside of strict  mode, JavaScript\nmakes it very easy to introduce global variables: just drop the let , var , or\nconst  from an assignment.\nAdding T ypeScript introduces another problem: while the type checker\nknows about built-in properties of Document  and HTMLElement , it certainly\ndoesn’ t know about the ones you’ve added:\ndocument.monkey = 'Tamarin';\n//       ~~~~~~ Property 'monkey' does not exist on type 'Document'\nThe most straightforward way to fix this error is with an any  assertion:\n(document as any).monkey = 'Tamarin';  // OK\nThis satisfies the type checker , but, as should be no surprise by now , it has\nsome downsides. As with any use of any , you lose type safety and language\nservices:\n(document as any).monky = 'Tamarin';  // Also OK, misspelled\n(document as any).monkey = /Tamarin/;  // Also OK, wrong type\nThe best solution is to move your data out of window , document , or the\nDOM. But if you can’ t (perhaps you’re using a library that requires it or are\nin the process of migrating a JavaScript application), then the monkey patch\nis part of your environment ( Item 76 ) and you should model it with\nT ypeScript. There’ s no perfect way to do this, but as any  sets a low bar for\nsafety and developer experience, and there are ways to do considerably\nbetter .\nImagine you’re building a web application and you have an object with\ninformation about the currently logged-in user . Y ou fetch this on page load\nvia an API and store it as a global variable for convenient access throughout\nyour code:\ninterface User { \n  name: string;\n} \n \ndocument.addEventListener(""DOMContentLoaded"", async () => { \n  const response = await fetch('/api/users/current-user'); \n  const user = (await response.json()) as User; \n  window.user = user; \n  //     ~~~~ Property 'user' does not exist \n  //          on type 'Window & typeof globalThis'.\n}); \n \n// ... elsewhere ...\nexport function greetUser() { \n  alert(`Hello ${window.user.name}!`); \n  //                    ~~~~ Property 'user' does not exist on type Window...\n}\nThe type errors arise because T ypeScript doesn’ t know about our patch to\nthe global object. Rather than writing (window as any) , one option is to\nuse an augmentation, one of the special abilities of interface  ( Item 13 ):\ndeclare global { \n  interface Window { \n    /** The currently logged-in user */ \n    user: User; \n  }\n}\nThis tells T ypeScript that Window  has another property that it didn’ t know\nabout from the built-in DOM types. W ith the augmentation in place, our\ncode passes the type checker:\ndocument.addEventListener(""DOMContentLoaded"", async () => { \n  const response = await fetch('/api/users/current-user'); \n  const user = (await response.json()) as User; \n  window.user = user;  // OK\n}); \n \n// ... elsewhere ...\nexport function greetUser() { \n  alert(`Hello ${window.user.name}!`);  // OK\n}\nThis is an improvement over using any  in a few ways:\nY ou get type safety . The type checker will flag misspellings or\nassignments of the wrong type.\nY ou can attach documentation to the property ( Item 68 ).\nY ou get autocomplete and other language services on the property .\nThere is a record of precisely what the monkey patch is.\nThere are a few problems with the augmentation approach. In cases (such as\nuser ) where a global is set while your application is running, there’ s no\nway to introduce the augmentation only after this has happened. This masks\na race condition in our code. What happens if we call greetUser()  before\nwindow.user  is set?\nT o avoid issues like this, you may want to include undefined  as a\npossibility on your global. This will force you to handle the possibility that\nuser  isn’ t available wherever you access it:\ndeclare global { \n  interface Window { \n    /** The currently logged-in user */ \n    user: User | undefined; \n  }\n} \n \n// ...\nexport function greetUser() { \n  alert(`Hello ${window.user.name}!`); \n  //             ~~~~~~~~~~~ 'window.user' is possibly 'undefined'.\n}\nThere’ s a trade-of f here between correctness and convenience.\nIf your serving infrastructure allows it, another solution for this specific\nsituation would be to inline the user  variable into the HTML of the page:\n<script type=""text/javascript"">\nwindow.user = { name: 'Bill Withers' };\n</script>\n<script src=""your-code.js""></script>\nThis way you can safely remove the undefined  possibility since user  has\nbeen unconditionally set before any of your code runs and there’ s no\npossibility of a race condition.\nAnother issue with augmentation is that, as the declare global  suggests,\nit applies globally . Y ou can’ t hide it from other parts of your code or from\nlibraries. If your app includes multiple pages and user  is only available on\nsome of them, the global augmentation won’ t be able to model that\naccurately .\nAn alternative approach that doesn’ t pollute the global scope is to use a\nnarrower  type assertion. Rather than (window as any) , we can define\nanother type with our added property:\ntype MyWindow = (typeof window) & { \n  /** The currently logged-in user */ \n  user: User | undefined;\n} \n \ndocument.addEventListener(""DOMContentLoaded"", async () => { \n  const response = await fetch('/api/users/current-user'); \n  const user = (await response.json()) as User; \n  (window as MyWindow).user = user;  // OK\n}); \n \n// ...\nexport function greetUser() { \n  alert(`Hello ${(window as MyWindow).user.name}!`); \n  //             ~~~~~~~~~~~~~~~~~~~~~~~~~ Object is possibly 'undefined'.\n}\nT ypeScript is OK with the type assertion because Window  and MyWindow\nshare properties ( Item 9 ). And you get type safety in the assignment. The\nscope issues are also more manageable: there’ s no global modification of\nthe Window  type, just the introduction of a new type (which is only in scope\nif you import it).\nThe downside is that you have to write an assertion (or introduce a new\nvariable) whenever you reference the monkey-patched property . And you’ll\nwant to enforce that no one sneaks in a (window as any) , perhaps using a\nlinter rule.\nBut you can take this all as encouragement to refactor into something more\nstructured. Monkey patching shouldn’ t be too  easy!",7475
58-Item 48 Avoid Soundness Traps.pdf,58-Item 48 Avoid Soundness Traps,"Things to Remember\nPrefer structured code to storing data in globals or on the DOM.\nIf you must store data on built-in types, use one of the type-safe\napproaches (augmentation or asserting a custom interface).\nUnderstand the scoping issues of augmentations. Include undefined  if\nthat’ s a possibility at runtime.\nI t e m  4 8 :  A v o i d  S o u n d n e s s  T r a p s\nHang out on  the internet much and you’ll hear gripes about how T ypeScript\nisn’ t “sound,” and that this makes it a poor choice of language. This item\nwill explain what this means and walk you through common sources of\nunsoundness in T ypeScript. Rest assured, T ypeScript is a great language,\nand it’ s never a good idea to listen to people on the internet!\nA language is called “sound” if the static type of every symbol is\nguaranteed to be compatible with its runtime value. Using the terminology\nfrom Item 7 , this means that every symbol’ s runtime value remains in the\ndomain of that symbol’ s static type.\nHere’ s an example of a sound type:\nconst x = Math.random();\n//    ^? const x: number\nT ypeScript infers a static type of number  for x , and this is sound: whatever\nvalue Math.random()  returns at runtime, it will be a number . This doesn’ t\nmean that x  could be any number  at runtime: a more precise type would be\nthe half-open interval [0, 1) ,  but T ypeScript has no way to express this.\nnumber  is good enough. Soundness is more about accuracy than precision.\nHere’ s an example of unsoundness in T ypeScript:\nconst xs = [0, 1, 2];\n//    ^? const xs: number[]\nconst x = xs[3];\n//    ^? const x: number\nThe static type of x  is inferred as number , but at runtime its value is\nundefined , which is not a number . So this is unsound and can lead to\nproblems at runtime, for example, if you try to call a method on x :\nconsole.log(x.toFixed(1));\nThere are no type errors, but when you run this code it will throw an error:\nconsole.log(x.toFixed(1)); \n              ^ \n \nTypeError: Cannot read properties of undefined (reading 'toFixed')\nUnsound types can easily lead to runtime errors, so a sound type system is\ngenerally considered to be a desirable property of a programming language.\nSoundness comes with trade-of fs, however . It’ s easier for less expressive\ntype systems to achieve soundness. If T ypeScript didn’ t support generic\ntypes, for example, it would eliminate many of the sources of unsoundness\nthat you’ll read about later . But generic types are useful! This hypothetical\nversion of T ypeScript would have a harder time modeling JavaScript\npatterns and would catch fewer bugs.\nIn other words, there’ s a trade-of f among a type system’ s expressiveness, its\nsoundness, and its convenience. T ypeScript gives you some choices about\nwhere you want to be on this spectrum: by enabling strictNullChecks\n( Item 2 ), you accept some inconvenience (needing to annotate null  types\nand do null  checks) in exchange for increased expressiveness.\nAs we saw previously , T ypeScript as a whole is emphatically not  sound. In\nfact, soundness is not a design goal of T ypeScript at all. Instead, it favors\nconvenience and the ability to work with existing JavaScript libraries.\nStill, unsoundness can lead to crashes, bugs, or even data corruption, and\nyou should avoid it when you can. Unchecked array accesses are one well-\nknown soundness trap, but there are many others in T ypeScript. The rest of\nthis item will go through some of the sources of unsoundness in T ypeScript\nand show how you can rework your code to avoid them.\nany\nIf you “put an any  on it,” then anything goes. The static types may or may\nnot have anything to do with real runtime types:\nfunction logNumber(x: number) { \n  console.log(x.toFixed(1));  // x is a string at runtime \n  //          ^? (parameter) x: number\n}\nconst num: any = 'forty two';\nlogNumber(num);  // no error\nThere are no type errors here, but this code will throw an exception at\nruntime.\nThe solution is simple: limit your use of any  or , better , don’ t use it at all!\nThis chapter has lots of advice about how to mitigate and avoid the static\ntype disaster that is any , but the highlights are to limit the scope of any  and\nto use unknown  as a safer alternative when possible. For built-ins like\nJSON.parse  that return any  types, Item 71  shows you how to use\ndeclaration mer ging to get a safer alternative.\nT ype Assertions\nThe slightly less of fensive cousin of any  is the “type assertion.” W e’ve\nalready covered this in Item 9 , but here’ s a refresher on what this looks like:\nfunction logNumber(x: number) { \n  console.log(x.toFixed(1));\n}\nconst hour = (new Date()).getHours() || null;\n//    ^? const hour: number | null\nlogNumber(hour);\n//        ~~~~ ... Type 'null' is not assignable to type 'number'.\nlogNumber(hour as number);  // type checks, but might blow up at runtime\nThe as number  in the last line is the type assertion, and it makes the error\ngo away .\nWhat can you do about this? Y ou can replace many assertions with\nconditionals ( if  statements or ternary operators):\nif (hour !== null) { \n  logNumber(hour);  // ok \n  //        ^? const hour: number\n}\nW ithin the if  block, the static type of hour  is narrowed based on the\ncondition, so the type assertion isn’ t needed (see Item 22  for more on\nnarrowing).\nT ype assertions often come up in the context of input validation. It’ s a good\nidea to adopt a systematic approach to keeping your T ypeScript types and\nyour runtime validation logic in sync. Item 74  will walk you through your\noptions.\nObject and Array Lookups\nEven in strict  mode, T ypeScript doesn’ t do any sort of bounds checking\non array lookups. As we saw in the introduction to this item, this can lead\ndirectly to unsoundness and runtime errors.\nThe same can happen when you reference a property on an object with an\nindex type:\ntype IdToName = { [id: string]: string };\nconst ids: IdToName = {'007': 'James Bond'};\nconst agent = ids['008'];  // undefined at runtime.\n//    ^? const agent: string\nWhy does T ypeScript allow this sort of code? Because it’ s extremely\ncommon and because it’ s quite dif ficult to prove whether any particular\nindex/array access is valid. If you’d like T ypeScript to try , there’ s a\nnoUncheckedIndexedAccess  option. If you turn it on, it finds the error in\nthe example from the introduction but also flags perfectly valid code:\nconst xs = [1, 2, 3];\nalert(xs[3].toFixed(1));  // invalid code\n//    ~~~~~ Object is possibly 'undefined'.\nalert(xs[2].toFixed(1));  // valid code\n//    ~~~~~ Object is possibly 'undefined'.\nThis option moves you to a dif ferent place on the spectrum of soundness\nversus convenience: T ypeScript is able to catch more errors, but it is less\nconvenient to work with because it also flags code that’ s not an error .\nnoUncheckedIndexedAccess  is at least smart enough to understand some\ncommon array constructs:\nconst xs = [1, 2, 3];\nfor (const x of xs) { \n  console.log(x.toFixed(1));  // OK\n}\nconst squares = xs.map(x => x * x);  // also OK\nIf you’re concerned about unsafe access to specific arrays or objects, you\ncan explicitly add undefined  to their value types:\nconst xs: (number | undefined)[] = [1, 2, 3];\nalert(xs[3].toFixed(1));\n//    ~~~~~ Object is possibly 'undefined'. \n \ntype IdToName = { [id: string]: string | undefined };\nconst ids: IdToName = {'007': 'James Bond'};\nconst agent = ids['008'];\n//    ^? const agent: string | undefined\nalert(agent.toUpperCase());\n//    ~~~~~ 'agent' is possibly 'undefined'.\nThe advantage of this approach over noUncheckedIndexedAccess  is that it\nlets you limit the scope (and presumably false positives) of that flag. The\ndisadvantage is that it lacks the smarts of the flag: the for-of  loop will give\nyou errors with this approach. It also introduces the possibility that you\npush  an undefined  onto the array .\nFinally , it’ s often possible to rework your code to reduce the need for these\nsorts of lookups. Rather than passing indices or keys to functions, try to\nwork with the objects that they  refer to.\nInaccurate T ype Definitions\nThe type declarations for a JavaScript library are like a giant type assertion:\nthey claim to statically model the runtime behavior of the library but there’ s\nnothing that guarantees this. (Unless, that is, the library is written in\nT ypeScript, the declarations are generated by tsc , and the library has no\nunsound types!)\nIt’ s hard to show a current example here since these kinds of bugs tend to\nget fixed once you highlight them, particularly for declarations on\nDefinitelyT yped (@types ). But a famous historic one was the React.FC\ndefinition in @types/react , which made UI components accept children,\neven when this didn’ t make logical sense.\nHow do you work around this? The best way is to fix the bug! For types on\nDefinitelyT yped, the turnaround time on this is usually a week or less. If\nthis isn’ t an option, you can work around some issues via augmentation or ,\nin the worst case, a type assertion.\nIt’ s also worth noting that some functions have types that are just very hard\nto model statically . T ake a look at the parameter list for\nString.prototype.replace  for a head-scratching example:\n'foo'.replace(/f(.)/, (fullMatch, group1, offset, fullString, namedGroups) => \n{ \n  console.log(fullMatch);  // ""fo"" \n  console.log(group1);  // ""o"" \n  console.log(offset);  // 0 \n  console.log(fullString); // ""foo"" \n  console.log(namedGroups);  // undefined \n  return fullMatch;\n});\nIf you’re interested in the offset  parameter , its position will depend on the\nnumber of capture groups (parenthesized expressions) in your regular\nexpression. T ypeScript has no concept of a regex literal type, so there’ s no\nway to determine the number of capture groups statically . So the callback\nparameters get an any  type.\nThere are also some functions that are incorrectly typed for historical\nreasons, e.g., Object.assign . If this is causing you trouble, Item 71  has a\nfix.\nT ype declarations model more than just JavaScript libraries. They also\ndescribe the environment in which your code runs: the expected JavaScript\nruntime and other global environments. Item 76  has more to say about the\nimportance of creating an accurate model of your environment.\nBivariance in Class Hierarchies\nAssignability is tricky to think about with function types. It works a bit\ndif ferently for the return type and the parameter types. For the return type,\nassignability works exactly like any other type:\ndeclare function f(): number | string;\nconst f1: () => number | string | boolean = f;  // OK\nconst f2: () => number = f;\n//    ~~ Type '() => string | number' is not assignable to type '() => \nnumber'.\n//         Type 'string | number' is not assignable to type 'number'.\nThis makes sense: if you call a function expecting it to return a number  but\nthe function could also return a string , then trouble will ensue. W e say that\nfunctions  are covariant  in their return types.\nParameter types go the opposite way:\ndeclare function f(x: number | string): void;\nconst f1: (x: number | string | boolean) => void = f;\n//    ~~\n// Type 'string | number | boolean' is not assignable to type 'string | \nnumber'.\nconst f2: (x: number) => void = f;  // OK\nThis also makes sense: you shouldn’ t be able to call a function expecting\nnumber|string  with a boolean . Functions are contravariant  in their\nparameter types.\nNow let’ s see what happens when we apply this to classes:\nclass Parent { \n  foo(x: number | string) {} \n  bar(x: number) {}\n}\nclass Child extends Parent { \n  foo(x: number) {}  // OK \n  bar(x: number | string) {}  // OK\n}\nRecall from Item 7  that extends  on a class  or interface  can be read as\n“subtype of.” But in that case, given what we’ve just learned about function\nassignability , surely one of the two methods on Child  should be an error .\nSince functions are contravariant in their parameter types, the Child foo\nmethod should not be assignable to the Parent foo .\nY ou can adapt this form of unsoundness to get an undetected exception:\nclass FooChild extends Parent  { \n  foo(x: number) { \n    console.log(x.toFixed()); \n  }\n}\nconst p: Parent = new FooChild();\np.foo('string');  // No type error, crashes at runtime\nT ypeScript models methods on classes as bivariant : if either the parent or\nthe child method is assignable to the other , then it’ s valid. Historically this\nwas how all  function assignments were modeled. But with\nstrictFunctionTypes , which was introduced in T ypeScript 2.6 way back\nin 2017, standalone function types are treated more accurately .\nIn practice this means that when you’re inheriting from a class, you need to\ntake extra care to get the method signatures correct. T ypically , child classes\nshould have the exact same method signature as their parents. But they can\nget out of sync over time if you change the parent’ s signature and expect to\nget a type error for all child implementations. Be on the lookout for this!\nWhen you change a method signature on a class in a hierarchy , check the\nsame method on any parent or child classes.\nT ypeScript’ s Inaccurate Model of V ariance for Objects\nand Arrays\nThis one has been widely discussed online. Here’ s the standard example of\nhow it works:\nfunction addFoxOrHen(animals: Animal[]) { \n  animals.push(Math.random() > 0.5 ? new Fox() : new Hen());\n} \n \nconst henhouse: Hen[] = [new Hen()];\naddFoxOrHen(henhouse); // oh no, a fox in the henhouse!\nThe issue is that it’ s only safe to assign Hen[]  to Animal[]  if you don’ t\nmodify the array .  In other words, only readonly Hen[]  should be\nassignable to readonly Animal[] . T ypeScript hasn’ t always had\nreadonly , though, and in the early days it chose to allow this sort of code.\nPerhaps in the future there will be a new strict  option to handle this\nsource of unsoundness.\nWhat can you  do about it? It’ s best not to mutate function parameters,\nwhich you can enforce with a readonly  annotation ( Item 14 ):\nfunction addFoxOrHen(animals: readonly Animal[]) { \n  animals.push(Math.random() > 0.5 ? new Fox() : new Hen()); \n  //      ~~~~ Property 'push' does not exist on type 'readonly Animal[]'.\n}\nY ou can dodge the issue entirely by rewriting the initial example so that the\nfunction returns an Animal , rather than adding it to an array:\nfunction foxOrHen(): Animal { \n  return Math.random() > 0.5 ? new Fox() : new Hen();\n} \n \nconst henhouse: Hen[] = [new Hen(), foxOrHen()];\n//                                  ~~~~~~~~~~ error, yay! Chickens are safe.\n// Type 'Animal' is missing the following properties from type 'Hen': ...\nY ou can run into similar issues with any object mutated by a function, not\njust arrays. If you create an alias for your object ( Item 23 ) and mutate it,\nthen you can run into trouble even without a function call.\nWhile variance can be tricky to think about, the lesson here is\nstraightforward: avoid mutating function parameters! And to make sure you\ndon’ t, declare them readonly  or Readonly .\nFunction Calls Don’t Invalidate Refinements\nHere’ s some code that doesn’ t look too suspicious at first glance (at least\nfrom a type safety perspective):\ninterface FunFact { \n  fact: string; \n  author?: string;\n} \n \nfunction processFact(fact: FunFact, processor: (fact: FunFact) => void) { \n  if (fact.author) { \n    processor(fact); \n    console.log(fact.author.blink());  // ok \n    //               ^? (property) FunFact.author?: string \n  }\n}\nDepending on what processor  does, however , the call to blink()  might\nthrow at runtime:\nprocessFact( \n  {fact: 'Peanuts are not actually nuts', author: 'Botanists'}, \n  f => delete f.author\n);\n// Type checks, but throws `Cannot read property 'blink' of undefined`.\nThe issue is that if (fact.author)  refines the type of fact.author  from\nstring|undefined  to string . This is sound. However , the call to\nprocessor(fact)  should  invalidate this refinement. The type of\nfact.author  should revert back to string|undefined  because T ypeScript\nhas no way of knowing what the callback will do to our refined fact.\nWhy does T ypeScript allow this? Because most functions don’ t mutate their\nparameters, and this sort of pattern is common in JavaScript.\nHow can you avoid this? Again, don’ t mutate your function parameters!\nY ou can enforce that callbacks do this by passing them a Readonly  version\nof the object ( Item 14 ).\nAssignability and Optional Properties\nIt’ s important to remember that object types in T ypeScript types aren’ t\n“sealed”: they could have properties other than the ones you’ve declared\n( Item 4 ). When combined with optional properties, this can lead to\nunsoundness.\nHere’ s how this might happen:\ninterface Person { \n  name: string;\n}\ninterface PossiblyAgedPerson extends Person { \n  age?: number;\n}\nconst p1 = { name: ""Serena"", age: ""42 years"" };\nconst p2: Person = p1;\nconst p3: PossiblyAgedPerson = p2;\nconsole.log(`${p3.name} is ${p3.age?.toFixed(1)} years old.`);\nThe assignment from p1  to p2  circumvents excess property checking ( Item\n1 1 ). p2  has a static type of Person . This is sound because the type {name:\nstring; age: string}  is assignable to Person . W ith structural typing,\nit’ s OK to have extra properties.\nThe assignment to p3  is where we lose soundness. If you think of types as\nbeing sealed, without having extra properties, then this assignment should\nbe allowed: a Person  wouldn’ t have an age  property and, since this\nproperty is optional on PossiblyAgedPerson ,  that would be OK. But types\naren’ t sealed and, as happened here, it’ s possible that they have additional\nproperties that are incompatible with the optional property’ s type.\nIf you run into this issue, it may be because you’ve had a name collision\nbetween overly generic property names (e.g., type ). T ry choosing more\nspecific property names. Naming the properties ageInYears  and\nageFormatted  in this example would have prevented this error .\nUnsoundness is just one of the problems with optional properties. Item 37\ndiscusses other reasons why you should think carefully before adding one.\nThere are a few other sources of unsoundness in T ypeScript, but these are\nsome of the ones that you’re most likely to come across in practice.\nRemember , unsoundness isn’ t a flaw in the language. It reflects a choice\nabout where T ypeScript wants to be positioned along the spectrum of\nconvenience, expressiveness, and safety . If you want to move to a dif ferent\npoint along that spectrum, you have some knobs that let you do so (e.g.,\nstrictNullChecks  and noUncheckedIndexedAccess ). Otherwise, be\naware of the common patterns that lead to unsoundness and try to avoid\nthem.\nThings to Remember\n“Unsoundness” is when a symbol’ s value at runtime diver ges from its\nstatic type. It can lead to crashes and other bad behavior without type\nerrors.",19133
59-Item 49 Track Your Type Coverage to Prevent Regressions in Type Safety.pdf,59-Item 49 Track Your Type Coverage to Prevent Regressions in Type Safety,"Be aware of some of the common ways that unsoundness can arise:\nany  types, type assertions ( as , is ), object and array lookups, and\ninaccurate type definitions.\nA void mutating function parameters as this can lead to unsoundness.\nMark them as read-only if you don’ t intend to mutate them.\nMake sure child classes match their parent’ s method declarations.\nBe aware of how optional properties can lead to unsound types.\nI t e m  4 9 :  T r a c k  Y o u r  T y p e  C o v e r a g e  t o\nP r e v e n t  R e g r e s s i o n s  i n  T y p e  S a f e t y\nY ou’ve  enabled noImplicitAny  and added type annotations to all the\nvalues that had implicit any  types. Are you safe from the problems\nassociated with any  types? The answer is “no”; any  types can still enter\nyour program in two main ways:\nThr ough explicit any  types\nEven if you follow the advice of Items 43  and 44 , making your any\ntypes both narrow and specific, they remain any  types. In particular ,\ntypes like any[]  and {[key: string]: any}  become plain any s once\nyou index into them, and the resulting any  types can flow through your\ncode.\nFr om thir d-party type declarations\nThis is particularly insidious since any  types from an @types\ndeclaration file enter silently: even though you have noImplicitAny\nenabled and you never wrote the word “any ,” you still have any  types\nflowing through your code.\nBecause of the negative ef fects any  types can have on type safety and\ndeveloper experience ( Item 5 ), it’ s a good idea to keep track of the number\nof them in your codebase. There are many ways to do this, including the\ntype-coverage  package on npm:\n$ npx type-coverage \n9985 / 10117 98.69%\nThis means that, of the 10,1 17 symbols in this project, 9,985 (98.69%) had\na type other than any  or an alias to any . If a change inadvertently introduces\nan any  type and it flows through your code, you’ll see a corresponding drop\nin this percentage.\nIn some ways, this percentage is a way of keeping score on how well\nyou’ve followed the advice of the other items in this chapter . Using\nnarrowly scoped any  will reduce the number of symbols with any  types,\nand so will using more specific forms like any[] . T racking this numerically\nhelps you make sure things only get better over time.\nEven collecting type coverage information once can be informative.\nRunning type-coverage  with the --detail  flag will print where every\nany  type occurs in your code:\n$ npx type-coverage --detail \npath/to/code.ts:1:10 getColumnInfo \npath/to/module.ts:7:1 pt2 \n...\nThese are worth investigating because they’re likely to turn up sources of\nany s that you hadn’ t considered. Let’ s look at a few examples.\nExplicit any  types are often the result of choices you made for expediency\nearlier on. Perhaps you were getting a type error that you didn’ t want to\ntake the time to sort out. Maybe the type was one that you hadn’ t written\nout yet. Or you might have just been in a rush.\nT ype assertions with any  can prevent types from flowing where they\notherwise would. Perhaps you’ve built an application that works with\ntabular data and needed a single-parameter function that built up some kind\nof column description:\nfunction getColumnInfo(name: string): any { \n  return utils.buildColumnInfo(appState.dataSchema, name);  // Returns any\n}\nThe utils.buildColumnInfo  function returned any  at some point. As a\nreminder , you added a comment and an explicit : any  annotation to the\nfunction.\nHowever , in the intervening months you’ve also added a type for\nColumnInfo , and utils.buildColumnInfo  no longer returns any . The any\nannotation is now throwing away valuable type information. Get rid of it!\nThird-party any  types can come in a few forms, but the most extreme is\nwhen you give an entire module an any  type:\ndeclare module 'my-module';\nNow you can import anything from my-module  without error . These\nsymbols all have any  types and will lead to more any  types if you pass\nvalues through them:\nimport {someMethod, someSymbol} from 'my-module';  // OK \n \nconst pt1 = { x: 1, y: 2 };\n//    ^? const pt1: { x: number; y: number; }\nconst pt2 = someMethod(pt1, someSymbol);  // OK\n//    ^? const pt2: any\nSince the usage looks identical to a well-typed module, it’ s easy to for get\nthat you stubbed out the module. Or maybe a coworker did it and you never\nknew in the first place. It’ s worth revisiting these from time to time. Maybe\nthere are of ficial type declarations for the module. Or perhaps after reading\nChapter 8  you’ve gained enough understanding of the module to write types\nyourself and contribute them back to the community .\nAnother common source of any s with third-party declarations is when\nthere’ s a bug in the types. Maybe the declarations didn’ t follow the advice\nof Item 30  and declared a function to return a union type when in fact it\nreturns something much more specific. When you first used the function,\nthis didn’ t seem worth fixing so you used an any  assertion. But maybe the\ndeclarations have been fixed since then. Or maybe it’ s time to fix them\nyourself!\nIf you’d like to continually be aware of the any  types in your code, you can\nset up type-coverage  as a T ypeScript Language Service plug-in. This is\nlike having X-ray vision, letting you see all the any  types hiding in plain\nsight in your code ( Figure 5-1 ).\nFigur e 5-1. Symbols with an any  type highlighted in your editor . None of these would have been\nnoImplicitAny  err ors.\nIf you add type-coverage  to your continuous integration system, you’ll\nfind out about surprising drops in type safety as soon as they happen.\nThe considerations that led you to use an any  type may no longer apply .\nMaybe there’ s a type you can plug in now where previously you used any .\nMaybe an unsafe type assertion is no longer necessary . Maybe the bug in\nthe type declarations you were working around has been fixed. T racking\nyour type coverage highlights these choices and encourages you to keep\nrevisiting them.\nThings to Remember\nEven with noImplicitAny  set, any  types can make their way into your\ncode either through explicit any s or third-party type declarations\n(@types ).\nConsider tracking how well-typed your program is using a tool like\ntype-coverage . This will encourage you to revisit decisions about\nusing any  and increase type safety over time.\n1 W ith the exception of never .",6474
60-Item 50 Think of Generics as Functions Between Types.pdf,60-Item 50 Think of Generics as Functions Between Types,"Chapter 6. Generics and T ype-\nLevel Programming\nT ypeScript’ s type system is designed to model the runtime behavior of\nJavaScript code. Because JavaScript is so dynamic and permissive, this has\npushed T ypeScript’ s type system to develop increasingly powerful\ncapabilities. As Item 15  explained, this includes logic for mapping between\ntypes.\nWhen you add generic type aliases to the mix, T ypeScript’ s type system\nbecomes powerful enough that you can think of it as its own independent\nprogramming language. (T ypeScript’ s type system is T uring Complete , so\nthis is true in a formal sense.) Rather than programming with values, as you\ndo in JavaScript, you’re now programming with types. In other words, type-\nlevel programming. This is distinct from metaprogramming (writing\nprograms that operate on programs), though the two terms are sometimes\nconflated.\nLearning new languages is fun, and you can find all sorts of wild\napplications built using T ypeScript’ s type system, ranging from games to\nSQL parsers. This has been driven  in part by the T ype Challenges  project,\nwhich includes hundreds of increasingly dif ficult puzzles to solve in the\ntype system. Solving these as you read this chapter is a great way to cement\nwhat you’ve learned.\nThis chapter also includes a few cautionary notes. Just because T ypeScript\nincludes a programming language for types doesn’ t mean it’ s a particularly\nintuitive, er gonomic, or pleasant language to work with. Just because you\ncan  write logic at the type level doesn’ t mean it’ s always a good idea.\nOveruse of generic types can lead to cryptic, hard-to-maintain code. Josh\nGoldber g puts it well in Learning T ypeScript  (O’Reilly):\nAlthough generics can give us a lot of flexibility in describing types in\ncode, they can become rather complex quite quickly . Pr ogrammers new\nto T ypeScript often go thr ough a phase of overusing generics to the point\nof making code confusing to r ead and overly complex to work with.\nT ypeScript best practice is generally to use generics only when\nnecessary , and to be clear about what they’r e used for when they ar e.\nThis chapter will help you decide whether it’ s necessary to use generic\ntypes and presents some alternatives. Used well, type-level code can\nimprove other developers’ experiences without their ever needing to know\nthat there’ s fancy type-level code involved.\nI t e m  5 0 :  T h i n k  o f  G e n e r i c s  a s  F u n c t i o n s\nB e t w e e n  T y p e s\nItem 15  showed how you can use type operations ( extends , mapped types,\nindexing, keyof ) to reduce repetition between related types. In value-land,\nfunctions are one of the key ways to factor out repeated code. In type-land,\nthe equivalent of a function is a generic type . A generic type takes one or\nmore type parameters  and produces a concrete, nongeneric type. Whereas\nyou “call” a function, you “instantiate” a generic type.\nThe built-in Partial  generic type makes all the properties of another type\noptional. Here’ s how you might define that yourself:\ntype MyPartial<T> = {[K in keyof T]?: T[K]};\nHere T  is the type parameter . Y ou can see that this works exactly the same\nas the built-in Partial  type:\ninterface Person { \n  name: string; \n  age: number;\n} \n \ntype MyPartPerson = MyPartial<Person>;\n//   ^? type MyPartPerson = { name?: string; age?: number; } \n \ntype PartPerson = Partial<Person>;\n//   ^? type PartPerson = { name?: string; age?: number; }\nBy defining this generic type, we’ve encapsulated the type-level operations\nrequired to optionalize all the properties on another type. This is exactly\nanalogous to how a function might encapsulate the logic of taking one value\nand producing another . Y ou don’ t need to know the details of how\nMath.cos  is implemented to know that it calculates the cosine of a number .\nY ou can write generic types that take multiple type parameters. Here’ s how\nyou might try to define the equivalent of the built-in Pick  generic:\ntype MyPick<T, K> = { \n  [P in K]: T[P] \n  //    ~        Type 'K' is not assignable to type 'string | number | \nsymbol'. \n  //        ~~~~ Type 'P' cannot be used to index type 'T'.\n};\nEven when you’re programming at the type level, T ypeScript applies all the\nsame tools of static analysis to check for assignability and other errors in\nyour code. Here it’ s found two problems:\nW e’re mapping over K , but T ypeScript has no reason to believe that it\ncontains types that can be used as property keys, namely string ,\nnumber , or symbol .\nEven if it were a valid property key , T ypeScript has no reason to\nbelieve that P  can be used to index into T . T  might not be an object\ntype, and it might not have that key .\nThere are many ways to deal with type-level errors, just as there are many\nways to deal with type errors in nongeneric code. Perhaps the simplest is to\nignore them. This works surprisingly well!\n// @ts-expect-error (don't do this!)\ntype MyPick<T, K> = { [P in K]: T[P] };\ntype AgeOnly = MyPick<Person, 'age'>;\n//   ^? type AgeOnly = { age: number; }\nY ou can think of this as the type-level equivalent of T ypeScript emitting\nJavaScript, even in the presence of type errors ( Item 3 ). Just because it\ndoesn’ t like your implementation of a generic type doesn’ t mean that\nT ypeScript won’ t let you use it.\nOf course, T ypeScript is right to complain. This version of MyPick  is quite\nerror prone:\ntype FirstNameOnly = MyPick<Person, 'firstName'>;\n//   ^? type FirstNameOnly = { firstName: unknown; }\ntype Flip = MyPick<'age', Person>;\n//   ^? type Flip = {}\nRather than getting a type error , incorrect uses of MyPick  just return the\nwrong type. It’ s almost like programming in JavaScript!\nAnother way to make the error go away is to add intersections with the\ntypes that T ypeScript is expecting. Here’ s what that looks like:\ntype MyPick<T, K> = { [P in K & PropertyKey]: T[P & keyof T] }; \n \ntype AgeOnly = MyPick<Person, 'age'>;\n//   ^? type AgeOnly = { age: number; }\ntype FirstNameOnly = MyPick<Person, 'firstName'>;\n//   ^? type FirstNameOnly = { firstName: never; }\nPropertyKey  is a built-in alias for string | number | symbol . Y ou can\nthink of this sort of intersection as a kind of type-level equivalent of as\nany . It has made the type errors in the implementation go away and left the\ncorrect uses unchanged. The incorrect uses come out slightly dif ferently ,\nand this is perhaps an improvement: never  is often an indication that\nsomething has gone wrong.\nBut keeping with the analogy , as any  is rarely the right choice in value-\nland, and these intersections are not typically the best choice at the type\nlevel, either . Y ou often solve type errors by making a function accept a\nnarrower type for its parameters, and that’ s exactly what we want to do\nhere. Y ou can add a constraint on type parameters using the extends\nkeyword:\ntype MyPick<T extends object, K extends keyof T> = {[P in K]: T[P]}; \n \ntype AgeOnly = MyPick<Person, 'age'>;\n//   ^? type AgeOnly = { age: number; }\ntype FirstNameOnly = MyPick<Person, 'firstName'>;\n//                                  ~~~~~~~~~~~\n//            Type '""firstName""' does not satisfy the constraint 'keyof \nPerson'.\ntype Flip = MyPick<'age', Person>;\n//                 ~~~~~ Type 'string' does not satisfy the constraint \n'object'.\nBy constraining T  to be an object type and constraining K  to be a subtype of\nthe keys of T , we’ve solved two problems at once: we’ve eliminated the\ntype errors in the implementation and we’ve produced type errors on the\ninvalid instantiations of MyPick .\nWhen you have noImplicitAny  set, T ypeScript requires that you provide\ntype annotations for all function parameters. There’ s no equivalent of this\nfor type parameters. If you don’ t specify a constraint, it defaults to\nunknown , which allows users to pass in any type whatsoever . When you’re\ndefining a generic type, consider whether you want to give your users a bit\nless freedom and a bit more safety .\nWhen you write a function, you choose descriptive parameter names and\nwrite TSDoc comments ( Item 68 ). Y ou should do that for generic types as\nwell. There’ s a convention of using one-letter names for type parameters (as\nthis item has), but you should be just as wary of these in type-level code as\nyou would be of one-letter variable names.\nThe general rule of thumb in naming is that the length of a name should\nmatch its scope. Long-lived globals should have long, descriptive names,\nwhereas short names like i , k , or v  can actually improve legibility in a\nconcise arrow function with limited scope. For a short generic like MyPick ,\nT  and K  are fine. But for a longer definition where the type parameter has\nbroader scope (a generic class, say), a longer , more meaningful name will\nimprove clarity .\nY ou can write TSDoc for generic types and the T ypeScript language service\nwill surface it in relevant situations, just as it would for functions. The type-\nlevel equivalent of @param  is @template :1\n/**\n * Construct a new object type using a subset of the properties of another one\n * (same as the built-in `Pick` type).\n * @template T The original object type\n * @template K The keys to pick, typically a union of string literal types.\n */\ntype MyPick<T extends object, K extends keyof T> = { \n  [P in K]: T[P]\n};\nIf you inspect MyPick  at an instantiation site, you’ll get the full\ndocumentation. And if you mouse over T  or K  in the definition, you’ll see\nthe documentation for just that type parameter ( Figure 6-1 ).\nFigur e 6-1. The @template  TSDoc tag can be used to document a type parameter .\nT ypeScript types are  best thought of as sets of values ( Item 7 ), so generic\ntypes inherently operate on sets. This is quite distinct from JavaScript\nfunctions where you know that each parameter will have a single value\nevery time the function is called. In practice this means that you always\nneed to think about how your generic type will behave with union types.\nItem 53  shows you how to do this.\nY ou  write tests for your value-level code, what about for your type-level\ncode? Y ou absolutely should test your types! This is an interesting and deep\nenough topic that it warrants its own item. Check out Item 55 .\nY ou can also add type parameters to some value-level constructs such as\nfunctions and classes. W e might accompany our Pick  generic type with a\ncorresponding pick  function, for example:\nfunction pick<T extends object, K extends keyof T>( \n  obj: T, ...keys: K[]\n): Pick<T, K> { \n  const picked: Partial<Pick<T, K>> = {}; \n  for (const k of keys) { \n    picked[k] = obj[k]; \n  } \n  return picked as Pick<T, K>;\n} \n \nconst p: Person = { name: 'Matilda', age: 5.5 };\nconst age = pick(p, 'age');\n//    ^? const age: Pick<Person, ""age"">\nconsole.log(age);  // logs { age: 5.5 }\nJust looking at the type and ignoring the bits between the parentheses, this\nlooks a lot like the definition of the MyPick  type from earlier:\ntype P = typeof pick;\n//   ^? type P = <T extends object, K extends keyof T>(\n//         obj: T, ...keys: K[]\n//      ) => Pick<T, K>\nY ou can think of generic functions as conceptually defining an associated\ngeneric type. The beauty of generic functions, however , is that T ypeScript\ncan often infer the type parameters from the values when the function is\ncalled. In the previous example, we just wrote pick(p, 'age') . This is\nsignificantly more concise than (and produces the exact same results as)\nwriting out the types explicitly:\nconst age = pick<Person, 'age'>(p, 'age');\n//    ^? const age: Pick<Person, ""age"">\nAnother advantage is that the user of your pick  function needn’ t know that\nthey’re working with generic types or type-level operations at all. They can\njust enjoy the accurate, precise types. The type of age  is a hint that there’ s\ntype-level programming at work, but this, too, can be hidden if you like.\nItem 56  shows how .\nClasses can also take type parameters, and these, too, can be inferred from\nusage:\nclass Box<T> { \n  value: T; \n  constructor(value: T) { \n    this.value = value; \n  }\n} \n \nconst dateBox = new Box(new Date());\n//    ^? const dateBox: Box<Date>\nRecall from Item 8  that class  is one of the few constructs in T ypeScript\nthat introduces both a type and a value. For a generic class, it introduces a\ngeneric type that relates the type parameter ( T ) to the properties and\nmethods of that class.\nJust as classes are good at capturing related bits of state that you’d\notherwise have to track yourself, generic classes are a good way to capture\ntypes. A generic class’ s type parameters are set when it’ s constructed and\nthey don’ t need to be passed to its methods when you call them (though its\nmethods can have type parameters of their own). Item 28  explored how this\ncould be used to gain more fine-grained control over type inference.\nIn value-land, you can write “higher order functions” like map , filter , and\nreduce  that take other functions as parameters. This gives you enormous\nflexibility to factor out shared behaviors. Is there a type-level equivalent of\nthese?\nAt the time of this writing, the answer is no. These would be “functions on\nfunctions on types” or “higher -kinded types” as they’re usually known.",13432
61-Item 51 Avoid Unnecessary Type Parameters.pdf,61-Item 51 Avoid Unnecessary Type Parameters,"They would let you factor out common operations, like applying a generic\ntype to the value types in an object:\ntype MapValues<T extends object, F> = { \n  [K in keyof T]: F<T[K]>; \n  //              ~~~~~~~ Type 'F' is not generic.\n};\nThe good news is that this doesn’ t limit what you can do with generic types.\nIt only limits the way you express yourself. In this case, you need to use a\nmapped type instead of MapValues . Similarly , there’ s no such thing as an\nanonymous generic type.\nGeneric types are best thought of as functions between types. Keep this in\nmind as you write them. Y ou’re working at the type level now and it’ s\nexciting and new . But you’re still coding, and all the best practices you’ve\nlearned for writing value-level code still apply .\nThings to Remember\nThink of generic types as functions between types.\nUse extends  to constrain the domain of type parameters, just as you’d\nuse a type annotation to constrain a function parameter .\nChoose type parameter names that increase the legibility of your code,\nand write TSDoc for them.\nThink of generic functions and classes as conceptually defining\ngeneric types that are conducive to  type inference.\nI t e m  5 1 :  A v o i d  U n n e c e s s a r y  T y p e\nP a r a m e t e r s\nHere’ s what  the of ficial T ypeScript Handbook  has to say about generic\nfunctions:\nW riting generic functions is fun, and it can be easy to get carried away\nwith type parameters. Having too many type parameters or using\nconstraints wher e they ar en’ t needed can make infer ence less successful,\nfrustrating callers of your function.\nIt goes on to of fer a few specific pieces of advice about how to use generics,\nincluding one that is sometimes called the “Golden Rule of Generics”:\nT ype Parameters Should Appear T wice\nT ype parameters ar e for r elating the types of multiple values. If a type\nparameter is only used once in the function signatur e, it’ s not r elating\nanything.\nRule: If a type parameter only appears in one location, strongly\nreconsider if you actually need it.\nThis rule gives you a specific way to tell whether any type parameter is\ngood or bad, but it’ s not always obvious how to apply it, and it doesn’ t of fer\nmuch guidance about how to rework your code if you’re using generics\npoorly . In this item we’ll go through a few examples of good and bad uses\nof generics to illustrate how the rule works, and we’ll rewrite the bad ones.\nLet’ s start with the identity  function:\nfunction identity<T>(arg: T): T { \n  return arg;\n}\nThis function takes a single parameter and returns it, leaving its type\nunaltered. Here’ s how you might use it:\nconst date = identity(new Date());\n//    ^? const date: Date\nconst nums = [1, 2, 3];\n//    ^? const nums: number[]\nconst numsCopy = nums.map(identity);\n//    ^? const numsCopy: number[]\nThis function can be useful in practice if you’re required to pass in a\ncallback but you don’ t want to alter your data. Thinking about the Golden\nRule, is this a good use of generics or a bad use? In this example, the type\nparameter T  appears in two places after its declaration:\nfunction identity<T>(arg: T): T { \n  //           (decl.)    1   2 \n  return arg;\n}\nSo this passes the test and is a good use of generics. And rightly so: it\nrelates two types because it says that the input parameter ’ s type and the\nfunction’ s return type are the same.\nHow about this one?\nfunction third<A, B, C>(a: A, b: B, c: C): C { \n  return c;\n}\nThe type parameter C  appears twice, so it’ s fine. But A  and B  only appear\nonce (other than in their declarations), so this function fails the test. Y ou can\nrewrite it using only one type parameter:\nfunction third<C>(a: unknown, b: unknown, c: C): C { \n  return c;\n}\nHere’ s a type declaration for a function that parses Y AML:\ndeclare function parseYAML<T>(input: string): T;\nIs this a good use of generics or a bad use of generics? The type parameter\nT  only appears once, so it must be bad. How to fix it? It depends what your\ngoal is. These so-called “return-only generics” are dangerous because\nthey’re equivalent to a type assertion ( Item 9 ), but don’ t use the word as :\ninterface Weight { \n  pounds: number; \n  ounces: number;\n} \n \nconst w: Weight = parseYAML('');\nAt first blush, this code looks safe because there are no type assertions or\nany  types. But this is an illusion. Y ou could replace Weight  with any other\ntype and this code would still type check. Setting a default value for the\ntype parameter doesn’ t change this:\ndeclare function parseYAML<T=null>(input: string): T;\nconst w: Weight = parseYAML('');  // still allowed\nIt’ s better to make this function return unknown  instead (see Item 46  for a\nrefresher on the unknown  type):\ndeclare function parseYAML(input: string): unknown;\nThis will force users of the function to perform a type assertion on the\nresult:\nconst w = parseYAML('') as Weight;\nThis is actually a good thing since it forces you to be explicit about your\nunsafe type assertion. There are no illusions of type safety here!2\nHow about this one?\nfunction printProperty<T, K extends keyof T>(obj: T, key: K) { \n  console.log(obj[key]);\n}\nSince K  only appears once, this is a bad use of generics ( T  is fine because it\nappears both as a parameter type and as a constraint on K ). Fix it by moving\nthe keyof T  into the parameter type and eliminating K :\nfunction printProperty<T>(obj: T, key: keyof T) { \n  console.log(obj[key]);\n}\nThis function looks superficially similar:\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) { \n  return obj[key];\n}\nThis one, however , is actually a good use of generics. T o see why , we need\nto look at the inferred return type of the function. If you inspect\ngetProperty  in your editor , you’ll see that its return type is T[K] . That\nmeans this signature is equivalent to:\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] { \n  return obj[key];\n}\nSo K  does  appear twice! This is a good use of generics: K  is related to T , and\nthe return type is related to both K  and T .\nWhat about a class?\nclass ClassyArray<T> { \n  arr: T[]; \n  constructor(arr: T[]) { this.arr = arr; } \n \n  get(): T[] { return this.arr; } \n  add(item: T) { this.arr.push(item); } \n  remove(item: T) { \n    this.arr = this.arr.filter(el => el !== item) \n  }\n}\nThis is fine since T  appears many times in the implementation (I count 5).\nWhen you instantiate a ClassyArray , you bind the type parameter and it\nrelates the types of all the properties and methods on the class. (This can be\nuseful for creating inference sites, as we saw in Item 28 .)\nThis class, on the other hand, fails the test:\nclass Joiner<T extends string | number> { \n  join(els: T[]) { \n    return els.map(el => String(el)).join(','); \n  }\n}\nFirst of all, T  only applies to join , so it can be moved down onto the\nmethod, rather than the class:\nclass Joiner { \n  join<T extends string | number>(els: T[]) { \n    return els.map(el => String(el)).join(','); \n  }\n}\nBy moving the declaration of T  closer to its use, we make it possible for\nT ypeScript to infer the type of T . Generally , this is what you want! But in\nthis case, since T  only appears once, you should make it nongeneric:\nclass Joiner { \n  join(els: (string | number)[]) { \n    return els.map(el => String(el)).join(','); \n  }\n}\nFinally , why does this need to be a class at all? These sorts of wrapper\nclasses are common in Java (which doesn’ t support standalone functions)\nbut they’re unnecessary  in JavaScript.3 Make it a standalone function\ninstead:\nfunction join(els: (string|number)[]) { \n  return els.map(el => String(el)).join(',');\n}\nHow about this function to get the length of any array-like object?\ninterface Lengthy { \n  length: number;\n}\nfunction getLength<T extends Lengthy>(x: T) { \n  return x.length;\n}\nSince T  only appears once after its definition, this is a bad use of generics. It\ncould be written as:\nfunction getLength(x: Lengthy) { \n  return x.length;\n}\nor even:\nfunction getLength(x: {length: number}) { \n  return x.length;\n}\nOr , since T ypeScript has a built-in ArrayLike  type:\nfunction getLength(x: ArrayLike<unknown>) { \n  return x.length;\n}\nEvery rule has exceptions, so are there any exceptions to this one? There\nare some rare cases where extraneous type parameters can help you get an\nimplementation right. For example, both type parameters in this function\nare bad:\ndeclare function processUnrelatedTypes<A, B>(a: A, b: B): void;\nThe fix is to rewrite it this way:\ndeclare function processUnrelatedTypes(a: unknown, b: unknown): void;\nThis has a consequence for the implementation of the function, however . In\nthe first declaration, a  and b  were not assignable to one another in the body\nof the function:\nfunction processUnrelatedTypes<A, B>(a: A, b: B) { \n    a = b;\n//  ~ Type 'B' is not assignable to type 'A'. \n    b = a;\n//  ~ Type 'A' is not assignable to type 'B'.\n}\nW ith the improved type signature, they are:\nfunction processUnrelatedTypes(a: unknown, b: unknown) { \n  a = b;  // ok \n  b = a;  // ok\n}\nA workaround is to use a single overload to create a distinct type signature\nfor callers versus the implementation. Item 52  shows what this looks like.\nAs a general rule, however , this sort of situation is rare, and you should\navoid generic type parameters that only appear once.\nBy now you should have a good sense for how to apply the golden rule of\ngenerics and how to fix the declarations that break it. As you read and write\ngeneric functions, think about whether they follow this rule! If a function or\nclass doesn’ t need to be generic, then it will be easier to understand and\nmaintain if it isn’ t.\nPut another way , the first rule of generics is “don’ t.”\nThings to Remember\nA void adding type parameters to functions and classes that don’ t need\nthem.\nSince type parameters relate types, every type parameter must appear\ntwo or more times to establish a relationship.\nRemember that a type parameter may appear in an inferred type.\nA void “return-only generics.”",10225
62-Item 52 Prefer Conditional Types to Overload Signatures.pdf,62-Item 52 Prefer Conditional Types to Overload Signatures,"Unneeded type parameters can often be replaced with the unknown\ntype.\nI t e m  5 2 :  P r e f e r  C o n d i t i o n a l  T y p e s  t o\nO v e r l o a d  S i g n a t u r e s\nHow would  you write a type declaration for this JavaScript function?\nfunction double(x) { \n  return x + x;\n}\ndouble  can be passed either a string  or a number . So you might use a\nunion type:\ndeclare function double(x: string | number): string | number;\nWhile this declaration is accurate, it’ s a bit imprecise:\nconst num = double(12);\n//    ^? const num: string | number\nconst str = double('x');\n//    ^? const str: string | number\nWhen double  is passed a number , it returns a number . And when it’ s passed\na string , it returns a string . This declaration misses that nuance and will\nproduce types that are inconvenient to work with.\nY ou might try to capture this relationship by making the function generic:\ndeclare function double<T extends string | number>(x: T): T; \n \nconst num = double(12);\n//    ^? const num: 12\nconst str = double('x');\n//    ^? const str: ""x""\nUnfortunately , in our zeal for precision we’ve overshot. The types are now a\nlittle too  precise. When passed a string  type, this double  declaration will\nresult in a string  type, which is correct. But when passed a string literal\ntype, the return type is the same string literal type. This is wrong: doubling\n'x'  results in 'xx' , not 'x' . As Item 40  explained, imprecise types are\npreferable to inaccurate types, so this is a step in the wrong direction. How\ncan we do better?\nAnother option is to provide multiple type declarations, also known as\n“overload signatures” (see Item 3  for a refresher). While JavaScript only\nallows you to write one implementation of a function, T ypeScript allows\nyou to write any number of type signatures. Y ou can use this to improve the\ntype of double :\ndeclare function double(x: number): number;\ndeclare function double(x: string): string; \n \nconst num = double(12);\n//    ^? const num: number\nconst str = double('x');\n//    ^? const str: string\nThis is progress! But there’ s still a subtle bug. This type declaration will\nwork with values that are either a string  or a number , but not with values\nthat could be either:\nfunction f(x: string | number) { \n  return double(x); \n  //            ~ Argument of type 'string | number' is not assignable \n  //              to parameter of type 'string'\n}\nThis call to double  is safe and should return string|number . When you\nprovide overload signatures, T ypeScript processes them one by one until it\nfinds a match. The error you’re seeing is a result of the last overload (the\nstring  version) failing, because string|number  is not assignable to\nstring .\nWhile you could fix this by adding a third string|number  overload, a\nbetter solution is to use a conditional type . Conditional types are like if\nstatements (conditionals) in type space. They’re perfect for situations like\nthis one where there are a few possibilities that you need to cover:\ndeclare function double<T extends string | number>( \n  x: T\n): T extends string ? string : number;\nThis is similar to the first attempt to type double  using a generic function,\nbut with a more elaborate return type. Y ou read the conditional type like\nyou’d read a ternary ( ?: ) operator in JavaScript:\nIf T  is a subtype of string  (i.e., string , or a string literal, or a union\nof string literals, or a template literal type), then the return type is\nstring .\nOtherwise return number .\nW ith this declaration, all of our examples work:\nconst num = double(12);\n//    ^? const num: number\nconst str = double('x');\n//    ^? const str: string \n \nfunction f(x: string | number) { \n  //     ^? function f(x: string | number): string | number \n  return double(x);  // ok\n}\nThe string|number  example works because conditional types distribute\nover unions. When T  is string|number , T ypeScript resolves the\nconditional type as follows:\n  (string|number) extends string ? string : number \n→ (string extends string ? string : number) | \n  (number extends string ? string : number) \n→ string | number\nThe way that conditional types distribute over unions is part of the design of\nT ypeScript’ s type system. It didn’ t have to be this way . But in many cases\n(such as this one), this behavior is correct and extremely convenient.\nWhile the type declaration using overload signatures was simpler to write,\nthe version using conditional types is more correct because it generalizes to\nthe union of the individual cases. This is often the case for overload\nsignatures. Whereas overloads are treated independently , the type checker\ncan analyze conditional types as a single expression, distributing them over\nunions.\nWhenever you write a conditional type, you should think about whether you\nwant it to distribute over unions. Usually you do, but this isn’ t always the\ncase. Item 53  presents a situation where distribution is incorrect and shows\nhow you can gain some control over it.\nAre there any situations where you should prefer overloads? If the union\ncase is implausible, or if your function really acts as two or more very\ndistinct functions with completely dif ferent signatures, then it may not be\nworth the ef fort to handle it, and keeping the distinct overloads separate will\nresult in more readable code.\nIf you find yourself in this situation, though, think about whether it would\nbe clearer to have two dif ferent functions. An example of this comes from\nthe Node standard library , which of fers both callback- and Promise-based\nversions of filesystem functions like readFile . This could  be a single\nfunction that behaves dif ferently depending on its ar guments. But you\ngenerally know in advance whether you’re using callbacks or Promises, so\nit’ s clearer and simpler to have two distinct functions.\nSince this is a chapter on type-level programming, we’ve focused entirely\non the types. But it’ s worth briefly discussing how to implement  overloaded\nfunctions and functions that return conditional types. This can often be\nawkward and require type assertions in the function body . T ypeScript will\nnot infer a conditional type for a variable.\nOne strategy is to define a single overload to present a dif ferent type\nsignature to callers than you use to implement the function. For example:",6423
63-Item 53 Know How to Control the Distribution of Unions over Conditional Types.pdf,63-Item 53 Know How to Control the Distribution of Unions over Conditional Types,"function double<T extends string | number>( \n  x: T\n): T extends string ? string : number;\nfunction double(x: string | number): string | number { \n  return typeof x === 'string' ? x + x : x + x;\n}\nHere we use the conditional type for the externally visible API, but use a\nsimpler type for the implementation. (The typeof  check looks a bit odd but\nsaves us a type assertion.) T ypeScript does some checking that the two\nsignatures are compatible, but it cannot do a perfect job. It’ s still important\nto test your types, as explained in Item 55 .\nThings to Remember\nPrefer conditional types to overloaded type signatures. By distributing\nover unions, conditional types allow your declarations to support union\ntypes without additional overloads.\nIf the union case is implausible, consider whether your function would\nbe clearer as two or more functions with dif ferent names.\nConsider using the single overload strategy for implementing functions\ndeclared with  conditional types.\nI t e m  5 3 :  K n o w  H o w  t o  C o n t r o l  t h e\nD i s t r i b u t i o n  o f  U n i o n s  o v e r  C o n d i t i o n a l\nT y p e s\nItem 52  looked at how conditional types distribute over unions, and how\nthis could be helpful in typing a double  function:\ndeclare function double<T extends number | string>( \n  x: T\n): T extends string ? string : number; \n \nconst num = double(12);\n//    ^? const num: number\nconst str = double('x');\n//    ^? const str: string \n \ndeclare let numOrStr: number | string;\nconst either = double(numOrStr);\n//    ^? const either: number | string\nIn this case, the distribution over unions produced the desired result. This is\ntypically , but not always, the case.\nT o see an example of where distribution is not desirable, let’ s define an\nisLessThan  function that determines whether its first ar gument is less than\nthe second. W e’d like it to operate on dates, numbers, and strings. As a\nconvenience, if you pass a Date  in as the first ar gument, we’d like to allow\nyou to pass a number (milliseconds since epoch) as the second ar gument.\nY ou can model this using a conditional type:\ntype Comparable<T> = \n    T extends Date ? Date | number: \n    T extends number ? number : \n    T extends string ? string : \n    never; \n \ndeclare function isLessThan<T>(a: T, b: Comparable<T>): boolean;\nThis seems to allow and disallow the combinations that we expect:\nisLessThan(new Date(), new Date());  // ok\nisLessThan(new Date(), Date.now());  // ok, Date/number comparison allowed\nisLessThan(12, 23);  // ok\nisLessThan('A', 'B');  // ok\nisLessThan(12, 'B');\n//             ~~~ Argument of type 'string' is not assignable to parameter\n//                 of type 'number'.\nBecause of the way it’ s written, Comparable  distributes over unions. Is this\ndesirable? Evidently not:\nlet dateOrStr = Math.random() < 0.5 ? new Date() : 'A';\n//  ^? let dateOrStr: Date | string\nisLessThan(dateOrStr, 'B')  // ok, but should be an error\nThe second parameter should really be the intersection of the two\npossibilities, not the union. And (Date | number) & string  is never , so\nthis call shouldn’ t be allowed at all.\nHow can we prevent distribution? Unions only distribute over conditional\ntypes if the condition is a bare type ( T extends ... ). So to prevent\ndistribution, we need to complicate the expression a bit. The standard way\nto do this is to wrap T  in a one-element tuple type, [T] :\ntype Comparable<T> = \n    [T] extends [Date] ? Date | number: \n    [T] extends [number] ? number : \n    [T] extends [string] ? string : \n    never;\nThe type [A]  is assignable to [B]  if and only if A  is assignable to B . So on\nthe surface this change doesn’ t look like it should af fect the behavior of\nComparable . But since [T]  is not a bare type, unions no longer distribute\nover Comparable  and we get the desired errors without breaking the other\nvalid calls:\nisLessThan(new Date(), new Date());  // ok\nisLessThan(new Date(), Date.now());  // ok, Date/number comparison allowed\nisLessThan(12, 23);  // ok\nisLessThan('A', 'B');  // ok\nisLessThan(12, 'B');\n//             ~~~ Argument of type 'string' is not assignable to parameter\n//                 of type 'number'.\nisLessThan(dateOrStr, 'B');\n//                    ~~~ Argument of type 'string' is not assignable to\n//                        parameter of type 'never'.\nSometimes the situation is reversed and you have a conditional type that\ndoesn’ t distribute but you’d like it to. This typically occurs as an\ninadvertent consequence of the way that the generic type was implemented.\nT o see how this might happen, let’ s implement a generic type, NTuple<T,\nN> , that produces a tuple with N  elements, all of type T . This is a step up in\ncomplexity from the types we’ve seen before, but we’ll talk our way\nthrough it. Here’ s one way to do it using an accumulator:\ntype NTuple<T, N extends number> = NTupleHelp<T, N, []>; \n \ntype NTupleHelp<T, N extends number, Acc extends T[]> = \n  Acc['length'] extends N \n  ? Acc \n  : NTupleHelp<T, N, [T, ...Acc]>;\nThe trick here is to keep adding elements to a tuple type until its length\nproperty matches the number that we want. Remember that this lookup is\nhappening in the type system. Looking up 'length'  on an array type will\nyield number , but for a tuple type it will yield a more precise numeric literal\ntype like 0 , 1 , 2 , etc.\nThis generic type works as we’d hope for constructing N -tuples if N  is a\nsingle number:\ntype PairOfStrings = NTuple<string, 2>;\n//   ^? type PairOfStrings = [string, string]\ntype TripleOfNumbers = NTuple<number, 3>;\n//   ^? type TripleOfNumbers = [number, number, number]\nBut it does not work as we’d hope if N  is a union:\ntype PairOrTriple = NTuple<bigint, 2 | 3>;\n//   ^? type PairOrTriple = [bigint, bigint]\nThis should  be [bigint, bigint] | [bigint, bigint, bigint] . The\nimmediate issue is that Acc['length'] extends 2 | 3  is true as soon as\nthe accumulator gets to be a pair . But the deeper issue is that our conditional\ntype isn’ t distributing over unions. W e’d like it to. Why isn’ t it, and how\ncan we fix it?\nThe problem is that the condition is Acc['length'] extends N , which\ndoes not start with the bare “N extends…” that’ s required for distribution.\nSo the easiest fix is to add an extra conditional type that looks like this:\ntype NTuple<T, N extends number> = \n    N extends number \n    ? NTupleHelp<T, N, []> \n    : never;\nBecause N  is constrained to extend number , this conditional will always\nevaluate to true  (you could make it N extends any  or N extends\nunknown  if you like). Its sole purpose is to add a conditional type in the\nright form for distribution. And it works!\ntype PairOrTriple = NTuple<bigint, 2 | 3>;\n//   ^? type PairOrTriple = [bigint, bigint] | [bigint, bigint, bigint]\nThis happens because NTupleHelp  is instantiated with N = 2  and N = 3\nand the results are unioned together . Using an accumulator is a common\ntechnique with recursive generic types because it can improve their\nperformance. Item 57  will explain how .4\nConditional types have two other surprising behaviors that you should be\naware of when they distribute over the boolean  and never  types.\nFirst, boolean . Let’ s define a generic type that yields a celebratory message\nif its ar gument is true :\ntype CelebrateIfTrue<V> = V extends true ? 'Huzzah!' : never; \n \ntype Party = CelebrateIfTrue<true>;\n//   ^? type Party = ""Huzzah!""\ntype NoParty = CelebrateIfTrue<false>;\n//   ^? type NoParty = never\ntype SurpriseParty = CelebrateIfTrue<boolean>;\n//   ^? type SurpriseParty = ""Huzzah!""\nIt’ s surprising that this last instantiation resolves to ""Huzzah!""  because you\nwouldn’ t expect boolean extends true  to be true. What’ s going on is a\nbit more subtle. Internally , T ypeScript treats boolean  as a union:\ntype boolean = true | false;\nBecause boolean  is a union, it can distribute over conditional types. So\nspelling it out a bit, the evaluation looks like this:\ntype SurpriseParty \n    = CelebrateIfTrue<boolean> \n    = CelebrateIfTrue<true | false> \n    = CelebrateIfTrue<true> | CelebrateIfTrue<false> \n    = ""Huzzah!"" | never \n    = ""Huzzah!"";\nIn this case, it’ s probably not what you wanted. As before, you can prevent\ndistribution by wrapping the condition in a one-tuple:\ntype CelebrateIfTrue<V> = [V] extends [true] ? 'Huzzah!' : never; \n \ntype SurpriseParty = CelebrateIfTrue<boolean>;\n//   ^? type SurpriseParty = never\nAnother surprise comes with the never  type. Looking at this definition,\nyou’d expect AllowIn<T>  to always evaluate to either ""Yes"" , ""No""  or\npossibly ""Yes"" | ""No"" :\ntype AllowIn<T> = T extends {password: ""open-sesame""} ? ""Yes"" : ""No"";\nBut there’ s one other possibility if T  is never :\ntype N = AllowIn<never>;\n//   ^? type N = never\nWhy does this evaluate to never  if neither side of the conditional is never ?\nAgain, it’ s all about distribution over unions. T ypeScript treats the never",9078
64-Item 54 Use Template Literal Types to Model DSLs and Relationships Between Strings.pdf,64-Item 54 Use Template Literal Types to Model DSLs and Relationships Between Strings,"type as an empty union and, if there’ s nothing to distribute over , you get\nempty  back. This might make a bit more sense if you replace T  with\nT|never  (which is the same as T ) and see what happens:\nAllowIn<T> \n  = AllowIn<T | never> \n  = AllowIn<T> | AllowIn<never> \n  = AllowIn<T> | never \n  = AllowIn<T>\nSurely T|never  should be treated the same as T . And when distribution\napplies, this means that F<never>  must be never , regardless of how you\ndefine F . As before, if you don’ t want this, one solution is to wrap your\ncondition in a one-tuple.\nThe way that conditional types distribute over unions is one of their most\npowerful and useful capabilities. It is usually , but not always, the behavior\nthat you want. When you write a generic type, think about whether you\nwant it to distribute over unions, and be aware of how seemingly innocuous\nrefactors can enable or disable distribution.\nThings to Remember\nThink about whether you want unions to distribute over your\nconditional types.\nKnow how to enable or disable distribution by adding conditions or by\nwrapping conditions in one-tuples.\nBe aware of the surprising behavior of boolean  and never  types when\nthey distribute  over unions.\nI t e m  5 4 :  U s e  T e m p l a t e  L i t e r a l  T y p e s  t o  M o d e l\nD S L s  a n d  R e l a t i o n s h i p s  B e t w e e n  S t r i n g s\nItem 35  suggested using more precise alternatives to string  types in your\nown code. But there are many strings in the world and it’ s hard to avoid\nthem entirely . In these cases, T ypeScript of fers its own unique tool for\ncapturing patterns and relationships in strings: template literal types. This\nitem will explore how this feature works and how you can use it to bring\nsafety to code that would be impossible to type otherwise.\nLike all programming languages, T ypeScript has a string  type but, as\nwe’ve seen in previous items, it also has string literal  types, which are types\nwhose domain consists of a single string value. These are often combined\nwith unions:\ntype MedalColor = 'gold' | 'silver' | 'bronze';\nW ith unions of string literal types, you can model finite sets of strings. W ith\nstring  itself you can capture the infinite set all possible strings. T emplate\nliteral types let you model something in between, for example, the set of all\nstrings starting with pseudo :\ntype PseudoString = `pseudo${string}`;\nconst science: PseudoString = 'pseudoscience';  // ok\nconst alias: PseudoString = 'pseudonym';  // ok\nconst physics: PseudoString = 'physics';\n//    ~~~~~~~ Type '""physics""' is not assignable to type '`pseudo${string}`'.\nLike string , the PseudoString  type has an infinite domain ( Item 7 ). But\nunlike string , values in the PseudoString  type have some structure: they\nall start with pseudo . As with other type-level constructs, the syntax for\ntemplate literal types is deliberately meant to evoke JavaScript’ s template\nliterals.\nJavaScript abounds with structured strings. For example, what if you want\nto require that an object have some known set of properties, but also allow\nany others that start with data- ? (This pattern is common with the DOM.)\ninterface Checkbox { \n  id: string; \n  checked: boolean; \n  [key: `data-${string}`]: unknown;\n} \n \nconst check1: Checkbox = { \n  id: 'subscribe', \n  checked: true, \n  value: 'yes',\n// ~~~~ Object literal may only specify known properties,\n//        and 'value' does not exist in type 'Checkbox'. \n  'data-listIds': 'all-the-lists',  // ok\n};\nconst check2: Checkbox = { \n  id: 'subscribe', \n  checked: true, \n  listIds: 'all-the-lists',\n// ~~~~~~ Object literal may only specify known properties,\n//          and 'listIds' does not exist in type 'Checkbox'\n};\nHad we used string  as the index type, we’d lose the benefit of excess\nproperty checking on check1  (see Item 1 1 ) and incorrectly permit the\nproperty without a data-  prefix on check2 :\ninterface Checkbox { \n  id: string; \n  checked: boolean; \n  [key: string]: unknown;\n} \n \nconst check1: Checkbox = { \n  id: 'subscribe', \n  checked: true, \n  value: 'yes',  // permitted \n  'data-listIds': 'all-the-lists',\n};\nconst check2: Checkbox = { \n  id: 'subscribe', \n  checked: true, \n  listIds: 'all-the-lists'  // also permitted, matches index type\n};\nT emplate literal types are helpful for modeling subsets of string , but their\nreal power comes when we  combine them with generics and type inference\nto capture r elationships  between types.\nConsider the querySelector  function provided by the DOM. T ypeScript is\nalready clever enough to give you a more specific subtype of HTMLElement\nif you query for it:\nconst img = document.querySelector('img');\n//    ^? const img: HTMLImageElement | null\nThis allows you to access img.src , for example, which would not be\npermitted on the less specific Element  type. ( Item 75  covers T ypeScript and\nthe DOM.)\nThis cleverness is not very deep, though. If you try to query for an image\nwith a specific ID, you’ll just get an Element :\nconst img = document.querySelector('img#spectacular-sunset');\n//    ^? const img: Element | null\nimg?.src\n//   ~~~ Property 'src' does not exist on type 'Element'.\nW ith the help of template literal types, we can make this work. T ypeScript’ s\ntype declarations for the DOM ( lib.dom.d.ts ) include a mapping from tag\nname to type:\ninterface HTMLElementTagNameMap { \n  ""a"": HTMLAnchorElement; \n  ""abbr"": HTMLElement; \n  ""address"": HTMLElement; \n  ""area"": HTMLAreaElement; \n  // ... many more ... \n  ""video"": HTMLVideoElement; \n  ""wbr"": HTMLElement;\n}\nas well as a few declarations for querySelector :5\ninterface ParentNode extends Node { \n  // ... \n  querySelector<E extends Element = Element>(selectors: string): E | null; \n  // ...\n}\nNow we can use a template literal type to add an overload for the tag#id\ncase:\ntype HTMLTag = keyof HTMLElementTagNameMap;\ndeclare global { \n  interface ParentNode { \n    querySelector< \n      TagName extends HTMLTag \n    >( \n      selector: `${TagName}#${string}` \n    ): HTMLElementTagNameMap[TagName] | null; \n  }\n}\nThe example from before now works as you’d hope, returning the more\nprecise image type and allowing access to its src  property:\nconst img = document.querySelector('img#spectacular-sunset');\n//    ^? const img: HTMLImageElement | null\nimg?.src  // ok\nThis is helpful, but we’ve slightly missed the mark:\nconst img = document.querySelector('div#container img');\n//    ^? const img: HTMLDivElement | null\nA space  in a CSS selector means “descendant of.” In this case, our template\nliteral type `${TagName}#${string}`  matched ""div"" , then ""#"" , then\n""container img"" . In attempting to get more precise types, we’ve run afoul\nof Item 40 ’ s advice to prefer imprecision to inaccuracy .\nWhile one could imagine building an entire CSS selector parser using\ntemplate literal types, a less ambitious way to handle this issue is to guard\nagainst characters with special meanings in CSS selectors using another\noverload:\ntype CSSSpecialChars = ' ' | '>' | '+' | '~' | '||' | ',';\ntype HTMLTag = keyof HTMLElementTagNameMap; \n \ndeclare global { \n  interface ParentNode { \n    // escape hatch \n    querySelector( \n      selector: `${HTMLTag}#${string}${CSSSpecialChars}${string}` \n    ): Element | null; \n \n    // same as before \n    querySelector< \n      TagName extends HTMLTag \n    >( \n      selector: `${TagName}#${string}` \n    ): HTMLElementTagNameMap[TagName] | null; \n  }\n}\nNow you at least get an imprecise type for the more complex selector ,\nrather than an inaccurate type:\nconst img = document.querySelector('img#spectacular-sunset');\n//    ^? const img: HTMLImageElement | null\nconst img2 = document.querySelector('div#container img');\n//    ^? const img2: Element | null\nThis will help ensure safe usage. For more on T ypeScript and the DOM, see\nItem 75 .\nT emplate literal types are often combined with conditional types to\nimplement parsers for  domain-specific languages (DSLs) like CSS\nselectors. T o see how this works, let’ s try to get precise types for an\nobjectToCamel  function that camelCases the keys of a snake_cased object:\n// e.g. foo_bar -> fooBar\nfunction camelCase(term: string) { \n  return term.replace(/_([a-z])/g, m => m[1].toUpperCase());\n} \n \n// (return type to be filled in shortly)\nfunction objectToCamel<T extends object>(obj: T) { \n  const out: any = {}; \n  for (const [k, v] of Object.entries(obj)) { \n    out[camelCase(k)] = v; \n  } \n  return out;\n} \n \nconst snake = {foo_bar: 12};\n//    ^? const snake: { foo_bar: number; }\nconst camel = objectToCamel(snake);\n// camel's value at runtime is {fooBar: 12};\n// we'd like the type to be {fooBar: number}\nconst val = camel.fooBar;  // we'd like this to have a number type\nconst val2 = camel.foo_bar;  // we'd like this to be an error\nLet’ s start by defining a type-level ToCamelOnce  helper:\ntype ToCamelOnce<S extends string> = \n    S extends `${infer Head}_${infer Tail}` \n    ? `${Head}${Capitalize<Tail>}` \n    : S; \n \ntype T = ToCamelOnce<'foo_bar'>;  // type is ""fooBar""\nHere we’ve used the infer  keyword in a conditional type to extract the part\nof the string before and after an underscore. When S  is ""foo_bar"" , then\nHead  is the string literal type ""foo""  and Tail  is the string literal type\n""bar"" . When we get a match, we construct a new string (using a template\nliteral type) without the underscore and with the first letter of the tail\ncapitalized ( Capitalize  is a built-in helper).\nT o make this work on strings with multiple underscores like\n""foo_bar_baz"" , we need to make it recursive:\ntype ToCamel<S extends string> = \n    S extends `${infer Head}_${infer Tail}` \n    ? `${Head}${Capitalize<ToCamel<Tail>>}` \n    : S;\ntype T0 = ToCamel<'foo'>;  // type is ""foo""\ntype T1 = ToCamel<'foo_bar'>;  // type is ""fooBar""\ntype T2 = ToCamel<'foo_bar_baz'>;  // type is ""fooBarBaz""\nNow we can give objectToCamel  a more precise type using a mapped type\n( Item 15 ) that rewrites the keys using the helper:\ntype ObjectToCamel<T extends object> = { \n  [K in keyof T as ToCamel<K & string>]: T[K]\n}; \n \nfunction objectToCamel<T extends object>(obj: T): ObjectToCamel<T> { \n  // ... as before ...\n}\nAnd now the types are exactly what we wanted!\nconst snake = {foo_bar: 12};\n//    ^? const snake: { foo_bar: number; }\nconst camel = objectToCamel(snake);\n//    ^? const camel: ObjectToCamel<{ foo_bar: number; }>\n//                    (equivalent to { fooBar: number; })\nconst val = camel.fooBar;\n//    ^? const val: number\nconst val2 = camel.foo_bar;\n//                 ~~~~~~~ Property 'foo_bar' does not exist on type\n//                         '{ fooBar: number; }'. Did you mean 'fooBar'?\nThis new , more precise type for objectToCamel  is an excellent example of\n“fancy” T ypeScript features being used to benefit a developer . Y ou don’ t\nneed to know anything about template literal types, conditional types, or\nmapped types to use objectToCamel . But you still benefit from them in the\nform of more precise types. Y our experience of T ypeScript is that it\nunderstands this code even if you don’ t understand precisely how it does\nthat.\nOne small issue is that the display of the camel ’ s type isn’ t ideal. Item 56\nwill explain how to improve it.\nThings to Remember\nUse template literal types to model structured subsets of string  types\nand domain-specific languages (DSLs).",11575
65-Item 55 Write Tests for Your Types.pdf,65-Item 55 Write Tests for Your Types,"Combine template literal types with mapped and conditional types to\ncapture nuanced relationships between types.\nT ake care to avoid crossing the line into inaccurate types. Strive for\nuses of template literal types that improve developer experience\nwithout requiring knowledge of fancy language features.\nI t e m  5 5 :  W r i t e  T e s t s  f o r  Y o u r  T y p e s\nW rite tests until fear is transformed into bor edom.\n— Phlip (quoted in Kent Beck, T est Driven Development:\nBy Example  [Addison-W esley Professional])\nY ou wouldn’ t write code without tests (I hope!), and you shouldn’ t write\ntype declarations without writing tests for them either . But how do you test\ntypes? If you’re authoring type declarations or a T ypeScript library , testing\nyour types is an essential, but surprisingly fraught, undertaking.\nThis is a particularly acute need for T ypeScript compared to most other\nprogramming languages for two reasons:\nT ypeScript lets you put an enormous amount of logic in the types .\nWhere there’ s logic, there might be bugs, and where there might be\nbugs, you should write tests.\nFor JavaScript libraries and, to some extent, T ypeScript code, you can\ndefine your types independently of the runtime implementation. This\nmeans that the two can get out of sync, and you need to write tests to\nensure that this doesn’ t happen.\nThere are two main ways to test types: using the type system and using\ntooling outside the type system. Either approach works, and both have their\nadvantages. This item will first look at some ineffective  ways to test types,\nthen talk about the pros and cons of the two standard approaches.\nSuppose you’ve written a type declaration for a map  function provided by a\nutility library (the popular Lodash library provides such a function, as do\nnative arrays):\ndeclare function map<U, V>(array: U[], fn: (u: U) => V): V[];\nHow can you check that this type declaration results in the expected types?\n(Presumably , there are separate tests for the implementation.) One common\ntechnique is to write a test file that calls the function:\nmap(['2017', '2018', '2019'], v => Number(v));\nThis will do some blunt error checking: if your declaration of map  only\nlisted a single parameter , this would catch the mistake. But does it feel like\nsomething is missing here?\nThe equivalent of this style of test for runtime behavior might look\nsomething like this:\ntest('square a number', () => { \n  square(1); \n  square(2);\n});\nSure, this tests that the square  function doesn’ t throw an error . But it\ndoesn’ t check the return value, so there’ s no real test of the behavior . An\nincorrect implementation of square  would still pass this test.\nThis approach is common in testing type declaration files because it’ s\nsimple to copy/paste existing unit tests for a library . And while it does\nprovide some value, it would be much better to actually check some types!\nOne way to do this is to assign the result to a variable with a declared type:\nconst lengths: number[] = map(['john', 'paul'], name => name.length);\nThis is exactly the sort of superfluous type declaration that Item 18  would\nencourage you to remove. But here it plays an essential role: it provides\nsome confidence that the map  declaration is at least doing something\nsensible with the types. And indeed, you can find many type declarations in\nDefinitelyT yped that use exactly this approach for testing.\nThere are a few problems with using assignment for testing, however .\nOne problem is that you have to create a named variable that is likely to be\nunused. This adds boilerplate, and also means that you’ll have to disable\nany linter rules that warn about unused variables.\nThe usual workaround is to define a helper:\nfunction assertType<T>(x: T) {} \n \nassertType<number[]>(map(['john', 'paul'], name => name.length));\nA second issue is that we’re checking assignability  of the two types rather\nthan equality . Often this works as you’d expect. For example:\nconst n = 12;\nassertType<number>(n);  // OK\nIf you inspect the n  symbol in your editor , you’ll see that its type is actually\n12 , a numeric literal type. This is a subtype of number , and the assignability\ncheck passes, just as you’d expect.\nSo far , so good. But things get murkier when you start checking the types of\nobjects:\nconst beatles = ['john', 'paul', 'george', 'ringo'];\nassertType<{name: string}[]>( \n  map(beatles, name => ({ \n    name, \n    inYellowSubmarine: name === 'ringo' \n  }))\n);  // OK\nThe map  call returns an array of {name: string, inYellowSubmarine:\nboolean}  objects. This is assignable to {name: string}[] , so the code\npasses the type checker . But what about the yellow submarine? In this case,\nwe’d really prefer to check for type equality .\nT esting for assignability can lead to surprising behavior with function types,\ntoo:\nconst add = (a: number, b: number) => a + b;\nassertType<(a: number, b: number) => number>(add);  // OK \n \nconst double = (x: number) => 2 * x;\nassertType<(a: number, b: number) => number>(double);  // OK!?\nIt’ s surprising that the second assertion succeeds since the functions take\ndif ferent numbers of parameters. But this is just how assignability works in\nT ypeScript: a function type is assignable to another function type that takes\nfewer parameters:\nconst g: (x: string) => any = () => 12;  // OK\nThis reflects the fact that it’ s perfectly fine to call a JavaScript function with\nmore parameters than it’ s declared to take. T ypeScript chooses to model this\nbehavior rather than bar it, lar gely because it is pervasive in callbacks. The\ncallback in the Lodash map  function, for example, takes up to three\nparameters:\nmap(array, (element, index, array) => { /* ... */ });\nWhile all three are available if you need them, it’ s very common to use only\none or sometimes two, as we have so far in this item. In fact, it’ s quite rare\nto use all three. If T ypeScript disallowed this assignment, it would report\nerrors in an enormous amount of JavaScript code.\nSo what can you do? Y ou could break apart the function type and test its\npieces using the built-in Parameters  and ReturnType  types:\nconst double = (x: number) => 2 * x;\ndeclare let p: Parameters<typeof double>;\nassertType<[number, number]>(p);\n//                           ~ Argument of type '[number]' is not\n//                             assignable to parameter of type [number, \nnumber]\ndeclare let r: ReturnType<typeof double>;\nassertType<number>(r);  // OK\nBut if “this” isn’ t complicated enough, there’ s another issue: Lodash’ s map\nsets the value of this  for its callback. T ypeScript can model this behavior\n(see Item 69 ), so your type declaration should do so. And you should test it.\nHow can we do that?\nOur tests of map  so far have been a bit “black box” in style: we’ve run an\narray and function through map  and tested the type of the result, but we\nhaven’ t tested the details of the intermediate steps. W e can do so by filling\nout the callback function and verifying the types of its parameters and this\ndirectly:\nconst beatles = ['john', 'paul', 'george', 'ringo'];\nassertType<number[]>(map( \n  beatles, \n  function(name, i, array) { \n    // ~~~ Argument of type '(name: any, i: any, array: any) => any' is \n    //     not assignable to parameter of type '(u: string) => any' \n    assertType<string>(name); \n    assertType<number>(i); \n    assertType<string[]>(array); \n    assertType<string[]>(this); \n    //                   ~~~~ 'this' implicitly has type 'any' \n    return name.length; \n  }\n));\nThis has surfaced a few issues with our declaration of map  from earlier ,\nnamely that its callback only takes one parameter and that it doesn’ t set a\ntype for this . Note the use of a function expression instead of an arrow\nfunction so that we could test the type of this .\nHere is a declaration that passes the checks:\ndeclare function map<U, V>( \n  array: U[], \n  fn: (this: U[], u: U, i: number, array: U[]) => V\n): V[];\nThere remains a final issue, however , and it is a major one. Here’ s a\ncomplete type declaration file for our module that will pass even the most\nstringent tests for map  but is worse than useless:\ndeclare module 'your-amazing-module';\nThis assigns an any  type to the entir e module . Y our type assertions will all\npass, but you won’ t have any type safety . What’ s worse, every call to a\nfunction in this module will quietly produce an any  type, contagiously\ndestroying type safety throughout your code. Even with noImplicitAny ,\nyou can still get any  types through  type declarations files.\nOne way to address this issue is by adding some “negative” tests: tests that\nare expected to fail. T ypeScript lets you do this  via @ts-expect-error\ncomments:\n// @ts-expect-error only takes two parameters\nmap([1, 2, 3], x => x * x, 'third parameter');\nThis inverts the usual error checking process: now you’ll get a compiler\nerror if there isn’ t  a type error . This does give you some protection against\nany  types, but be warned: @ts-expect-error  is a very blunt instrument.\nY ou can’ t say exactly which error you expect. For example, the previous\nsnippet still passes with an any  type because there will be an implicit any\nerror on the function parameter:\ndeclare const map: any;\nmap([1, 2, 3], x => x * x, 'third parameter');\n//             ~ Parameter 'x' implicitly has an 'any' type.\nOne workaround here is to split your code across multiple lines to reduce\nthe scope of the directive:\nmap( \n  [1, 2, 3], \n  x => x * x, \n  // @ts-expect-error only takes two parameters \n  'third parameter'\n);\nIt would be better if we could adapt assertType  to handle these pesky any\ntypes, though. W ith some cleverness, you can  detect an any  type using a\ntype alias. But rather than add complexity to our testing code, let’ s take this\nas a cue to pull in a testing library .\nOne of the more popular choices that works within the type system is\nexpect-type . Y ou  can use it on its own or via the vitest testing framework,\nwhich bundles it. Here’ s what it looks like:\nimport {expectTypeOf} from 'expect-type'; \n \nconst beatles = ['john', 'paul', 'george', 'ringo'];\nexpectTypeOf(map( \n  beatles, \n  function(name, i, array) { \n    expectTypeOf(name).toEqualTypeOf<string>(); \n    expectTypeOf(i).toEqualTypeOf<number>(); \n    expectTypeOf(array).toEqualTypeOf<string[]>(); \n    expectTypeOf(this).toEqualTypeOf<string[]>(); \n    return name.length; \n  }\n)).toEqualTypeOf<number[]>();\nAs you’d hope, it’ s able to catch any  types, dif fering function types, and\nsubtle dif ferences like readonly  properties:\nconst anyVal: any = 1;\nexpectTypeOf(anyVal).toEqualTypeOf<number>();\n//                                 ~~~~~~\n//           Type 'number' does not satisfy the constraint 'never'. \n \nconst double = (x: number) => 2 * x;\nexpectTypeOf(double).toEqualTypeOf<(a: number, b: number) => number>();\n//                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//           Type ... does not satisfy '""Expected: function, Actual: never""' \n \ninterface ABReadOnly { \n  readonly a: string; \n  b: number;\n}\ndeclare let ab: {a: string, b: number};\nexpectTypeOf(ab).toEqualTypeOf<ABReadOnly>();\n//               ~~~~~~~~~~~~~\n//           Arguments for the rest parameter 'MISMATCH' were not provided.\nexpectTypeOf(ab).toEqualTypeOf<{a: string, b: number}>();  // OK\nT esting types in this way of fers a number of advantages:\nIt doesn’ t require any additional tooling. All type testing is done via\ntsc , which you’re using already .\nSince types are tested structurally , it won’ t get tripped up by\nmeaningless dif ferences like 1|2  versus 2|1 .\nT ypeScript’ s language service will help with refactoring. If you rename\nan interface, for example, its name will also get updated in any type\nassertions.\nY our assertions will get formatted in the same way as your code if\nyou’re using a formatting tool like prettier .\nThere are also a few downsides to this approach:\nThe error message for mismatched types ( 'MISMATCH' ) doesn’ t give\nmuch guidance about what the mismatch is or where it occurs.\nBecause it’ s testing the structure of types, it cannot detect issues\naround how they display . As Item 56  will explain, you have some\ncontrol over this and should care about it.\nThat being said, this is a great way to test your types and it’ s a vast\nimprovement over the hand-rolled attempts we saw earlier in this item.\nAnother approach in this vein was popularized by the T ype Challenges\nrepo . It looks like this:\nexport type Equals<X, Y> = \n  (<T>() => T extends X ? 1 : 2) extends \n  (<T>() => T extends Y ? 1 : 2) ? true : false; \n \nexport type Expect<T extends true> = T; \n \nconst double = (x: number) => 2 * x;\ntype Test1 = Expect<Equals<typeof double, (x: number) => number>>;\ntype Test2 = Expect<Equals<typeof double, (x: string) => number>>;\n//                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//                  Type 'false' does not satisfy the constraint 'true'.\nRecall from Item 48  that function types are covariant with respect to their\nreturn types. But the only way the first conditional type could reliably be\nassignable to the second is if X  is equal to Y . (T ry plugging in a few concrete\ntypes for X , Y , and T  to convince yourself of this.) Rather than relying on\ntype-level logic to test for equality , this is the rare case where we can get\nT ypeScript itself to compare types for equality .\nWhile this is slightly more robust than expect-type , it has many of the\nsame advantages and disadvantages. The error messages for failed tests\naren’ t particularly illuminating. And type equality is such a rare concept in\nT ypeScript that the semantics are a bit murky . Some parts of the type’ s\ndisplay matter , while others don’ t:\ntype Test3 = Expect<Equals<1 | 2, 2 | 1>>;  // good!\ntype Test4 = Expect<Equals<[a: 1, b: 2], [1, 2]>>;  // maybe not so good\ntype Test5 = Expect<Equals<{x: 1} & {y: 2}, {x: 1, y: 2}>>;  // surprising\n//                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//                  Type 'false' does not satisfy the constraint 'true'.\nSo much for testing types within the  type system. What if you want to test\ntypes using an external tool? T wo common ones are dtslint  and eslint-\nplugin-expect-type . As the names suggest, these both operate as linters.\ndtslint  was built to test type declarations in the DefinitelyT yped\nrepository . It operates through specially formatted comments. Here’ s how\nyou might write the last test for the map  function using dtslint :\nconst beatles = ['john', 'paul', 'george', 'ringo'];\nmap(beatles, function( \n  name,  // $ExpectType string \n  i,     // $ExpectType number \n  array  // $ExpectType string[]\n) { \n  this   // $ExpectType string[] \n  return name.length;\n});  // $ExpectType number[]\nRather than checking assignability , dtslint  inspects the type of each\nsymbol and does a textual comparison. This matches how you’d manually\ntest the type declarations in your editor: dtslint  essentially automates this\nprocess. This approach does have some drawbacks: despite being\nfundamentally the same type, number|string  and string|number  are\ntextually dif ferent. But so are string  and any , despite being assignable to\neach other , which is really the point.\neslint-plugin-expect-type  works in a similar way , but as an ESLint\nplugin. This is more convenient if you want to test your own T ypeScript\ntypes, rather than type declarations on DefinitelyT yped. In addition to\n$ExpectType  comments, it will check the types in T woslash-style\ncomments:\nconst spiceGirls = ['scary', 'sporty', 'baby', 'ginger', 'posh'];\n//    ^? const spiceGirls: string[]\nThis should look familiar: it’ s the same syntax used for code samples in this\nbook! Y ou can also use T woslash-style comments on the T ypeScript\nplayground (see Figure P-1  in the Preface to the Second Edition ).\nT esting types using an external tool has a number of strengths:\nIt matches the way you interact with types in your editor . There’ s no\ntype-level fanciness required to do a character -by-character\ncomparison of type displays.\nSince it tests the string representation of a type, it’ s able to catch issues\naround how types display ( Item 56 ).\nThe ESLint plugin’ s auto-fixer makes it easy to update tests.\nThere are some downsides, though:\nIt requires setting up another tool (though it’ s likely you’re already\nusing ESLint).\nIt can be too sensitive; e.g., saying that 1|2  and 2|1  are dif ferent types\nbecause they display dif ferently .\nY ou miss out on type formatting / refactoring since the types are in\ncomments.\nSome tools take a hybrid approach. tsd , for example, is a type testing tool\nthat operates within the type system but also includes an external tool to\nprovide the stricter type checks that are hard to get otherwise.\nFinally , there are some things you might like to test that neither tool can\nhelp you with. For example, here’ s a popular trick for providing\nautocomplete on a few values while still allowing any string :\ntype Game = 'wordle' | 'crossword' | (string & {});\nconst spellingBee: Game = 'spelling bee';\nlet g: Game = '';\nIf you hit Ctrl-Space inside that last empty string, T ypeScript will suggest\n“wordle” or “crossword.” But it will still allow any string to be assigned to\na Game . If you want to write a test that this works as you expect, neither of\nthe two approaches described in this item will help ( Figure 6-2 ).\nFigur e 6-2. T ypeScript offers autocomplete for two values, but accepts all strings.\nT esting type declarations is tricky business. Y ou should  test them. But be\naware of the pitfalls of some of the common techniques. Don’ t roll your\nown type testing system. If you’re writing type declarations on\nDefinitelyT yped, you should use dtslint  because that’ s the standard tool\nin that setting. If you’re testing your own code, use a library like vitest ,",18173
66-Item 56 Pay Attention to How Types Display.pdf,66-Item 56 Pay Attention to How Types Display,"expect-type , or tsd . If you want to write tests that are sensitive to the way\na type displays, not just its structure, use eslint-plugin-expect-type .\nThings to Remember\nWhen testing types, be aware of the dif ference between equality and\nassignability , particularly for function types.\nFor functions that use callbacks, test the inferred types of the callback\nparameters. Don’ t for get to test the type of this  if it’ s part of your\nAPI.\nA void writing your own type testing code. Use one of the standard\ntools instead.\nFor code on DefinitelyT yped, use dtslint . For your own code, use\nvitest , expect-type , or the T ype Challenges approach. If you want\nto test type display , use eslint-plugin-expect-type .\nI t e m  5 6 :  P a y  A t t e n t i o n  t o  H o w  T y p e s  D i s p l a y\nUsually , we care about what types ar e  and which values are assignable to\nthem. But when you’re using a T ypeScript library , the way it chooses to\ndisplay  types can make a big dif ference in your experience of using it. This\nmeans that, as a library author , you need to pay attention to how your types\ndisplay .\nFor any type, there are many valid ways to display it. For example, union\ntypes typically display their constituents in the order in which you listed\nthem:\ntype T123 = '1' | '2' | '3';\n//   ^? type T123 = ""1"" | ""2"" | ""3""\nBut if you happen to have introduced an overlapping union earlier , you\nmight get a dif ferent display:\ntype T21 = '2' | '1';\n//   ^? type T21 = ""2"" | ""1"" \n \ntype T123 = '1' | '2' | '3';\n//   ^? type T123 = ""2"" | ""1"" | ""3""\nIs it 1, 2, 3 or 2, 1, 3? They’re two equally valid representations of the exact\nsame type. In this case the legibility is about the same for both, but\nsometimes it can vary substantially between multiple representations.\nT o see an example of an undesirable type display , let’ s  implement a\nPartiallyPartial  generic that makes a few of the properties of an object\noptional but not the others. Here’ s an implementation:\ntype PartiallyPartial<T, K extends keyof T> = \n  Partial<Pick<T, K>> & Omit<T, K>;\nHere’ s what it might look like in practice:\ninterface BlogComment { \n  commentId: number; \n  title: string; \n  content: string;\n} \n \ntype PartComment = PartiallyPartial<BlogComment, 'title'>;\n//   ^? type PartComment =\n//          Partial<Pick<BlogComment, ""title"">> &\n//          Omit<BlogComment, ""title"">\nThe generic type is implemented correctly , and this is a perfectly valid\ndisplay of the result of this instantiation. But it leaves a few things to be\ndesired for a user inspecting PartComment : what is the type of title ? Is it\nnullable? And what other fields are there behind that Omit ? The whole\nthing feels implementation-y , as though it’ s telling the user more about how\nthe generic type was defined than what the resulting type is.\nW e’d like to tell T ypeScript to do a little more work to resolve those generic\ntypes. There’ s a widespread trick to do exactly that:\ntype Resolve<T> = T extends Function ? T : {[K in keyof T]: T[K]};\nW e’ll talk about how this works momentarily . But first, here’ s how you use\nit:\ntype PartiallyPartial<T, K extends keyof T> = \n  Resolve<Partial<Pick<T, K>> & Omit<T, K>>; \n \ntype PartComment = PartiallyPartial<BlogComment, 'title'>;\n//   ^? type PartComment = {\n//          title?: string | undefined;\n//          commentId: number;\n//          content: string;\n//      }\nBy wrapping the generic type with Resolve , we’ve magically told\nT ypeScript to flatten out the display of all its properties. It’ s much clearer\nwhat this type is now . Even better , all traces of the implementation are\ngone. The user of this type doesn’ t need to know that it’ s been implemented\nusing Partial , Pick , or Omit .\nSo how does Resolve  work? If you ignore the conditional type, you’re left\nwith an expression that looks it should be the identity for object types:\ntype ObjIdentity<T> = {[K in keyof T]: T[K]};\nAnd indeed, this does work to “resolve” some types. Because it’ s a\nhomomorphic mapped type (see Item 15 ), it allows primitive types to pass\nthrough unmodified:\ntype S = ObjIdentity<string>;\n//   ^? type S = string\ntype N = ObjIdentity<number>;\n//   ^? type N = number\ntype U = ObjIdentity<'A' | 'B' | 'C'>;\n//   ^? type U = ""A"" | ""B"" | ""C""\nIt’ s not the identity for functions, however , which is why we need the\nconditional type guarding Resolve :\ntype F = ObjIdentity<(a: number) => boolean>;\n//   ^? type F = {}\nThis helper is ubiquitous in T ypeScript code that uses lots of generic types.\nResolve  is my choice of names, but you may also see it called Simplify ,\nNOP , NOOP , or Merge In sertions .\nY ou can make a DeepResolve  that recursively resolves object types, but\nthis typically isn’ t a good idea because Resolve  winds up being too\naggressive on classes:\ntype D = Resolve<Date>;\n//   ^? type D = {\n//        toLocaleString: {\n//            (locales?: Intl.LocalesArgument,\n//             options?: Intl.DateTimeFormatOptions | undefined): string;\n//            (): string;\n//            (locales?: string | string[] | undefined,\n//             options?: Intl.DateTimeFormatOptions | undefined): string;\n//        };\n//        ... 42 more ...;\n//        [Symbol.toPrimitive]: {\n//            ...;\n//        };\n//      }\nThe inlining has backfired here. Better to just let this type display as Date .\nY ou can also use Resolve  to inline keyof  expressions if you feel that\nimproves their legibility:\ninterface Color { r: number; g: number; b: number; a: number };\ntype Chan = keyof Color;\n//   ^? type Chan = keyof Color\ntype ChanInline = Resolve<keyof Color>;\n//   ^? type ChanInline = ""r"" | ""g"" | ""b"" | ""a""\nSometimes there are particularly important cases for which you’d like to\nhave types display cleanly . For PartiallyPartial , this might be when the\ntype parameter K  is never  (in which case none of the fields are optional).\nHere’ s how that case is handled with our current definition:\ntype FullComment = PartiallyPartial<BlogComment, never>;\n//   ^? type FullComment = {\n//             title: string;\n//             commentId: number;\n//             content: string;\n//           }\nThis result is correct and it’ s a valid way of displaying this type. But there’ s\na more concise representation available: FullComment  is just BlogComment .\nW e can get a more concise type by checking for this case:\ntype PartiallyPartial<T extends object, K extends keyof T> = \n  [K] extends [never] \n  ? T  // special case \n  : T extends unknown  // extra conditional to preserve distribution over \nunions \n  ? Resolve<Partial<Pick<T, K>> & Omit<T, K>> \n  : never; \n \ntype FullComment = PartiallyPartial<BlogComment, never>;\n//   ^? type FullComment = BlogComment\nSee Item 53  for an explanation of why we’ve wrapped the condition in a\ntuple type ( [K]  instead of K ) and added a T extends unknown  clause.\nAdding this special case does not change the behavior of\nPartiallyPartial  at all, it just improves the way it displays its result in\none situation.\nY ou may see some other techniques used to adjust type display , for\nexample:\nExclude<keyof T, never>  to inline keyof  expressions\nunknown & T  or {} & T  to inline object types\nThese can both be replaced by Resolve , which has the same ef fect and is\nless brittle.\nWhen you change the display of your types, make sure you don’ t sacrifice\nlegibility in one case for the sake of another . Since these manipulations are\nsubtle and don’ t af fect assignability , it’ s easy for regressions to go",7638
67-Item 57 Prefer Tail-Recursive Generic Types.pdf,67-Item 57 Prefer Tail-Recursive Generic Types,"unnoticed. New versions of T ypeScript can also af fect how types display .\nFor this reason, it’ s important to have a system in place for testing the\ndisplay of types. Item 55  shows you how .\nThings to Remember\nThere are many valid ways to display the same type. Some are clearer\nthan others.\nT ypeScript gives you some tools to control how types display , notably\nthe Resolve  generic. Make judicious use of this to clarify type display\nand hide implementation details.\nConsider handling important special cases of generic types to improve\ntype display .\nW rite tests for your generic types and their display to avoid\nregressions.\nI t e m  5 7 :  P r e f e r  T a i l - R e c u r s i v e  G e n e r i c  T y p e s\nThe history  of computing is filled with accidental programming languages.\nY ou add some customizability to a system. Y our users like it and ask for\nmore. Y ou add a few more useful features. Y ou keep giving your users more\ncontrol. Soon enough, someone points out that you’re T uring Complete!6\nFamous examples of this dynamic include Microsoft Excel, the C\npreprocessor , C++ templates, and T ypeScript generic types.\nThese accidental programming languages are often purely functional\nbecause this paradigm gives you tremendous control with a minimum of\nconcepts. All you need is function composition and some sort of branching.\nIn the case of T ypeScript’ s type system, function composition means\ninstantiating a generic type. And you can get branching either by looking up\nkeys in an object type or by using a conditional type.\nPurely functional languages typically implement looping via recursion. As\nwe saw in Item 54 , this can be used to great ef fect to process string types.\nBut while recursion is conceptually ef ficient, it comes with some real-world\ndrawbacks because each recursive call requires a new entry on the stack.\nT o see how this can be a problem, let’ s write a JavaScript function to sum\nall the numbers in a list. One way is with recursion:\nfunction sum(nums: readonly number[]): number { \n  if (nums.length === 0) { \n    return 0; \n  } \n  return nums[0] + sum(nums.slice(1));\n} \n \nconsole.log(sum([0, 1, 2, 3, 4]));\nAs you’d expect, this prints:\n10\nThis is not a very ef ficient way to sum a list of numbers. Each number in\nthe list entails another recursive call that uses stack space and will\neventually overflow . For me, using Node.js, this happens when the array\nhas somewhere between 7,000 and 8,000 elements:\nconst arr = Array(7875).fill(1);\nconsole.log(sum(arr));\n    return nums[0] + sum(nums.slice(1)); \n                              ^ \n \nRangeError: Maximum call stack size exceeded\nA version of sum  implemented using a for-of  loop would have no such\nlimitation. So are loops inherently better than recursion? Not so fast! Long\nago, functional programmers came up with a clever solution to this\nproblem. If the last thing a function does is call itself recursively and return\nthat value, it can give up its space on the stack: its work is done and it\ndoesn’ t need it any more. This is known as T ail Call Optimization  (TCO)\nand functions with this form are called tail r ecursive .\nHere’ s a tail-recursive version of sum  that uses an accumulator:\nfunction sum(nums: readonly number[], acc=0): number { \n  if (nums.length === 0) { \n    return acc; \n  } \n  return sum(nums.slice(1), nums[0] + acc);\n}\nRunning this quickly produces the correct result without a stack overflow:7\n$ bun sum-tail-rec.js \n7875\nThe same concerns apply to recursive T ypeScript type aliases. T ypeScript\nlimits the number of recursive instantiations of a type alias to prevent\ninfinite loops and sluggishness in the type checker . But it supports T ail Call\nOptimization and gives tail-recursive type aliases a much greater depth\nlimit. Because they are more ef ficient and more capable, you should make\nrecursive type aliases tail recursive whenever possible.\nThis is particularly relevant for generics that process string literal types one\ncharacter at a time. For example, here’ s a generic type that converts a string\nliteral type to the union of the characters in the string:\ntype GetChars<S extends string> = \n    S extends `${infer FirstChar}${infer RestOfString}` \n    ? FirstChar | GetChars<RestOfString> \n    : never; \n \ntype ABC = GetChars<""abc"">;\n//   ^? type ABC = ""a"" | ""b"" | ""c""\nThis performs an operation (a union with FirstChar ) after its recursive\ncall, so it is not tail recursive. For string literal types longer than about 50\ncharacters, you’ll get an overflow:\ntype Long = GetChars<""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWX"">;\n//          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//          Type instantiation is excessively deep and possibly infinite.\nFor a more realistic example of how this could cause a problem, let’ s revisit\nobjectToCamel  from Item 54 . That function took an object with\nsnake_cased properties ( {foo_bar: 0} ) and returned an equivalent object\nwith camelCased properties ({fooBar: 0} ).  W e developed a ToCamel\ngeneric to convert the string literal type ""foo_bar""  into ""fooBar"" .\nNow let’ s go in the opposite direction and implement ToSnake . There’ s no\ndelimiter (“_”) in this case, so we’ll process the string type character by\ncharacter .\nHere’ s an implementation:\ntype ToSnake<T extends string> = \n    string extends T \n    ? string  // We want ToSnake<string> = string \n    : T extends `${infer First}${infer Rest}` \n    ? (First extends Uppercase<First>  // Is First a capital letter? \n      ? `_${Lowercase<First>}${ToSnake<Rest>}`  // e.g. ""B"" -> ""_b"" \n      : `${First}${ToSnake<Rest>}`) \n    : T; \n \ntype S = ToSnake<'fooBarBaz'>;\n//   ^? type S = ""foo_bar_baz"" \n \ntype Two = ToSnake<'className' | 'tagName'>;\n//   ^? type Two = ""class_name"" | ""tag_name""\nThere are two recursive calls here, depending on whether the first character\nof the string literal type is a capital letter . If so, we want to replace it with an\nunderscore and a lowercase letter and keep going. Otherwise we leave it as\nis and keep going. The second example shows that it distributes over unions\ncorrectly ( Item 53 ).\nThis type alias does work after the recursive call in each branch of the\nconditional (string concatenation, lowercasing), so it’ s not tail recursive.\nAnd, as you might expect by now , it’ s easy for it to overflow the stack:\ntype Long = ToSnake<'reallyDescriptiveNamePropThatsALittleTooLoquacious'>;\n//          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//          Type instantiation is excessively deep and possibly infinite.\nIf you try to snake_case an object with a long key using this helper , your\ntype will blow up. While 50 characters might seem like enough for a\nproperty name, there are many examples of properties that are much longer ,\nparticularly in the Java world.8\nW e can lift the limitation for long string literal types and speed up type\nchecking for all instantiations by refactoring ToSnake  to be tail recursive:\ntype ToSnake<T extends string, Acc extends string = """"> = \n  string extends T \n  ? string  // We want ToSnake<string> = string \n  : T extends `${infer First}${infer Rest}` \n  ? ToSnake< \n      Rest, \n      First extends Uppercase<First> \n      ? `${Acc}_${Lowercase<First>}` \n      : `${Acc}${First}` \n    > \n  : Acc; \n \ntype S = ToSnake<'fooBarBaz'>;\n//   ^? type S = ""foo_bar_baz"" \n \ntype Two = ToSnake<'className' | 'tagName'>;\n//   ^? type Two = ""class_name"" | ""tag_name"" \n \ntype Long = ToSnake<'reallyDescriptiveNamePropThatsALittleTooLoquacious'>;\n//   ^? type Long = \n""really_descriptive_name_prop_thats_a_little_too_loquacious""\nAs with the tail-recursive version of sum , we’ve added an accumulator to\ntrack the work we’ve done so far . This allows us to shift the recursive\ninstantiation into a tail position and lift the limit. Y ou’ll be able to\nsnake_case whatever wordy property names your Java coworkers throw at\nyou!\nThings to Remember",8090
68-Item 58 Consider Codegen as an Alternative to Complex Types.pdf,68-Item 58 Consider Codegen as an Alternative to Complex Types,"Aim to make your recursive generic types tail recursive. They’re more\nef ficient and have greater depth limits.\nRecursive type aliases can often be made tail recursive by rewriting\nthem to use an  accumulator .\nI t e m  5 8 :  C o n s i d e r  C o d e g e n  a s  a n  A l t e r n a t i v e\nt o  C o m p l e x  T y p e s\nBewar e of the T uring tar -pit in which everything is possible but nothing\nof inter est is easy .\n— Alan Perlis\nThis chapter has explored programming at the type level in T ypeScript. This\nmeans implementing logic and functions that operate on types rather than\nvalues ( Item 50 ). Just like regular programs, we can write tests ( Item 55 )\nand think about their performance ( Item 57 ). Especially with tools for\nworking with template literal types ( Item 54 ), type-level programs in\nT ypeScript can do some truly impressive things.\nT ypeScript’ s type system is T uring complete, so in theory you can represent\nany computation with it. As the quote at the start of this item warns, though,\njust because something is possible does not mean it’ s easy . Or wise.\nSuppose your T ypeScript program interacts with a database and includes\nsome SQL:\nasync function getBooks(db: Database) { \n  const result = await db.query( \n    `SELECT title, author, year, publisher FROM books` \n  ); \n  return result.rows;\n}\nW ith some cleverness, you may be able to use template literal types and\nconditional types to parse that query in T ypeScript’ s type system. Combine\nthis with a type representing your database schema, and you may actually\nbe able to infer the result type of that query from the query SQL itself. This\nis an impressive achievement, and you’ll certainly get more precise types\nfrom it.\nBut what if your program also includes this query?\nasync function getLatestBookByAuthor(db: Database, publisher: string) { \n  const result = await db.query( \n    `SELECT author, MAX(year) FROM books GROUP BY author WHERE publisher=$1`, \n    [publisher] \n  ); \n  return result.rows;\n}\nGetting the right types for this query is substantially harder . Y our SQL\nquery parser will need to understand GROUP BY  clauses, MAX  expressions,\nand know that the $1  placeholder means that you need to pass a second\nparameter with a single string  in an array . Even if you were able to build a\nparser for the first query , this one will likely push your code into the\n“T uring tar -pit”, where everything is possible but nothing is easy . Y ou may\nalso find it increasingly hard to be sure you’re following the advice of Item\n40  to prefer imprecise types to inaccurate types. W ith more complex\nprograms, it’ s easier to make mistakes.\nThere’ s an alternative that’ s considerably simpler , though: code generation,\nor codegen. Codegen is metaprogramming in the true sense: programs that\noperate on code and generate other code. The beauty of codegen is that it\nlets you write your type manipulations in any language you like. Y es,\nT ypeScript’ s type system is powerful and capable, but it’ s probably not your\nfirst choice for getting a job done. W ith codegen, you can write your type\nmanipulation code in ordinary T ypeScript. Y ou could also use Python or\nRust. Even a shell script might do the job.\nFor our SQL queries, one option is to use the  PgT yped library . It finds\nappropriately-tagged SQL queries in your T ypeScript, examines them\nagainst a live database, and writes out a type declaration file with the input\nand output types. Here’ s how you’d write your query in T ypeScript using\nPgT yped:\n// books-queries.ts\nimport { sql } from '@pgtyped/runtime';\nconst selectLatest = sql`\n    SELECT author, MAX(year)\n    FROM books\n    GROUP BY author\n    WHERE publisher=$publisher\n`; \n \nasync function getLatestBookByAuthor(db: Database, publisher: string) { \n  const result = await selectLatest.run({publisher}, db); \n  //    ^? const result: any[] \n  return result;\n}\nThen you run the pgtyped  command to do codegen:\n$ npx pgtyped -c pgtyped.config.json\n( pgtyped.config.json  is a file that tells PgT yped how to connect to your\ndatabase)\nThis results in a new file containing some types:\n// books-queries.types.ts\n/** Types generated for queries found in ""books-queries.ts"" */ \n \n/** 'selectLatest' parameters type */\nexport interface selectLatestParams { \n  publisher: string;\n} \n \n/** 'selectLatest' return type */\nexport interface selectLatestResult { \n  author: string; \n  year: number;\n} \n \n/** 'selectLatest' query type */\nexport interface selectLatestQuery { \n  params: selectLatestParams; \n  result: selectLatestResult;\n}\nand some changes to books-queries.ts :\n// books-queries.ts\nimport { sql } from '@pgtyped/runtime';\nimport { selectLatestQuery } from './books-queries.types';\nexport const selectLatestBookByAuthor = sql<selectLatestQuery>`\n    SELECT author, MAX(year)\n    FROM books\n    GROUP BY author\n    WHERE publisher=$publisher\n`; \n \nasync function getLatestBookByAuthor(db: Database, publisher: string) { \n  const result = await selectLatestBookByAuthor.run({publisher}, db); \n  //    ^? const result: selectLatestResult[] \n  return result;\n}\nOur query is now correctly typed! PgT yped is certainly not a simple\nprogram, but it’ s written in T ypeScript, uses standard database and testing\nlibraries, and is surely less painful to develop than any equivalently\npowerful tool written in T ypeScript’ s type system would be.\nIn addition to allowing you to work in a more conventional programming\nsystem, the codegen approach gives you complete control over how the\ntypes display . The tricks described in Item 56  won’ t be needed with your\ngenerated types. Y ou can make them look exactly the way you like. Don’ t\nlike the snake_case type names? Just pipe them through sed  or your text\nprocessing tool of choice.\nThe resulting types are also likely to be much less taxing on the T ypeScript\ncompiler and language services than your hand-rolled SQL parser .\nThe one notable cost of code generation is that it adds another build step\nthat must be run regularly to ensure that the generated code stays in sync. In\nthe SQL case, that means that the pgtyped  command would need to be\nrerun whenever a query changes or the database schema changes. The usual\nway to enforce this is by doing codegen on your continuous integration (CI)\nsystem and running git diff  to make sure nothing has changed. Y ou\nmight also add this as a pre-push check.\nSoftware engineering is a constant battle against complexity . Major\nprogramming languages like T ypeScript and the ecosystems around them\nhave been built to give you a fighting chance. T ype-level T ypeScript, while\nan impressive tool, is not the best weapon in this battle. If you write some\nfancy type-level code in T ypeScript and feel like you’re wading through the\nT uring tar -pit, consider whether you could generate types instead and write\nyour code in a more conventional language.\nItems 42  and 74  explore other ways in which codegen can be used to\nimprove type safety and reduce maintenance overhead.\nThings to Remember\nWhile type-level T ypeScript is an impressively powerful tool, it’ s not\nalways the best tool for the job.\nFor complex type manipulations, consider generating code and types\nas an alternative to writing type-level code. Y our code generation tool\ncan be written in ordinary T ypeScript or any other language.\nRun codegen and git diff  on your continuous integration system to\nmake sure generated code stays in sync.\n1 This name makes more sense if you’re coming from the C++ world, where generic types are\nknown as “template types” and developers talk about “template metaprogramming.”\n2 There are a few any -returning functions in the standard library , such as JSON.parse . See Item\n71  for a discussion of how to make them return unknown  instead.\n3 There’ s a famous adage for object-oriented programmers: “Don’ t make objects that end with\ner .”\n4 A remaining issue with this definition is that NTuple<string, number>  is [] , but it should\nbe string[] . T ry fixing it without breaking existing behavior .\n5 Since E  only appears once in this declaration, it’ s a bad use of a type parameter . See Item 51 .\n6 For T ypeScript, see https://or eil.ly/C5EzQ .\n7 Although ES2015 requires that JavaScript engines support T ail Call Optimization, at the time\nof this writing only Safari does. This means that to see TCO in action, you need to use a\nruntime like bun that’ s based on JavaScriptCore (Safari) rather than one like Node that’ s based\non V8 (Chrome)\n8 T ry Googling\n“V irtualMachineDeviceRuntimeInfoV irtualEthernetCardRuntimeStateVmDirectPathGen2Inact\niveReasonOther .”",8760
69-7. TypeScript Recipes.pdf,69-7. TypeScript Recipes,,0
70-Item 59 Use Never Types to Perform Exhaustiveness Checking.pdf,70-Item 59 Use Never Types to Perform Exhaustiveness Checking,"Chapter 7. T ypeScript Recipes\nAs the T ypeScript community has grown, developers have come up with\nmore and more tricks for solving specific problems. Some of these\n“recipes” leverage T ypeScript’ s type checker to catch new categories of\nmistakes, such as values getting out of sync or nonexhaustive conditionals.\nOthers are tricks for modeling patterns that T ypeScript struggles with on its\nown: iterating over objects, filtering null  values from Arrays, or modeling\nvariadic functions.\nBy applying the recipes in this chapter , you’ll help T ypeScript catch more\nreal problems with fewer false positives. If you enjoy these, you’ll find\nmany more recipes in Stefan Baumgartner ’ s T ypeScript Cookbook .\nI t e m  5 9 :  U s e  N e v e r  T y p e s  t o  P e r f o r m\nE x h a u s t i v e n e s s  C h e c k i n g\nStatic type analysis  is a great way to find places where you do something\nthat you shouldn’ t. When you assign the wrong type of value, reference a\nnonexistent property , or call a function with the wrong number of\nar guments, you’ll get a type error .\nBut there are also errors of omission: times when you should do something\nbut you don’ t. While T ypeScript won’ t always catch these on its own,\nthere’ s a popular trick that can be used to convert a missing case in a\nswitch  or if  statement into a type error . This is known as “exhaustiveness\nchecking.” Let’ s see how it works.\nSuppose you’re building a drawing program, perhaps using the HTML\n<canvas>  element. Y ou might define the set of shapes you can draw using a\ntagged union:\ntype Coord = [x: number, y: number];\ninterface Box { \n  type: 'box'; \n  topLeft: Coord; \n  size: Coord;\n}\ninterface Circle { \n  type: 'circle'; \n  center: Coord; \n  radius: number;\n}\ntype Shape = Box | Circle;\nY ou can draw these using built-in canvas methods:\nfunction drawShape(shape: Shape, context: CanvasRenderingContext2D) { \n  switch (shape.type) { \n    case 'box': \n      context.rect(...shape.topLeft, ...shape.size); \n      break; \n    case 'circle': \n      context.arc(...shape.center, shape.radius, 0, 2 * Math.PI); \n      break; \n  }\n}\nSo far , so good. Now you decide to add a third shape:\ninterface Line { \n  type: 'line'; \n  start: Coord; \n  end: Coord;\n}\ntype Shape = Box | Circle | Line;\nThere are no type errors, but this change has introduced a bug: drawShape\nwill silently ignore any line shapes. This is an error of omission. How can\nwe get T ypeScript to catch this kind of mistake?\nIf you look at the type of shape  after an exhaustive switch  statement,\nthere’ s a clue:\nfunction processShape(shape: Shape) { \n  switch (shape.type) { \n    case 'box': break; \n    case 'circle': break; \n    case 'line': break; \n    default: \n      shape \n      // ^? (parameter) shape: never \n  }\n}\nRecall from Item 7  that the never  type is a “bottom” type whose domain is\nthe empty set. When we’ve covered all the possible types of Shape , this is\nall that’ s left. If we missed a case, then the type would be something other\nthan never :\nfunction processShape(shape: Shape) { \n  switch (shape.type) { \n    case 'box': break; \n    case 'circle': break; \n    // (forgot 'line') \n    default: \n      shape \n      // ^? (parameter) shape: Line \n  }\n}\nNo value is assignable to the never  type, and we can use this to turn an\nomission into a type error:\nfunction assertUnreachable(value: never): never { \n  throw new Error(`Missed a case! ${value}`);\n} \n \nfunction drawShape(shape: Shape, context: CanvasRenderingContext2D) { \n  switch (shape.type) { \n    case 'box': \n      context.rect(...shape.topLeft, ...shape.size); \n      break; \n    case 'circle': \n      context.arc(...shape.center, shape.radius, 0, 2 * Math.PI); \n      break; \n    default: \n      assertUnreachable(shape); \n      //                ~~~~~ \n      // ... type 'Line' is not assignable to parameter of type 'never'. \n  }\n}\nW e’ll get into the details of assertUnreachable  momentarily , but first let’ s\nfix the error by covering the missing case:\nfunction drawShape(shape: Shape, context: CanvasRenderingContext2D) { \n  switch (shape.type) { \n    case 'box': \n      context.rect(...shape.topLeft, ...shape.size); \n      break; \n    case 'circle': \n      context.arc(...shape.center, shape.radius, 0, 2 * Math.PI); \n      break; \n    case 'line': \n      context.moveTo(...shape.start); \n      context.lineTo(...shape.end); \n      break; \n    default: \n      assertUnreachable(shape); // ok \n  }\n}\nIt’ s important to leave the assertUnreachable  call in place, even if it is, as\nthe name suggests, unreachable. It protects you from future errors of\nomission should you introduce additional shapes.\nWhy throw an exception in assertUnreachable ? Isn’ t this code\nunreachable? That may be the case for well-typed T ypeScript, but it’ s\nalways possible that drawShape  will be called from JavaScript, or with an\nany  or other unsound type ( Item 48 ). Throwing an exception protects us\nfrom surprise values at runtime, not just during type checking.\nThe exhaustiveness check was especially helpful for drawShape  because it\ndidn’ t have a return value. It was only run for side ef fects. If your function\ndoes return a value, then  annotating the return type gives you some\nprotection against missing cases:\nfunction getArea(shape: Shape): number { \n  //                            ~~~~~~ Function lacks ending return statement \nand \n  //                                   return type does not include \n'undefined'. \n  switch (shape.type) { \n    case 'box': \n      const [width, height] = shape.size; \n      return width * height; \n    case 'circle': \n      return Math.PI * shape.radius ** 2; \n  }\n}\nIf we’d omitted the return type annotation, T ypeScript would have inferred\nit as number | undefined  rather than producing an error . It’ s likely that\nthis would have produced errors elsewhere in your code, where you call\ngetArea , but it’ s better to get errors close to where the mistake was made.\nAs Item 18  explained, it’ s a good idea to add a return type annotation to any\nfunction with multiple return s.\n(Y ou’ll only get this error  when strictNullChecks  is set, since otherwise,\nundefined  is part of the number  type. This is a great reason to use\nstrictNullChecks !)\nAs the error says, if undefined  is a legitimate return value, then this check\nwon’ t protect you. Even when a function returns a value, it can be a good\nidea to do exhaustiveness checking.\nThat’ s why we added never  as the return type for assertUnreachable\nearlier . Since never  is assignable to all other types, you can safely return it,\nregardless of the return type of the function:\nfunction getArea(shape: Shape): number { \n  switch (shape.type) { \n    case 'box': \n      const [width, height] = shape.size; \n      return width * height; \n    case 'circle': \n      return Math.PI * shape.radius ** 2; \n    case 'line': \n      return 0; \n    default: \n      return assertUnreachable(shape);  // ok \n  }\n}\nThe assertUnreachable  pattern is common in T ypeScript code and you\nmay run into other variations on it, either using a direct assignment to\nnever :\nfunction processShape(shape: Shape) { \n  switch (shape.type) { \n    case 'box': break; \n    case 'circle': break; \n    default: \n      const exhaustiveCheck: never = shape; \n      //    ~~~~~~~~~~~~~~~ Type 'Line' is not assignable to type 'never'. \n      throw new Error(`Missed a case: ${exhaustiveCheck}`); \n  }\n}\nor using the satisfies  operator:\nfunction processShape(shape: Shape) { \n  switch (shape.type) { \n    case 'box': break; \n    case 'circle': break; \n    default: \n      shape satisfies never \n      //    ~~~~~~~~~ Type 'Line' does not satisfy the expected type 'never'. \n      throw new Error(`Missed a case: ${shape}`); \n  }\n}\nAll of these patterns work in the same way . Use whichever one you like\nbest.\nW ith some cleverness, the same trick can be extended to make sure you\nhandle all pairs  of two types, i.e., the cross-product. For example, say you\nwrite some code to play “rock, paper , scissors”:\ntype Play = 'rock' | 'paper' | 'scissors'; \n \nfunction shoot(a: Play, b: Play) { \n  if (a === b) { \n    console.log('draw'); \n  } else if ( \n    (a === 'rock' && b === 'scissors') || \n    (a === 'paper' && b === 'rock') \n  ) { \n    console.log('A wins'); \n  } else { \n    console.log('B wins'); \n  }\n}\nUnfortunately , we’ve missed a case. If A plays scissors on B’ s paper , then,\nmuch to player A ’ s surprise, this function will report that B has won. W e\ncan use a template literal type ( Item 54 ) and exhaustiveness checking to\nforce ourselves to cover every possible case explicitly:\nfunction shoot(a: Play, b: Play) { \n  const pair = `${a},${b}` as `${Play},${Play}`;  // or: as const \n  //    ^? const pair: ""rock,rock"" | ""rock,paper"" | ""rock,scissors"" | \n  //                   ""paper,rock"" | ""paper,paper"" | ""paper,scissors"" | \n  //                   ""scissors,rock"" | ""scissors,paper"" | \n""scissors,scissors"" \n  switch (pair) { \n    case 'rock,rock': \n    case 'paper,paper': \n    case 'scissors,scissors': \n      console.log('draw'); \n      break; \n    case 'rock,scissors': \n    case 'paper,rock': \n      console.log('A wins'); \n      break; \n    case 'rock,paper': \n    case 'paper,scissors': \n    case 'scissors,rock': \n      console.log('B wins'); \n      break; \n    default: \n      assertUnreachable(pair); \n      //                ~~~~ Argument of type ""scissors,paper"" is not \n      //                     assignable to parameter of type 'never'. \n  }\n}\nBy default, `${a},${b}`  would have a type of string .\n`${Play},${Play}`  is a subtype of string  consisting of the nine possible\npairs of plays separated by a comma. W e can apply the usual\nexhaustiveness checking trick to make sure we’ve covered all nine. In this\ncase, we missed one and it resulted in a type error . The error even included\nthe combination we missed! As before, add the missing case and leave the\nassertion in place in case you ever add an additional possible play .\nWhile it comes up less frequently than straightforward exhaustiveness\nchecking, this technique is occasionally helpful for modeling transitions\nbetween states.\nThe typescript-eslint rule switch-exhaustiveness-check  can also be\nused for exhaustiveness checking. Whereas assertUnreachable  is opt-in,\nthe linter rule is opt-out. If you enable it, you may find that some of your\nswitch  statements were not intended to be exhaustive, or that they are\nexhaustive for reasons that are hard to capture in the type system. And you\ncan use assertUnreachable  in other situations that are intended to be\nexhaustive, such as if  statements. But you may find some bugs, too, so the\nlinter rule is worth a try!\nErrors of omission are just as important as errors of commission. Use never\ntypes and the assertUnreachable  trick to let T ypeScript help you avoid\nthem.\nThings to Remember\nUse an assignment to the never  type to ensure that all possible values\nof a type are handled (an “exhaustiveness check”).\nAdd a return type annotation to functions that return from multiple\nbranches. Y ou may still want an explicit exhaustiveness check,\nhowever .",11376
71-Item 60 Know How to Iterate Over Objects.pdf,71-Item 60 Know How to Iterate Over Objects,"Consider using template literal types to ensure that every combination\nof two or more types  is handled.\nI t e m  6 0 :  K n o w  H o w  t o  I t e r a t e  O v e r  O b j e c t s\nThis code runs fine, and yet T ypeScript flags an error in it. Why?\nconst obj = { \n  one: 'uno', \n  two: 'dos', \n  three: 'tres',\n};\nfor (const k in obj) { \n  const v = obj[k]; \n  //        ~~~~~~ Element implicitly has an 'any' type \n  //               because type ... has no index signature\n}\nInspecting the obj  and k  symbols gives a clue:\nconst obj = { one: 'uno', two: 'dos', three: 'tres' };\n//    ^? const obj: {\n//         one: string;\n//         two: string;\n//         three: string;\n//       }\nfor (const k in obj) { \n  //       ^? const k: string \n  // ...\n}\nThe type of k  is string , but you’re trying to index into an object whose\ntype only has three specific keys: 'one' , 'two' , and 'three' . There are\nstrings other than these three, so this has to fail.\nUsing a type assertion to get a narrower type for k  fixes the issue:\nfor (const kStr in obj) { \n  const k = kStr as keyof typeof obj; \n  //    ^? const k: ""one"" | ""two"" | ""three"" \n  const v = obj[k];  // OK\n}\nSo the real question is: why is the type of k  in the first example inferred as\nstring  rather than ""one"" | ""two"" | ""three"" ?\nT o understand, let’ s look at a slightly dif ferent example:\ninterface ABC { \n  a: string; \n  b: string; \n  c: number;\n} \n \nfunction foo(abc: ABC) { \n  for (const k in abc) { \n    //       ^? const k: string \n    const v = abc[k]; \n    //        ~~~~~~ Element implicitly has an 'any' type \n    //               because type 'ABC' has no index signature \n  }\n}\nIt’ s the same error as before. And you can “fix” it using the same sort of\ntype assertion ( k as keyof ABC ). But in this case T ypeScript is right to\ncomplain. Here’ s why:\nconst x = {a: 'a', b: 'b', c: 2, d: new Date()};\nfoo(x);  // OK\nThe function foo  can be called with any value assignable  to ABC , not just a\nvalue with 'a' , 'b' , and 'c'  properties. It’ s entirely possible that the value\nwill have other properties, too (see Item 4  for a refresher on why). T o allow\nfor this, T ypeScript gives k  the only type it can be confident of, namely ,\nstring .1\nUsing a type assertion to keyof ABC  would have another downside here:\nfunction foo(abc: ABC) { \n  for (const kStr in abc) { \n    let k = kStr as keyof ABC; \ny;\n    //  ^? let k: keyof ABC (equivalent to ""a"" | ""b"" | ""c"") \n    const v = abc[k]; \n    //    ^? const v: string | number \n  }\n}\nIf ""a"" | ""b"" | ""c""  is too narrow for k , then string | number  is\ncertainly too narrow for v . In the preceding example, one of the values is a\nDate , but it could be anything. This could lead to chaos at runtime. As Item\n9  explained, type assertions should always make you nervous because\nT ypeScript might be on to something. (Surprisingly , T ypeScript will let you\ndeclare let k: keyof ABC  above this for-in  loop and use k  as the\niterator , but this is no safer than a type assertion and is less explicit.)\nSo what if you just want to iterate over the object’ s keys and values without\ntype errors? Object.entries  lets you iterate over both simultaneously:\nfunction foo(abc: ABC) { \n  for (const [k, v] of Object.entries(abc)) { \n    //        ^? const k: string \n    console.log(v); \n    //          ^? const v: any \n  }\n}\nWhile these types may be hard to work with, they are at least honest!2\nAnother reason that T ypeScript infers string  in for-in  loops is pr ototype\npollution . This is a security issue where properties defined on\nObject.prototype  are inherited by all other objects. These inherited\nproperties will be enumerated by a for-in  loop, so string  is a safer\nchoice. (Object.entries  excludes inherited properties.)\nA safe way to get more precise types is to explicitly list the keys you’re\ninterested in:\nfunction foo(abc: ABC) { \n  const keys = ['a', 'b', 'c'] as const; \n  for (const k of keys) { \n    //       ^? const k: ""a"" | ""b"" | ""c"" \n    const v = abc[k]; \n    //    ^? const v: string | number \n  }\n}\nIf your intention is to cover all the keys in ABC , you’ll need some way to\nkeep the keys  array in sync with the type.\nWhile iterating over objects comes with many hazards, iterating over a Map\ndoes not:\nconst m = new Map([ \n  //  ^? const m: Map<string, string> \n  ['one', 'uno'], \n  ['two', 'dos'], \n  ['three', 'tres'],\n]);\nfor (const [k, v] of m.entries()) { \n  //        ^? const k: string \n  console.log(v); \n  //          ^? const v: string\n}\nMap s are  easier to iterate over because they don’ t have the same structural\nbehavior as objects: you’ll never put a number  value in a Map<string,\nstring>  without using a type assertion or going through an any  type. But\nthey can be less convenient to work with if your data is coming via JSON or\nfrom another API that’ s already designed to use objects. Item 16  has an\nexample of how replacing an object type with a Map  can improve the type\nsafety of your code.\nIf you want to iterate over the keys and values in an immutable object, you\ncan use an explicit type assertion on the key in a for-in  loop. T o safely\niterate over an object that could have additional properties, use\nObject.entries . It’ s always safe, though the key and value types are more\ndif ficult to work with. And consider whether a Map  might be an appropriate\nalternative.",5487
72-Item 61 Use Record Types to Keep Values in Sync.pdf,72-Item 61 Use Record Types to Keep Values in Sync,"Things to Remember\nBe aware that any objects your function receives as parameters might\nhave additional keys.\nUse Object.entries  to iterate over the keys and values of any object.\nUse a for-in  loop with an explicit type assertion to iterate objects\nwhen you know exactly what the keys will be.\nConsider Map  as an alternative to objects since it’ s easier to iterate\nover .\nI t e m  6 1 :  U s e  R e c o r d  T y p e s  t o  K e e p  V a l u e s  i n\nS y n c\nSuppose you’re  writing a UI component for drawing scatter plots. It has a\nfew dif ferent types of properties that control its display and behavior:\ninterface ScatterProps { \n  // The data \n  xs: number[]; \n  ys: number[]; \n \n  // Display \n  xRange: [number, number]; \n  yRange: [number, number]; \n  color: string; \n \n  // Events \n  onClick?: (x: number, y: number, index: number) => void;\n}\nT o avoid unnecessary work, you’d like to redraw the chart only when you\nneed to. Changing data or display properties will require a redraw , but\nchanging the event handler will not.\nHere’ s one way you might implement this optimization:\nfunction shouldUpdate( \n  oldProps: ScatterProps, \n  newProps: ScatterProps\n) { \n  for (const kStr in oldProps) { \n    const k = kStr as keyof ScatterProps; \n    if (oldProps[k] !== newProps[k]) { \n      if (k !== 'onClick') return true; \n    } \n  } \n  return false;\n}\n(See Item 60  for an explanation of the keyof  assertion in this loop. This\nassertion is safe because we don’ t care about the value types, only whether\nthey are equal.)\nWhat happens when you or a coworker add a new property? The\nshouldUpdate  function will redraw the chart whenever it changes. Y ou\nmight call this the conservative or “fail open” approach. The upside is that\nthe chart will always look right. The downside is that it might be drawn too\noften.\nA “fail closed” approach might look like this:\nfunction shouldUpdate( \n  oldProps: ScatterProps, \n  newProps: ScatterProps\n) { \n  return ( \n    oldProps.xs !== newProps.xs || \n    oldProps.ys !== newProps.ys || \n    oldProps.xRange !== newProps.xRange || \n    oldProps.yRange !== newProps.yRange || \n    oldProps.color !== newProps.color \n    // (no check for onClick) \n  );\n}\nW ith this approach there won’ t be any unnecessary redraws, but there might\nbe some necessary  draws that get dropped. An important principle in\noptimization is to “first, do no harm.” W e shouldn’ t sacrifice correct\nbehavior for the sake of performance.\nNeither approach is ideal. What you’d really like is to force your coworker\nor future self to make a decision when adding the new property . Y ou might\ntry adding a comment:\ninterface ScatterProps { \n  xs: number[]; \n  ys: number[]; \n  // ... \n  onClick?: (x: number, y: number, index: number) => void; \n \n  // Note: if you add a property here, update shouldUpdate!\n}\nBut do you really expect this to work? It would be better if the type checker\ncould enforce this for you.\nIf you set it up the right way , it can. The key is to use a Record  type with\nthe right set of keys:\nconst REQUIRES_UPDATE: Record<keyof ScatterProps, boolean> = { \n  xs: true, \n  ys: true, \n  xRange: true, \n  yRange: true, \n  color: true, \n  onClick: false,\n}; \n \nfunction shouldUpdate( \n  oldProps: ScatterProps, \n  newProps: ScatterProps\n) { \n  for (const kStr in oldProps) { \n    const k = kStr as keyof ScatterProps; \n    if (oldProps[k] !== newProps[k] && REQUIRES_UPDATE[k]) { \n      return true; \n    } \n  } \n  return false;\n}\nThe keyof ScatterProps  annotation tells the type checker that\nREQUIRES_UPDATE  should have all the same properties as ScatterProps .\nCritically , these are all required properties.\nNow if in the future you add a new property to ScatterProps :\ninterface ScatterProps { \n  // ... \n  onDoubleClick?: () => void;\n}\nthen this will produce an error in the definition of REQUIRES_UPDATE :\nconst REQUIRES_UPDATE: Record<keyof ScatterProps, boolean> = { \n  //  ~~~~~~~~~~~~~~~ Property 'onDoubleClick' is missing in type ... \n  // ...\n};\nThis will certainly force the issue! Deleting or renaming a property will\ncause a similar error . This is excess property checking ( Item 1 1 ) at work,\nand it lets us enforce that the object has exactly the set of properties we\nwant, no more, no less. T ypeScript has given us a third choice in the classic\nfail open/fail closed dilemma, namely “just fail.”\nIt’ s important that we used an object with boolean values here. Had we used\nan array:\nconst PROPS_REQUIRING_UPDATE: (keyof ScatterProps)[] = [ \n  'xs', \n  'ys', \n  // ...\n];\nthen we would have been forced into the same fail open/fail closed choice.\nRecords and mapped types are ideal if you want one object to have exactly\nthe same properties as another . Here we used it to avoid the classic fail\nopen/fail closed dilemma, but there are many other applications, for",4954
73-Item 62 Use Rest Parameters and Tuple Types to Model Variadic Functions.pdf,73-Item 62 Use Rest Parameters and Tuple Types to Model Variadic Functions,"example, requiring that every property in your application’ s state have a\ncorresponding URL parameter .\nThings to Remember\nRecognize the fail open versus fail closed dilemma.\nUse Record  types to keep related values and types synchronized.\nConsider using Record  types to force choices when adding new\nproperties to an interface.\nI t e m  6 2 :  U s e  R e s t  P a r a m e t e r s  a n d  T u p l e\nT y p e s  t o  M o d e l  V a r i a d i c  F u n c t i o n s\nSometimes you’d like to have a function take a dif ferent number of\nar guments, depending on a T ypeScript type.\nT o see how this might happen, imagine that you have an interface that\ndescribes the query parameters that dif ferent routes in a web app can accept:\ninterface RouteQueryParams { \n  '/': null, \n  '/search': { query: string; language?: string; } \n  // ...\n}\nThis says that the root page ( / ) does not take any query parameters,\nwhereas the /search  page takes a query  param and an optional language\nparam.\nY ou can define a function to construct a URL for a route:\nfunction buildURL(route: keyof RouteQueryParams, params?: any) { \n  return route + (params ? `?${new URLSearchParams(params)}` : '');\n} \n \nconsole.log(buildURL('/search', {query: 'do a barrel roll', language: 'en'}))\nconsole.log(buildURL('/'))\nThis builds the URLs you’d expect:\n/search?query=do+a+barrel+roll&language=en \n/\nUnfortunately , it’ s not very safe thanks to that any  on the second parameter .\nY ou’re free to construct a URL for any route with whatever search\nparameters you like:\nbuildURL('/', {query: 'recursion'});  // should be an error (no params for \nroot)\nbuildURL('/search');  // should be an error (missing params)\nHere’ s a safer version:\nfunction buildURL<Path extends keyof RouteQueryParams>( \n  route: Path, \n  params: RouteQueryParams[Path]\n) { \n  return route + (params ? `?${new URLSearchParams(params)}` : '');\n}\nW e’ve made the function generic in the route, which can usually be\ninferred, and made the parameter type depend on this route.\nThis new type signature works perfectly for the /search  route:\nbuildURL('/search', {query: 'do a barrel roll'})\nbuildURL('/search', {query: 'do a barrel roll', language: 'en'})\nbuildURL('/search', {})\n//                  ~~ Property 'query' is missing in type '{}'\nFor the root page, however , you need to pass an additional null  parameter:\nbuildURL('/', {query: 'recursion'});  // error, good!\n//            ~~~~~~~~~~~~~~~~~~~~ Argument of type '{ query: string; }' is\n//                                 not assignable to parameter of type 'null'\nbuildURL('/', null);  // ok\nbuildURL('/');  // we'd like this to be allowed\n// ~~~~~ Expected 2 arguments, but got 1.\nW riting an extra null  isn’ t the end of the world, of course, but it is a\nnuisance and the old API with its optional parameter looked nicer . W e could\nmake the second parameter optional with the new version, but this should\nonly be allowed when the route doesn’ t take any search parameters. In other\nwords, we want the function to take a variable number of ar guments,\ndepending on an inferred type.\nThe trick to doing this is to use a conditional type ( Item 52 ) and rest\nparameters:\nfunction buildURL<Path extends keyof RouteQueryParams>( \n  route: Path, \n  ...args: ( \n      RouteQueryParams[Path] extends null \n      ? [] \n      : [params: RouteQueryParams[Path]] \n    )\n) { \n  const params = args ? args[0] : null; \n  return route + (params ? `?${new URLSearchParams(params)}` : '');\n}\nIf the query parameter type extends null , then this looks like: (route:\nPath, ...args: []) , which is a one-parameter function. If it doesn’ t, then\nit looks like (route: Path, ...args: [params: ...]) , which is a two-\nparameter function.\nThis works exactly as you’d hope:\nbuildURL('/search', {query: 'do a barrel roll'})\nbuildURL('/search', {query: 'do a barrel roll', language: 'en'})\nbuildURL('/search', {})\n//                  ~~ Property 'query' is missing in type '{}' ... \n \nbuildURL('/', {query: 'recursion'});\n//            ~~~~~~~~~~~~~~~~~~~~ Expected 1 arguments, but got 2.\nbuildURL('/', null);\n//            ~~~~ Expected 1 arguments, but got 2.\nbuildURL('/');  // ok\nWhen you inspect the call sites, it really looks like there are two dif ferent\nfunctions, depending on the route. The rest parameter is an implementation\ndetail that’ s hidden from the user . T ypeScript has even picked up the name\nof the second parameter (params )  from the label on the tuple element:\nbuildURL('/');\n// ^? function buildURL<""/"">(route: ""/""): string\nbuildURL('/search', {query: 'do a barrel roll'})\n// ^? function buildURL<""/search"">(\n//      route: ""/search"", params: { query: string; language?: string; }\n//    ): string\nIf you fail to include this label, your users will see a more generic parameter\nname like args_0 .\nThis is the most general technique for modeling variadic functions. Y ou\ncould also use overload signatures to achieve a similar ef fect, but this would\nresult in code duplication and, as Item 52  explained, conditional types\nhandle unions more naturally than overloads.\nSometimes the number or type of parameters to a function depends on a\nT ypeScript type. When this happens, you can model it using rest parameters\nwith a tuple type.\nThings to Remember\nUse rest parameters and tuple types to model functions whose\nsignature depends on the type of an ar gument.\nUse conditional types to model relationships between the type of one\nparameter and the number and type of the remaining parameters.\nRemember to label the elements of your tuple types to get meaningful\nparameter names at call sites.",5713
74-Item 63 Use Optional Never Properties to Model Exclusive Or.pdf,74-Item 63 Use Optional Never Properties to Model Exclusive Or,"I t e m  6 3 :  U s e  O p t i o n a l  N e v e r  P r o p e r t i e s  t o\nM o d e l  E x c l u s i v e  O r\nIn ordinary speech, “or” means “exclusive or .” Only programmers and\nlogicians use an inclusive  or .\nIn T ypeScript, it’ s easy to get mixed up between these two:\ninterface ThingOne { \n  shirtColor: string;\n}\ninterface ThingTwo { \n  hairColor: string;\n}\ntype Thing = ThingOne | ThingTwo;\nW e usually read the last line as “type Thing  is a ThingOne  or ThingTwo .”\nBut just like JavaScript’ s runtime or ( || ), T ypeScript’ s type-level or ( | ) is\nan inclusive  or . There’ s no reason a thing can’ t be both a ThingOne  and  a\nThingTwo :\nconst bothThings = { \n  shirtColor: 'red', \n  hairColor: 'blue',\n};\nconst thing1: ThingOne = bothThings;  // ok\nconst thing2: ThingTwo = bothThings;  // ok\nWhy does this work? It’ s because T ypeScript has a structural type system\n( Item 4 ). Both the ThingOne  and ThingTwo  types allow additional\nproperties that aren’ t declared in their interface, though, as Item 1 1\nexplains, this is sometimes obscured by excess property checking.\nSo what if you really do want an exclusive or? What if you want to keep\nyour ThingOne s  and ThingTwo s separate? How can you model that?\nThe standard trick is to use an optional never  type in your interface to\ndisallow a property:\ninterface OnlyThingOne { \n  shirtColor: string; \n  hairColor?: never;\n}\ninterface OnlyThingTwo { \n  hairColor: string; \n  shirtColor?: never;\n}\ntype ExclusiveThing = OnlyThingOne | OnlyThingTwo;\nNow none of the assignments from before pass the type checker:\nconst thing1: OnlyThingOne = bothThings;\n//    ~~~~~~ Types of property 'hairColor' are incompatible.\nconst thing2: OnlyThingTwo = bothThings;\n//    ~~~~~~ Types of property 'shirtColor' are incompatible.\nconst allThings: ExclusiveThing = { \n  //  ~~~~~~~~~ Types of property 'hairColor' are incompatible. \n  shirtColor: 'red', \n  hairColor: 'blue',\n};\nThis works because no value is assignable to a never  type. But because the\nproperty is optional , there’ s exactly one way out: not having that property .\nThis isn’ t just useful for unions. Recall from Item 4  that structural typing\nisn’ t a good model for two- and three-dimensional vectors. Y ou can use an\noptional never  to directly disallow a z  property on a 2D vector:\ninterface Vector2D { \n  x: number; \n  y: number; \n  z?: never;\n}\nW ith this type, you’ll get an error if you accidentally pass a three-\ndimensional vector to a function like norm  that expects a two-dimensional\nvector:\nfunction norm(v: Vector2D) { \n  return Math.sqrt(v.x ** 2 + v.y ** 2);\n}\nconst v = {x: 3, y: 4, z: 5};\nconst d = norm(v);\n//             ~ Types of property 'z' are incompatible.\nThis wouldn’ t be an error without the z?: never  because the call is\nstructurally valid, even though it’ s semantically incorrect. W e’ll look at\nanother approach to fixing the Vector2D  problem, brands, in Item 64 .\nY ou can also use a tagged union ( Item 34 ) to achieve an exclusive or:\ninterface ThingOneTag { \n  type: 'one'; \n  shirtColor: string;\n}\ninterface ThingTwoTag { \n  type: 'two'; \n  hairColor: string;\n}\ntype Thing = ThingOneTag | ThingTwoTag;\nA string can’ t be both 'one'  and  'two' , so there’ s no overlap between\nthese types. This means there’ s no distinction between inclusive and\nexclusive or . This is one of many great reasons to use tagged unions when\nyou can.\nRather than adding optional never  properties by hand, it’ s possible to\ndefine a generic exclusive or ( XOR ) helper:\ntype XOR<T1, T2> = \n    (T1 & {[k in Exclude<keyof T2, keyof T1>]?: never}) | \n    (T2 & {[k in Exclude<keyof T1, keyof T2>]?: never});\nY ou can use this to construct ExclusiveThing  directly from the\ninterface s at the start of this item:\ntype ExclusiveThing = XOR<ThingOne, ThingTwo>;\nconst allThings: ExclusiveThing = { \n  //  ~~~~~~~~~ Types of property 'hairColor' are incompatible. \n  shirtColor: 'red', \n  hairColor: 'blue',\n};",4049
75-Item 64 Consider Brands for Nominal Typing.pdf,75-Item 64 Consider Brands for Nominal Typing,"While tagged unions are a more common way to create exclusive types in\nT ypeScript, the optional never  trick can be helpful in situations where you\neither can’ t or don’ t want to add an explicit tag.\nThings to Remember\nIn T ypeScript, “or” is “inclusive or”: A | B  means either A , B , or both.\nConsider the “both” possibility in your code, and either handle it or\ndisallow it.\nUse tagged unions to model exclusive or where it’ s convenient.\nConsider using optional never  properties where it isn’ t.\nI t e m  6 4 :  C o n s i d e r  B r a n d s  f o r  N o m i n a l  T y p i n g\nItem 4  discussed structural typing and how it can sometimes lead to\nsurprising results:\ninterface Vector2D { \n  x: number; \n  y: number;\n}\nfunction calculateNorm(p: Vector2D) { \n  return Math.sqrt(p.x ** 2 + p.y ** 2);\n} \n \ncalculateNorm({x: 3, y: 4});  // OK, result is 5\nconst vec3D = {x: 3, y: 4, z: 1};\ncalculateNorm(vec3D);  // OK! result is also 5\nWhat if you’d like calculateNorm  to reject 3D vectors? This goes against\nthe structural typing model of T ypeScript but is certainly more\nmathematically correct.\nItem 63  showed how you can specifically prevent a z  field using an optional\nnever  property . This is a purely type-level fix. It doesn’ t require you to\nchange the values at runtime.\nY ou can also prevent types from being assignable to one another by adding\na “tag” to the value at runtime:\ninterface Vector2D { \n  type: '2d'; \n  x: number; \n  y: number;\n}\nHere the type  property serves as the “tag.” This pattern is particularly\ncommon with union types. Item 34  explored “tagged unions” in more detail\nand they are certainly one way to mitigate this problem. They do have a few\ndownsides, however . They add runtime overhead, changing what was\npreviously a very simple type with only numeric properties into one with a\nmix of strings and numbers. Moreover , you can only add an explicit tag like\nthis to object types.\nInterestingly , you can get many of the same benefits as explicit tags while\noperating only in the type system. In this context, tags are typically known\nas “brands” (think cows, not Coca-Cola). This types-only approach removes\nruntime overhead and also lets you brand built-in types like string  or\nnumber  where you can’ t attach additional properties. This is known as\nnominal typing , as opposed to T ypeScript’ s usual structural typing. W ith\nnominal typing, a value is a Vector2D  because you say it is, not because it\nhas the right shape.\nLet’ s see how this works using filesystem paths. What if you have a\nfunction that operates on the filesystem and requires an absolute (as\nopposed to a relative) path? This is easy to check at runtime (does the path\nstart with “/”?), but not so easy in the type system.\nHere’ s an approach with brands:\ntype AbsolutePath = string & {_brand: 'abs'};\nfunction listAbsolutePath(path: AbsolutePath) { \n  // ...\n}\nfunction isAbsolutePath(path: string): path is AbsolutePath { \n  return path.startsWith('/');\n}\nY ou can’ t construct an object that is a string  and has a _brand  property .\nThis is purely a game with the type system. (If you think you can assign\nproperties to a string , Item 10  will explain why you’re mistaken.)\nIf you have a string  path that could be either absolute or relative, you can\ncheck using the type guard, which will refine its type:\nfunction f(path: string) { \n  if (isAbsolutePath(path)) { \n    listAbsolutePath(path); \n  } \n  listAbsolutePath(path); \n  //               ~~~~ Argument of type 'string' is not assignable to \n  //                    parameter of type 'AbsolutePath'\n}\nThis is helpful documentation about which functions expect absolute or\nrelative paths, and which type of path each variable holds. It is not an\nironclad guarantee: path as AbsolutePath  will succeed for any string .\nBut if you avoid these sorts of assertions, then the only way to get an\nAbsolutePath  is to be given one or to check, which is exactly what you\nwant.\nY ou can also brand number  types—for example, to attach units:\ntype Meters = number & {_brand: 'meters'};\ntype Seconds = number & {_brand: 'seconds'}; \n \nconst meters = (m: number) => m as Meters;\nconst seconds = (s: number) => s as Seconds; \n \nconst oneKm = meters(1000);\n//    ^? const oneKm: Meters\nconst oneMin = seconds(60);\n//    ^? const oneMin: Seconds\nThis can be awkward in practice, however , since arithmetic operations\nmake the numbers for get their brands:\nconst tenKm = oneKm * 10;\n//    ^? const tenKm: number\nconst v = oneKm / oneMin;\n//    ^? const v: number\nIf your code involves lots of numbers with mixed units, though, this may\nstill be an attractive approach to documenting the expected types of numeric\nparameters.\nThere are other techniques for branding types. Y ou may encounter code that\nuses private fields to brand classes or an intersection with T ypeScript string-\nbased enums, which are nominally typed ( Item 72 ).\nAnother common technique is to use  a unique symbol  type:\ndeclare const brand: unique symbol;\nexport type Meters = number & {[brand]: 'meters'};\nThe advantage of this technique is that, since the brand  symbol isn’ t\nexported, users will have to use a type assertion or helper function to get a\nvalue with a Meters  type. They can’ t use the brand directly or create\nanother type that’ s compatible with it.\nRegardless of how you construct them, brands can be used to model many\nproperties that cannot be expressed within the type system. For example,\nusing binary search to find an element in a list:\nfunction binarySearch<T>(xs: T[], x: T): boolean { \n  let low = 0, high = xs.length - 1; \n  while (high >= low) { \n    const mid = low + Math.floor((high - low) / 2); \n    const v = xs[mid]; \n    if (v === x) return true; \n    [low, high] = x > v ? [mid + 1, high] : [low, mid - 1]; \n  } \n  return false;\n}\nThis works if the list is sorted, but will result in false negatives if it is not.\nY ou can’ t represent a sorted list in T ypeScript’ s type system. But you can\ncreate a brand:\ntype SortedList<T> = T[] & {_brand: 'sorted'}; \n \nfunction isSorted<T>(xs: T[]): xs is SortedList<T> { \n  for (let i = 0; i < xs.length - 1; i++) { \n    if (xs[i] > xs[i + 1]) { \n      return false; \n    } \n  } \n  return true;\n} \n \nfunction binarySearch<T>(xs: SortedList<T>, x: T): boolean { \n  // ...\n}\nT o call this version of binarySearch , you either need to be given a\nSortedList  (i.e., have proof that the list is sorted) or prove that it’ s sorted\nyourself using isSorted . The linear scan isn’ t great, but at least you’ll be\nsafe!\nThis is a helpful perspective to have on the type checker in general. T o call\na method on an object, for instance, you either need to be given a non- null\nobject or prove that it’ s non-null  yourself with a conditional. This is\nanalogous to the two ways of getting a SortedList : you can either be given\none, or prove that the list is sorted yourself.\nThings to Remember\nW ith nominal typing, a value has a type because you say it has a type,\nnot because it has the same shape as that type.\nConsider attaching brands to distinguish primitive and object types that\nare semantically distinct but structurally identical.\nBe familiar with the various techniques for branding: properties on\nobject types, string-based enums, private fields, and unique symbols.\n1 Symbols can also be object keys but they are not enumerable.\n2 The typings for utility functions like Lodash’ s _.forEach  and may provide more precise\ntypes for k  and v , but these are unsound for the reasons mentioned in this item.",7683
76-8. Type Declarations and types.pdf,76-8. Type Declarations and types,,0
77-Item 65 Put TypeScript and types in devDependencies.pdf,77-Item 65 Put TypeScript and types in devDependencies,"Chapter 8. T ype Declarations\nand @types\nDependency management can be confusing in any language, and T ypeScript\nis no exception. In fact, because types are often shipped as separate\npackages, dependencies in T ypeScript can be especially bewildering.\nThis chapter will help you build a mental model for how dependencies\nwork in T ypeScript and show you how to sort through some of the issues\nthat can come up with them. It will also help you craft your own type\ndeclaration files to publish and share with others. By writing great type\ndeclarations, you can help not just your own project but the entire\nT ypeScript community .\nI t e m  6 5 :  P u t  T y p e S c r i p t  a n d  @ t y p e s  i n\nd e v D e p e n d e n c i e s\nThe Node Package Manager , npm, is ubiquitous in the JavaScript world. It\nprovides both a repository of JavaScript libraries (the npm registry) and a\nway to specify which versions of them you depend on ( package.json ).\nnpm draws a distinction between a few types of dependencies, each of\nwhich goes in a separate section of package.json :\ndependencies\nThese are packages that are required to run your JavaScript. If you\nimport lodash  at runtime, then it should go in dependencies . When\nyou publish your code on npm and another user installs it, it will also\ninstall these dependencies. (These are known as transitive\ndependencies.)\ndevDependencies\nThese packages are used to develop and test your code but are not\nrequired at runtime. Y our test framework is an example of a\ndevDependency . Unlike dependencies , these are not  installed\ntransitively with your packages.\npeerDependencies\nThese are packages that you require at runtime but don’ t want to be\nresponsible for tracking. If you publish a React component, for\nexample, it will be compatible with a range of versions of React itself.\nY ou’d prefer that the user select one, rather than you choosing for them,\nwhich could result in multiple versions of React running on the same\npage.\nOf these, dependencies  and devDependencies  are by far the most\ncommon. As you use T ypeScript, be aware of which type of dependency\nyou’re adding. Because T ypeScript is a development tool and T ypeScript\ntypes do not exist at runtime ( Item 3 ), packages related to T ypeScript\ngenerally belong in devDependencies .\nThe first dependency to consider is T ypeScript itself. While you can install\nT ypeScript system-wide, this is a bad idea for two main reasons:\nThere’ s no guarantee that you and your coworkers will always have the\nsame version installed.\nIt adds a step to your project setup.\nMake T ypeScript a devDependency  instead. That way you and your\ncoworkers will always get the correct version when you run npm install .\nY ou update T ypeScript the same way you’d update any other package.\nY our IDE and build tools will happily discover a version of T ypeScript\ninstalled in this way . On the command line, for example, you can use npx  to\nrun the version of tsc  installed by npm:\n$ npx tsc\nThe next type of dependency to consider is type dependencies  or @types . If\na library itself does not come with T ypeScript type declarations, then you\nmay still be able to find typings on  DefinitelyT yped, a community-\nmaintained collection of type definitions for JavaScript libraries. T ype\ndefinitions from DefinitelyT yped are published on the npm registry under\nthe @types  scope: @types/jquery  has type definitions for jQuery ,\n@types/lodash  has types for Lodash, and so on. These @types  packages\nonly contain the types . They don’ t contain the implementation.\nY our @types  dependencies should also be devDependencies , even if the\npackage itself is a direct dependency . For example, to depend on React and\nits type declarations, you might run:\n$ npm install react\n$ npm install --save-dev @types/react\nThis will result in a package.json  file that looks something like this:\n{\n  ""devDependencies"": {\n    ""@types/react"": ""^18.2.23"",\n    ""typescript"": ""^5.2.2""\n  },\n  ""dependencies"": {\n    ""react"": ""^18.2.0""\n  }\n}\nThe idea here is that you should publish JavaScript, not T ypeScript, and\nyour JavaScript does not depend on the @types  when you run it.\n(T ypeScript users might depend on these @types , but transitive types\ndependencies are best avoided. Item 70  will show you how .)\nWhat if you’re building a web app, with no intentions to ever publish it as a\nlibrary on npm?  Y ou may find advice to the ef fect that it’ s not worth\nseparating out devDependencies  in this situation, and that you may as well\njust make everything a prod dependency . Even for a web app, though,\nputting @types  in devDependencies  has a few advantages:",4717
78-Item 66 Understand the Three Versions Involved in Type Declarations.pdf,78-Item 66 Understand the Three Versions Involved in Type Declarations,"If your app has a server component, you can run npm install --\nproduction  to only install prod dependencies in your production\nimage. Assuming you’ve compiled your T ypeScript to JavaScript\nalready , these will be the only dependencies you need to run your\ncode. This will result in a slimmer image that spins up more quickly .\nIf you’re using an automated dependency update tool (such as\nRenovate or Dependabot), you can tell it to prioritize production\ndependencies. These are the ones that are more likely to have\nimportant security updates that could af fect end users of your code,\nand these are the ones that you should focus on.\nThere are a few things that can go wrong with @types  dependencies, and\nthe next item will delve deeper into this topic.\nThings to Remember\nUnderstand the dif ference between dependencies  and\ndevDependencies  in package.json .\nPut T ypeScript in your project’ s devDependencies . Don’ t install\nT ypeScript system-wide.\nPut @types  dependencies  in devDependencies , not dependencies .\nI t e m  6 6 :  U n d e r s t a n d  t h e  T h r e e  V e r s i o n s\nI n v o l v e d  i n  T y p e  D e c l a r a t i o n s\nDependency management  rarely conjures up happy feelings for software\ndevelopers. Usually , you just want to use a library and not think too much\nabout whether its transitive dependencies are compatible with yours.\nThe bad news is that T ypeScript doesn’ t make this any better . In fact, it can\nmake dependency management quite a bit mor e  complicated. This is\nbecause instead of having a single version to worry about, you now have up\nto three:\nThe version of the package\nThe version of its type declarations ( @types )\nThe version of T ypeScript\nIf any of these versions get out of sync with one another , you can run into\nerrors that may not be clearly related to dependency management. But as\nthe saying goes, “make things as simple as possible, but no simpler .”\nUnderstanding the full complexity of T ypeScript package management will\nhelp you diagnose and fix problems. And it will help you make more\ninformed decisions when it comes time to publish type declarations of your\nown.\nHere’ s how dependencies in T ypeScript are supposed to work. Y ou install a\npackage as a direct dependency , and you install its types as a dev\ndependency (see Item 65 ):\n$ npm install react \n+ react@18.2.0 \n \n$ npm install --save-dev @types/react \n+ @types/react@18.2.23\nNote that the major and minor versions ( 18.2 ) match but the patch versions\n(.0  and .23 ) do not. This is exactly what you want to see. The 18.2  in the\n@types  version means that these type declarations describe the API of\nversion 18.2  of react . Assuming the react  module follows good semantic\nversioning hygiene, the patch versions ( 18.2.1 , 18.2.2 , … ) will not\nchange its public API and will not require updates to the type declarations.\nBut the type declarations themselves  might have bugs or omissions. The\npatch versions of the @types  module correspond to these sorts of fixes and\nadditions. In this case, there were many more updates to the type\ndeclarations than the library itself (23 versus 0).\nV ersion matching can go wrong in a few ways.\nFirst, you might update a library but for get to update its type declarations.\nThis often happens as a result of automatic dependency updating tools such\nas Dependabot. In this case you’ll get type errors whenever you try to use\nnew features of the library . If there were breaking changes to the library ,\nyou might get runtime errors despite your code passing the type checker .\nThe solution is usually to update your type declarations so that the versions\nare back in sync. If the type declarations have not been updated, you have a\nfew options. Y ou can use an augmentation in your own project to add new\nfunctions and methods that you’d like to use ( Item 71  shows you how). Or\nyou can contribute updated type declarations back to the community .\nSecond, your type declarations might get ahead of your library . This can\nhappen if you’ve been using a library without its typings (perhaps you gave\nit an any  type using declare module ) and try to install them later . If there\nhave been new releases of the library and its type declarations, your\nversions might be out of sync. The symptoms of this are similar to the first\nproblem, just in reverse. The type checker will be comparing your code\nagainst the latest API, while you’ll be using an older one at runtime. The\nsolution is to either upgrade the library or downgrade the type declarations\nuntil they match.\nThird, the type declarations might require a newer version of T ypeScript\nthan you’re using in your project. Much of the development of T ypeScript’ s\ntype system has been motivated by an attempt to more precisely type\npopular JavaScript libraries like Lodash, React, and Ramda. It makes sense\nthat the type declarations for these libraries would want to use the latest and\ngreatest features to get you better type safety .\nY ou’ll experience this problem as type errors in the @types  declarations\nthemselves. The solution is to do one of the following: upgrade your\nT ypeScript version, use an older version of the type declarations, or , if you\nreally can’ t update T ypeScript, stub out the types with declare module . It\nis possible for a library to provide dif ferent type declarations for dif ferent\nversions of T ypeScript via typesVersions . This is rare (well under 1% of\npackages on DefinitelyT yped do so), but you may encounter it in widely\nused typings like @types/node  and @types/react .\nT o install @types  for a specific version of T ypeScript, you can use:\nnpm install --save-dev @types/react@ts4.9\nThe version matching between libraries and their types is best ef fort and\nmay not always be correct. But the more popular the library is, the more\nlikely it is that its type declarations will get this right.\nFourth, you can wind up with duplicate @types  dependencies. Say you\ndepend on @types/foo  and @types/bar . If @types/bar  depends on an\nincompatible version of @types/foo , then npm will attempt to resolve this\nby installing both versions, one in a nested folder:\nnode_modules/ \n  @types/ \n    foo/ \n      index.d.ts @1.2.3 \n    bar/ \n      index.d.ts \n      node_modules/ \n        @types/ \n          foo/ \n            index.d.ts @2.3.4\nWhile this is sometimes OK for node modules that are used at runtime, it\nalmost certainly won’ t be OK for type declarations, which live in a flat\nglobal namespace. Y ou’ll see this as errors about duplicate declarations or\ndeclarations that cannot be mer ged. Y ou can track down why you have a\nduplicate type declaration by running npm ls @types/foo . The solution is\ntypically to update your dependency on @types/foo  or @types/bar  so that\nthey are compatible.\nT ransitive @types  dependencies like these are often a source of trouble. If\nyou’re publishing types, see Item 70  for a way to avoid them. If you have a\nlar ge number of duplicated type declarations, it can even become a\nperformance issue for the T ypeScript compiler . Item 78  dives into this topic\nin more detail.\nSome packages, particularly those written in T ypeScript, choose  to bundle\ntheir own type declarations. This is usually indicated by a ""types""  field in\ntheir package.json  which points to a .d.ts  file:\n{\n  ""name"": ""left-pad"",\n  ""version"": ""1.3.0"",\n  ""description"": ""String left pad"",\n  ""main"": ""index.js"",\n  ""types"": ""index.d.ts""\n  // ...\n}\nDoes this solve all our problems? W ould I even be asking if the answer was\n“yes”?\nBundling types does  solve the problem of version mismatch, particularly if\nthe library itself is written in T ypeScript and the type declarations are\ngenerated by tsc  (with the declaration  setting). But bundling has some\nproblems of its own.\nFirst, what if there’ s an error in the bundled types that can’ t be fixed\nthrough augmentation ( Item 71 )? Or the types worked fine when they were\npublished, but a new T ypeScript version has since been released which flags\nan error . W ith @types , you could depend on the library’ s implementation\nbut not its type declarations. But with bundled types, you lose this option.\nOne bad type declaration might keep you stuck on an old version of\nT ypeScript. Contrast this with DefinitelyT yped: as T ypeScript is developed,\nMicrosoft runs it against all the type declarations on DefinitelyT yped.\nBreaks are fixed quickly .\nSecond, what if your types depend on another library’ s type declarations?\nUsually , this would be a devDependency  ( Item 65 ). But if you publish your\nmodule and another user installs it, they won’ t get your devDependencies .\nT ype errors will result. On the other hand, you probably don’ t want to make\nit a direct dependency either , since then your JavaScript users will install\n@types  modules for no reason. Item 70  discusses the standard workaround\nfor this situation. But if you publish your types on DefinitelyT yped, this is\nnot a problem at all: you declare your type dependency there, and only your\nT ypeScript users will get it.\nSome projects adopt a hybrid solution of publishing their T ypeScript types\nas a separate package. This keeps you in control of your own code while\nstill allowing you to cleanly separate the implementation and type\ndependency trees.\nThird, what if you need to fix an issue with the type declarations of an old\nversion of your library? W ould you be able to go back and release a patch\nupdate? DefinitelyT yped has mechanisms for simultaneously maintaining\ntype declarations for dif ferent versions of the same library , something that\nmight be hard for you to do in your own project.\nFourth, how committed are you to accepting patches for type declarations?\nRemember , the versions  of react  and @types/react  from the start of this\nitem. There were far more patch updates to the type declarations than the\nlibrary itself. DefinitelyT yped is community maintained and is able to\nhandle this volume. In particular , if a library maintainer doesn’ t look at a\npatch within five days, a global maintainer will. Can you commit to a\nsimilar turnaround time for your library?\nManaging dependencies in T ypeScript can be challenging, but it does come\nwith rewards: well-written type declarations can help you learn how to use\nlibraries correctly and can greatly improve your productivity with them. As\nyou run into issues with dependency management, keep the three versions\nin mind.\nIf you are publishing packages, weigh the pros and cons of bundling type\ndeclarations versus publishing them on DefinitelyT yped. The of ficial\nrecommendation is to bundle type declarations only if the library is written\nin T ypeScript. This works well in practice since tsc  can automatically\ngenerate type declarations for you (by using the declaration  compiler\noption). For JavaScript libraries, handcrafted type declarations are more",11032
79-Item 68 Use TSDoc for API Comments.pdf,79-Item 68 Use TSDoc for API Comments,"likely to contain errors, and they’ll require more updates. If you publish\nyour type declarations on DefinitelyT yped, the community will help you\nsupport and maintain them.\nThings to Remember\nThere are three versions involved in an @types  dependency: the\nlibrary version, the @types  version, and the T ypeScript version.\nRecognize the symptoms of dif ferent types of version mismatch.\nIf you update a library , make sure you update the corresponding\n@types .\nUnderstand the pros and cons of bundling types versus publishing\nthem on DefinitelyT yped.  Prefer bundling types if your library is\nwritten in T ypeScript, and DefinitelyT yped if it is not.\nI t e m  6 7 :  E x p o r t  A l l  T y p e s  T h a t  A p p e a r  i n\nP u b l i c  A P I s\nUse T ypeScript long enough and you’ll eventually find yourself wanting to\nuse a type  or interface  from a third-party library , only to find that it isn’ t\nexported. This is just a nuisance for library users. As you’ll see, any type\nthat’ s part of a public API is ef fectively exported anyway , even if not\nexplicitly . As a library author , this means that you ought to just export your\ntypes to begin with as a convenience to your users.\nSuppose you want to create some private, unexported types:\ninterface SecretName { \n  first: string; \n  last: string;\n} \n \ninterface SecretSanta { \n  name: SecretName; \n  gift: string;\ngg;\n} \n \nexport function getGift(name: SecretName, gift: string): SecretSanta { \n  // ...\n}\nAs a user of your module, I cannot directly import SecretName  or\nSecretSanta , only getGift . But this is more an annoyance than a firm\nbarrier: because those types appear in an exported function signature, I can\nextract them. One way is to use the Parameters  and ReturnType  generic\ntypes:\ntype MySanta = ReturnType<typeof getGift>;\n//   ^? type MySanta = SecretSanta\ntype MyName = Parameters<typeof getGift>[0];\n//   ^? type MyName = SecretName\nIf your goal in not exporting these types was to preserve flexibility , then the\njig is up! Y ou’ve already committed to them by putting them in a public\nAPI. Do your users a favor and export them.\nThings to Remember\nExport types that appear in any form in any public method. Y our users\nwill be able to extract them anyway , so you may as well make it easy\nfor  them.\nI t e m  6 8 :  U s e  T S D o c  f o r  A P I  C o m m e n t s\nHere’ s a T ypeScript function to generate a greeting:\n// Generate a greeting. Result is formatted for display.\nfunction greet(name: string, title: string) { \n  return `Hello ${title} ${name}`;\n}\nThe author was kind enough to leave a comment describing what this\nfunction does. But for documentation intended to be read by users of your\nfunctions, it’ s better to use JSDoc-style comments:\n/** Generate a greeting. Result is formatted for display. */\nfunction greetJSDoc(name: string, title: string) { \n  return `Hello ${title} ${name}`;\n}\nThe reason is that there is a nearly universal convention in editors to surface\nJSDoc-style comments when the function is called (see Figure 8-1 ).\nFigur e 8-1. JSDoc-style comments ar e shown in tooltips in your editor .\nThe inline comment, in contrast, gets no such treatment (see Figure 8-2 ).\nFigur e 8-2. Inline comments ar e typically not shown in tooltips.\nThe T ypeScript language service supports this convention, and you should\ntake advantage of it. If a comment describes a public API, it should be\nJSDoc. In the context of T ypeScript, these comments are sometimes called\nTSDoc. Y ou can use many of the usual conventions  like @param  and\n@returns :\n/**\n * Generate a greeting.\n * @param name Name of the person to greet\n * @param title The person's title\n * @returns A greeting formatted for human consumption.\n */\nfunction greetFullTSDoc(name: string, title: string) { \n  return `Hello ${title} ${name}`;\n}\nThis lets editors show the relevant documentation for each parameter as\nyou’re writing out a function call (as shown in Figure 8-3 ). Only the\ndocumentation for the name  parameter is shown here, not title .\nFigur e 8-3. An @param annotation lets your editor show documentation for the curr ent parameter as\nyou type it.\nY ou can also use TSDoc with type definitions:\n/** A measurement performed at a time and place. */\ninterface Measurement { \n  /** Where was the measurement made? */ \n  position: Vector3D; \n  /** When was the measurement made? In seconds since epoch. */ \n  time: number; \n  /** Observed momentum */ \n  momentum: Vector3D;\n}\nAs you inspect individual fields in a Measurement  object, you’ll get\ncontextual documentation (see Figure 8-4 ).\nFigur e 8-4. TSDoc for a field is shown when you mouse over that field in your editor .\nThe documentation on individual fields is carried along through mapped\ntypes so long as they are “homomorphic” (see Item 15 ). This includes\nhelper types such as Partial  and Pick .\nY ou can use the @template  tag to document type parameters for generic\ntypes. Item 50  shows how this works.\nTSDoc comments are formatted using Markdown, so if you want to use\nbold, italic, or bulleted lists, you can (see Figure 8-5 ).\nFigur e 8-5. TSDoc comments can include Markdown formatting.\nT ry to avoid writing essays in your documentation, though. The best\ncomments are short and to the point.\nJSDoc includes some conventions for specifying type information ( @param\n{string} name ... ), but you should avoid these in favor of T ypeScript\ntypes ( Item 31 ).\nFinally , you should mark deprecated symbols using  the @deprecated  tag.\nNot only does this provide a clear indication that a function is deprecated, it\nalso enables the most aggressive TSDoc feature of all: @deprecated\nsymbols are typically rendered using strikethrough  text. This means you\ndon’ t even need to inspect a symbol to know it’ s deprecated, as you can see\nin Figure 8-6 .",5913
80-Item 69 Provide a Type for this in Callbacks if Its Part of Their API.pdf,80-Item 69 Provide a Type for this in Callbacks if Its Part of Their API,"Figur e 8-6. Symbols marked with the @depr ecated tag ar e struck thr ough.\nIf you mark a method as deprecated, do your users a favor and say what the\nnew alternative is. At the very least, include a reference to documentation\non the deprecation.\nThings to Remember\nUse JSDoc-/TSDoc-formatted comments to document exported\nfunctions, classes, and types. This helps editors surface information for\nyour users when it’ s most relevant.\nUse @param , @returns , and Markdown for formatting.\nA void including type information in documentation (see Item 31 ).\nMark deprecated APIs with @deprecated .\nI t e m  6 9 :  P r o v i d e  a  T y p e  f o r  t h i s  i n  C a l l b a c k s\ni f  I t ’ s  P a r t  o f  T h e i r  A P I\nJavaScript’ s this  keyword is  one of the most notoriously confusing parts of\nthe language. Unlike variables declared with let  or const , which are\nlexically scoped, this  is dynamically scoped: its value depends not on\nwhere it appears in your code but on how you get there.\nthis  is most often used in classes, where it typically references the current\ninstance of an object:\nclass C { \n  vals = [1, 2, 3]; \n  logSquares() { \n    for (const val of this.vals) { \n      console.log(val ** 2); \n    } \n  }\n} \n \nconst c = new C();\nc.logSquares();\nThis logs:\n1 \n4 \n9\nNow look what happens if you try to put logSquares  in a variable and call\nthat:\nconst c = new C();\nconst method = c.logSquares;\nmethod();\nThis version throws an error at runtime:\n        for (const val of this.vals) { \n                               ^ \n \nTypeError: Cannot read properties of undefined (reading 'vals')\nThe problem is that c.logSquares()  actually does two things: it calls\nC.prototype.logSquares  and  it binds the value of this  in that function\nto c . By pulling out a reference to logSquares , you’ve separated these, and\nthis  gets set to undefined .\nJavaScript gives you complete control over this  binding. Y ou can use call\nto explicitly set this  and fix the problem:\nconst c = new C();\nconst method = c.logSquares;\nmethod.call(c);  // Logs the squares again\nThere’ s no reason that this  had to be bound to an instance of C . It could\nhave been bound to anything. So libraries can, and do, make the value of\nthis  part of their APIs. Even the DOM does this in event handlers, for\ninstance:\ndocument.querySelector('input')?.addEventListener('change', function(e) { \n  console.log(this);  // Logs the input element on which the event fired.\n});\nthis  binding often comes up in the context of callbacks like this one. If you\nwant to define an onClick  handler in a class, for example, you might try\nthis:\nclass ResetButton { \n  render() { \n    return makeButton({text: 'Reset', onClick: this.onClick}); \n  } \n  onClick() { \n    alert(`Reset ${this}`); \n  }\n}\nWhen a user clicks the button, it will alert with “Reset undefined.” Oops!\nAs usual, the culprit is this  binding. A common solution is to create a\nbound version of the method in the constructor:\nclass ResetButton { \n  constructor() { \n    this.onClick = this.onClick.bind(this); \n  } \n  render() { \n    return makeButton({text: 'Reset', onClick: this.onClick}); \n  } \n  onClick() { \n    alert(`Reset ${this}`); \n  }\n}\nThe onClick() { ... }  definition defines a property on\nResetButton.prototype . This is shared by all instances of ResetButton .\nWhen you bind this.onClick = ...  in the constructor , it creates a\nproperty called onClick  on the instance of ResetButton  with this  bound\nto that instance. The onClick  instance property comes before the onClick\nprototype property in the lookup sequence, so this.onClick  refers to the\nbound function in the render()  method.\nThere is a shorthand for this  binding that is extremely convenient:\nclass ResetButton { \n  render() { \n    return makeButton({text: 'Reset', onClick: this.onClick}); \n  } \n  onClick = () => { \n    alert(`Reset ${this}`); // ""this"" refers to the ResetButton instance. \n  }\n}\nHere we’ve replaced onClick  with an arrow function. This will define a\nnew function every time a ResetButton  is constructed with this  set to the\nappropriate value. It’ s instructive to look at the generated JavaScript:\nclass ResetButton { \n  constructor() { \n    this.onClick = () => { \n      alert(`Reset ${this}`); // ""this"" refers to the ResetButton instance. \n    }; \n  } \n  render() { \n    return makeButton({ text: 'Reset', onClick: this.onClick }); \n  }\n}\nSo what does this all have to do with T ypeScript? Because this  binding is\npart of JavaScript, T ypeScript models it. This means that if you’re writing\n(or typing) a library that sets the value of this  on callbacks, then you\nshould model it, too.\nY ou can do so by adding a this  parameter to your callback:\nfunction addKeyListener( \n  el: HTMLElement, \n  listener: (this: HTMLElement, e: KeyboardEvent) => void\n) { \n  el.addEventListener('keydown', e => listener.call(el, e));\n}\nThe this  parameter is special: it’ s not just another positional ar gument.\nY ou can see this if you try to call it with two parameters:\nfunction addKeyListener( \n  el: HTMLElement, \n  listener: (this: HTMLElement, e: KeyboardEvent) => void\n) { \n  el.addEventListener('keydown', e => { \n    listener(el, e); \n    //           ~ Expected 1 arguments, but got 2 \n  });\n}\nEven better , T ypeScript will enforce that you call the function with the\ncorrect this  context:\nfunction addKeyListener( \n  el: HTMLElement, \n  listener: (this: HTMLElement, e: KeyboardEvent) => void\n) { \n  el.addEventListener('keydown', e => { \n    listener(e); \n    // ~~~~~~~~ The 'this' context of type 'void' is not assignable \n    //          to method's 'this' of type 'HTMLElement' \n  });\n}\nAs a user of this function, you can reference this  in the callback and get\nfull type safety:\ndeclare let el: HTMLElement;\naddKeyListener(el, function(e) { \n  console.log(this.innerHTML); \n  //          ^? this: HTMLElement\n});\nOf course, if you use an arrow function here, you’ll override the value of\nthis . T ypeScript will catch the issue:\nclass Foo { \n  registerHandler(el: HTMLElement) { \n    addKeyListener(el, e => { \n      console.log(this.innerHTML); \n      //               ~~~~~~~~~ Property 'innerHTML' does not exist on 'Foo' \n    }); \n  }\n}\nDon’ t for get about this ! If you set the value of this  in your callbacks,\nthen it’ s part of your API, and you should include it in your type\ndeclarations.\nIf you’re designing a new API, try not to use dynamic this  binding. While\nit was historically popular , it has always been a source of confusion, and the\nprevalence of arrow functions makes this sort of API much harder to use in\nmodern JavaScript.",6776
81-Item 70 Mirror Types to Sever Dependencies.pdf,81-Item 70 Mirror Types to Sever Dependencies,"Things to Remember\nUnderstand how this  binding works.\nProvide a type for this  in callbacks if it’ s part of your API.\nA void dynamic this  binding in new APIs.\nI t e m  7 0 :  M i r r o r  T y p e s  t o  S e v e r  D e p e n d e n c i e s\nSuppose you’ve written a library for parsing CSV files. Its API is simple:\nyou pass in the contents of the CSV file and get back a list of objects\nmapping column names to values.\nAs a convenience for your Node.js users, you allow the contents to be either\na string  or a Node.js Buffer :\n// parse-csv.ts\nimport {Buffer} from 'node:buffer'; \n \nfunction parseCSV(contents: string | Buffer): {[column: string]: string}[]  { \n  if (typeof contents === 'object') { \n    // It's a buffer \n    return parseCSV(contents.toString('utf8')); \n  } \n  // ...\n}\nThe type definition for Buffer  comes from the Node.js type declarations,\nwhich you must install:\nnpm install --save-dev @types/node\nHere we’re following the advice of Item 65  by making @types  dev\ndependencies rather than production dependencies.\nWhen you publish your CSV parsing library , you generate type declarations\nusing --declaration  and bundle them with it. Here’ s what the generated\n.d.ts  file looks like:\n// parse-csv.d.ts\nimport { Buffer } from 'node:buffer';\nexport declare function parseCSV(contents: string | Buffer): { \n    [column: string]: string;\n}[];\nIf you take this approach, the JavaScript users of your library will be happy ,\nbut T ypeScript web developers will not be. Y ou’ll get complaints from them\nthat they’re getting an error from your library:\nCannot find module 'node:buffer' or its corresponding type declarations.\nBecause we’ve made @types/node  a devDependency , it’ s not installed\nwith our package, even though our types, which are part of our package,\ndepend on it.\nSo should we make @types/node  a prod dependency? This will make the\nerror go away , but now you’re likely to get a dif ferent set of complaints:\nJavaScript developers will wonder what these @types  modules are that\nthey’re depending on.\nT ypeScript web developers will wonder why they’re depending on\nNode.js.\nT ypeScript developers using a dif ferent version of Node.js will wonder\nwhy they have duplicated type definitions.\nThese complaints are reasonable. The Buffer  behavior isn’ t essential and is\nonly relevant for users who are using Node.js already . And the declaration\nin @types/node  is only relevant to Node.js users who are also using\nT ypeScript. The @types/node  package is not small (nearly 100k lines of\ncode), and our library only uses a very tiny part of it.\nT ypeScript’ s structural typing ( Item 4 ) can help you out of the jam. Rather\nthan using the declaration of Buffer  from @types/node , you can write\nyour own with just the methods and properties you need. In this case that’ s\njust a toString  method that can accept an encoding:\nexport interface CsvBuffer { \n  toString(encoding?: string): string;\n}\nexport function parseCSV( \n  contents: string | CsvBuffer\n): {[column: string]: string}[]  { \n  // ...\n}\nThis interface is dramatically shorter than the complete one, but it does\ncapture our (simple) needs from a Buffer . In a Node.js project, calling\nparseCSV  with a real Buffer  is still OK because the types are compatible:\nparseCSV(new Buffer(""column1,column2\nval1,val2"", ""utf-8""));  // OK\nLooking again at the CsvBuffer  interface, there’ s nothing about it that’ s\nspecific to CSV files. Giving it a more “structural” name can reinforce this:\n/** Anything convertible to a string with an encoding, e.g. a Node buffer. */\nexport interface StringEncodable { \n  toString(encoding?: string): string;\n}\nSince it’ s important that a Node Buffer  is assignable to StringEncodable\n(the comment says as much!), you should write a unit test that verifies this:\nimport {Buffer} from 'node:buffer';\nimport {parseCSV} from './parse-csv'; \n \ntest('parse CSV in a buffer', () => { \n  expect( \n    parseCSV(new Buffer(""column1,column2\nval1,val2"", ""utf-8"")) \n  ).toEqual( \n    [{column1: 'val1', column2: 'val2'}] \n  );\n});\nThis test verifies both the runtime behavior of your code and the\nassignability of a Node Buffer  to StringEncodable . The test imports",4272
82-Item 71 Use Module Augmentation to Improve Types.pdf,82-Item 71 Use Module Augmentation to Improve Types,"node:buffer , but that’ s fine because @types/node  can be a\ndevDependency  without af fecting users of your library .\nIf your code starts using more methods from the Buffer  interface, then\nyou’ll need to add them to your version of this interface as well. This may\nfeel duplicative but, as they say in the Go Language community , “a little\ncopying is better than a little dependency .” If you depend on a lar ge portion\nof another library’ s types, you may choose to formalize this copying by\nvendoring the dependency .\nIn any case, by severing the @types  dependency you get a good experience\nfor JavaScript and all kinds of T ypeScript developers. If the @types\ndependency had dependencies of its own, then you may sever an entire\ndependency tree, which can have a lar ge positive impact on compiler\nperformance ( Item 78 ).\nThis technique is also helpful for severing dependencies between your unit\ntests and production systems. See the getAuthors  example in Item 4 .\nThings to Remember\nA void transitive type dependencies in published npm modules.\nUse structural typing to sever dependencies that are nonessential.\nDon’ t force JavaScript users to depend on @types . Don’ t force web\ndevelopers to depend on Node.js.\nI t e m  7 1 :  U s e  M o d u l e  A u g m e n t a t i o n  t o\nI m p r o v e  T y p e s\nJavaScript famously has some “bad parts,” like implicit globals and type\ncoercions. Most of these were design decisions made in the halcyon days of\nthe mid-90s that have proven extremely hard to reverse.\nT ypeScript has a few historical warts of its own. One of these is the type\ndeclaration for JSON.parse , which returns any :\ndeclare let apiResponse: string;\nconst response = JSON.parse(apiResponse);\nconst cacheExpirationTime = response.lastModified + 3600;\n//    ^? const cacheExpirationTime: any\nIf you fail to give response  a type, it will quietly spread any  types\nthroughout your code. As Item 5  explained, this will undermine type safety ,\nthwart language services, and generally give you a poor experience with\nT ypeScript.\nIt would be better if JSON.parse  returned unknown  which, as Item 46\nexplained, can be used as a type-safe alternative to any . So why doesn’ t it?\nIt’ s because the unknown  type was only introduced in T ypeScript 3.0, which\ncame out in July of 2018. Enormous amounts of T ypeScript code had been\nwritten before then, and changing the return type of JSON.parse  would\nhave been extremely disruptive. So the T ypeScript team made a concession\nto pragmatism. Future code will be a bit less safe, but existing code won’ t\nbreak.\nBut just because the T ypeScript team decided to keep this type signature\ndoesn’ t mean that you have to. Recall from Item 13  that interface s have a\nspecial power that type aliases do not: they participate in “declaration\nmer ging,” where repeated definitions of the same interface  are mer ged to\nform a final result.\nW e can use this to change the type signature of JSON.parse . Here’ s what it\nlooks like (in lib.es5.d.ts ):\ninterface JSON { \n  parse( \n    text: string, \n    reviver?: (this: any, key: string, value: any) => any \n  ): any; \n  // ...\n}\ndeclare var JSON: JSON;\n;\nW e’re interested in the interface . If you define your own interface\nJSON  in a type declaration file in your project, T ypeScript will mer ge it with\nthe library declarations.\n// declarations/safe-json.d.ts\ninterface JSON { \n  parse( \n    text: string, \n    reviver?: (this: any, key: string, value: any) => any \n  ): unknown;\n}\nNote the changed return type. The result is similar to a T ypeScript function\noverload ( Item 52 ). Since libs are loaded before our code, our overload will\nalways win. The result is that JSON.parse  now returns unknown :\nconst response = JSON.parse(apiResponse);\n//    ^? const response: unknown\nconst cacheExpirationTime = response.lastModified + 3600;\n//                          ~~~~~~~~ response is of type 'unknown'.\nUsing it requires a type assertion, which is exactly what you want:\ninterface ApiResponse { \n  lastModified: number;\n}\nconst response = JSON.parse(apiResponse) as ApiResponse;\nconst cacheExpirationTime = response.lastModified + 3600;  // ok\n//    ^? const cacheExpirationTime: number\nY ou can do something similar for the fetch API’ s\nResponse.prototype.json() , which also returns any . Here’ s a fix:\n// declarations/safe-response.d.ts\ninterface Body { \n  json(): Promise<unknown>;\n}\nThese changes were clear wins. But since you’re only making changes that\naf fect your own code, you’re also free to make more controversial changes\nthat would never fly in the broader T ypeScript ecosystem.\nFor example, it’ s part of the language spec that the Set  constructor can take\na string . This results in something that might not be what you expect:\n> new Set('abc') \nSet(3) { 'a', 'b', 'c' }\nIf your intention was to create a one-element set containing 'abc' , then this\nmight introduce bugs in your code. Since the type of both would be\nSet<string> , and this is how JavaScript works, T ypeScript can’ t help you\ncatch this mistake.\nBut there’ s no reason you can’ t ban calling the Set  constructor with a\nstring  in your own code. It’ s a little more dif ficult than changing the return\ntype of JSON.parse , but it all comes back to declaration mer ging.\nHere’ s the declaration of Set  from lib.es2015.collections.d.ts :\ninterface Set<T> { \n  add(value: T): this; \n  delete(value: T): boolean; \n  has(value: T): boolean; \n  readonly size: number; \n  // ...\n} \n \ninterface SetConstructor { \n  new <T = any>(values?: readonly T[] | null): Set<T>; \n  readonly prototype: Set<any>;\n}\ndeclare var Set: SetConstructor;\nThere’ s also an overload of the constructor in lib.es2015.iterable.d.ts :\ninterface SetConstructor { \n  new <T>(iterable?: Iterable<T> | null): Set<T>;\n}\nThis is the one we’d like to “knock out.” Here’ s how:\n// declarations/ban-set-string-constructor.d.ts:\ninterface SetConstructor { \n  new (str: string): void;\n}\nW ith this in place, constructing a Set  with a string  still won’ t produce a\ntype error . But it will return void , so trying to do anything with the result\nwill give you a clue that something is amiss:\nconst s = new Set('abc');\n//    ^? const s: void\nconsole.log(s.has('abc'));\n//            ~~~ Property 'has' does not exist on type 'void'.\nconst otherSet: Set<string> = s;\n//    ~~~~~~~~ Type 'void' is not assignable to type 'Set<string>'.\nT o give users a stronger hint what’ s going on, you could have the Set\nconstructor return a string literal type containing an error . Y ou can also\nmark this constructor @deprecated  to make it appear struck-through in\nyour user ’ s editor ( Item 68 ):\ninterface SetConstructor { \n  /** @deprecated */ \n  new (str: string): 'Error! new Set(string) is banned.';\n} \n \nconst s = new Set('abc');\n//    ^? const s: ""Error! new Set(string) is banned.""\nNone of these is a perfect solution: it would be better if we produced a type\nerror when you constructed the Set , rather than producing an unusable type.\nBut that’ s not possible in T ypeScript, and this is what real-world\napplications of this technique often wind up looking like.\nOf course, with great power comes great responsibility . Here are a few\nthings to be aware of:\nAs with all type-level constructs, this only af fects type checking. The\nruntime behavior of JSON.parse  and the Set  constructor are not\naf fected, either in your own code or in library code.\nThis technique is best used either to make the built-in types stricter and\nmore precise, or to disallow certain things. If you add declarations that\ndon’ t reflect reality at runtime, you can create a confusing situation. As\nItem 40  explained, incorrect types can be worse than no types.\nW e “knocked out” the Set  constructor by making it return void  or an\nerror string. But this won’ t work as well if you want to ban a function\nor method that already returns void .\nW e used declaration mer ging to improve built-in types, but the same\ntechnique can be used for third-party @types  and bundled type declarations\nas well. Y ou can find a collection of improvements to the built-in types in\nthe ts-reset  npm package.\nThings to Remember\nUse declaration mer ging to improve existing APIs or disallow\nproblematic constructs.\nUse void  or error string returns to “knock out” methods and mark\nthem @deprecated .\nRemember that overloads only apply at the type level. Don’ t make the\ntypes diver ge from reality .",8592
83-9. Writing and Running Your Code.pdf,83-9. Writing and Running Your Code,,0
84-Item 72 Prefer ECMAScript Features to TypeScript Features.pdf,84-Item 72 Prefer ECMAScript Features to TypeScript Features,"Chapter 9. W riting and Running\nY our Code\nThis chapter is a bit of a grab bag: it covers some issues that come up in\nwriting code (not types) as well as issues you may run into when you run\nyour code.\nI t e m  7 2 :  P r e f e r  E C M A S c r i p t  F e a t u r e s  t o\nT y p e S c r i p t  F e a t u r e s\nThe relationship between T ypeScript and JavaScript has changed over time.\nWhen Microsoft first started work on T ypeScript in 2010, the prevailing\nattitude around JavaScript was that it was a problematic language that\nneeded to be fixed. It was common for frameworks and source-to-source\ncompilers to add missing features like classes, decorators, and a module\nsystem to JavaScript. T ypeScript was no dif ferent. Early versions included\nhome-grown versions of classes, enums, and modules.\nOver time, TC39, the  standards body that governs JavaScript, added many\nof these same features to the core JavaScript language. And the features\nthey added were not compatible with the versions that existed in\nT ypeScript. This left the T ypeScript team in an awkward predicament:\nadopt the new features from the standard or maintain existing code?\nT ypeScript has lar gely chosen to do the former and eventually articulated its\ncurrent governing principle: TC39 defines the runtime, while T ypeScript\ninnovates solely in the type space.\nThere are a few remaining features from before this decision. It’ s important\nto recognize and understand these, because they don’ t fit the pattern of the\nrest of the language. In general, I recommend avoiding them to keep the\nrelationship between T ypeScript and JavaScript as clear as possible. This\nwill also ensure that your code is compatible with alternative T ypeScript\ncompilers and won’ t break as a result of future standards alignment.\nIf you follow this advice, you can think of T ypeScript as “JavaScript with\ntypes.”\nEnums\nMany languages model types that can take on a small set of values using\nenumerations  or enums . T ypeScript adds them to JavaScript:\nenum Flavor { \n  Vanilla = 0, \n  Chocolate = 1, \n  Strawberry = 2,\n} \n \nlet flavor = Flavor.Chocolate;\n//  ^? let flavor: Flavor \n \nFlavor  // Autocomplete shows: Vanilla, Chocolate, Strawberry\nFlavor[0]  // Value is ""Vanilla""\nThe ar gument for enums is that they provide more safety and transparency\nthan bare numbers. But enums in T ypeScript have some quirks. There are\nactually several variants on enums that all have subtly dif ferent behaviors:\nNumber -valued enum (like Flavor )\nThe number  type  is assignable to this, so it’ s not very safe. (It was\ndesigned this way to make bit flag structures possible.)\nString-valued enum\nThis does  of fer type safety , and also more informative values at runtime.\nBut it’ s not structurally typed, unlike every other type in T ypeScript\n(more on this momentarily).\nconst enum\nUnlike  regular enums, const enums go away completely at runtime. If\nyou changed to const enum Flavor  in the previous example, the\ncompiler would rewrite Flavor.Chocolate  as 1 . This also breaks our\nexpectations around how the compiler behaves and still has the\ndiver gent behaviors between string  and number -valued enums.\nconst enum  with the preserveConstEnums  flag set\nThis emits runtime code for const enum s, just like for a regular enum .\nThat string-valued enums are nominally typed comes as a particular\nsurprise, since every other type in T ypeScript uses structural typing for\nassignability ( Item 4 ):\nenum Flavor { \n  Vanilla = 'vanilla', \n  Chocolate = 'chocolate', \n  Strawberry = 'strawberry',\n} \n \nlet favoriteFlavor = Flavor.Chocolate;  // Type is Flavor\nfavoriteFlavor = 'strawberry';\n// ~~~~~~~~~~~ Type '""strawberry""' is not assignable to type 'Flavor'\nThis has implications when you publish a library . Suppose you have a\nfunction that takes a Flavor :\nfunction scoop(flavor: Flavor) { /* ... */ }\nBecause a Flavor  at runtime is really just a string, it’ s fine for your\nJavaScript users to call it with one:\nscoop('vanilla');  // OK in JavaScript\nbut your T ypeScript users will need to import the enum  and use that instead:\nscoop('vanilla');\n//    ~~~~~~~~~ '""vanilla""' is not assignable to parameter of type 'Flavor' \n \nimport {Flavor} from 'ice-cream';\nscoop(Flavor.Vanilla);  // OK\nThese diver gent experiences for JavaScript and T ypeScript users are a\nreason to avoid  string-valued enums.\nT ypeScript of fers an alternative to enums that is less common in other\nlanguages: a union of literal types.\ntype Flavor = 'vanilla' | 'chocolate' | 'strawberry'; \n \nlet favoriteFlavor: Flavor = 'chocolate';  // OK\nfavoriteFlavor = 'americone dream';\n// ~~~~~~~~~~~ Type '""americone dream""' is not assignable to type 'Flavor'\nThis of fers as much safety as the enum and has the advantage of translating\nmore directly to JavaScript. It also provides autocomplete in your editor , as\nshown in Figure 9-1 .\nFigur e 9-1. T ypeScript offering autocomplete for a union of string literal types.\nFor more on unions of string literal types, see Item 35 .\nWhat about numeric enums, like our initial definition of Flavor ? If you\nhave the option, strongly consider using strings for your values instead.\nNumeric enums don’ t of fer the safety you expect, and they’re harder to\nwork with than strings. Which would you rather see in your JavaScript\ndebugger or in a network request, {""flavor"": 1}  or {""flavor"":\n""chocolate""} ?\nParameter Properties\nIt’ s common  to assign constructor parameters to properties when initializing\na class:\nclass Person { \n  name: string; \n  constructor(name: string) { \n    this.name = name; \n  }\n}\nT ypeScript provides a more compact syntax for this:\nclass Person { \n  constructor(public name: string) {}\n}\nThis is called a “parameter property ,” and it is equivalent to the code in the\nfirst example. There are a few issues to be aware of with parameter\nproperties:\nThey are one of the few constructs that generate code when you\ncompile to JavaScript ( enum s are another). Generally , compilation just\ninvolves erasing types.\nBecause the parameter is only used in generated code, the source looks\nlike it has unused parameters.\nA mix of parameter and nonparameter properties can hide the design\nof your classes.\nFor example:\nclass Person { \n  first: string; \n  last: string; \n  constructor(public name: string) { \n    [this.first, this.last] = name.split(' '); \n  }\n}\nThis class has three properties ( first , last , name ), but this is hard to read\nof f the code because only two are listed before the constructor . This gets\nworse if the constructor takes other parameters, too.\nIf your class consists only  of parameter properties and no methods, you\nmight consider making it an interface  and using object literals.\nRemember that the two are assignable to one another because of structural\ntyping ( Item 4 ):\nclass PersonClass { \n  constructor(public name: string) {}\n}\nconst p: PersonClass = { name: 'Jed Bartlet' };  // OK \n \ninterface Person { \n  name: string;\n}\nconst jed: Person = new PersonClass('Jed Bartlet');  // also OK\nOpinions are divided on parameter properties. While I generally avoid\nthem, others appreciate the saved keystrokes. Be aware that they do not fit\nthe pattern of the rest of T ypeScript, however , and may in fact obscure that\npattern for new developers. T ry to avoid hiding the design of your class\nbehind a mix of parameter and  nonparameter properties.\nNamespaces and T riple-Slash Imports\nBefore  ECMAScript 2015, JavaScript didn’ t have an of ficial module\nsystem. Dif ferent environments added this missing feature in dif ferent\nways: Node.js used require  and module.exports , whereas in the browser ,\nthe AMD system used a define  function with a callback.\nT ypeScript also filled this gap with its own module system. This was done\nusing a module  keyword and “triple-slash” imports. After ECMAScript\n2015 added an of ficial module system, T ypeScript added namespace  as a\nsynonym for module , to avoid confusion:\n// other.ts\nnamespace foo { \n  export function bar() {}\n}\n// index.ts\n/// <reference path=""other.ts""/>\nfoo.bar();\nOutside of type declaration files, triple-slash imports and the module\nkeyword are just a historical curiosity . In your own code, you should use\nECMASCript 2015-style modules ( import  and export ).\nexperimentalDecorators\nDecorators can be used to annotate or modify classes, methods, and\nproperties. If a symbol is preceded by an @  sign, then it’ s a decorator .\nThey’re common in Angular and several other frameworks.\nIn 2015, T ypeScript added support for a draft proposal of decorators in\norder to support Angular . This was gated behind the --\nexperimentalDecorators  flag.\nEight years later , in 2023, the decorators proposal reached stage 3 in a very\ndif ferent form. Y ou can use standard decorators without any flags. Here’ s\nwhat an ECMAScript standard decorator looks like:\nclass Greeter { \n  greeting: string; \n  constructor(message: string) { \n    this.greeting = message; \n  } \n  @logged  // <-- this is the decorator \n  greet() { \n    return `Hello, ${this.greeting}`; \n  }\n} \n \nfunction logged(originalFn: any, context: ClassMethodDecoratorContext) { \n  return function(this: any, ...args: any[]) { \n    console.log(`Calling ${String(context.name)}`); \n    return originalFn.call(this, ...args); \n  };\n} \n \nconsole.log(new Greeter('Dave').greet());\n// Logs:\n// Calling greet\n// Hello, Dave\nY ou can tell which version of decorators you’re using by checking for\nexperimentalDecorators  in your tsconfig.json . If it’ s set, then you’re\nusing nonstandard decorators. If you’re able to, turn this of f! But you may\nbe forced to keep this setting by a library or framework, at least until it\nadopts the latest standards.\nIf you are using experimentalDecorators , try not to dig the hole deeper\nby writing your own nonstandard decorators. Y ou’ll eventually have to\nmigrate these to the standard version.\nIf you don’ t have this flag set, then feel free to write decorators to your\nheart’ s content. Just remember that decorators aren’ t the best solution to all\nproblems and can sometimes make your code harder to follow . T ry to avoid\ndecorators that change a method’ s type signature, for example.\nMember V isibility Modifiers (Private, Protected, and\nPublic)\nHistorically , JavaScript lacked a way to make the properties and methods of\na class private. The usual workaround was a convention that underscore-\nprefixed fields weren’ t part of a class’ s public API:\nclass Foo { \n  _private = 'secret123';\n}\nBut this only discourages users from accessing private data. It’ s easy to\ncircumvent:\nconst f = new Foo();\nf._private;  // 'secret123'\nT ypeScript adds public , protected , and private  field visibility modifiers\nthat seem to provide some enforcement:\nclass Diary { \n  private secret = 'cheated on my English test';\n} \n \nconst diary = new Diary();\ndiary.secret\n//    ~~~~~~ Property 'secret' is private and only accessible within ... \n'Diary'\nBut private  is a feature of the type system and, as Item 3  explained,\nfeatures of the type system all go away at runtime. Here’ s what this snippet\nlooks like when T ypeScript compiles it to JavaScript:\nclass Diary { \n  constructor() { \n    this.secret = 'cheated on my English test'; \n  }\n}\nconst diary = new Diary();\ndiary.secret;\nThe private  indicator is gone, and your secret is out! Much like the\n_private  convention, T ypeScript’ s visibility modifiers only discourage you\nfrom accessing private data. Y ou can even access a private property from\nwithin T ypeScript  using a type assertion or iteration:\nconst diary = new Diary();\n(diary as any).secret  // OK \n \nconsole.log(Object.entries(diary));\n// logs [[""secret"", ""cheated on my English test""]]\nES2022 of ficially added support for private fields. Unlike T ypeScript’ s\nprivate , ECMAScript’ s private is enforced both for type checking and at\nruntime. T o use it, prefix your class property with a # :\nclass PasswordChecker { \n  #passwordHash: number; \n \n  constructor(passwordHash: number) { \n    this.#passwordHash = passwordHash; \n  } \n \n  checkPassword(password: string) { \n    return hash(password) === this.#passwordHash; \n  }\n} \n \nconst checker = new PasswordChecker(hash('s3cret'));\nchecker.#passwordHash\n//      ~~~~~~~~~~~~~ Property '#passwordHash' is not accessible outside class\n//                    'PasswordChecker' because it has a private identifier.\nchecker.checkPassword('secret');  // Returns false\nchecker.checkPassword('s3cret');  // Returns true\nThe #passwordHash  property is not accessible from outside the class and is\nnot enumerable. Even for tar gets of that don’ t natively support private fields\n(ES2021 or earlier), there’ s a fallback implementation that will keep your\ndata private. ECMAScript private fields are standard, widely supported, and\nmore secure than T ypeScript’ s private .  Y ou should use them instead.\nWhat about public  and protected ? In JavaScript (and T ypeScript),\npublic  is the default visibility so there’ s no need to annotate this explicitly .\nAnd while private  implies encapsulation, protected  implies inheritance.\nThe general rule in object-oriented programming is to prefer composition\nover inheritance, so practical uses of protected  are quite rare.\nreadonly  as a field modifier is a type-level construct and is fine to use. See\nItem 14 . A field may be both #private  and readonly .\nThings to Remember\nBy and lar ge, you can convert T ypeScript to JavaScript by removing\nall the types from your code.\nEnums, parameter properties, triple-slash imports, experimental\ndecorators, and member visibility modifiers are historical exceptions to\nthis rule.\nT o keep T ypeScript’ s role in your codebase as clear as possible and to\navoid future compatibility issues, avoid nonstandard features.",14041
85-Item 73 Use Source Maps to Debug TypeScript.pdf,85-Item 73 Use Source Maps to Debug TypeScript,"I t e m  7 3 :  U s e  S o u r c e  M a p s  t o  D e b u g\nT y p e S c r i p t\nWhen you run T ypeScript code, you’re actually running the JavaScript that\nthe T ypeScript compiler generates. This is true of any source-to-source\ncompiler , be it a minifier , a compiler , or a preprocessor . The hope is that\nthis is mostly transparent, that you can pretend that the T ypeScript source\ncode is being executed without ever having to look at the JavaScript.\nThis works well until you have to debug your code. Debuggers generally\nwork on the code you’re executing and don’ t know about the translation\nprocess it went through. Since JavaScript is such a popular tar get language,\nbrowser vendors collaborated to solve this problem. The result is source\nmaps. They map positions and symbols in a generated file back to the\ncorresponding positions and symbols in the original source. Most browsers\nand many IDEs support them. If you’re not using them to debug your\nT ypeScript, you’re missing out!\nSuppose you’ve created a small script to add a button to an HTML page\nthat increments every time you click it:\n// index.ts\nfunction addCounter(el: HTMLElement) { \n  let clickCount = 0; \n  const button = document.createElement('button'); \n  button.textContent = 'Click me'; \n  button.addEventListener('click', () => { \n    clickCount++; \n    button.textContent = `Click me (${clickCount})`; \n  }); \n  el.appendChild(button);\n} \n \naddCounter(document.body);\nIf you load this in your browser and open the debugger , you’ll see the\ngenerated JavaScript (here we’re using a tar get of ES5). This closely\nmatches the original source, so debugging isn’ t too dif ficult, as you can see\nin Figure 9-2 .\nFigur e 9-2. Debugging generated JavaScript using Chr ome’ s developer tools. For this simple\nexample, the generated JavaScript closely r esembles the T ypeScript sour ce.\nLet’ s make the page more fun by fetching an interesting fact about each\nnumber from numbersapi.com :\n// index.ts\nfunction addCounter(el: HTMLElement) { \n  let clickCount = 0; \n  const triviaEl = document.createElement('p'); \n  const button = document.createElement('button'); \n  button.textContent = 'Click me'; \n  button.addEventListener('click', async () => { \n    clickCount++; \n    const response = await fetch(`http://numbersapi.com/${clickCount}`); \n    const trivia = await response.text(); \n    triviaEl.textContent = trivia; \n    button.textContent = `Click me (${clickCount})`; \n  }); \n  el.appendChild(triviaEl); \n  el.appendChild(button);\n}\nIf you click the button several times quickly , you may discover a race\ncondition! If you open up your browser ’ s debugger to investigate now ,\nyou’ll see that the generated source has gotten dramatically more\ncomplicated (see Figure 9-3 ).\nFigur e 9-3. The T ypeScript compiler has generated JavaScript that doesn’ t closely r esemble the\noriginal T ypeScript sour ce. This will make debugging mor e difficult.\nT o support async  and await  in older browsers, T ypeScript has rewritten the\nevent handler as a state machine. This has the same behavior , but the code\nno longer bears such a close resemblance to the original source. This is\nwhere source maps can help. T o tell T ypeScript to generate one, set the\nsourceMap  option in your tsconfig.json :\n{\n  ""compilerOptions"": {\n    ""sourceMap"": true\n  }\n}\nNow when you run tsc , it generates two output files for each .ts  file: a .js\nfile and a .js.map  file. The latter is the source map. W ith this file in place, a\nnew index.ts  file appears in your browser ’ s debugger . Y ou can set\nbreakpoints and inspect variables in it, just as you’d hope (see Figure 9-4 ).\nFigur e 9-4. When a sour ce map is pr esent, you can work with the original T ypeScript sour ce in your\ndebugger , rather than the generated JavaScript.\nNote that index.ts  appears in italics in the file list on the left. This indicates\nthat it isn’ t a “real” file in the sense that the web page included it. Rather , it\nwas included via the source map. Depending on your settings, index.js.map\nwill contain either a reference to index.ts  (in which case the browser loads it\nover the network) or an inline copy of it (in which case no request is\nneeded).\nThere are a few things to be aware of with source maps:\nIf you are using a bundler or minifier with T ypeScript, it may generate\na source map of its own. T o get the best debugging experience, you\nwant this to map all the way back to the original T ypeScript sources,\nnot the generated JavaScript. If your bundler has built-in support for\nT ypeScript, then this should just work. If not, you may need to hunt\ndown some flags to make it read source map inputs.\nBe aware of whether you’re serving source maps in production. If your\nJS file has a reference to the source map, then the browser will only\nload it when the debugger is open, so there’ s no performance impact\nfor end users. (Inline source maps are always downloaded, so you\nshould avoid them in production.) If your source map contains a copy\nof your original source code, then there may be content that you didn’ t\nintend to publicize. Does the world really need to see your snarky\ncomments or internal bug tracker URLs?\nY ou can also debug  Node.js programs using source maps. This is typically\ndone via your editor or by connecting to your Node process from a\nbrowser ’ s debugger . Here’ s some code written in T ypeScript that’ s intended\nto be run in Node.js:\n// bedtime.ts\nasync function sleep(ms: number) { \n  return new Promise<void>(resolve => setTimeout(resolve, ms));\n} \n \nasync function main() { \n  console.log('Good night!'); \n  await sleep(1000); \n  console.log('Morning already!?');\n} \n \nmain();\n(The void  in Promise<void>  indicates that sleep  doesn’ t resolve to a\nusable value, similar to returning void  from a function.)\nT o debug this, compile it to JavaScript with sourceMap  set in your\ntsconfig.json . Then run it with node  using the --inspect-brk  flag:\n$ tsc bedtime.ts \n$ node --inspect-brk bedtime.js \nDebugger listening on ws://127.0.0.1:9229/587c380b-fdb4-48df-8c09-a83f36d8a2e7 \nFor help, see: https://nodejs.org/en/docs/inspector\nNow you can open your browser to debug. In Chrome, for example, you\nnavigate to chr ome://inspect . Y ou should see a remote tar get that you can\n“Inspect,” as shown in Figure 9-5 .\nFigur e 9-5. Selecting a r emote debug tar get to inspect in Google Chr ome ( chrome://inspect ).\nOnce you connect, you’ll see the usual browser dev tools with the generated\nJavaScript, as shown in Figure 9-6  (here we’re using a tar get of ES2015).\nFigur e 9-6. Generated JavaScript for a Node.js pr ogram in Google Chr ome Devtools. Note the\nsour ce map r efer ence at the bottom.\nIn addition to opening a websocket running the remote debugging protocol,\nthe --inspect-brk  flag pauses execution of your code at the very\nbeginning. This is convenient for switching over to the T ypeScript view and\nsetting up breakpoints in the original source, as shown in Figure 9-7 .\nFigur e 9-7. Debugging the original T ypeScript sour ce for a Node.js pr ogram.\nJavaScript’ s debugger  statement is another convenient way to set a\nbreakpoint exactly where you want.\nIf you generate .d.ts  files for your project (by setting the declaration\noption), T ypeScript can also generate .d.ts.map  files that map your type\ndeclarations back to the original source. Y ou enable this by setting\ndeclarationMap . This can be useful for improving languages services like\n“Go to Definition” in your editor , particularly if you’re using project\nreferences ( Item 78 ).\nThe type checker can catch many errors before you run your code, but it is\nno substitute for a good debugger . Use source maps to get a great\nT ypeScript debugging experience.\nThings to Remember\nDon’ t debug generated JavaScript. Use source maps to debug your\nT ypeScript code at runtime.",7982
86-Item 74 Know How to Reconstruct Types at Runtime.pdf,86-Item 74 Know How to Reconstruct Types at Runtime,"Make sure that your source maps are mapped all the way through to\nthe code that you run.\nKnow how to debug Node.js code written in T ypeScript.\nDepending on your settings, your source maps might contain an inline\ncopy of your original code. Don’ t publish them unless you know what\nyou’re doing!\nI t e m  7 4 :  K n o w  H o w  t o  R e c o n s t r u c t  T y p e s  a t\nR u n t i m e\nAt some point  in the process of learning T ypeScript, most developers have\nan epiphany when they realize that T ypeScript types aren’ t “real”: they’re\nerased at runtime ( Item 3 ). This might be accompanied by a feeling of\ndread: if the types aren’ t real, how can you trust them?\nThe independence of types from runtime behavior is a key part of the\nrelationship between T ypeScript and JavaScript ( Item 1 ). And most of the\ntime this system works very well. But there are undeniably times when it\nwould be extremely convenient to have access to T ypeScript types at\nruntime. This item explores how this situation might arise and what your\noptions are.\nImagine you’re implementing a web server and you define an API endpoint\nfor creating a comment on a blog post (we saw this API before in Item 42 ).\nY ou define a T ypeScript type for the request body:\ninterface CreateComment { \n  postId: string; \n  title: string; \n  body: string;\n}\nY our request handler should validate the request. Some of this validation\nwill be at the application level (does postId  reference a post that exists and\nthat the user can comment on?), but some will be at the type level (does the\nrequest have all the properties we expect, are they of the right type, and are\nthere any extra properties?).\nHere’ s what that might look like:\napp.post('/comment', (request, response) => { \n  const {body} = request; \n  if ( \n    !body || \n    typeof body !== 'object' || \n    Object.keys(body).length !== 3 || \n    !('postId' in body) || typeof body.postId !== 'string' || \n    !('title' in body) || typeof body.title !== 'string' || \n    !('body' in body) || typeof body.body !== 'string' \n  ) { \n    return response.status(400).send('Invalid request'); \n  } \n  const comment = body as CreateComment; \n  // ... application validation and logic ... \n  return response.status(200).send('ok');\n});\nThis is already a lot of validation code, even with just three properties.\nW orse, there’ s nothing to ensure that the checks are accurate and in sync\nwith our type. Nothing checks that we spelled the properties correctly . And\nif we add a new property , we’ll need to remember to add a check, too.\nThis is code duplication at its worst. W e have two things (a type and\nvalidation logic) that need to stay in sync. It would be better if there was a\nsingle source of truth. The interface  seems like the natural source of\ntruth, but it’ s erased at runtime so it’ s unclear how you’d use it in this way .\nLet’ s look at a few possible solutions to this conundrum.\nGenerate the T ypes from Another Source\nIf your API  is specified in some other form, perhaps using GraphQL or an\nOpenAPI schema, then you can use that as the source of truth and generate\nyour T ypeScript types from it.\nThis typically involves running an external tool to generate types and,\npossibly , validation code. An OpenAPI spec  uses JSON Schema, for\nexample, so you can use a tool like json-schema-to-typescript  to\ngenerate the T ypeScript types, and a JSON Schema validator such as Ajv  to\nvalidate requests.\nThe downside of this approach is that it adds some complexity and a build\nstep that must be run whenever your API schema changes. But if you’re\nalready specifying your API using OpenAPI or some other system, then this\nhas the enormous advantage of not introducing any new sources of truth,\nand this is the approach that you should prefer .\nIf this is a good fit for your situation, then Item 42  includes an example of\ngenerating T ypeScript types from a schema.\nDefine T ypes with a Runtime Library\nT ypeScript’ s design  makes it impossible to derive runtime values from\nstatic types. But going the other direction (from a runtime value to a static\ntype) is straightforward using the type-level typeof  operator:\nconst val = { postId: '123', title: 'First', body: 'That is all'};\ntype ValType = typeof val;\n//   ^? type ValType = { postId: string; title: string; body: string; }\nSo one option is to define your types using runtime constructs and derive\nthe static types from those. This is typically done using a library . There are\nmany of these, but at the moment the most popular is Zod (React’ s\nPropTypes  is another example).\nHere’ s how the request validation logic would look with Zod:\nimport { z } from 'zod'; \n \n// runtime value for type validation\nconst createCommentSchema = z.object({ \n  postId: z.string(), \n  title: z.string(), \n  body: z.string(),\n}); \n \n// static type\ntype CreateComment = z.infer<typeof createCommentSchema>;\n//   ^? type CreateComment = { postId: string; title: string; body: string; } \n \napp.post('/comment', (request, response) => { \n  const {body} = request; \n  try { \n    const comment = createCommentSchema.parse(body); \n    //    ^? const comment: { postId: string; title: string; body: string; } \n    // ... application validation and logic ... \n    return response.status(200).send('ok'); \n  } catch (e) { \n    return response.status(400).send('Invalid request'); \n  }\n});\nZod has completely eliminated the duplication: the value\ncreateCommentSchema  is now the source of truth, and both the static type\nCreateComment  and the schema validation\n(createCommentSchema.parse ) are derived from that.\nZod and the other runtime type libraries are quite ef fective at solving this\nproblem. So what are the downsides to using them?\nY ou now have two ways to define types: Zod’ s syntax ( z.object ) and\nT ypeScript’ s (interface ). While these systems have many\nsimilarities, they’re not exactly the same. Y ou’re already using\nT ypeScript, so presumably your team has committed to learning how\nto define types using it. Now everyone needs to learn to use Zod as\nwell.\nRuntime type systems tend to be contagious: if createCommentSchema\nneeds to reference another type, then that type will also need to be\nreworked into a runtime type. This may make it hard to interoperate\nwith other sources of types, for example, if you wanted to reference a\ntype from an external library or generate some types from your\ndatabase ( Item 58 ).\nHaving a distinct runtime type validation system comes with a few other\nadvantages, too:\nLibraries like Zod can express many constraints that are hard to\ncapture with T ypeScript types, for example, “a valid email address” or\n“an integer .” If you don’ t use a tool like Zod, you’ll have to write this\nsort of validation yourself.\nThere’ s no additional build step. Everything is done through\nT ypeScript. If you expect your schema to change frequently , then this\nwill eliminate a failure mode and tighten your  iteration cycle.\nGenerate Runtime V alues from Y our T ypes\nIf you’re willing to introduce a new tool and build step, then there’ s another\npossibility: you can reverse the approach from the previous section and\ngenerate a runtime value from your T ypeScript type. JSON Schema is a\npopular tar get.\nT o make this work we’ll put our API types in an api.ts  file:\n// api.ts\nexport interface CreateComment { \n  postId: string; \n  title: string; \n  body: string;\n}\nthen we can run typescript-json-schema  to generate JSON Schema for\nthis type:\n$ npx typescript-json-schema api.ts '*' > api.schema.json\nHere’ s what that file looks like:\n{\n  ""$schema"": ""http://json-schema.org/draft-07/schema#"",\n  ""definitions"": {\n    ""CreateComment"": {\n      ""type"": ""object"",\n      ""properties"": {\n        ""body"": { ""type"": ""string"" },\n        ""postId"": { ""type"": ""string"" },\n        ""title"": { ""type"": ""string"" }\n      }\n    }\n  }\n}\nNow we can load api.schema.json  at runtime. If you enable T ypeScript’ s\nresolveJsonModule  option, this can be done with an ordinary import . Y ou\ncan perform validation using any JSON Schema validation library . Here we\nuse the Ajv  library:\nimport Ajv from 'ajv'; \n \nimport apiSchema from './api.schema.json';\nimport {CreateComment} from './api'; \n \nconst ajv = new Ajv(); \n \napp.post('/comment', (request, response) => { \n  const {body} = request; \n  if (!ajv.validate(apiSchema.definitions.CreateComment, body)) { \n    return response.status(400).send('Invalid request'); \n  } \n  const comment = body as CreateComment; \n  // ... application validation and logic ... \n  return response.status(200).send('ok');\n});\nThe great strength of generating values from your T ypeScript types is that\nyou can continue to use all the T ypeScript tools you know and love to\ndefine your types. Y ou don’ t need to learn a second way to define types\nsince the JSON Schema is an implementation detail. Y our API types can\nreference types from @types  or other sources since they’re just T ypeScript\ntypes.\nThe downside is that you’ve introduced a new tool and a new build step.\nWhenever you change api.ts , you’ll need to regenerate api.schema.json . In\npractice, you’d want to enforce that these stay in sync using your\ncontinuous integration system.\nWhile you don’ t typically need to access T ypeScript types at runtime, there\nare occasionally situations like input validation where it’ s extremely useful.\nW e’ve seen three approaches to this problem. So which one should you\nchoose?\nUnfortunately , there’ s no perfect answer . Each option is a trade-of f. If your\ntypes are already expressed in some other form, like an OpenAPI schema,\nthen use that as the source of truth for both your types and your validation\nlogic. This will incur some tooling and process overhead, but it’ s worth it to\nhave a single source of truth.\nIf not, then the decision is trickier . W ould you rather introduce a build step\nor a second way to define types? If you need to reference types that are only\ndefined using T ypeScript types (perhaps they’re coming from a library or\nare generated), then generating JSON Schema from your T ypeScript types\nis the best option. Otherwise, you need to pick your poison!\nThings to Remember\nT ypeScript types are erased before your code is run. Y ou can’ t access\nthem at runtime without additional tooling.\nKnow your options for runtime types: using a distinct runtime type\nsystem (such as Zod), generating T ypeScript types from values ( json-\nschema-to-typescript ), and generating values from your T ypeScript\ntypes (typescript-json-schema ).\nIf you have another specification for your types (e.g., a schema), use\nthat as the source of truth.\nIf you need to reference external T ypeScript types, use typescript-\njson-schema  or an equivalent.\nOtherwise, weigh whether you prefer another build step or another\nsystem for  specifying types.",11008
87-Item 75 Understand the DOM Hierarchy.pdf,87-Item 75 Understand the DOM Hierarchy,"I t e m  7 5 :  U n d e r s t a n d  t h e  D O M  H i e r a r c h y\nMost of the  items in this book are agnostic about where you run your\nT ypeScript: in a web browser , on a server , or on a phone. This one is\ndif ferent. If you’re not working in a browser , skip ahead to Item 76 !\nThe DOM hierarchy is always present when you’re running JavaScript in a\nweb browser . When you use document.getElementById  to get an element,\nor document.createElement  to create one, it’ s always a particular kind of\nelement, even if you’re not entirely familiar with the taxonomy . Y ou call the\nmethods and use the properties that you want and hope for the best.\nW ith T ypeScript, the hierarchy of DOM elements becomes more visible.\nKnowing your Node s from your Element s and EventTarget s will help you\ndebug type errors and decide when type assertions are appropriate. Because\nso many APIs are based on the DOM, this is relevant even if you’re using a\nframework like React or D3.\nSuppose you want to track a user ’ s mouse as they drag it across a <div> .\nY ou write some seemingly innocuous JavaScript:\nfunction handleDrag(eDown) { \n  const targetEl = eDown.currentTarget; \n  targetEl.classList.add('dragging'); \n  const dragStart = [eDown.clientX, eDown.clientY]; \n  const handleUp = (eUp) => { \n    targetEl.classList.remove('dragging'); \n    targetEl.removeEventListener('mouseup', handleUp); \n    const dragEnd = [eUp.clientX, eUp.clientY]; \n    console.log('dx, dy = ', [0, 1].map(i => dragEnd[i] - dragStart[i])); \n  } \n  targetEl.addEventListener('mouseup', handleUp);\n}\nconst surfaceEl = document.getElementById('surface');\nsurfaceEl.addEventListener('mousedown', handleDrag);\nWhen you add type annotations and run the type checker , it flags no fewer\nthan 1 1 errors in these 14 lines of code:\nfunction handleDrag(eDown: Event) { \n  const targetEl = eDown.currentTarget; \n  targetEl.classList.add('dragging'); \n  // ~~~~~           'targetEl' is possibly 'null' \n  //       ~~~~~~~~~ Property 'classList' does not exist on type 'EventTarget' \n  const dragStart = [ \n     eDown.clientX, eDown.clientY \n     //    ~~~~~~~        ~~~~~~~ Property '...' does not exist on 'Event' \n  ]; \n  const handleUp = (eUp: Event) => { \n    targetEl.classList.remove('dragging'); \n    // ~~~~~           'targetEl' is possibly 'null' \n    //       ~~~~~~~~~ Property 'classList' does not exist on type \n'EventTarget' \n    targetEl.removeEventListener('mouseup', handleUp); \n    // ~~~~~ 'targetEl' is possibly 'null' \n    const dragEnd = [ \n      eUp.clientX, eUp.clientY \n      //  ~~~~~~~      ~~~~~~~   Property '...' does not exist on 'Event' \n    ]; \n    console.log('dx, dy = ', [0, 1].map(i => dragEnd[i] - dragStart[i])); \n  } \n  targetEl.addEventListener('mouseup', handleUp); \n  // ~~~~~ 'targetEl' is possibly 'null'\n} \n \nconst surfaceEl = document.getElementById('surface');\nsurfaceEl.addEventListener('mousedown', handleDrag);\n// ~~~~~~ 'surfaceEl' is possibly 'null'\nWhat went wrong? What’ s this EventTarget ? And why might everything\nbe null ?\nT o understand the EventTarget  errors, it helps to dig into the DOM\nhierarchy a bit. Here’ s some HTML:\n<p id=""quote"">and <i>yet</i> it moves</p>\nIf you open your browser ’ s JavaScript console and get a reference to the p\nelement, you’ll see that it’ s an HTMLParagraphElement :\nconst p = document.getElementsByTagName('p')[0];\np instanceof HTMLParagraphElement\n// true\n//\nAn HTMLParagraphElement  is a subtype of HTMLElement , which is a\nsubtype of Element , which is a subtype of Node , which is a subtype of\nEventTarget . Note that these are all JavaScript runtime values, not just\nT ypeScript types. T able 9-1  lists some examples of types along the\nhierarchy .\nT able 9-1. T ypes in the DOM hierar chy\nT ype Examples\nEventTarget window , XMLHttpRequest\nNode document , Text , Comment\nElement HTMLElement s, SVGElement s\nHTMLElement <i> , <b>\nHTMLButtonElement<button>\nAn EventTarget  is the most general of all DOM types. All you can do with\nit is add event listeners, remove them, and dispatch events. W ith this in\nmind, the classList  errors start to make a bit more sense:\nfunction handleDrag(eDown: Event) { \n  const targetEl = eDown.currentTarget; \n  targetEl.classList.add('dragging'); \n  // ~~~~~           'targetEl' is possibly 'null' \n  //       ~~~~~~~~~ Property 'classList' does not exist on type 'EventTarget' \n  // ...\n}\nAs its name implies, an Event ’ s currentTarget  property is an\nEventTarget . It could even be null . T ypeScript has no reason to believe\nthat it has a classList  property . While currentTarget  may be an\nHTMLElement  in practice, from the type system’ s perspective there’ s no\nreason it couldn’ t be window  or an XMLHttpRequest . (current Tar get  is\nthe element you registered the listener on, while target  is the element\nwhere the event originated, which could have a dif ferent type.)\nMoving up the hierarchy we come to Node . Node s that are not Element s\ninclude text fragments and comments. For instance, in this HTML:\n<p> \n  And <i>yet</i> it moves \n  <!-- quote from Galileo -->\n</p>\nthe outermost element is an HTMLParagraphElement . As you can see here,\nit has children  and childNodes :\n> p.children \nHTMLCollection [i] \n> p.childNodes \nNodeList(5) [text, i, text, comment, text]\nchildren  returns an HTMLCollection , an array-like structure containing\njust the child Element s (<i>yet</i> ). childNodes  returns a NodeList , an\narray-like collection of Node s. This includes not just Element s\n(<i>yet</i> ) but also text fragments (“And,” “it moves”) and comments\n(“quote from Galileo”). (See Item 17  for a refresher on what “array-like”\nmeans.) Y ou can use array spread syntax ( [...p.childNodes] ) to get a\ntrue array if you need one.\nWhat’ s the dif ference between  an Element  and an HTMLElement ? There are\nnon-HTML Element s including the whole hierarchy of SVG tags. These\nare SVGElement s, which are another type of Element . What’ s the type of an\n<html>  or <svg>  tag? They’re HTMLHtmlElement  and SVGSVGElement . If\nyou don’ t use SVG or MathML then, in practice, all your Element s will be\nHTMLElement s.\nSometimes specialized Element  classes will have properties of their own—\nfor example, an HTMLImageElement  has a src  property , and an\nHTMLInputElement  has a value  property . If you want to read one of these\nproperties of f a value, its type must be specific enough to have that\nproperty .\nT ypeScript’ s type declarations for the DOM make liberal use of literal types\nto try to get you the most specific type possible. For example:\nconst p = document.getElementsByTagName('p')[0];\n//    ^? const p: HTMLParagraphElement\nconst button = document.createElement('button');\n//    ^? const button: HTMLButtonElement\nconst div = document.querySelector('div');\n//    ^? const div: HTMLDivElement | null\nBut this is not always possible, notably with document.getElementById :\nconst div = document.getElementById('my-div');\n//    ^? const div: HTMLElement | null\nWhile type assertions are generally frowned upon ( Item 9  explains why),\nthis is a case where you know more than T ypeScript does and so they are\nappropriate. There’ s nothing wrong with this assertion, so long as you know\nthat #my-div  is a div:\ndocument.getElementById('my-div') as HTMLDivElement;\nA runtime check will do the trick if you don’ t know:\nconst div = document.getElementById('my-div');\nif (div instanceof HTMLDivElement) { \n  console.log(div); \n  //          ^? const div: HTMLDivElement\n}\n( Item 54  explores another way to get more precise types for\nHTMLElement s.)\nW ith strictNullChecks  enabled, you’ll need to consider the case that\ndocument.getElementById  returns null . Depending on whether this can\nreally happen, you can either add an if  statement or a non-null assertion\n(! ):\nconst div = document.getElementById('my-div')!;\n//    ^? const div: HTMLElement\nThese types are not specific to T ypeScript. Rather , they are generated from\nthe formal specification of the DOM. This is an example of the advice of\nItem 42  to generate types from specs when possible.\nSo much for the DOM hierarchy . What about the clientX  and clientY\nerrors?\nfunction handleDrag(eDown: Event) { \n  // ... \n  const dragStart = [ \n     eDown.clientX, eDown.clientY \n     //    ~~~~~~~        ~~~~~~~ Property '...' does not exist on 'Event' \n  ]; \n  // ...\n}\nIn addition to the hierarchy for Node s and Element s, there is also a\nhierarchy for Event s. T ypeScript’ s lib.dom.d.ts  defines no fewer than 54\nsubtypes of Event !\nPlain Event  is the most generic type of event. More specific types include:\nUIEvent\nAny sort of user interface event\nMouseEvent\nAn event triggered by the mouse, such as a click\nTouchEvent\nA touch event on a mobile device\nKeyboardEvent\nA key press\nThe problem in handleDrag  is that the events are declared as Event , while\nclientX  and clientY  exist only on the more specific MouseEvent  type.\nSo how can you fix the example from the start of this item? Item 24\nexplained how T ypeScript makes use of context to infer more precise types,\nand the DOM declarations make extensive use of this. Inlining the\nmousedown handler gives T ypeScript more context and removes most of\nthe errors. Y ou can also declare the parameter type to be MouseEvent  rather\nthan Event .\nHere’ s a complete version of the code sample from the start of this item that\npasses the type checker:\nfunction addDragHandler(el: HTMLElement) { \n  el.addEventListener('mousedown', eDown => { \n    const dragStart = [eDown.clientX, eDown.clientY]; \n    const handleUp = (eUp: MouseEvent) => { \n      el.classList.remove('dragging'); \n      el.removeEventListener('mouseup', handleUp); \n      const dragEnd = [eUp.clientX, eUp.clientY]; \n      console.log('dx, dy = ', [0, 1].map(i => dragEnd[i] - dragStart[i])); \n    } \n    el.addEventListener('mouseup', handleUp); \n  });\n} \n \nconst surfaceEl = document.getElementById('surface');\nif (surfaceEl) { \n  addDragHandler(surfaceEl);\n}\nThe if  statement at the end handles the possibility that there is no\n#surface  element. If you know that this element exists, you could use a\nnon-null assertion instead (surfaceEl! ).  addDragHandler  requires a non-",10402
88-Item 76 Create an Accurate Model of Your Environment.pdf,88-Item 76 Create an Accurate Model of Your Environment,"null HTMLElement , following Item 33 ’ s advice to push null  values to the\nperimeter .\nThings to Remember\nThe DOM has a type hierarchy that you can usually ignore while\nwriting JavaScript. But these types become more important in\nT ypeScript. Understanding them will help you write T ypeScript for the\nbrowser .\nKnow the dif ferences between Node , Element , HTMLElement , and\nEventTarget , as well as those between Event  and MouseEvent .\nEither use a specific enough type for DOM elements and Events in\nyour code or give T ypeScript the context to infer it.\nI t e m  7 6 :  C r e a t e  a n  A c c u r a t e  M o d e l  o f  Y o u r\nE n v i r o n m e n t\nAs Item 3  explained, your T ypeScript code will eventually get converted to\nJavaScript and executed. More specifically , it will be executed by a\nparticular runtime (V8, JavaScriptCore,  SpiderMonkey) in a particular\nenvironment (a web page in a browser , a test runner in Node.js, Deno,\nElectron, etc.).\nFor T ypeScript to statically model the runtime behavior of your code, it\nneeds a model of that environment. One of your main goals in configuring a\nT ypeScript project is to ensure that this model is as accurate as possible.\nThe more accurately you model your runtime environment, the more\nef fective T ypeScript will be at finding errors in your code.\nFor example, your generated JavaScript might run in a browser where it’ s\nincluded in an HTML page:\n<script src=""path/to/bundle.js""></script>\nT ypeScript gives you a few ways to model this. One is via the lib  setting in\nyour tsconfig.json :\n{\n  ""compilerOptions"": {\n    ""lib"": [""dom"", ""es2021""]\n  }\n}\nBy including ""dom""  in ""lib"" , we tell T ypeScript that it should include type\ndeclarations for a browser . The ""es2021""  indicates that we expect the\nbrowser to have built-in support for everything in the JavaScript standard\nfrom that year (either natively or via a polyfill). Using a feature from a\nnewer version (for example, array.toSorted() ) will result in a type error .\nY ou may not know precisely which features are in each ECMAScript\nversion, but T ypeScript does. By creating an accurate model of your\nenvironment, it can help you catch this particular mistake.\nY ou can also model the types available in a web browser by installing the\n@types/web  package, which gives you a bit more control over versioning.\nItem 75  has much more to say about T ypeScript and the DOM.\nIt’ s likely that your script tag isn’ t the only one on your page. Perhaps your\nHTML actually looks like this:\n<script type=""text/javascript"">\nwindow.userInfo = { name: 'Jane Doe', accountId: '123-abc' };\n</script>\n<script src=""https://code.jquery.com/jquery-3.7.1.min.js""></script>\n<script type=""text/javascript"">\n// ... load Google Analytics ...\n</script>\n<script src=""path/to/bundle.js""></script>\nEach of those <script>  tags modifies the environment in some way ,\nadding global variables  that are available to your code. T o ensure accurate\ntype checking, you’ll need to tell T ypeScript about them.\nY ou can model the userInfo  global with a type declaration file:\n// user-info-global.d.ts\ninterface UserInfo { \n  name: string; \n  accountId: string;\n}\ndeclare global { \n  interface Window { \n    userInfo: UserInfo; \n  }\n}\nSee Item 47  for more on more on the Window  syntax here.\nY ou can model the libraries by installing their type declarations:\n$ npm install --save-dev @types/google.analytics @types/jquery\nT o get an accurate model, it’ s essential that the @types  package models the\nversion of the library that you source on your page. See Item 66  for more on\nhow to match these up. If you get this wrong, T ypeScript may report\nspurious errors or miss some real ones.\nPerhaps you’re bundling your code using webpack, which lets you import\nCSS and image files directly from JavaScript. These files are part of the\nenvironment, but T ypeScript doesn’ t know about them and will complain:\nimport sunrisePath from './images/beautiful-sunrise.jpg';\n//                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// Cannot find module './images/beautiful-sunrise.jpg' or its type \ndeclarations.\nT o make this work, you need to model these types of imports:\n// webpack-imports.d.ts\ndeclare module '*.jpg' { \n  const src: string; \n  export default src;\n}\nwebpack actually lets you import specific CSS rules from CSS modules. If\nyou use this feature, you’ll need to either add it to your model or install one",4501
89-Item 77 Understand the Relationship Between Type Checking and Unit Testing.pdf,89-Item 77 Understand the Relationship Between Type Checking and Unit Testing,"of the npm packages that does this for you.\nIt’ s possible that dif ferent parts of your application run in dif ferent\nenvironments. For example, your app might have client code that runs in a\nbrowser and server code that runs under Node.js, not to mention test code\nthat runs in its own environment. Since these are distinct environments,\nyou’ll want to model them separately . The usual way to do this is with\nmultiple tsconfig.json  files and project references, which are discussed in\nItem 78 .\nAs with the browser , make sure you model the Node.js environment\naccurately . If you run your code using Node.js version 20, make sure you\ninstall that version of @types/node . This will ensure that you only use the\nlibrary features that are available to you at runtime.\nThings to Remember\nY our code runs in a particular environment. T ypeScript will do a better\njob of checking your code if you create an accurate static model of that\nenvironment.\nModel global variables and libraries that are loaded onto a web page\nalong with your code.\nMatch versions between type declarations and the libraries and runtime\nenvironment that you use.\nUse multiple tsconfig.json  files and project references to model distinct\nenvironments within a single project (for example client and server).\nI t e m  7 7 :  U n d e r s t a n d  t h e  R e l a t i o n s h i p\nB e t w e e n  T y p e  C h e c k i n g  a n d  U n i t  T e s t i n g\nY ou sometimes  hear claims that adopting T ypeScript lets you delete most of\nyour unit tests. Or , flipping the ar gument around, that there’ s no point in\nadding types to your code since you’ll still need to write unit tests.\nThese are both extreme positions, but there is an interesting distinction\nhiding behind the bluster . Unit tests and type checking are both forms of\nprogram verification. So what’ s the relationship between the two? When\nshould you write tests, and when should you rely on types?\nLet’ s consider a function that adds two numbers:\n/** Returns the sum of the two numbers. */\nfunction add(a, b) { \n  // implementation omitted\n}\nIf this seems too simple to test, then take a quick look at the IEEE 754\nfloating point spec. There are quite a few corner cases! Here’ s what a unit\ntest might look like:\ntest('add', () => { \n  expect(add(0, 0)).toEqual(0); \n  expect(add(123, 456)).toEqual(579); \n  expect(add(-100, 90)).toEqual(-10);\n});\nAssuming these tests pass, how confident should we be in the correctness of\nthe add  function? There are an enormous number of possible inputs.\nNumbers in JavaScript are 64-bit floats, so there are 264 possible values for\neach parameter , or 2128 possible inputs in total. That’ s an enormous number:\nit starts with 3 and is followed by 38 more digits.  Our three test cases only\ncover an infinitesimal fraction of the possibilities.\nThese gaps create space for bugs to creep in. For example, what if this were\nthe implementation?\nfunction add(a, b) { \n  if (isNaN(a) || isNaN(b)) { \n    return 'Not a number!'; \n  } \n  return (a|0) + (b|0);\n}\nThis passes our unit test. But the behavior with NaN  values is surprising and\nprobably misguided (it should certainly be called out in the\ndocumentation!). The ef fect of the bitwise operations is to round the inputs\ntoward zero before adding them. Presumably , the function should add\nnonintegers, too. Unless we specifically wrote unit tests for these cases, we\nwouldn’ t be able to catch these bugs.\nNow let’ s see what happens if you add types:\nfunction add(a: number, b: number): number { \n  if (isNaN(a) || isNaN(b)) { \n    return 'Not a number!'; \n    // ~~~ Type 'string' is not assignable to type 'number'. \n  } \n  return (a|0) + (b|0);\n}\nThanks to our type annotations, T ypeScript has been able to spot one of the\nbugs. There are whole classes of implementation errors that it can prevent:\nreturning the wrong type or performing invalid operations on the inputs.\nY ou could write a unit test to check that add  returns a number , but you’d\nnever be able to test this for all 2128 possible inputs. T ypeScript has.\nOf course, there are many mistakes that the type checker can’ t catch. It\ndoesn’ t catch the issue with decimals versus integers. In fact, here’ s another\nimplementation that passes the type checker but is clearly wrong:\nfunction add(a: number, b: number): number { \n  return a - b; // oops!\n}\nAny unit test where b  is non-zero would catch this bug, but the type checker\nis blind to it.\nUnit tests and type checking are complementary processes. Unit tests\ndemonstrate that your code behaves correctly in at least some situations. In\nother words, they provide a lower bound on correctness. A type checker can\nprove that you haven’ t made a particular class of errors, say returning the\nwrong type. It provides an upper bound on incorrectness. Y ou can think of\nthe two processes as whittling away at the bugs from both ends until you’re\nsatisfied that your code works well enough.\nRegardless of what the documentation or types say , in JavaScript, functions\ncan be called with any type of ar gument. In addition to adding numbers, the\nsimple version of the add  function ( return a+b ) has the following\nbehavior:\n> add(null, null) \n0 \n> add(null, 12) \n12 \n> add(undefined, null) \nNaN \n> add('ab', 'cd') \n'abcd'\nShould you test these behaviors? T ypeScript is unhappy if you do:\ntest('out-of-domain add', () => { \n  expect(add(null, null)).toEqual(0); \n  //         ~~~~ Type 'null' is not assignable to parameter of type 'number'. \n  expect(add(null, 12)).toEqual(12); \n  //         ~~~~ Type 'null' is not assignable to parameter of type 'number'. \n  expect(add(undefined, null)).toBe(NaN); \n  //         ~~~~~~~~~ Type 'undefined' is not assignable to parameter of ... \n  expect(add('ab', 'cd')).toEqual('abcd'); \n  //         ~~~~ Type 'string' is not assignable to parameter of type \n'number'.\n});\nThis makes sense. Unit tests are about demonstrating expected behavior .\nFor invalid inputs, there is no expected behavior to demonstrate. Y ou should\nrely on the type checker to prevent these invalid calls. There’ s no need to\nwrite these sorts of unit tests.\nThere’ s an important caveat to this for functions that have potentially\nharmful side ef fects. Imagine you have a function that updates a user record\nin a database:\ninterface User { \n  id: string; \n  name: string; \n  memberSince: string;\n} \n \ndeclare function updateUserById( \n  id: string, \n  update: Partial<Omit<User, 'id'>> & {id?: never}\n): Promise<User>;\nThe intention of the elaborate type on the update  parameter is that this\nfunction really shouldn’ t be used to change a user ’ s ID. ( Item 63  explains\nthe “optional never” trick.) Doing so might cause a collision or even a\nsecurity issue if it allows one user to impersonate another . But this is only\nenforced at the type level. If you call this function from JavaScript, perhaps\neven with untrusted user input, then it’ s entirely possible that the update\nar gument will have an id  property . It would be better if the function threw\nan exception (i.e., rejected) rather than corrupting the database.\nThis is a good behavior to specify and test, even if it’ s disallowed by the\ntypes. Y ou can use an @ts-expect-error  directive in your test to assert\nthat it’ s a type error:\ntest('invalid update', () => { \n  // @ts-expect-error Can't call updateUserById to update an ID. \n  expect(() => updateUserById('123', {id: '234'})).toReject();\n});\nOne of the main goals in software quality assurance (QA) is to find\nproblems as soon as possible, when the cost of fixing them is low . The\nworst way to learn about a bug is to have an end user (or a security\nresearcher!) report it when it’ s already in production. Better , but still\nexpensive, is to catch it as part of a manual QA process. Better yet is an\nautomated QA process, say an integration test. Unit tests catch bugs even\nearlier and more quickly . But type checking is the most immediate of all,\nreporting bugs right in your editor , hopefully in the exact place that you\nmade a mistake.",8182
90-Item 78 Pay Attention to Compiler Performance.pdf,90-Item 78 Pay Attention to Compiler Performance,"T o catch bugs as quickly as possible, you should rely on the type checker\nwhere you can. T ypeScript can catch many errors, but sometimes it requires\na bit of help. Items 59 , 61 , and 64  all present techniques for helping the type\nchecker catch new classes of errors. But when you can’ t rely on type\nchecking, namely for testing behaviors, unit tests are the next best option.\nIf your types themselves contain logic ( Chapter 6  is all about this), then you\nabsolutely need to write tests for them. T ype tests are a dif ferent sort of test\nthan unit tests. Item 55  explores the fascinating world of type testing.\nFinally , while both types and unit tests will help catch bugs when you\nrefactor , types also power the language services that make programming a\nmore enjoyable experience. As Item 6  explained, they can even do the\nrefactoring for you!\nUnit tests and type checking are both forms of program verification, but\nthey work in dif ferent and complementary ways. Y ou typically want both.\nKeep their respective roles clear and avoid repeating the same checks with\nboth.\nThings to Remember\nT ype checking and unit testing are dif ferent, complementary\ntechniques for demonstrating program correctness. Y ou want both.\nUnit tests demonstrate correct behavior on particular inputs, while type\nchecking eliminates whole classes of incorrect behaviors.\nRely on the type checker to check types. W rite unit tests for behaviors\nthat can’ t be checked with types.\nA void testing inputs that would be type errors unless there are\nconcerns about security or data corruption.\nI t e m  7 8 :  P a y  A t t e n t i o n  t o  C o m p i l e r\nP e r f o r m a n c e\nAs Item 3  explained, T ypeScript types are erased when you compile your\ncode to JavaScript. So generally speaking, T ypeScript has zero impact on\nthe runtime performance of your code.\nT ypeScript can  have an impact on the performance of your developer\ntooling, however . T ypeScript comes with two executables, tsc  and\ntsserver  ( Item 6 ). It makes sense to talk about the performance of both of\nthem:\ntsc , the T ypeScript compiler\nSlow performance here means that your code will take longer to type\ncheck as part of a batch process (perhaps on your CI system) and will\ntake longer to produce build artifacts ( .js  and .d.ts  files).\ntsserver , the T ypeScript Language Service\nSlow performance here means that your editor might feel sluggish or\nunresponsive. It may take a frustratingly long time for errors to appear\nor disappear after you change your code.\nIf build or editor performance becomes a problem on your project, there are\nmany techniques available that might help. This item will look at a few of\nthe most impactful. For each it will say which type of performance it\nimpacts.\nSeparate T ype Checking from Building\nThis  only af fects tsc  (build) performance, not tsserver  (editor).\nAt a high level, T ypeScript does two things: it checks your code for type\nerrors and it emits JavaScript. The type checking is typically the more CPU\nintensive of the two. If you don’ t need the type checking, then skipping this\nstep can be a huge time saver .\nAt first blush, this may sound like a strange thing to do. Isn’ t type checking\nthe whole point of using T ypeScript instead of JavaScript? In practice,\nthough, you may be running T ypeScript indirectly via some other tool,\nperhaps a bundler ( webpack , vite , etc.) or ts-node . By default, these tools\nwill type check your code and then bundle or run the generated JavaScript.\nBut they don’ t need  to do this. Y ou can tell any of them to run in “transpile\nonly” mode to skip the checking.\nThis can make a noticeable dif ference even for trivial programs:\n// hello.ts\nconsole.log('Hello World!');\nHere’ s how quickly this runs with and without type checking using ts-\nnode :\n$ time ts-node --transpileOnly hello.ts \nHello World! \nts-node --transpileOnly hello.ts  0.12s user 0.02s system 110% cpu 0.123 total \n$ time ts-node hello.ts \nHello World! \nts-node hello.ts  1.60s user 0.08s system 255% cpu 0.656 total\nThis trivial program took 1.6 seconds to run with type checking but only\n0.12 seconds without. If ts-node  or a bundler is part of your toolchain,\nturning of f type checking can significantly tighten your iteration cycle and\nimprove your developer experience (DX). Y ou may even be able to plug in\nan alternative T ypeScript compiler , such as swc , to get a bigger speedup.\nOf course, type checking is still important! Y ou’ll still get type errors as you\ndevelop code in your editor (via tsserver ), and you should make sure to\nrun tsc  on your CI service to make sure you only commit code that passes\nthe type checker .\nPrune Unused Dependencies and Dead Code\nThis af fects both build and editor performance.\nThe less code you have, the faster T ypeScript can process it. Fewer types\nand symbols also means lower RAM usage by tsserver , which will make\nyour editor more responsive.\nOne good way to shrink your project is via dead code elimination. If you set\nthe noUnusedLocals  flag, T ypeScript will detect some unused code and\ntypes:\nfunction foo() {}\n//       ~~~ 'foo' is declared but its value is never read. \n \nexport function bar() {}\nThis works well for un-exported symbols. But an exported symbol might be\nunused, too, if it’ s never imported anywhere. T o detect that, you’ll need a\nmore sophisticated tool like knip . This will also report unused third-party\ndependencies (e.g., node modules). Removing these can be a huge win\nsince their type declarations may be many thousands of lines.\nIn fact, it’ s likely that the majority of the types in your project come from\nthird-party code. Y ou can run tsc --listFiles  to get a printout of all the\nsources that go into your T ypeScript project:\n$ tsc --listFiles \n.../lib/node_modules/typescript/lib/lib.es5.d.ts \n.../lib/node_modules/typescript/lib/lib.es2015.d.ts \n.../lib/node_modules/typescript/lib/lib.es2016.d.ts \n.../lib/node_modules/typescript/lib/lib.es2017.d.ts \n...\nThe results may surprise you! Sometimes one dependency can pull in\nhundreds or thousands of others ( Item 70  describes a way to avoid this). A\ngood way to visualize this is with a treemap. Since tsc  will spend more\ntime on a lar ge file than a small file, you’ll want to visualize the number of\nbytes in each file being compiled.\nHere’ s the magic incantation (the stat  syntax may vary depending on your\nplatform):\n$ tsc --noEmit --listFiles | xargs stat -f ""%z %N"" | npx webtreemap-cli\nFor one of the author ’ s projects, the results looked like Figure 9-8 .\nFigur e 9-8. T r eemap of the files that T ypeScript considers, weighted by file size.\nThis is a lot of code: nearly 1 10 MB! And most of it is evidently Google\nAPIs? Many of these were APIs (compute, dialogflow , dfareporting,\nhealthcare) that my project did not use. As it turned out, Google bundled all\n300+ of its APIs as a single package, weighing in at an impressive 80.5\nMB. My project depended on only one or two APIs, but this design meant\nthat it still pulled in all three hundred of them.\nIn this case, updating to a newer version of googleapis fixed the issue since\nthey added support for depending on just one API. If a dependency is\nparticularly lar ge, you may want to look into alternatives. Y ou may also\nnotice that you’re pulling in multiple versions of the same library . The\nsolution is to update versions until your dependencies align ( Item 66 ).\nRegardless of the actions you take, the treemap visualization will make you\nmore aware of what you’re building and put you on the scent of potential\nissues. Before looking at my treemap, I hadn’ t thought much about my\nproject’ s use of googleapis. Afterwards, I couldn’ t  think of much else!\nIncremental Builds and Project References\nThese only af fect build ( tsc ) performance.\nIf you run tsc  twice in a row , it will repeat all its work on the second\ninvocation. But if you set the incremental  option, it will do something\nsmarter: on the first invocation, it will write a .tsbuildinfo  file that saves\nsome of the work it’ s done. On the second invocation, it will read that file\nand use it to check your types more quickly .\nT ypeScript lets you take this incremental approach a step further with\n“Project references.” The idea here is that if your code base has distinct\nparts (say client/server or source/test), then changes to one should have a\nlimited ef fect on the other . In particular , if you change the implementation\nof a function in your source (but not its type signature), then T ypeScript\nshouldn’ t have to redo type checking for your tests. And no change to the\ntests should require T ypeScript to redo type checking for your source.\nT o set up project references, you create a tsconfig.json  file for each distinct\npart of your repo. These files say which other parts of your code they can\nreference. Y our tests will reference your source, but not the other way\naround. Y ou also typically have a top-level tsconfig.json  for shared\nconfiguration. Here’ s what the setup might look like:\nroot \n├── src \n│   ├── fib.ts \n│   └── tsconfig.json \n├── test \n│   ├── fib.test.ts \n│   └── tsconfig.json \n├── tsconfig-base.json \n└── tsconfig.json\nHere’ s what these files look like:\n// tsconfig-base.json\n{\n  ""compilerOptions"": {\n    // other settings\n    ""declaration"": true,\n    ""composite"": true\n  }\n}\n// tsconfig.json\n{\n  ""files"": [],\n  ""references"": [\n    { ""path"": ""./src"" },\n    { ""path"": ""./test"" }\n  ]\n}\n// src/tsconfig.json\n{\n  ""extends"": ""../tsconfig-base.json"",\n  ""compilerOptions"": {\n    ""outDir"": ""../dist/src"",\n    ""rootDir"": "".""\n  }\n}\n// src/fib.ts\nexport function fib(n: number): number { \n  if (n < 2) { \n    return n; \n  } \n  return fib(n - 1) + fib(n - 2);\n}\n// test/tsconfig.json\n{\n  ""extends"": ""../tsconfig-base.json"",\n  ""compilerOptions"": {\n    ""outDir"": ""../dist/test"",\n    ""rootDir"": "".""\n  },\n  ""references"": [\n    { ""path"": ""../src"" }\n  ]\n}\n// test/fib.test.ts\nimport {fib} from '../src/fib'; \n \ndescribe('fib', () => { \n  it('should handle base cases', () => { \n    expect(fib(0)).toEqual(0); \n    expect(fib(1)).toEqual(1); \n  }) \n \n  it('should handle larger numbers', () => { \n    expect(fib(2)).toEqual(1); \n    expect(fib(3)).toEqual(2); \n    expect(fib(4)).toEqual(3); \n    expect(fib(5)).toEqual(5); \np(())q();\n    expect(fib(16)).toEqual(987); \n  });\n});\nThat’ s a lot of configuration! Here are the interesting bits:\nThe src  and test  tsconfig.json  inherit a shared base configuration that\nsets composite  and declaration  (to output .d.ts  files).\nThe top-level tsconfig.json  consists only of a list of references to\nsubprojects.\nThe test  tsconfig.json  references src  but not the other way around.\nW ith this setup in place, you can run tsc  with the -b  / --build  flag to\nmake it act as a sort of build coordinator . After a first run, if you make a\nchange to sr c/fib.ts  that does not af fect the API, you’ll see something like\nthis:\n$ tsc -b -v \nProject 'src/tsconfig.json' is out of date because output \n  'dist/src/tsconfig.tsbuildinfo' is older than input 'src/fib.ts' \nBuilding project 'src/tsconfig.json'... \nProject 'test/tsconfig.json' is up to date with .d.ts files from its \n  dependencies \nThe last line is the important one. Our change didn’ t af fect the .d.ts  files (it\nwas an implementation change, not an API change), so the test project\ndidn’ t need to be rebuilt.\nThere are a few caveats to be aware of with project references:\nIn order for them to be useful, you must have declaration  set, so that\ntsc  outputs .d.ts  files on disk. If you  use noEmit  or run tsc  via\nwebpack , vite , or some other tool, then project references won’ t help\nyou.\nProject references are most useful in lar ge monorepos. The general\nrule of thumb is that they’re helpful primarily if you have more first-\nparty code than third-party code (i.e., more lines of your own code\nthan in node modules). This is rarely the case for small- to medium-\nsized projects, but it’ s often the case at lar ge corporations.\nWhile creating a small number of projects can speed up your\ninteractions with T ypeScript, creating too many can do the opposite.\nT ry to scope projects to lar ge chunks of your code. Creating distinct\nprojects for src  and test , or client  and server , will be a win on\nlar ge apps. But creating a separate project for each of your thousand\nUI components will create or ganizational overhead and is unlikely to\nimprove  T ypeScript performance.\nSimplify Y our T ypes\nThis af fects both build and editor performance.\nSuppose you want to create a type to represent a year . Item 29  encouraged\nyou to craft types that can only represent valid states, so you craft a type\nthat should hold up for the rest of the millennium:\ntype Digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';\ntype Year = `2${Digit}${Digit}${Digit}`;\nconst validYear: Year = '2024';\nconst invalidYear: Year = '1999';\n//    ~~~~~~~~~~~ Type '""1999""' is not assignable to type\n//                '""2000"" | ""2001"" | ""2002"" | ... 996 more ... | ""2999""'.\nWhile it’ s interesting that we can represent this type using T ypeScript’ s type\nsystem, it may not be wise. The error hints at why: the Year  type is a union\nwith a thousand elements! Every time T ypeScript has to do something with\nthis type, it will have to check all of these. This is likely to make tsc  and\ntsserver  sluggish. Better to use something simpler like a string  or a\nnumber , or even a branded type ( Item 64 ) if you want to model this\ndistinctly .\nThis is an extreme example, but enormous unions do sometimes arise, and\nyou should be aware that they can be a performance problem. Other ways to\nmake your types more ef ficient include:\nExtend interface s rather than intersecting type  aliases. Item 13  goes\ninto great detail about the similarities and dif ferences between type\nand interface . Usually they are interchangeable. But for subtyping,\nT ypeScript is able to operate more ef ficiently with extends .\nAnnotating return types. Item 18  discusses the pros and cons of adding\ntype annotations, but providing explicit annotations on the return type\nof functions can save T ypeScript work in inferring the type.\nY ou should be particularly careful if you’re writing complex recursive\ntypes. Item 57  goes into more detail about how to keep these from blowing\nup.\nThings to Remember\nThere are two forms of T ypeScript performance issues: build\nperformance ( tsc ) and editor latency ( tsserver ). Recognize the\nsymptoms of each and direct your optimizations accordingly .\nKeep type checking separate from your build process.\nRemove dead code and dependencies, and be on guard for code bloat\nin type dependencies. Use a treemap to visualize what T ypeScript is\ncompiling.\nUse incremental builds and project references to reduce the work tsc\ndoes between builds.\nSimplify your types: avoid lar ge unions, use interface  extension\nrather than intersection types, and consider annotating function return\ntypes.",15256
91-Item 79 Write Modern JavaScript.pdf,91-Item 79 Write Modern JavaScript,"Chapter 10. Modernization and\nMigration\nY ou’ve heard that T ypeScript is great. Y ou also know from painful\nexperience that maintaining your 15-year -old, 100,000-line JavaScript\nlibrary isn’ t. If only it could become a T ypeScript library!\nThis chapter of fers some advice about migrating your JavaScript project to\nT ypeScript without losing your sanity or abandoning the ef fort.\nThe less code you have, the easier it will be to migrate. So it’ s a good idea\nto remove deprecated features and do a round of dead code elimination\nbefore you start a T ypeScript migration. Y ou may want to hold of f on other\nforms of modernization, however: converting a jQuery web app to React\nwill actually be much easier once you’ve adopted T ypeScript.\nOnly the smallest codebases can be migrated in one fell swoop. The key for\nlar ger projects is to migrate gradually . Item 81  discusses how to do this. For\na long migration, it’ s essential to track your progress and make sure you\ndon’ t backslide. This creates a sense of momentum and inevitability to the\nchange. Item 82  discusses ways to do this.\nMigrating a lar ge project to T ypeScript won’ t necessarily be easy , but it\ndoes of fer a huge potential upside. A 2017 study found that 15% of bugs\nfixed in JavaScript projects on GitHub could have been prevented with\nT ypeScript.1 Even more impressive, a survey of 6 months’ worth of\npostmortems at Airbnb found that 38% of them could have been prevented\nby T ypeScript.2 If you’re advocating for T ypeScript at your or ganization,\nstats like these will help! So will running some experiments and finding\nearly adopters. Item 80  discusses how to experiment with T ypeScript before\nyou begin migration.\nSince this chapter is lar gely about JavaScript, many of the code samples are\neither pure JavaScript (and not expected to pass the type checker) or\nchecked with looser settings (e.g., with noImplicitAny  of f). W e’ll make\noccasional reference to the author ’ s dygraphs charting library in this chapter\nas an example of legacy code in need of modernization and migration.\ndygraphs is a venerable old JavaScript library that saw its most active\nperiod of development from 2009–2016.\nI t e m  7 9 :  W r i t e  M o d e r n  J a v a S c r i p t\nIn addition  to checking your code for type safety , T ypeScript compiles it to\nany version of JavaScript, all the way back to 2009 vintage ES5. Since\nT ypeScript is a superset of the latest  version of JavaScript, this means that\nyou can use tsc  as a “transpiler”: something that takes new JavaScript and\nconverts it to older , more widely supported JavaScript.\nT aking a dif ferent perspective, this means that when you decide to convert\nan existing JavaScript codebase to T ypeScript, there’ s no downside to\nadopting all the latest JavaScript features. In fact, there’ s quite a bit of\nupside: because T ypeScript is designed to work with modern JavaScript,\nmodernizing your JS is a great first step toward adopting T ypeScript.\nAnd because T ypeScript is a superset of JavaScript, learning to write more\nmodern and idiomatic JavaScript means you’re learning to write better\nT ypeScript, too.\nThis item presents some of the highlights of modern JavaScript, which I’m\ndefining here as everything introduced in ES2015 (aka ES6) and after . This\nmaterial is covered in much greater detail in other books and online. If any\nof the topics mentioned here are unfamiliar , you owe it to yourself to learn\nmore about them. T ypeScript can be tremendously helpful when you’re\nlearning a new language feature like async /await : it almost certainly\nunderstands the feature better than you do and can guide you toward correct\nusage.\nThese features are all worth understanding, but by far the most important\nfor adopting T ypeScript are ECMAScript modules and ES2015 classes.\nW e’ll look at those first and then quickly list some of the other highlights. If\nyour project is already using these features, then count your blessings! Y our\nmigration will be much easier .\nUse ECMAScript Modules\nBefore the 2015 version of ECMAScript (ES) there was no standard way to\nbreak your code into separate modules. There were many solutions, from\nmultiple <script>  tags, manual concatenation, and Makefiles, to Node.js-\nstyle require  statements  or AMD-style define  callbacks. T ypeScript even\nhad its own module system ( Item 72 ).\nT oday there is one standard: ECMAScript modules, aka import  and\nexport . If your JavaScript codebase is still a single file, if you use\nconcatenation or one of the other module systems, it’ s time to switch to ES\nmodules. This may require setting up a tool like webpack or ts-node.\nT ypeScript works best with ES modules, and adopting them will facilitate\nyour transition, not least because it will allow you to migrate modules one\nat a time (see Item 82 ).\nThe details will vary depending on your setup, but if you’re using\nCommonJS like this:\n// CommonJS\n// a.js\nconst b = require('./b');\nconsole.log(b.name); \n \n// b.js\nconst name = 'Module B';\nmodule.exports = {name};\nthen the ES module equivalent would look like:\n// ECMAScript module\n// a.ts\nimport * as b from './b';\nconsole.log(b.name); \n \n// b.ts\nexport const name = 'Module B';\nY ou can adopt ES modules in your T ypeScript without adopting them in the\ngenerated JavaScript, which may be a more dif ficult change. If you set the\nmodule  option to ""commonjs""  in your tsconfig.json , for example,\nT ypeScript would compile the second code sample to the  first one.\nUse Classes Instead of Prototypes\nJavaScript has a flexible prototype-based object model. But by and lar ge, JS\ndevelopers have ignored this in favor of a more rigid class-based model.\nThis was of ficially codified in the language with the introduction of the\nclass  keyword in ES2015.\nIf your code uses prototypes in a straightforward way , switch to using\nclasses. That is, instead of:\nfunction Person(first, last) { \n  this.first = first; \n  this.last = last;\n} \n \nPerson.prototype.getName = function() { \n  return this.first + ' ' + this.last;\n} \n \nconst marie = new Person('Marie', 'Curie');\nconsole.log(marie.getName());\nwrite:\nclass Person { \n  constructor(first, last) { \n    this.first = first; \n    this.last = last; \n  } \n \n  getName() { \n    return this.first + ' ' + this.last; \n  }\n} \n \nconst marie = new Person('Marie', 'Curie');\nconsole.log(marie.getName());\nT ypeScript struggles with the prototype version of Person  but understands\nthe class-based version with minimal annotations. If you’re unfamiliar with\nthe syntax, T ypeScript will help you get it right.\nFor code that uses older -style classes, the T ypeScript language service\nof fers a “Convert function to an ES2015 class” quick fix that can speed this\nup ( Figure 10-1 ).\nFigur e 10-1. The T ypeScript language service offers a quick fix to convert older -style classes to\nES2015 classes.\nOther Features\nAdopting ES2015 modules and classes will have the greatest impact on\nfacilitating your code’ s migration to T ypeScript. But there are many other\nnew features of JavaScript: a new version comes out every year! Having at\nleast a passing familiarity with them will help you write more succinct and\nidiomatic JavaScript, and hence T ypeScript. If any of the features in this list\naren’ t familiar to you, do some Googling to learn more. Even just knowing\nthe name of the feature can be helpful.\nUse let  and const  instead of var  to declare variables. The reason is\nthat var  has some quirky scoping rules. If you’re curious to learn more\nabout them, read Effective JavaScript . But better to avoid var  and not\nworry!\nUse for-of  or array methods like map  instead of C-style for(;;)\nloops. The  three-part C-style for  loop introduces an index variable\nthat you may not otherwise need, is easier to get wrong, and doesn’ t\nadapt as well to iterators (as described in Item 17 ). See Item 60  for\nmore on how to iterate over objects in T ypeScript.\nUse async  and await  for  asynchronous functions instead of callbacks\nor raw Promises. This is covered in detail in Item 27 .\nPrefer arrow functions to function expressions because they’re more\nconcise and they preserve  the this  value from their surrounding\ncontext. Item 69  explains this  binding.\nUse default parameter values. T raditionally you’d set default values on\nfunction parameters in the implementation, but in modern JavaScript\nyou can put the default value directly in the declaration ( function\nfoo(param=123) {} ). In T ypeScript this has the added advantage that\nit allows the parameter ’ s type to be inferred from the default value.\nUse compact object literals and destructuring assignment. Rather than\nwriting {x: x} , you can just write {x} . This encourages consistent\nnaming of variables. Conversely you can write [x, y] = pair  to\nunpack values from an array (or object). This works particularly well\nwith T ypeScript tuple types.\nUse Map  and Set  instead  of objects for associative arrays. If you’ve\never tried to read the string ""constructor""  or ""prototype""  of f of an\nobject, you’ll know why . The ES2015 containers avoid the many\nproblems that stem from JavaScript’ s conflation of objects and\nassociative arrays.\nUse optional chaining to facilitate working with nullable values.\nRather than writing x && x.y , you can just write x?.y . Y ou can also\nuse this to conditionally call a function that could be undefined : fn.?\n() . But, as Items 33  and 37  explain, better still to avoid null  values\naltogether .\nUse “nullish coalescing” ( ?? ) to fill in default values instead of || . If x\nis 0 , then x || 10  evaluates to 10 , whereas x ?? 10  will be 0 .\nConflating truthiness and nullishness is a common source of bugs. Y ou\ngenerally want to check for null , and ??  helps you do that.\nDon’ t bother  with ""use strict"" . This enables “strict mode,” an ES5\n(2009) innovation that opts you into a less error -prone variant of the\nlanguage. T ypeScript is more strict than strict mode. It will even\ninclude ""use strict""  in its output JS when you’re in module mode\n(i.e., import  and export ) to keep you in strict mode at runtime. In\nother words, putting ""use strict""  in your T ypeScript source has no\nef fect.\nThese are just a few of the many new JavaScript features that T ypeScript\nlets you use. TC39, the body that governs JS standards, is very active, and\nnew features are added year to year . The T ypeScript team is currently\ncommitted to implementing any feature  that reaches stage 3 (out of 4) in the\nstandardization process, so you don’ t even have to wait for the ink to dry .\nCheck out the TC39 GitHub repo  for the latest. As of this writing, the\nPipeline, Records, and T uples proposals in particular have great potential to\nimpact T ypeScript.\nThings to Remember",10934
92-Item 80 Use ts-check and JSDoc to Experiment with TypeScript.pdf,92-Item 80 Use ts-check and JSDoc to Experiment with TypeScript,"T ypeScript lets you write modern JavaScript whatever your runtime\nenvironment. T ake advantage of this by using the language features it\nenables. In addition to improving your codebase, this will help\nT ypeScript understand your code.\nAdopt ES modules ( import /export ) and classes to facilitate your\nmigration to T ypeScript.\nUse T ypeScript to learn about language features like classes,\ndestructuring, and async /await .\nCheck the TC39 GitHub repo and T ypeScript release notes to learn\nabout all the latest language features.\nI t e m  8 0 :  U s e  @ t s - c h e c k  a n d  J S D o c  t o\nE x p e r i m e n t  w i t h  T y p e S c r i p t\nBefore you begin the process of converting your source files from\nJavaScript to T ypeScript ( Item 81 ), you may want to experiment with type\nchecking to get an initial read on the sorts of issues that will come up.\nT ypeScript’ s @ts-check  directive lets you do exactly this. It directs the type\nchecker to analyze a single file and report whatever issues it finds. Y ou can\nthink of it as an extremely loose version of type checking: looser even than\nT ypeScript with noImplicitAny  of f.\nHere’ s how it works:\n// @ts-check\nconst person = {first: 'Grace', last: 'Hopper'};\n2 * person.first\n//  ~~~~~~~~~~~~ The right-hand side of an arithmetic operation must be of \ntype\n//               'any', 'number', 'bigint' or an enum type\nT ypeScript infers the type of person.first  as string , so 2 *\nperson.first  is a type error , no type annotations required.\nWhile it may surface this sort of blatant type error , or functions called with\ntoo many ar guments, in practice, @ts-check  tends to turn up a few specific\ntypes of errors.\nUndeclared Globals\nIf these  are symbols that you’re defining, then declare them with let  or\nconst . If they are “ambient” symbols that are defined elsewhere (in a\n<script>  tag in an HTML file, for instance), then you can create a type\ndeclaration file to describe them. For example, if you have JavaScript like\nthis:\n// @ts-check\nconsole.log(user.firstName);\n//          ~~~~ Cannot find name 'user'\nthen you could create a file called types.d.ts :\ninterface UserData { \n  firstName: string; \n  lastName: string;\n}\ndeclare let user: UserData;\nY ou may need to adjust your tsconfig.json  file so that T ypeScript is aware\nof this file. If it is, it will make the error disappear .\nThis types.d.ts  file is a valuable artifact because it models the environment\nin which your code runs ( Item 76 ). It will become the basis for your\nproject’ s type declarations.\nUnknown Libraries\nIf you’re using a third-party library , T ypeScript needs to know about it. For\nexample, you might use jQuery to set the size of an HTML element. W ith\n@ts-check , T ypeScript will flag an error:\n// @ts-check\n$('#graph').style({'width': '100px', 'height': '100px'});\n// Error: Cannot find name '$'\nThe solution is to install the type declarations for jQuery:\n$ npm install --save-dev @types/jquery\nNow the error is specific to jQuery:\n// @ts-check\n$('#graph').style({'width': '100px', 'height': '100px'});\n//          ~~~~~ Property 'style' does not exist on type \n'JQuery<HTMLElement>'\nIn fact, it should be .css , not .style .\n@ts-check  lets you take advantage of the T ypeScript declarations for\npopular JavaScript libraries without migrating to T ypeScript yourself. This\nis one of the best reasons to use it. Make sure you install the types for the\nversion of the libraries that you’re using. Item 66  explains how to do this\nand discusses what can go wrong if you have mismatched versions.\nDOM Issues\nAssuming you’re writing code that runs in a web browser , T ypeScript is\nlikely to flag issues around your handling of DOM elements. For example:\n// @ts-check\nconst ageEl = document.getElementById('age');\nageEl.value = '12';\n//    ~~~~~ Property 'value' does not exist on type 'HTMLElement'\nItem 75  is all about how the DOM is typed and how to resolve these sorts of\nerrors in T ypeScript code. As a quick recap, the issue is that only\nHTMLInputElement s have a value  property , but\ndocument.getElementById  returns the more generic HTMLElement .\nIf you know that the #age  element really is an input  element, then this is\nan appropriate time to use a type assertion. But this is still a JS file, so you\ncan’ t write as HTMLInputElement . Instead, you can assert a type using\nJSDoc:\n// @ts-check\nconst ageEl = /** @type {HTMLInputElement} */(document.getElementById('age'));\nageEl.value = '12';  // OK\nIf you mouse over ageEl  in your editor , you’ll see that T ypeScript now\nconsiders it an HTMLInputElement . T ake care as you type the JSDoc @type\nannotation: the parentheses after the comment are required.\nThis leads us to the next type of error that comes up with @ts-check :\ninaccurate JSDoc.\nInaccurate JSDoc\nIf your project already has JSDoc-style comments, T ypeScript will begin\nchecking them when you flip on @ts-check . If you previously used a tool\nlike Google’ s Closure Compiler that used these comments for type\nchecking, then this shouldn’ t cause major headaches. But you may be in for\nsome surprises if your comments were more like “aspirational JSDoc”:\n// @ts-check\n/**\n * Gets the size (in pixels) of an element.\n * @param {Node} el The element\n * @return {{w: number, h: number}} The size\n */\nfunction getSize(el) { \n  const bounds = el.getBoundingClientRect(); \n  //                ~~~~~~~~~~~~~~~~~~~~~ \n  //     Property 'getBoundingClientRect' does not exist on type 'Node' \n  return {width: bounds.width, height: bounds.height}; \n  //      ~~~~~ Type '{ width: any; height: any; }' is not \n  //            assignable to type '{ w: number; h: number; }'\n}\nThe first issue is a misunderstanding of the DOM:\ngetBoundingClientRect()  is defined on Element , not Node . So the\n@param  tag should be updated. The second is a mismatch between\nproperties specified in the @return  tag and the implementation. Presumably\nthe rest of the project uses the width  and height  properties, so the @return\ntag should be updated. It could even be dropped since T ypeScript will\nhappily infer a return type.\nY ou can use JSDoc to gradually add type annotations to your project. The\nT ypeScript language service will of fer to infer type annotations as a quick\nfix for code where it’ s clear from usage:\nfunction double(val) { \n  return 2 * val;\n}\nY ou should see a dotted underline under val  in your editor . Clicking this\nshould of fer the Quick Fix, as shown in Figure 10-2 .\nFigur e 10-2. The T ypeScript Language Services offer a quick fix to infer parameter types fr om usage.\nThis results in a correct JSDoc annotation:\n// @ts-check\n/**\n * @param {number} val\n */\nfunction double(val) { \n  return 2 * val;\n}\nThis can be helpful to encourage types to flow through your code with @ts-\ncheck . But it doesn’ t always work so well. For instance:\nfunction loadData(data) { \n  data.files.forEach(async file => { \n    // ... \n  });\n}\nIf you use the quick fix to annotate data , you’ll wind up with:\n/**\n * @param {{\n *  files: { forEach: (arg0: (file: any) => Promise<void>) => void; };\n * }} data\n */\nfunction loadData(data) { \n  // ...\n}\nThis is structural typing gone awry ( Item 4 ). While the function would\ntechnically work on any sort of object with a forEach  method with that\nsignature, the intent was most likely for the parameter to be {files:\nstring[]} .\nY ou can get much of the T ypeScript experience in a JavaScript project\nusing JSDoc annotations and @ts-check . This is appealing because it\nrequires no changes in your tooling. But it’ s best not to go too far in this\ndirection. Comment boilerplate has real costs: it’ s easy for your logic to get\nlost in a sea of JSDoc. T ypeScript works best with .ts  files, not .js  files. The\ngoal is ultimately to convert your project to T ypeScript, not to JavaScript\nwith JSDoc annotations.\nThe true value of @ts-check  is or ganizational: it can be a useful way to\nexperiment with types, discover blockers, and get a sense for how dif ficult\nmigration will be befor e  you ask management to commit to a weeks- or\nmonths-long T ypeScript transition.",8258
93-Item 81 Use allowJs to Mix TypeScript and JavaScript.pdf,93-Item 81 Use allowJs to Mix TypeScript and JavaScript,"Things to Remember\nAdd ""// @ts-check "" to the top of a JavaScript file to enable type\nchecking without converting to T ypeScript.\nRecognize common errors. Know how to declare globals and add type\ndeclarations for third-party libraries.\nUse JSDoc annotations for type assertions and better type inference.\nDon’ t spend too much time getting your code perfectly typed with\nJSDoc. Remember that the goal is to convert to .ts !\nI t e m  8 1 :  U s e  a l l o w J s  t o  M i x  T y p e S c r i p t  a n d\nJ a v a S c r i p t\nFor a small project, you may be able to convert from JavaScript to\nT ypeScript in one fell swoop. But for a lar ger project this “stop the world”\napproach won’ t work. Y ou need to be able to transition gradually . That\nmeans you need a way for T ypeScript and JavaScript to coexist.\nThe key to this is the allowJs  compiler option. W ith allowJs , T ypeScript\nfiles and JavaScript files may import one another . For JavaScript files this\nmode is extremely permissive. Unless you use @ts-check  ( Item 80 ), the\nonly errors you’ll see are syntax errors. This is “T ypeScript is a superset of\nJavaScript” in the most trivial sense.\nWhile it’ s unlikely to catch errors, allowJs  does give you an opportunity to\nintroduce T ypeScript into your build chain before you start making code\nchanges. This is a good idea because you’ll want to be able to run your tests\nas you convert individual modules to T ypeScript, as described in Item 82 .\nIf your bundler includes T ypeScript integration or has a plug-in available,\nthat’ s usually the easiest path forward. W ith webpack , for instance, you\ninstall ts-loader :\n$ npm install --save-dev ts-loader\nand configure it in your webpack.config.js :\nmodule.exports = { \n  module: { \n    rules: [ \n      { \n        test: /\.tsx?$/, \n        use: 'ts-loader', \n        exclude: /node_modules/, \n      }, \n    ], \n  }, \n  // ...\n};\nMost unit testing tools have an option like this as well. W ith jest , for\ninstance, you install ts-jest  and pass T ypeScript sources through it by\nspecifying a jest.config.js  like:\nmodule.exports = { \n  transform: { \n    '^.+\\.tsx?$': 'ts-jest', \n  },\n};\nIf you run your code through Node.js, the easiest option is to set up ts-\nnode . Y ou can either use this as a drop-in replacement for the node\ncommand or register it with node  so that it can understand T ypeScript:\n$ node -r ts-node/register main.ts\nIf your build chain is custom, your task will be more involved. But there’ s\nalways a good fallback option: when you specify the outDir  option,\nT ypeScript will generate pure JavaScript sources in a directory that parallels\nyour source tree. Usually , your existing build chain can be run over that.\nY ou may need to tweak T ypeScript’ s JavaScript output so that it closely\nmatches your original JavaScript source (e.g., by specifying the target  and\nmodule  options).",2929
94-Item 82 Convert Module by Module Up Your Dependency Graph.pdf,94-Item 82 Convert Module by Module Up Your Dependency Graph,"Adding T ypeScript into your build and test process may not be the most\nenjoyable task, but it is an essential one that will let you begin to migrate\nyour code with confidence,  as we’ll discuss in the next item.\nThings to Remember\nUse the allowJs  compiler option to support mixed JavaScript and\nT ypeScript as you transition your project.\nGet your tests and build chain working with T ypeScript before\nbeginning lar ge-scale migration.\nI t e m  8 2 :  C o n v e r t  M o d u l e  b y  M o d u l e  U p  Y o u r\nD e p e n d e n c y  G r a p h\nY ou’ve adopted modern JavaScript, converting your project to use\nECMAScript modules and classes ( Item 79 ). Y ou’ve integrated T ypeScript\ninto your build chain and have all your tests passing ( Item 81 ). Now for the\nfun part: converting your JavaScript to T ypeScript. But where to begin?\nWhen you add types to a module, it’ s likely to surface new type errors in all\nthe other modules that import it. Ideally , you’d like to convert each module\nonce and be done with it. This implies that you should convert modules\ngoing up  the dependency graph: starting with the leaves (modules that\nimport no others) and moving up to the root. (Only computer programmers\nthink the roots of trees are at the top!)\nThe very first modules to migrate are your third-party dependencies since,\nby definition, you import them but they don’ t import you. Usually this\nmeans installing @types  modules. If you use the lodash  utility library , for\nexample, you’d run:\nnpm install --save-dev @types/lodash\nThese type declarations will help types flow through your code and surface\nissues in your use of the libraries. Make sure to match package versions\n(see Item 66 ). If your third-party libraries bundle their types, you can skip\nthis step. T ypeScript will find them straightaway .\nIf your code calls external APIs, you may also want to add type declarations\nfor these early on. Although these calls may happen anywhere in your code,\nthis is still in the spirit of moving up the dependency graph since you\ndepend on the APIs but they do not depend on you. Many types flow from\nAPI calls, and these are generally dif ficult to infer from context. For\nexample, you might replace:\nasync function fetchTable() { \n  const response = await fetch('/data'); \n  if (!response.ok) throw new Error('Failed to fetch!'); \n  return response.json();\n}\nwith:\ninterface TabularData { \n  columns: string[]; \n  rows: number[][];\n}\nasync function fetchTable(): Promise<TabularData> { \n  const response = await fetch('/data'); \n  if (!response.ok) throw new Error('Failed to fetch!'); \n  return response.json();\n}\nNow types will flow from all calls to fetchTable . As Item 42  explained,\nit’ s better not to write types from scratch if you can find an existing source\nof truth for them, such as a spec or database schema.\nAs you migrate your own modules, it’ s helpful to visualize the dependency\ngraph. Figure 10-3  shows an example graph from dygraphs, a medium-\nsized JavaScript project, made using the excellent madge  tool.\nThe bottom of this dependency graph is the circular dependency between\nutils.js  and tickers.js . There are many modules that import these two, but\nthey only import each other . This pattern is quite common: most projects\nwill have some sort of utility module at the bottom of the dependency\ngraph.\nFigur e 10-3. The dependency graph for a medium-sized JavaScript pr oject. Arr ows indicate imports.\nDarker -shaded boxes indicate that a module is involved in a cir cular import.\nIf you’d like to take any guesswork out of the ordering, you can run a\ntopological sort on your dependency graph. Placed in a spreadsheet and\nperhaps coupled with the number of lines of code in each file, this can give\nyou a good sense of how far you’ve come and how much work is left to do.\nAs you migrate your code, focus on adding types rather than refactoring. If\nthis is an old project, you’re likely to notice some strange things and want\nto fix them. Resist this ur ge! The immediate goal is to convert your project\nto T ypeScript, not to improve its design. Embarking on unrelated refactors\nwill slow you down, make code reviews harder , and increase the risk that\nyou introduce bugs. Make a note of code smells as you find them and add\nthem to a list of future refactors. File bugs now , fix them later . If this means\nusing any  or @ts-expect-error , that’ s fine.\nThere are a few common errors you’ll run into as you convert to\nT ypeScript. Some of these were covered in Item 80 , but there are some new\nones, too, notably undeclared class members and values with changing\ntypes. Let’ s look at each of these errors and how to address them.\nUndeclared Class Members\nClasses in JavaScript do not need to declare their members, but classes in\nT ypeScript do. When you rename a class’ s .js  file to .ts , it’ s likely to show\nerrors for every single property you reference:\nclass Greeting { \n  constructor(name) { \n    this.greeting = 'Hello'; \n    //   ~~~~~~~~ Property 'greeting' does not exist on type 'Greeting' \n    this.name = name; \n    //   ~~~~ Property 'name' does not exist on type 'Greeting' \n  } \n  greet() { \n    return `${this.greeting} ${this.name}`; \n    //             ~~~~~~~~         ~~~~ Property ... does not exist \n  }\n}\nThere’ s a helpful quick fix (see Figure 10-4 ) for this that you should take\nadvantage of.\nFigur e 10-4. The quick fix to add declarations for missing members is particularly helpful in\nconverting a class to T ypeScript.\nThis will add declarations for the missing members based on usage:\nclass Greeting { \n  greeting: string; \n  name: any; \n  constructor(name) { \n    this.greeting = 'Hello'; \n    this.name = name; \n  } \n  greet() { \n    return `${this.greeting} ${this.name}`; \n  }\n}\nT ypeScript was able to get the type for greeting  correct, but not the type\nfor name . After applying this quick fix, you should look through the\nproperty list and fix the any  types.\nIf this is the first time you’ve seen the full property list for your class, you\nmay be in for a shock. When I converted the main class in dygraph.js  (the\nroot module in Figure 10-3 ), I discovered that it had no fewer than 45\nmember variables! Migrating to T ypeScript has a way of surfacing bad\ndesigns like this that were previously implicit. It’ s harder to justify a bad\ndesign if you have to look at it. But again, resist the ur ge to refactor now .\nNote the oddity and think about how you’d fix it some other day .\nV alues with Changing T ypes\nT ypeScript will complain about code like this:\nconst state = {};\nstate.name = 'New York';\n//    ~~~~ Property 'name' does not exist on type '{}'\nstate.capital = 'Albany';\n//    ~~~~~~~ Property 'capital' does not exist on type '{}'\nThis topic is covered in more depth in Item 21 , so you may want to brush\nup on that item if you run into this error . If the fix is trivial, you can build\nthe object all at once:\nconst state = { \n  name: 'New York', \n  capital: 'Albany',\n};  // OK\nIf it is not, then this is an appropriate time to use a type assertion:\ninterface State { \n  name: string; \n  capital: string;\n}\nconst state = {} as State;\nstate.name = 'New York';  // OK\nstate.capital = 'Albany';  // OK\nT ype assertions are problematic and best avoided ( Item 9  explains why), so\nyou should refactor this eventually . But for now , an assertion is expedient\nand will help you keep the migration going. Leave yourself a TODO\ncomment or file a bug to clean this up later .\nIf you’ve been using JSDoc and @ts-check  ( Item 80 ), be aware that you\ncan actually lose  type safety by converting to T ypeScript. For instance,\nT ypeScript flags an error in this JavaScript:\n// @ts-check\n/**\n * @param {number} num\n */\nfunction double(num) { \n  return 2 * num;\n} \n \ndouble('trouble');\n//     ~~~~~~~~~\n// Argument of type 'string' is not assignable to parameter of type 'number'\nWhen you convert to T ypeScript, the @ts-check  and JSDoc stop being\nenforced. This means the type of num  is implicitly any , so there’ s no error:\n/**\n * @param {number} num\n */\nfunction double(num) { \n  return 2 * num;\n} \n \ndouble('trouble');  // OK\nFortunately there’ s a quick fix to move JSDoc types to T ypeScript types, as\nshown in Figure 10-5 .\nFigur e 10-5. Quick fix to copy JSDoc annotations to T ypeScript type annotations.\nUse this quick fix if it’ s available! Once you’ve copied type annotations to\nT ypeScript, make sure to remove them from the JSDoc to avoid redundancy\n(see Item 31 ):\nfunction double(num: number) { \n  return 2 * num;\n} \n \ndouble('trouble');\n//     ~~~~~~~~~\n// Argument of type 'string' is not assignable to parameter of type 'number'\nThis issue will also be caught when you turn on noImplicitAny , but you\nmay as well add the types now .\nMigrate your tests last. They should be at the top of your dependency graph\n(since your production code doesn’ t import them), and it’ s extremely\nreassuring to know that your tests continue to pass during the migration\ndespite your not having changed them at all. T ypeScript migration is a pure\nrefactor . It should not change the runtime behavior of your code or your\ntests.\nThings to Remember",9331
95-Item 83 Dont Consider Migration Complete Until You Enable noImplicitAny.pdf,95-Item 83 Dont Consider Migration Complete Until You Enable noImplicitAny,"Start migration by adding @types  for third-party modules and external\nAPI calls.\nBegin migrating your own modules from the bottom of the\ndependency graph upwards. The first module will usually be some sort\nof utility code. Consider visualizing the dependency graph to help you\ntrack progress.\nResist the ur ge to refactor your code as you uncover odd designs. Keep\na list of ideas for future refactors, but stay focused on T ypeScript\nconversion.\nBe aware of common errors that come up during conversion. Move\nJSDoc types into T ypeScript type annotations if necessary to avoid\nlosing type safety as you convert.\nI t e m  8 3 :  D o n ’ t  C o n s i d e r  M i g r a t i o n  C o m p l e t e\nU n t i l  Y o u  E n a b l e  n o I m p l i c i t A n y\nConverting your  whole project to .ts  is a big accomplishment. But your\nwork isn’ t done quite yet. Y our next goal is to turn on the noImplicitAny\noption. T ypeScript code without noImplicitAny  is best thought of as\ntransitional because it can mask real errors you’ve made in your type\ndeclarations.\nFor example, perhaps you’ve used the “Add all missing members” quick fix\nto add property declarations to a class, as described in Item 82 . Y ou’re left\nwith an any  type and would like to fix it:\nclass Chart { \n  indices: any; \n \n  // ...\n}\nindices  sounds like it should be an array of numbers, so you plug in that\ntype:\nclass Chart { \n  indices: number[]; \n \n  // ...\n}\nNo new errors result, so you then keep moving. Unfortunately , you’ve made\na mistake: number[]  is the wrong type. Here’ s some code from elsewhere\nin the class:\ngetRanges() { \n  for (const r of this.indices) { \n    const low = r[0]; \n    //    ^? const low: any \n    const high = r[1]; \n    //    ^? const high: any \n    // ... \n  }\n}\nClearly number[][]  or [number, number][]  would be a more accurate\ntype. Does it surprise you that indexing into a number  is allowed? T ake this\nas an indication of just how loose T ypeScript can be without\nnoImplicitAny .\nWhen you turn on noImplicitAny , this becomes an error:\ngetRanges() { \n  for (const r of this.indices) { \n    const low = r[0]; \n    //          ~~~~ Element implicitly has an 'any' type because \n    //               type 'Number' has no index signature \n    const high = r[1]; \n    //           ~~~~ Element implicitly has an 'any' type because \n    //                type 'Number' has no index signature \n    // ... \n  }\n}\nA good strategy for enabling noImplicitAny  is to set it in your local client\nand start fixing errors. The number of errors you get from the type checker\ngives you a good sense of your progress. T racking your type coverage ( Item\n49 ) can also give you a sense of progress during this phase of migration.\nRun your tests with every change and commit frequently because you may\nonly discover that you’ve made a mistake later . Y ou may find it helpful to\nfix noImplicitAny  errors going “up the graph,” as described in Item 82 .\nY ou can commit the type corrections without committing the tsconfig.json\nchange to your repo until you get the number of errors down to zero.\nY ou might also choose to prioritize type safety in some parts of your\ncodebase over others, perhaps by fixing noImplicitAny  errors in your\nproduction code before your unit tests. If you use project references\n(described in Item 78 ) then you can even have distinct tsconfig.json  files\nwith dif ferent strictness settings for dif ferent parts of your project.\nThere are many other knobs you can turn to increase the strictness of type\nchecking, culminating with ""strict"": true . But noImplicitAny  is the\nmost important one, and your project will get most of the benefits of\nT ypeScript even if you don’ t adopt other settings like strictNullChecks .\nGive everyone on your team a chance to get used to T ypeScript before you\nadopt stricter settings.\nThings to Remember\nDon’ t consider your T ypeScript migration done until you adopt\nnoImplicitAny . Loose type checking can mask real mistakes in type\ndeclarations.\nFix type errors gradually before enforcing noImplicitAny . Give your\nteam a chance to get comfortable with T ypeScript before adopting\nstricter checks.\n1 Z. Gao, C. Bird, and E. T . Barr , “T o T ype or Not to T ype: Quantifying Detectable Bugs in\nJavaScript” , ICSE 2017.\n2 Brie Bunge, “Adopting T ypeScript at Scale” , JSConf Hawaii 2019.",4430
96-Appendix. Item Mapping Between First and Second Editions.pdf,96-Appendix. Item Mapping Between First and Second Editions,"Appendix. Item Mapping\nBetween First and Second\nEditions\nAll but one of the items from the first edition can be found in the second as\nwell, though sometimes with significant changes. The lone retired item\ncovered T ypeScript’ s private  field visibility modifiers. The same material\nnow lives in Item 72 , which advises you to use ECMAScript standard\n#private  fields instead.\nThe second edition includes two new chapters as well as new items\nscattered throughout the book. This means that item numbers from the first\nedition generally won’ t match the second. If you see a reference to an\nEffective T ypeScript  item that seems to be talking about something else\nentirely , it may be from the first edition. This table will direct you to the\nright place.\nT able A-1. First edition to second edition item mapping\n1st ed. 2nd edition item number: title\n1 1: Understand the Relationship Between T ypeScript and\nJavaScript\n2 2: Know Which T ypeScript Options Y ou’re Using\n3 3: Understand That Code Generation Is Independent of\nT ypes\n4 4: Get Comfortable with Structural T yping\n5 5: Limit Use of the any T ype\n6 6: Use Y our Editor to Interrogate and Explore the T ype\nSystem\n7 7: Think of T ypes as Sets of V alues\n8 8: Know How to T ell Whether a Symbol Is in the T ype\nSpace or V alue Space\n9 9: Prefer T ype Annotations to T ype Assertions\n10 10: A void Object W rapper T ypes (String, Number ,\nBoolean, Symbol, BigInt)\n1 1 1 1: Distinguish Excess Property Checking from T ype\nChecking\n1st ed. 2nd edition item number: title\n12 12: Apply T ypes to Entire Function Expressions When\nPossible\n13 13: Know the Dif ferences Between type and interface\n14 15: Use T ype Operations and Generic T ypes to A void\nRepeating Y ourself\n15 16: Prefer More Precise Alternatives to Index\nSignatures\n16 17: A void Numeric Index Signatures\n17 14: Use readonly to A void Errors Associated with\nMutation\n18 61: Use Record T ypes to Keep V alues in Sync\n19 18: A void Cluttering Y our Code with Inferable T ypes\n20 19: Use Dif ferent V ariables for Dif ferent T ypes\n21 20: Understand How a V ariable Gets Its T ype\n22 22: Understand T ype Narrowing\n23 21: Create Objects All at Once\n24 23: Be Consistent in Y our Use of Aliases\n1st ed. 2nd edition item number: title\n25 27: Use async Functions Instead of Callbacks to\nImprove T ype Flow\n26 24: Understand How Context Is Used in T ype Inference\n27 26: Use Functional Constructs and Libraries to Help\nT ypes Flow\n28 29: Prefer T ypes That Always Represent V alid States\n29 30: Be Liberal in What Y ou Accept and Strict in What\nY ou Produce\n30 31: Don’ t Repeat T ype Information in Documentation\n31 33: Push Null V alues to the Perimeter of Y our T ypes\n32 34: Prefer Unions of Interfaces to Interfaces with\nUnions\n33 35: Prefer More Precise Alternatives to String T ypes\n34 40: Prefer Imprecise T ypes to Inaccurate T ypes\n35 42: A void T ypes Based on Anecdotal Data\n36 41: Name T ypes Using the Language of Y our Problem\nDomain\n1st ed. 2nd edition item number: title\n37 64: Consider “Brands” for Nominal T yping\n38 43: Use the Narrowest Possible Scope for any T ypes\n39 44: Prefer More Precise V ariants of any to Plain any\n40 45: Hide Unsafe T ype Assertions in W ell-T yped\nFunctions\n41 25: Understand Evolving T ypes\n42 46: Use unknown Instead of any for V alues with an\nUnknown T ype\n43 47: Prefer T ype-Safe Approaches to Monkey Patching\n44 49: T rack Y our T ype Coverage to Prevent Regressions\nin T ype Safety\n45 65: Put T ypeScript and @types in devDependencies\n46 66: Understand the Three V ersions Involved in T ype\nDeclarations\n47 67: Export All T ypes That Appear in Public APIs\n48 68: Use TSDoc for API Comments\n1st ed. 2nd edition item number: title\n49 69: Provide a T ype for this in Callbacks if it’ s part of\ntheir API\n50 52: Prefer Conditional T ypes to Overload Signatures\n51 70: Mirror T ypes to Sever Dependencies\n52 55: W rite T ests for Y our T ypes\n53 72: Prefer ECMAScript Features to T ypeScript Features\n54 60: Know How to Iterate Over Objects\n55 75: Understand the DOM hierarchy\n56 72: Prefer ECMAScript Features to T ypeScript Features\n57 73: Use Source Maps to Debug T ypeScript\n58 79: W rite Modern JavaScript\n59 80: Use @ts-check and JSDoc to Experiment with\nT ypeScript\n60 81: Use allowJs to Mix T ypeScript and JavaScript\n61 82: Convert Module by Module Up Y our Dependency\nGraph\n1st ed. 2nd edition item number: title\n62 83: Don’ t Consider Migration Complete Until Y ou\nEnable noImplicitAny",4566
97-Index.pdf,97-Index,"Index\nSymbols\n! (non-null) type assertion , Item 8: Know How to T ell Whether a Symbol Is\nin the T ype Space or V alue Space , Item 9: Prefer T ype Annotations to T ype\nAssertions\n! (not) operator , Item 8: Know How to T ell Whether a Symbol Is in the\nT ype Space or V alue Space\n# (visibility modifier) , Member V isibility Modifiers (Private, Protected, and\nPublic)\n& (and) operator , Item 8: Know How to T ell Whether a Symbol Is in the\nT ype Space or V alue Space\n& (intersection) operator , Item 7: Think of T ypes as Sets of V alues , Item 8:\nKnow How to T ell Whether a Symbol Is in the T ype Space or V alue Space ,\nItem 15: Use T ype Operations and Generic T ypes to A void Repeating\nY ourself\n? (optional chaining) operator , Item 9: Prefer T ype Annotations to T ype\nAssertions , Other Features\n?? (nullish coalescing) operator , Item 22: Understand T ype Narrowing ,\nOther Features\n@deprecated , Item 68: Use TSDoc for API Comments\n@param , Item 31: Don’ t Repeat T ype Information in Documentation , Item\n68: Use TSDoc for API Comments\n@returns , Item 68: Use TSDoc for API Comments\n@template , Item 68: Use TSDoc for API Comments\n@ts-check , Item 80: Use @ts-check and JSDoc to Experiment with\nT ypeScript - Things to Remember , V alues with Changing T ypes - V alues with\nChanging T ypes\n@ts-expect-error , Item 43: Use the Narrowest Possible Scope for any\nT ypes , Item 55: W rite T ests for Y our T ypes , Item 77: Understand the\nRelationship Between T ype Checking and Unit T esting\n@ts-ignore , Item 43: Use the Narrowest Possible Scope for any T ypes\n@types (type dependencies)\nconverting module by module , Item 82: Convert Module by Module\nUp Y our Dependency Graph - Item 82: Convert Module by Module Up\nY our Dependency Graph\nin devDependencies , Item 65: Put T ypeScript and @types in\ndevDependencies - Things to Remember\ndocumentation with TSDoc , Item 68: Use TSDoc for API Comments -\nThings to Remember\nsevering dependencies , Item 70: Mirror T ypes to Sever Dependencies -\nThings to Remember\nversion matching , Item 66: Understand the Three V ersions Involved in\nT ype Declarations - Things to Remember\n[] property accessor , Item 8: Know How to T ell Whether a Symbol Is in the\nT ype Space or V alue Space\n{} type , Item 46: Use unknown Instead of any for V alues with an Unknown\nT ype\n| (or) operator , Item 8: Know How to T ell Whether a Symbol Is in the T ype\nSpace or V alue Space\n| (union) operator , Item 8: Know How to T ell Whether a Symbol Is in the\nT ype Space or V alue Space\nA\naccumulators , Item 53: Know How to Control the Distribution of Unions\nover Conditional T ypes - Item 53: Know How to Control the Distribution of\nUnions over Conditional T ypes\nAir France Flight 447 , Item 29: Prefer T ypes That Always Represent V alid\nStates - Item 29: Prefer T ypes That Always Represent V alid States\naliases\navoiding null/undefined in , Item 32: A void Including null or undefined\nin T ype Aliases - Things to Remember\nconsistency in , Item 23: Be Consistent in Y our Use of Aliases - Things\nto Remember\nrecursion , Item 57: Prefer T ail-Recursive Generic T ypes\nallowJs , Item 81: Use allowJs to Mix T ypeScript and JavaScript - Things to\nRemember\nanecdotal data, avoiding in type design , Item 42: A void T ypes Based on\nAnecdotal Data - Things to Remember\nany type , Item 1: Understand the Relationship Between T ypeScript and\nJavaScript , Unsoundness and the any T ype\nassignability , Item 46: Use unknown Instead of any for V alues with an\nUnknown T ype\ndrawbacks to , Item 5: Limit Use of the any T ype - Things to Remember\nhiding unsafe type assertions , Item 45: Hide Unsafe T ype Assertions in\nW ell-T yped Functions - Things to Remember\nnarrow scope for , Item 43: Use the Narrowest Possible Scope for any\nT ypes - Things to Remember\nnoImplicitAny , noImplicitAny - noImplicitAny , Item 83: Don’ t\nConsider Migration Complete Until Y ou Enable noImplicitAny - Things\nto Remember\nprecise versus plain variants , Item 44: Prefer More Precise V ariants of\nany to Plain any - Things to Remember\nas soundness trap , any\ntesting types , Item 55: W rite T ests for Y our T ypes - Item 55: W rite T ests\nfor Y our T ypes\ntracking type coverage , Item 49: T rack Y our T ype Coverage to Prevent\nRegressions in T ype Safety - Things to Remember\ntype-safe approaches versus monkey patching , Item 47: Prefer T ype-\nSafe Approaches to Monkey Patching - Things to Remember\nunknown type versus , Item 46: Use unknown Instead of any for V alues\nwith an Unknown T ype - Things to Remember\nArray .isArray , Item 22: Understand T ype Narrowing\nArrayLike type , Item 17: A void Numeric Index Signatures\narrays\nfor any type precision , Item 44: Prefer More Precise V ariants of any to\nPlain any\nassociative , Item 16: Prefer More Precise Alternatives to Index\nSignatures\nevolving types , Item 25: Understand Evolving T ypes - Things to\nRemember\nobject destructuring syntax , Item 23: Be Consistent in Y our Use of\nAliases\nrobustness principle , Item 30: Be Liberal in What Y ou Accept and\nStrict in What Y ou Produce - Item 30: Be Liberal in What Y ou Accept\nand Strict in What Y ou Produce\nsoundness traps , Object and Array Lookups - Object and Array Lookups\ntuples, relationship with , Item 7: Think of T ypes as Sets of V alues\ntype inference , Item 18: A void Cluttering Y our Code with Inferable\nT ypes , Item 20: Understand How a V ariable Gets Its T ype\ntype narrowing , Item 22: Understand T ype Narrowing\nunchecked accesses , Item 48: A void Soundness T raps\nvariance in , T ypeScript’ s Inaccurate Model of V ariance for Objects and\nArrays - T ypeScript’ s Inaccurate Model of V ariance for Objects and\nArrays\narrow functions , Item 9: Prefer T ype Annotations to T ype Assertions - Item\n9: Prefer T ype Annotations to T ype Assertions , Other Features\nassertUnreachable pattern , Item 59: Use Never T ypes to Perform\nExhaustiveness Checking - Item 59: Use Never T ypes to Perform\nExhaustiveness Checking\nassignability\nof any and unknown types , Item 46: Use unknown Instead of any for\nV alues with an Unknown T ype\nof classes , Item 4: Get Comfortable with Structural T yping\nof optional properties , Assignability and Optional Properties -\nAssignability and Optional Properties\nin testing types , Item 55: W rite T ests for Y our T ypes - Item 55: W rite\nT ests for Y our T ypes\nin value space , Item 8: Know How to T ell Whether a Symbol Is in the\nT ype Space or V alue Space\nassignable in type errors , Item 7: Think of T ypes as Sets of V alues\nassociative arrays , Item 16: Prefer More Precise Alternatives to Index\nSignatures , Other Features\nasync functions , Item 27: Use async Functions Instead of Callbacks to\nImprove T ype Flow - Things to Remember\nasynchronous functions , Other Features\naugmented interfaces , Item 13: Know the Dif ferences Between type and\ninterface , Item 47: Prefer T ype-Safe Approaches to Monkey Patching - Item\n47: Prefer T ype-Safe Approaches to Monkey Patching , Item 71: Use\nModule Augmentation to Improve T ypes - Things to Remember\nawait keyword , Item 27: Use async Functions Instead of Callbacks to\nImprove T ype Flow - Things to Remember\nB\nban-types rule , Item 10: A void Object W rapper T ypes (String, Number ,\nBoolean, Symbol, BigInt)\nbest common type , Item 20: Understand How a V ariable Gets Its T ype\nBigInt values , Item 10: A void Object W rapper T ypes (String, Number ,\nBoolean, Symbol, BigInt)\nbivariant classes , Bivariance in Class Hierarchies - Bivariance in Class\nHierarchies\nboolean types , Item 53: Know How to Control the Distribution of Unions\nover Conditional T ypes\nbottom types , Item 7: Think of T ypes as Sets of V alues\nbrands , Item 64: Consider Brands for Nominal T yping - Things to Remember\nbundling type declarations , Item 66: Understand the Three V ersions\nInvolved in T ype Declarations - Item 66: Understand the Three V ersions\nInvolved in T ype Declarations\nC\nC-style for loops , Other Features\ncallbacks\nasync functions instead , Item 27: Use async Functions Instead of\nCallbacks to Improve T ype Flow - Things to Remember\nbinding this keyword in , Item 69: Provide a T ype for this in Callbacks\nif It’ s Part of Their API - Things to Remember , Other Features\ntype inference , Callbacks - Callbacks\ntype narrowing , Item 22: Understand T ype Narrowing\ncasts , Item 9: Prefer T ype Annotations to T ype Assertions\nchanging types, values with , V alues with Changing T ypes - V alues with\nChanging T ypes\nCJS (CommonJS) , Use ECMAScript Modules\nclasses\nassignability , Item 4: Get Comfortable with Structural T yping\nbivariance , Bivariance in Class Hierarchies - Bivariance in Class\nHierarchies\nmixing null/non-null values , Item 33: Push Null V alues to the\nPerimeter of Y our T ypes - Item 33: Push Null V alues to the Perimeter of\nY our T ypes\nparameter properties , Parameter Properties - Parameter Properties\nprototypes versus , Use Classes Instead of Prototypes - Use Classes\nInstead of Prototypes\ntype inference and explicit typing , Classes - Classes\ntype parameters in , Item 50: Think of Generics as Functions Between\nT ypes , Item 51: A void Unnecessary T ype Parameters - Item 51: A void\nUnnecessary T ype Parameters\ntype space versus value space , Y ou Cannot Check T ypeScript T ypes at\nRuntime , Item 8: Know How to T ell Whether a Symbol Is in the T ype\nSpace or V alue Space\nundeclared members , Undeclared Class Members - Undeclared Class\nMembers\nvisibility modifiers , Member V isibility Modifiers (Private, Protected,\nand Public)\nclosed types , Item 4: Get Comfortable with Structural T yping\ncode, writing and running\naccuracy of environment model , Item 76: Create an Accurate Model of\nY our Environment - Things to Remember\ncompiler performance , Item 78: Pay Attention to Compiler\nPerformance - Things to Remember\ndebugging with source maps , Item 73: Use Source Maps to Debug\nT ypeScript - Things to Remember\nDOM hierarchy , Item 75: Understand the DOM Hierarchy - Things to\nRemember\npreferring ECMAScript features , Item 72: Prefer ECMAScript\nFeatures to T ypeScript Features - Things to Remember\nreconstructing types at runtime , Item 74: Know How to Reconstruct\nT ypes at Runtime - Things to Remember\nrelationship between unit testing and type checking , Item 77:\nUnderstand the Relationship Between T ype Checking and Unit\nT esting - Things to Remember\ncodegen (code generation) , Item 58: Consider Codegen as an Alternative to\nComplex T ypes - Things to Remember\nCommonJS (CJS) , Use ECMAScript Modules\ncompact object literals , Other Features\ncompiling versus type checking , Item 3: Understand That Code Generation\nIs Independent of T ypes - Things to Remember\nconditional types\ndistribution of unions over , Item 53: Know How to Control the\nDistribution of Unions over Conditional T ypes - Things to Remember\noverload signatures versus , Item 52: Prefer Conditional T ypes to\nOverload Signatures - Things to Remember\nconfiguration settings , Item 2: Know Which T ypeScript Options Y ou’re\nUsing - Things to Remember\nconst assertions , Item 20: Understand How a V ariable Gets Its T ype\nconst construct\ntype space versus value space , Item 8: Know How to T ell Whether a\nSymbol Is in the T ype Space or V alue Space\ntype widening , Item 20: Understand How a V ariable Gets Its T ype\nconst contexts , Item 9: Prefer T ype Annotations to T ype Assertions , T uple\nT ypes\nconst enums , Enums\ncontext in type inference , Item 24: Understand How Context Is Used in\nT ype Inference - Things to Remember\ncontravariance , Bivariance in Class Hierarchies\ncontrol flow analysis , T ype Inference and Control Flow Analysis , Item 22:\nUnderstand T ype Narrowing , Item 23: Be Consistent in Y our Use of\nAliases - Things to Remember\ncovariance , Bivariance in Class Hierarchies\ncurrying , Currying - Currying\nD\ndead code, eliminating , Prune Unused Dependencies and Dead Code - Prune\nUnused Dependencies and Dead Code\ndebugging with source maps , Item 73: Use Source Maps to Debug\nT ypeScript - Things to Remember\ndeclaration mer ging , Item 13: Know the Dif ferences Between type and\ninterface , Item 71: Use Module Augmentation to Improve T ypes\ndeclared types  ( see  type declarations)\ndecorators , experimentalDecorators - experimentalDecorators\ndefault values , Item 37: Limit the Use of Optional Properties , Other\nFeatures\nDefinitelyT yped , Item 65: Put T ypeScript and @types in devDependencies\ndependencies , Item 65: Put T ypeScript and @types in devDependencies\ndependency management\nbinding this keyword in callbacks , Item 69: Provide a T ype for this in\nCallbacks if It’ s Part of Their API - Things to Remember\nconverting module by module , Item 82: Convert Module by Module\nUp Y our Dependency Graph - Things to Remember\ndocumentation with TSDoc , Item 68: Use TSDoc for API Comments -\nThings to Remember\neliminating unused dependencies , Prune Unused Dependencies and\nDead Code - Prune Unused Dependencies and Dead Code\nexporting public API types , Item 67: Export All T ypes That Appear in\nPublic APIs - Things to Remember\nJSON.parse augmentation , Item 71: Use Module Augmentation to\nImprove T ypes - Things to Remember\nmirroring types , Item 70: Mirror T ypes to Sever Dependencies - Things\nto Remember\nT ypeScript and @types in devDependencies , Item 65: Put T ypeScript\nand @types in devDependencies - Things to Remember\nversion matching , Item 66: Understand the Three V ersions Involved in\nT ype Declarations - Things to Remember\ndestructuring assignment , Item 18: A void Cluttering Y our Code with\nInferable T ypes , Other Features\ndevDependencies , Item 65: Put T ypeScript and @types in\ndevDependencies - Things to Remember\ndiscriminated unions  ( see  tagged unions)\ndisplaying types , Item 56: Pay Attention to How T ypes Display - Things to\nRemember\ndistinction without a dif ference , Item 23: Be Consistent in Y our Use of\nAliases\ndocumentation\nfor API comments , Item 68: Use TSDoc for API Comments - Things to\nRemember\nfor generic types , Item 50: Think of Generics as Functions Between\nT ypes\nJSDoc , Item 80: Use @ts-check and JSDoc to Experiment with\nT ypeScript - Things to Remember , V alues with Changing T ypes - V alues\nwith Changing T ypes\ntype information in , Item 31: Don’ t Repeat T ype Information in\nDocumentation - Things to Remember\nDOM hierarchy , Item 75: Understand the DOM Hierarchy - Things to\nRemember , DOM Issues\ndomain-specific languages (DSLs) , Item 54: Use T emplate Literal T ypes to\nModel DSLs and Relationships Between Strings\ndomains (of types) , Item 7: Think of T ypes as Sets of V alues - Things to\nRemember , Item 35: Prefer More Precise Alternatives to String T ypes\ndouble assertions , Item 46: Use unknown Instead of any for V alues with an\nUnknown T ype\nDR Y (don't repeat yourself) principle , Item 15: Use T ype Operations and\nGeneric T ypes to A void Repeating Y ourself - Things to Remember\nDSLs (domain-specific languages) , Item 54: Use T emplate Literal T ypes to\nModel DSLs and Relationships Between Strings\ndtslint , Item 55: W rite T ests for Y our T ypes\nduck typing , Item 4: Get Comfortable with Structural T yping - Things to\nRemember\nE\nECMAScript , Item 72: Prefer ECMAScript Features to T ypeScript\nFeatures - Things to Remember\nECMAScript modules (ESM) , Use ECMAScript Modules - Use\nECMAScript Modules\neditors , Item 6: Use Y our Editor to Interrogate and Explore the T ype\nSystem - Things to Remember\nElement (DOM hierarchy) , Item 75: Understand the DOM Hierarchy\nempty set , Item 7: Think of T ypes as Sets of V alues\nenums (enumerations) , Item 8: Know How to T ell Whether a Symbol Is in\nthe T ype Space or V alue Space , Enums - Enums\nenvironment models, accuracy of , Item 76: Create an Accurate Model of\nY our Environment - Things to Remember\nequality of types , Item 7: Think of T ypes as Sets of V alues\nerrors  ( see  type errors)\nES2015\nclasses versus prototypes , Use Classes Instead of Prototypes - Use\nClasses Instead of Prototypes\nECMAScript modules , Use ECMAScript Modules - Use ECMAScript\nModules\neslint-plugin-expect-type , Item 55: W rite T ests for Y our T ypes\nESM (ECMAScript modules) , Use ECMAScript Modules - Use\nECMAScript Modules\nEvent (DOM hierarchy) , Item 75: Understand the DOM Hierarchy\nEventT ar get (DOM hierarchy) , Item 75: Understand the DOM Hierarchy -\nItem 75: Understand the DOM Hierarchy\nevolving types , Item 25: Understand Evolving T ypes - Things to Remember\nexcess property checking , Item 9: Prefer T ype Annotations to T ype\nAssertions\ndisabling , Item 16: Prefer More Precise Alternatives to Index\nSignatures\nenabling , Item 18: A void Cluttering Y our Code with Inferable T ypes\nsynchronizing values , Item 61: Use Record T ypes to Keep V alues in\nSync - Things to Remember\ntype checking versus , Item 1 1: Distinguish Excess Property Checking\nfrom T ype Checking - Things to Remember\nexclusive or , modeling , Item 63: Use Optional Never Properties to Model\nExclusive Or - Things to Remember\nexhaustiveness checking , Item 59: Use Never T ypes to Perform\nExhaustiveness Checking - Things to Remember\nexpect-type , Item 55: W rite T ests for Y our T ypes\nexperimentalDecorators , experimentalDecorators - experimentalDecorators\nexplicit any types , Item 49: T rack Y our T ype Coverage to Prevent\nRegressions in T ype Safety\nexplicit type annotation , Item 20: Understand How a V ariable Gets Its T ype ,\nItem 43: Use the Narrowest Possible Scope for any T ypes , Simplify Y our\nT ypes\nexplicit type definitions , Item 28: Use Classes and Currying to Create New\nInference Sites - Things to Remember , Item 35: Prefer More Precise\nAlternatives to String T ypes\nexplicitly typed languages , T ype Inference and Control Flow Analysis\nexporting public API types , Item 67: Export All T ypes That Appear in\nPublic APIs - Things to Remember\nextends keyword , Item 7: Think of T ypes as Sets of V alues - Item 7: Think of\nT ypes as Sets of V alues , Item 8: Know How to T ell Whether a Symbol Is in\nthe T ype Space or V alue Space , Item 50: Think of Generics as Functions\nBetween T ypes\nF\nfail open/fail closed , Item 61: Use Record T ypes to Keep V alues in Sync -\nThings to Remember\nfile extensions , Item 1: Understand the Relationship Between T ypeScript\nand JavaScript\nfinite types , Item 7: Think of T ypes as Sets of V alues\nfor(;;) loops , Other Features\nfunction expressions , Item 12: Apply T ypes to Entire Function Expressions\nWhen Possible - Things to Remember\nfunction parameters\navoiding repeating same type , Item 38: A void Repeated Parameters of\nthe Same T ype - Things to Remember\nnaming , Item 50: Think of Generics as Functions Between T ypes\nrefactoring as objects , Item 38: A void Repeated Parameters of the\nSame T ype\nstring types in , Item 35: Prefer More Precise Alternatives to String\nT ypes - Item 35: Prefer More Precise Alternatives to String T ypes\ntype annotations with , Item 18: A void Cluttering Y our Code with\nInferable T ypes - Item 18: A void Cluttering Y our Code with Inferable\nT ypes\nfunction return types, type annotations with , Item 18: A void Cluttering Y our\nCode with Inferable T ypes - Item 18: A void Cluttering Y our Code with\nInferable T ypes\nfunction statements , Item 12: Apply T ypes to Entire Function Expressions\nWhen Possible - Things to Remember\nfunctional constructs , Item 21: Create Objects All at Once , Item 26: Use\nFunctional Constructs and Libraries to Help T ypes Flow - Things to\nRemember\nfunctions\nasynchronous , Other Features\navoiding any type , Item 44: Prefer More Precise V ariants of any to\nPlain any\ncontravariance , Bivariance in Class Hierarchies\ncovariance , Bivariance in Class Hierarchies\ngeneric types versus , Item 50: Think of Generics as Functions Between\nT ypes - Things to Remember\nhiding unsafe type assertions , Item 45: Hide Unsafe T ype Assertions in\nW ell-T yped Functions - Things to Remember\ninspecting , Item 6: Use Y our Editor to Interrogate and Explore the\nT ype System\ninvalidating refinements , Function Calls Don’ t Invalidate\nRefinements - Function Calls Don’ t Invalidate Refinements\noverloading , Y ou Cannot Overload a Function Based on T ypeScript\nT ypes , Item 45: Hide Unsafe T ype Assertions in W ell-T yped\nFunctions , Item 71: Use Module Augmentation to Improve T ypes\nrunning synchronously/asynchronously , Item 27: Use async Functions\nInstead of Callbacks to Improve T ype Flow\nstructural typing , Item 4: Get Comfortable with Structural T yping -\nThings to Remember\nunknown type in , Item 51: A void Unnecessary T ype Parameters\nvariadic , Item 62: Use Rest Parameters and T uple T ypes to Model\nV ariadic Functions - Things to Remember\nG\ngeneric types , Item 48: A void Soundness T raps\navoiding repetition with , Item 15: Use T ype Operations and Generic\nT ypes to A void Repeating Y ourself - Things to Remember\navoiding unnecessary type parameters , Item 51: A void Unnecessary\nT ype Parameters - Things to Remember\nconditional types versus overload signatures , Item 52: Prefer\nConditional T ypes to Overload Signatures - Things to Remember\ndisplaying , Item 56: Pay Attention to How T ypes Display - Things to\nRemember\ndistribution of unions over conditional types , Item 53: Know How to\nControl the Distribution of Unions over Conditional T ypes - Things to\nRemember\ndocumentation , Item 50: Think of Generics as Functions Between\nT ypes\nfunctions versus , Item 50: Think of Generics as Functions Between\nT ypes - Things to Remember\ntail-recursive , Item 57: Prefer T ail-Recursive Generic T ypes - Things to\nRemember\ntemplate literal types with , Item 54: Use T emplate Literal T ypes to\nModel DSLs and Relationships Between Strings - Item 54: Use\nT emplate Literal T ypes to Model DSLs and Relationships Between\nStrings\nGeoJSON , Item 30: Be Liberal in What Y ou Accept and Strict in What Y ou\nProduce , Item 40: Prefer Imprecise T ypes to Inaccurate T ypes - Item 40:\nPrefer Imprecise T ypes to Inaccurate T ypes , Item 42: A void T ypes Based on\nAnecdotal Data - Item 42: A void T ypes Based on Anecdotal Data , Item 46:\nUse unknown Instead of any for V alues with an Unknown T ype\nglobal variables , Item 47: Prefer T ype-Safe Approaches to Monkey\nPatching - Item 47: Prefer T ype-Safe Approaches to Monkey Patching , Item\n76: Create an Accurate Model of Y our Environment\nGoldber g, Josh , Generics and T ype-Level Programming\nH\nHejlsber g, Anders , Item 24: Understand How Context Is Used in T ype\nInference\nhiding unsafe type assertions , Item 45: Hide Unsafe T ype Assertions in\nW ell-T yped Functions - Things to Remember\nhomomorphic mapped types , Item 15: Use T ype Operations and Generic\nT ypes to A void Repeating Y ourself - Item 15: Use T ype Operations and\nGeneric T ypes to A void Repeating Y ourself , Item 56: Pay Attention to How\nT ypes Display\nHTMLElement (DOM hierarchy) , Item 75: Understand the DOM Hierarchy\nI\nimmutable values , Item 7: Think of T ypes as Sets of V alues\nimplicit any errors , Item 25: Understand Evolving T ypes\nimplicit anys , noImplicitAny\nimprecise versus inaccurate types , Item 40: Prefer Imprecise T ypes to\nInaccurate T ypes - Things to Remember\nin keyword , Item 8: Know How to T ell Whether a Symbol Is in the T ype\nSpace or V alue Space\ninclusive or , Item 63: Use Optional Never Properties to Model Exclusive Or\nincremental builds , Incremental Builds and Project References - Incremental\nBuilds and Project References\nindex signatures , Item 1 1: Distinguish Excess Property Checking from T ype\nChecking\nalternatives to , Item 16: Prefer More Precise Alternatives to Index\nSignatures - Things to Remember\navoiding numeric , Item 17: A void Numeric Index Signatures - Things to\nRemember\ninferring types  ( see  type inference)\ninfinite types , Item 7: Think of T ypes as Sets of V alues\ninspecting\nfunctions , Item 6: Use Y our Editor to Interrogate and Explore the T ype\nSystem\nmethod names , Item 6: Use Y our Editor to Interrogate and Explore the\nT ype System\nproperties , Item 6: Use Y our Editor to Interrogate and Explore the\nT ype System\ninstanceof\ntype narrowing , Item 22: Understand T ype Narrowing\nwith unknown type , Item 46: Use unknown Instead of any for V alues\nwith an Unknown T ype\ninterfaces\naugmented , Item 47: Prefer T ype-Safe Approaches to Monkey\nPatching - Item 47: Prefer T ype-Safe Approaches to Monkey Patching ,\nItem 71: Use Module Augmentation to Improve T ypes - Things to\nRemember\ntypes versus , Item 13: Know the Dif ferences Between type and\ninterface - Things to Remember , Simplify Y our T ypes\nunions of interfaces versus interfaces of unions , Item 34: Prefer Unions\nof Interfaces to Interfaces with Unions - Things to Remember\nintersection type , Item 7: Think of T ypes as Sets of V alues , Item 50: Think\nof Generics as Functions Between T ypes - Item 50: Think of Generics as\nFunctions Between T ypes\niterating over objects , Item 60: Know How to Iterate Over Objects - Things\nto Remember\nJ\nJavaScript\nmigrating to T ypeScript  ( see  migration)\nmixing with T ypeScript , Item 81: Use allowJs to Mix T ypeScript and\nJavaScript - Things to Remember\nrelationship with T ypeScript , Item 1: Understand the Relationship\nBetween T ypeScript and JavaScript - Things to Remember , Item 72:\nPrefer ECMAScript Features to T ypeScript Features , Item 74: Know\nHow to Reconstruct T ypes at Runtime\nwriting modern , Item 79: W rite Modern JavaScript - Things to\nRemember\n.js extension , Item 1: Understand the Relationship Between T ypeScript and\nJavaScript\nJSDoc , Item 31: Don’ t Repeat T ype Information in Documentation , Item\n80: Use @ts-check and JSDoc to Experiment with T ypeScript - Things to\nRemember , V alues with Changing T ypes - V alues with Changing T ypes\nJSON Schema , Generate the T ypes from Another Source , Generate\nRuntime V alues from Y our T ypes - Generate Runtime V alues from Y our\nT ypes\njson-schema-to-typescript , Item 42: A void T ypes Based on Anecdotal Data ,\nGenerate the T ypes from Another Source , Things to Remember\nJSON.parse , Item 71: Use Module Augmentation to Improve T ypes - Things\nto Remember\nK\nkeyof expressions , Item 15: Use T ype Operations and Generic T ypes to\nA void Repeating Y ourself\nL\nlanguage services , There Are No Language Services for any T ypes - There\nAre No Language Services for any T ypes , Item 6: Use Y our Editor to\nInterrogate and Explore the T ype System - Things to Remember\nLearning T ypeScript (Goldber g) , Generics and T ype-Level Programming\nlet keyword , Item 20: Understand How a V ariable Gets Its T ype\nlibraries\ntype declarations for , Unknown Libraries\ntype inference , Item 21: Create Objects All at Once , Item 26: Use\nFunctional Constructs and Libraries to Help T ypes Flow - Things to\nRemember\nliteral types , Item 7: Think of T ypes as Sets of V alues , Item 8: Know How\nto T ell Whether a Symbol Is in the T ype Space or V alue Space\nlocal type aliases , Currying\nLodash , Item 26: Use Functional Constructs and Libraries to Help T ypes\nFlow - Item 26: Use Functional Constructs and Libraries to Help T ypes Flow\nM\nMap types , Item 16: Prefer More Precise Alternatives to Index Signatures ,\nItem 60: Know How to Iterate Over Objects\nmapped types , Item 15: Use T ype Operations and Generic T ypes to A void\nRepeating Y ourself - Item 15: Use T ype Operations and Generic T ypes to\nA void Repeating Y ourself\nmetaprogramming , Generics and T ype-Level Programming , Item 58:\nConsider Codegen as an Alternative to Complex T ypes\nmethod names, inspecting , Item 6: Use Y our Editor to Interrogate and\nExplore the T ype System\nmigration\nconverting module by module , Item 82: Convert Module by Module\nUp Y our Dependency Graph - Things to Remember\nenabling noImplicitAny , Item 83: Don’ t Consider Migration Complete\nUntil Y ou Enable noImplicitAny - Things to Remember\nexperimenting with T ypeScript , Item 80: Use @ts-check and JSDoc to\nExperiment with T ypeScript - Things to Remember\nfile extensions , Item 1: Understand the Relationship Between\nT ypeScript and JavaScript\nmixing JavaScript and T ypeScript , Item 81: Use allowJs to Mix\nT ypeScript and JavaScript - Things to Remember\npreparing for , Modernization and Migration\nwriting modern JavaScript , Item 79: W rite Modern JavaScript - Things\nto Remember\nmirroring types , Item 70: Mirror T ypes to Sever Dependencies - Things to\nRemember\nmodeling dif ferences versus unifying types , Item 39: Prefer Unifying T ypes\nto Modeling Dif ferences - Things to Remember\nmodels (of environment), accuracy of , Item 76: Create an Accurate Model\nof Y our Environment - Things to Remember\nmodules\nas any type , Item 49: T rack Y our T ype Coverage to Prevent\nRegressions in T ype Safety , Item 55: W rite T ests for Y our T ypes\nCommonJS , Use ECMAScript Modules\nconverting up dependency graph , Item 82: Convert Module by Module\nUp Y our Dependency Graph - Things to Remember\nECMAScript , Use ECMAScript Modules - Use ECMAScript Modules\ntriple-slash imports , Namespaces and T riple-Slash Imports\nmonkey patching , Item 47: Prefer T ype-Safe Approaches to Monkey\nPatching - Things to Remember\nmutations, preventing errors with readonly , Item 14: Use readonly to A void\nErrors Associated with Mutation - Things to Remember\nN\nnamed types , Item 18: A void Cluttering Y our Code with Inferable T ypes\nnamespaces , Namespaces and T riple-Slash Imports\nnaming\nfunction parameters , Item 50: Think of Generics as Functions Between\nT ypes\ntypes , Item 41: Name T ypes Using the Language of Y our Problem\nDomain - Things to Remember\nnarrow scope for any type , Item 43: Use the Narrowest Possible Scope for\nany T ypes - Things to Remember\nnarrowing types , strictNullChecks , Item 22: Understand T ype Narrowing -\nThings to Remember , Item 47: Prefer T ype-Safe Approaches to Monkey\nPatching\nnested structures , Item 23: Be Consistent in Y our Use of Aliases\nnever type , Item 7: Think of T ypes as Sets of V alues , Item 53: Know How\nto Control the Distribution of Unions over Conditional T ypes - Item 53:\nKnow How to Control the Distribution of Unions over Conditional T ypes\nexhaustiveness checking , Item 59: Use Never T ypes to Perform\nExhaustiveness Checking - Things to Remember\nas optional , Item 63: Use Optional Never Properties to Model\nExclusive Or - Things to Remember\nNode (DOM hierarchy) , Item 75: Understand the DOM Hierarchy\nNode Package Manager (npm) , Item 65: Put T ypeScript and @types in\ndevDependencies\nNode.js source maps , Item 73: Use Source Maps to Debug T ypeScript - Item\n73: Use Source Maps to Debug T ypeScript\nnoEmit , Incremental Builds and Project References\nnoEmitOnError , Code with T ype Errors Can Produce Output\nnoImplicitAny , noImplicitAny - noImplicitAny , Item 50: Think of Generics\nas Functions Between T ypes , Item 83: Don’ t Consider Migration Complete\nUntil Y ou Enable noImplicitAny - Things to Remember\nnoImplicitThis , Other Options\nnominal typing , Item 64: Consider Brands for Nominal T yping - Things to\nRemember\nnon-null type assertions , strictNullChecks , Item 9: Prefer T ype Annotations\nto T ype Assertions\nnoUncheckedIndexedAccess option , Other Options , Object and Array\nLookups\nnpm (Node Package Manager) , Item 65: Put T ypeScript and @types in\ndevDependencies\nnull checking , Item 22: Understand T ype Narrowing\nnull values\navoiding in aliases , Item 32: A void Including null or undefined in T ype\nAliases - Things to Remember\nexcluding , Item 22: Understand T ype Narrowing\npushing to perimeter of types , Item 33: Push Null V alues to the\nPerimeter of Y our T ypes - Things to Remember\nstrictNullChecks , strictNullChecks - strictNullChecks\nnullable values , Other Features\nnullish coalescing operator , Item 22: Understand T ype Narrowing , Other\nFeatures\nnumber -valued enums , Enums , Enums\nnumeric index signatures, avoiding , Item 17: A void Numeric Index\nSignatures - Things to Remember\nO\nobject destructuring syntax , Item 23: Be Consistent in Y our Use of Aliases\nobject literals, type annotations with , Item 18: A void Cluttering Y our Code\nwith Inferable T ypes\nobject spread syntax , Item 21: Create Objects All at Once - Item 21: Create\nObjects All at Once\nobject wrapper types , Item 10: A void Object W rapper T ypes (String,\nNumber , Boolean, Symbol, BigInt) - Things to Remember\nObject.entries , Item 60: Know How to Iterate Over Objects\nObject.freeze , Item 20: Understand How a V ariable Gets Its T ype\nObject/object types , Item 46: Use unknown Instead of any for V alues with\nan Unknown T ype\nobjects\nfor any type precision , Item 44: Prefer More Precise V ariants of any to\nPlain any\nbuilding , Item 21: Create Objects All at Once - Things to Remember\nindex signatures\nalternatives to , Item 16: Prefer More Precise Alternatives to Index\nSignatures - Things to Remember\navoiding numeric , Item 17: A void Numeric Index Signatures -\nThings to Remember\niterating over , Item 60: Know How to Iterate Over Objects - Things to\nRemember\nrefactoring parameters as , Item 38: A void Repeated Parameters of the\nSame T ype\nsoundness traps , Object and Array Lookups - Object and Array Lookups\ntype inference , Item 18: A void Cluttering Y our Code with Inferable\nT ypes - Item 18: A void Cluttering Y our Code with Inferable T ypes , Item\n20: Understand How a V ariable Gets Its T ype - Item 20: Understand\nHow a V ariable Gets Its T ype , Objects\ntype narrowing , Item 22: Understand T ype Narrowing\ntype-safe approaches versus monkey patching , Item 47: Prefer T ype-\nSafe Approaches to Monkey Patching - Things to Remember\nvariance in , T ypeScript’ s Inaccurate Model of V ariance for Objects and\nArrays - T ypeScript’ s Inaccurate Model of V ariance for Objects and\nArrays\nomission, errors of , Item 59: Use Never T ypes to Perform Exhaustiveness\nChecking - Things to Remember\nopen types , Item 4: Get Comfortable with Structural T yping\nOpenAPI , Generate the T ypes from Another Source\noptional chaining operator , Item 9: Prefer T ype Annotations to T ype\nAssertions , Other Features\noptional never type , Item 63: Use Optional Never Properties to Model\nExclusive Or - Things to Remember\noptional properties , Item 37: Limit the Use of Optional Properties - Things to\nRemember , Assignability and Optional Properties - Assignability and\nOptional Properties\noptions  ( see  configuration settings)\noutput, produced with type errors , Code with T ype Errors Can Produce\nOutput - Code with T ype Errors Can Produce Output\noverload signatures versus conditional types , Item 52: Prefer Conditional\nT ypes to Overload Signatures - Things to Remember\noverloading functions , Y ou Cannot Overload a Function Based on\nT ypeScript T ypes , Item 45: Hide Unsafe T ype Assertions in W ell-T yped\nFunctions , Item 71: Use Module Augmentation to Improve T ypes\nP\nparameter properties , Parameter Properties - Parameter Properties\nparameters  ( see  function parameters)\npeerDependencies , Item 65: Put T ypeScript and @types in\ndevDependencies\nperformance\nef fect of T ypeScript types on , T ypeScript T ypes Have No Ef fect on\nRuntime Performance - T ypeScript T ypes Have No Ef fect on Runtime\nPerformance\nof T ypeScript compiler (tsc) , Item 78: Pay Attention to Compiler\nPerformance - Things to Remember\nPgT yped , Item 58: Consider Codegen as an Alternative to Complex T ypes -\nItem 58: Consider Codegen as an Alternative to Complex T ypes\nPick , Item 15: Use T ype Operations and Generic T ypes to A void Repeating\nY ourself - Item 15: Use T ype Operations and Generic T ypes to A void\nRepeating Y ourself\nPostel's Law , Item 30: Be Liberal in What Y ou Accept and Strict in What\nY ou Produce - Things to Remember\nprecise types , Item 4: Get Comfortable with Structural T yping\nprecision\nwith any type , Item 44: Prefer More Precise V ariants of any to Plain\nany - Things to Remember\nof types , Item 40: Prefer Imprecise T ypes to Inaccurate T ypes - Things\nto Remember\npreserveConstEnums , Enums\nprimitives , Item 10: A void Object W rapper T ypes (String, Number ,\nBoolean, Symbol, BigInt) - Things to Remember\nprivate modifier , Member V isibility Modifiers (Private, Protected, and\nPublic)\nproblem domain vocabulary , Item 41: Name T ypes Using the Language of\nY our Problem Domain - Things to Remember\nprogramming  ( see  type-level programming)\nproject references , Incremental Builds and Project References - Incremental\nBuilds and Project References\nPromises , Item 27: Use async Functions Instead of Callbacks to Improve\nT ype Flow - Things to Remember\nproperties\naliases and , Item 23: Be Consistent in Y our Use of Aliases - Item 23: Be\nConsistent in Y our Use of Aliases\nassignability of optional , Assignability and Optional Properties -\nAssignability and Optional Properties\ndefault values , Item 37: Limit the Use of Optional Properties\nexcess property checking , Item 9: Prefer T ype Annotations to T ype\nAssertions\ndisabling , Item 16: Prefer More Precise Alternatives to Index\nSignatures\nenabling , Item 18: A void Cluttering Y our Code with Inferable\nT ypes\nsynchronizing values , Item 61: Use Record T ypes to Keep V alues\nin Sync - Things to Remember\ntype checking versus , Item 1 1: Distinguish Excess Property\nChecking from T ype Checking - Things to Remember\ninspecting , Item 6: Use Y our Editor to Interrogate and Explore the\nT ype System\noptional , Item 37: Limit the Use of Optional Properties - Things to\nRemember\nparameter properties , Parameter Properties - Parameter Properties\nsoundness traps , Object and Array Lookups - Object and Array Lookups\ntype-safe approaches versus monkey patching , Item 47: Prefer T ype-\nSafe Approaches to Monkey Patching - Things to Remember\nvisibility modifiers , Member V isibility Modifiers (Private, Protected,\nand Public)\nproperty checks (in type narrowing) , Item 22: Understand T ype Narrowing\nPropertyKey , Item 50: Think of Generics as Functions Between T ypes\nprotected modifier , Member V isibility Modifiers (Private, Protected, and\nPublic)\nprototype pollution , Item 60: Know How to Iterate Over Objects\nprototypes versus classes , Use Classes Instead of Prototypes - Use Classes\nInstead of Prototypes\npublic API types\ndocumentation with TSDoc , Item 68: Use TSDoc for API Comments -\nThings to Remember\nexporting , Item 67: Export All T ypes That Appear in Public APIs -\nThings to Remember\npublic modifier , Member V isibility Modifiers (Private, Protected, and\nPublic)\nR\nReact library , Item 12: Apply T ypes to Entire Function Expressions When\nPossible , Inaccurate T ype Definitions , Item 65: Put T ypeScript and @types\nin devDependencies , Item 66: Understand the Three V ersions Involved in\nT ype Declarations , Item 66: Understand the Three V ersions Involved in\nT ype Declarations\nreadonly modifier , Item 14: Use readonly to A void Errors Associated with\nMutation - Things to Remember , Member V isibility Modifiers (Private,\nProtected, and Public)\nRecord types , Item 16: Prefer More Precise Alternatives to Index\nSignatures , Item 61: Use Record T ypes to Keep V alues in Sync - Things to\nRemember\nrecursion , Item 40: Prefer Imprecise T ypes to Inaccurate T ypes , Item 57:\nPrefer T ail-Recursive Generic T ypes - Things to Remember\nrefactoring\nany type and , any T ypes Mask Bugs When Y ou Refactor Code\nfunction parameters as objects , Item 38: A void Repeated Parameters of\nthe Same T ype\ntools for , Item 6: Use Y our Editor to Interrogate and Explore the T ype\nSystem\nwith type inference , Item 18: A void Cluttering Y our Code with\nInferable T ypes - Item 18: A void Cluttering Y our Code with Inferable\nT ypes\nrefining types , strictNullChecks , Function Calls Don’ t Invalidate\nRefinements - Function Calls Don’ t Invalidate Refinements\nrenaming symbols , Item 6: Use Y our Editor to Interrogate and Explore the\nT ype System - Item 6: Use Y our Editor to Interrogate and Explore the T ype\nSystem\nrepeating parameters, avoiding with same type , Item 38: A void Repeated\nParameters of the Same T ype - Things to Remember\nrepetition, avoiding , Item 15: Use T ype Operations and Generic T ypes to\nA void Repeating Y ourself - Things to Remember\nrest parameters , Item 62: Use Rest Parameters and T uple T ypes to Model\nV ariadic Functions - Things to Remember\nreturn-only generics , Item 9: Prefer T ype Annotations to T ype Assertions\nreusing variables, avoiding , Item 19: Use Dif ferent V ariables for Dif ferent\nT ypes - Things to Remember\nrobustness principle , Item 30: Be Liberal in What Y ou Accept and Strict in\nWhat Y ou Produce - Things to Remember\nruntime\ndeclared types versus runtime types , Runtime T ypes May Not Be the\nSame as Declared T ypes\nef fect of T ypeScript types on performance , T ypeScript T ypes Have No\nEf fect on Runtime Performance - T ypeScript T ypes Have No Ef fect on\nRuntime Performance\ninability to check T ypeScript at , Y ou Cannot Check T ypeScript T ypes\nat Runtime - Y ou Cannot Check T ypeScript T ypes at Runtime\nmodeling with type system , Item 1: Understand the Relationship\nBetween T ypeScript and JavaScript\nreconstructing types , Item 74: Know How to Reconstruct T ypes at\nRuntime - Things to Remember\ntype operations and runtime values , T ype Operations Cannot Af fect\nRuntime V alues - T ype Operations Cannot Af fect Runtime V alues\nruntime libraries , Define T ypes with a Runtime Library - Define T ypes with\na Runtime Library\nS\nsatisfies operator , Item 20: Understand How a V ariable Gets Its T ype\nschemas, generating types from , Generate the T ypes from Another Source\nscope for any type , Item 43: Use the Narrowest Possible Scope for any\nT ypes - Things to Remember\nsealed types , Item 4: Get Comfortable with Structural T yping\nsets of values, types as , Item 7: Think of T ypes as Sets of V alues - Things to\nRemember , Item 35: Prefer More Precise Alternatives to String T ypes , Item\n50: Think of Generics as Functions Between T ypes\nsevering dependencies , Item 70: Mirror T ypes to Sever Dependencies -\nThings to Remember\nshadowed variables , Item 19: Use Dif ferent V ariables for Dif ferent T ypes\nslice method , Item 6: Use Y our Editor to Interrogate and Explore the T ype\nSystem\nsoundness of type system , Item 1: Understand the Relationship Between\nT ypeScript and JavaScript\navoiding soundness traps , Item 48: A void Soundness T raps - Things to\nRemember\noptional properties , Item 37: Limit the Use of Optional Properties\nunsoundness , Runtime T ypes May Not Be the Same as Declared\nT ypes , Unsoundness and the any T ype\nsource maps, debugging with , Item 73: Use Source Maps to Debug\nT ypeScript - Things to Remember\nspecial values, types for , Item 36: Use a Distinct T ype for Special V alues -\nThings to Remember\nstatements in type space versus value space , Item 8: Know How to T ell\nWhether a Symbol Is in the T ype Space or V alue Space\nstatically typed languages , T ype Inference and Control Flow Analysis\nstrict mode , Other Options , Other Features\nstrictFunctionT ypes , Other Options , Bivariance in Class Hierarchies\nstrictNullChecks , strictNullChecks - strictNullChecks , Item 36: Use a\nDistinct T ype for Special V alues , Item 48: A void Soundness T raps , Item 59:\nUse Never T ypes to Perform Exhaustiveness Checking\nstring primitives , Item 10: A void Object W rapper T ypes (String, Number ,\nBoolean, Symbol, BigInt) - Item 10: A void Object W rapper T ypes (String,\nNumber , Boolean, Symbol, BigInt)\nstring-valued enums , Enums - Enums\nstringly typed , Item 35: Prefer More Precise Alternatives to String T ypes\nstrings\nalternatives to , Item 35: Prefer More Precise Alternatives to String\nT ypes - Things to Remember\nnumeric index signatures as , Item 17: A void Numeric Index\nSignatures - Things to Remember\ntemplate literal types , Item 54: Use T emplate Literal T ypes to Model\nDSLs and Relationships Between Strings - Things to Remember\nunions of literal types , Enums\nstructural typing , Item 4: Get Comfortable with Structural T yping - Things to\nRemember , Item 7: Think of T ypes as Sets of V alues , Item 63: Use Optional\nNever Properties to Model Exclusive Or , Item 64: Consider Brands for\nNominal T yping , Item 70: Mirror T ypes to Sever Dependencies\nstructured strings , Item 54: Use T emplate Literal T ypes to Model DSLs and\nRelationships Between Strings\nsubtypes , Item 7: Think of T ypes as Sets of V alues , Item 9: Prefer T ype\nAnnotations to T ype Assertions\nsupersets , Item 1: Understand the Relationship Between T ypeScript and\nJavaScript\nswitch-exhaustiveness-check , Item 59: Use Never T ypes to Perform\nExhaustiveness Checking\nSymbol values , Item 10: A void Object W rapper T ypes (String, Number ,\nBoolean, Symbol, BigInt)\nsymbols\nrenaming , Item 6: Use Y our Editor to Interrogate and Explore the T ype\nSystem - Item 6: Use Y our Editor to Interrogate and Explore the T ype\nSystem\ntype space versus value space , Item 8: Know How to T ell Whether a\nSymbol Is in the T ype Space or V alue Space - Things to Remember\nT\ntagged unions , Y ou Cannot Check T ypeScript T ypes at Runtime\ndrawbacks to , Item 64: Consider Brands for Nominal T yping\nduplication with , Item 15: Use T ype Operations and Generic T ypes to\nA void Repeating Y ourself\nexclusive or with , Item 63: Use Optional Never Properties to Model\nExclusive Or\nhelping type checker , Item 22: Understand T ype Narrowing\nmodeling application states , Item 29: Prefer T ypes That Always\nRepresent V alid States\nunions of interfaces versus interfaces of unions , Item 34: Prefer Unions\nof Interfaces to Interfaces with Unions\ntail-recursive generic types , Item 57: Prefer T ail-Recursive Generic T ypes -\nThings to Remember\nTC39 , Item 72: Prefer ECMAScript Features to T ypeScript Features , Other\nFeatures\nTCO (T ail Call Optimization) , Item 57: Prefer T ail-Recursive Generic\nT ypes\nTDD (test-driven development) , Item 18: A void Cluttering Y our Code with\nInferable T ypes\ntemplate literal types , Item 15: Use T ype Operations and Generic T ypes to\nA void Repeating Y ourself , Item 54: Use T emplate Literal T ypes to Model\nDSLs and Relationships Between Strings - Things to Remember , Item 59:\nUse Never T ypes to Perform Exhaustiveness Checking\ntesting\nrelationship with type checking , Item 77: Understand the Relationship\nBetween T ype Checking and Unit T esting - Things to Remember\ntypes , Item 4: Get Comfortable with Structural T yping - Item 4: Get\nComfortable with Structural T yping , Item 50: Think of Generics as\nFunctions Between T ypes , Item 55: W rite T ests for Y our T ypes - Things\nto Remember\nthis keyword\nbinding in callbacks , Item 69: Provide a T ype for this in Callbacks if\nIt’ s Part of Their API - Things to Remember\nbinding this keyword in callbacks , Other Features\ntype space versus value space , Item 8: Know How to T ell Whether a\nSymbol Is in the T ype Space or V alue Space\nthrowing (in type narrowing) , Item 22: Understand T ype Narrowing\ntop types , Item 7: Think of T ypes as Sets of V alues\ntranspiling , Item 3: Understand That Code Generation Is Independent of\nT ypes\ntriple-slash imports , Namespaces and T riple-Slash Imports\n.ts extension , Item 1: Understand the Relationship Between T ypeScript and\nJavaScript\ntsc (T ypeScript compiler) , Item 6: Use Y our Editor to Interrogate and\nExplore the T ype System\ncode generation versus type checking , Item 3: Understand That Code\nGeneration Is Independent of T ypes - Things to Remember\nperformance , Item 78: Pay Attention to Compiler Performance - Things\nto Remember\ntsd , Item 55: W rite T ests for Y our T ypes\nTSDoc , Item 68: Use TSDoc for API Comments - Things to Remember\ntsserver (T ypeScript server) , Item 6: Use Y our Editor to Interrogate and\nExplore the T ype System , Item 78: Pay Attention to Compiler Performance -\nThings to Remember\ntuples\narrays, relationship with , Item 7: Think of T ypes as Sets of V alues\nmodeling variadic functions , Item 62: Use Rest Parameters and T uple\nT ypes to Model V ariadic Functions - Things to Remember\ntype inference , Item 20: Understand How a V ariable Gets Its T ype ,\nT uple T ypes - T uple T ypes\nT uring tar -pit , Item 58: Consider Codegen as an Alternative to Complex\nT ypes\ntype aliases  ( see  aliases)\ntype annotations , Simplify Y our T ypes\nas documentation , Item 31: Don’ t Repeat T ype Information in\nDocumentation\nin exhaustiveness checks , Item 59: Use Never T ypes to Perform\nExhaustiveness Checking\nexplicit , Item 20: Understand How a V ariable Gets Its T ype , Item 43:\nUse the Narrowest Possible Scope for any T ypes\nfor function expressions , Item 12: Apply T ypes to Entire Function\nExpressions When Possible - Things to Remember\nwith function parameters , Item 18: A void Cluttering Y our Code with\nInferable T ypes - Item 18: A void Cluttering Y our Code with Inferable\nT ypes\nwith function return types , Item 18: A void Cluttering Y our Code with\nInferable T ypes - Item 18: A void Cluttering Y our Code with Inferable\nT ypes\nintent indicated with , Item 1: Understand the Relationship Between\nT ypeScript and JavaScript - Item 1: Understand the Relationship\nBetween T ypeScript and JavaScript\nwith object literals , Item 18: A void Cluttering Y our Code with\nInferable T ypes\nobject wrapper types and , Item 10: A void Object W rapper T ypes\n(String, Number , Boolean, Symbol, BigInt)\npreferring over type assertions , Item 9: Prefer T ype Annotations to\nT ype Assertions - Things to Remember\nreducing use of , Item 18: A void Cluttering Y our Code with Inferable\nT ypes - Things to Remember\nrelationship of T ypeScript/JavaScript , Item 1: Understand the\nRelationship Between T ypeScript and JavaScript\ntype assertions , T ype Operations Cannot Af fect Runtime V alues , Item 21:\nCreate Objects All at Once\nconst assertions versus , Item 20: Understand How a V ariable Gets Its\nT ype\nDOM hierarchy and , Item 75: Understand the DOM Hierarchy\nexcess property checking , Item 1 1: Distinguish Excess Property\nChecking from T ype Checking\nexplicit any types , Item 49: T rack Y our T ype Coverage to Prevent\nRegressions in T ype Safety\ngeneric types and , Item 51: A void Unnecessary T ype Parameters\nhiding unsafe type assertions , Item 45: Hide Unsafe T ype Assertions in\nW ell-T yped Functions - Things to Remember\niterating over objects , Item 60: Know How to Iterate Over Objects -\nThings to Remember\nwith JSDoc , DOM Issues\nin migration , V alues with Changing T ypes\nnon-null , strictNullChecks\npreferring type annotations over , Item 9: Prefer T ype Annotations to\nT ype Assertions - Things to Remember\nas soundness trap , T ype Assertions - T ype Assertions\ntype narrowing , Item 22: Understand T ype Narrowing , Item 47: Prefer\nT ype-Safe Approaches to Monkey Patching\nin type space , Item 8: Know How to T ell Whether a Symbol Is in the\nT ype Space or V alue Space\nwith unknown type , Item 46: Use unknown Instead of any for V alues\nwith an Unknown T ype\nwhen to use , Item 9: Prefer T ype Annotations to T ype Assertions - Item\n9: Prefer T ype Annotations to T ype Assertions\nT ype Challenges project , Generics and T ype-Level Programming\ntype checking\nwith @ts-check , Item 80: Use @ts-check and JSDoc to Experiment\nwith T ypeScript - Things to Remember , V alues with Changing T ypes -\nV alues with Changing T ypes\ncode generation versus , Item 3: Understand That Code Generation Is\nIndependent of T ypes - Things to Remember\nexcess property checking versus , Item 1 1: Distinguish Excess Property\nChecking from T ype Checking - Things to Remember\nrelationship with unit testing , Item 77: Understand the Relationship\nBetween T ype Checking and Unit T esting - Things to Remember\nseparating from building , Separate T ype Checking from Building -\nSeparate T ype Checking from Building\ntype coverage, tracking , Item 49: T rack Y our T ype Coverage to Prevent\nRegressions in T ype Safety - Things to Remember\ntype declarations , Item 21: Create Objects All at Once\nbinding this keyword in callbacks , Item 69: Provide a T ype for this in\nCallbacks if It’ s Part of Their API - Things to Remember\nconverting module by module , Item 82: Convert Module by Module\nUp Y our Dependency Graph - Item 82: Convert Module by Module Up\nY our Dependency Graph\ndeclaration mer ging , Item 13: Know the Dif ferences Between type and\ninterface\ninaccuracy in , Inaccurate T ype Definitions - Inaccurate T ype Definitions\nfor JSON.parse , Item 71: Use Module Augmentation to Improve\nT ypes - Things to Remember\nmirroring types , Item 70: Mirror T ypes to Sever Dependencies - Things\nto Remember\nruntime types versus , Runtime T ypes May Not Be the Same as\nDeclared T ypes\nfor third-party libraries , Unknown Libraries\nin type space , Item 8: Know How to T ell Whether a Symbol Is in the\nT ype Space or V alue Space\nfor undeclared globals , Undeclared Globals\nversion matching , Item 66: Understand the Three V ersions Involved in\nT ype Declarations - Things to Remember\nviewing , Item 6: Use Y our Editor to Interrogate and Explore the T ype\nSystem - Item 6: Use Y our Editor to Interrogate and Explore the T ype\nSystem\ntype dependencies  ( see  @types; dependency management)\ntype design\nanecdotal data, avoiding , Item 42: A void T ypes Based on Anecdotal\nData - Things to Remember\nany type and , any Hides Y our T ype Design\navoiding null/undefined in aliases , Item 32: A void Including null or\nundefined in T ype Aliases - Things to Remember\nimprecise versus inaccurate types , Item 40: Prefer Imprecise T ypes to\nInaccurate T ypes - Things to Remember\nnaming types , Item 41: Name T ypes Using the Language of Y our\nProblem Domain - Things to Remember\noptional properties , Item 37: Limit the Use of Optional Properties -\nThings to Remember\npushing null values to perimeter , Item 33: Push Null V alues to the\nPerimeter of Y our T ypes - Things to Remember\nrepeating function parameters of same type , Item 38: A void Repeated\nParameters of the Same T ype - Things to Remember\nrepresenting valid states , Item 29: Prefer T ypes That Always Represent\nV alid States - Things to Remember\nrobustness principle , Item 30: Be Liberal in What Y ou Accept and\nStrict in What Y ou Produce - Things to Remember\nfor special values , Item 36: Use a Distinct T ype for Special V alues -\nThings to Remember\nstring type alternatives , Item 35: Prefer More Precise Alternatives to\nString T ypes - Things to Remember\ntype information in documentation , Item 31: Don’ t Repeat T ype\nInformation in Documentation - Things to Remember\nunifying versus modeling dif ferences , Item 39: Prefer Unifying T ypes\nto Modeling Dif ferences - Things to Remember\nunions of interfaces versus interfaces of unions , Item 34: Prefer Unions\nof Interfaces to Interfaces with Unions - Things to Remember\ntype equality , Item 7: Think of T ypes as Sets of V alues\ntype errors\nassignable in , Item 7: Think of T ypes as Sets of V alues\nerrors of omission , Item 59: Use Never T ypes to Perform\nExhaustiveness Checking - Things to Remember\noutput produced from , Code with T ype Errors Can Produce Output -\nCode with T ype Errors Can Produce Output\npreventing with readonly , Item 14: Use readonly to A void Errors\nAssociated with Mutation - Things to Remember\nviewing , Item 6: Use Y our Editor to Interrogate and Explore the T ype\nSystem - Item 6: Use Y our Editor to Interrogate and Explore the T ype\nSystem\ntype guards , Item 22: Understand T ype Narrowing\ntype inference , Item 1: Understand the Relationship Between T ypeScript\nand JavaScript , Item 6: Use Y our Editor to Interrogate and Explore the T ype\nSystem - Item 6: Use Y our Editor to Interrogate and Explore the T ype\nSystem , Item 12: Apply T ypes to Entire Function Expressions When\nPossible , T ype Inference and Control Flow Analysis\naliases , Item 23: Be Consistent in Y our Use of Aliases - Things to\nRemember\nasync functions , Item 27: Use async Functions Instead of Callbacks to\nImprove T ype Flow - Things to Remember\navoiding type annotations , Item 18: A void Cluttering Y our Code with\nInferable T ypes - Things to Remember\nbuilding objects , Item 21: Create Objects All at Once - Things to\nRemember\ncallbacks , Item 27: Use async Functions Instead of Callbacks to\nImprove T ype Flow - Things to Remember\ncontext in , Item 24: Understand How Context Is Used in T ype\nInference - Things to Remember\nevolving types , Item 25: Understand Evolving T ypes - Things to\nRemember\nfunctional constructs and utility libraries , Item 26: Use Functional\nConstructs and Libraries to Help T ypes Flow - Things to Remember\nPromises , Item 27: Use async Functions Instead of Callbacks to\nImprove T ype Flow - Things to Remember\nseparating from explicit typing , Item 28: Use Classes and Currying to\nCreate New Inference Sites - Things to Remember\ntemplate literal types with , Item 54: Use T emplate Literal T ypes to\nModel DSLs and Relationships Between Strings - Item 54: Use\nT emplate Literal T ypes to Model DSLs and Relationships Between\nStrings\ntype narrowing , Item 22: Understand T ype Narrowing - Things to\nRemember\ntype widening , Item 20: Understand How a V ariable Gets Its T ype -\nThings to Remember\nvariables, avoiding reusing , Item 19: Use Dif ferent V ariables for\nDif ferent T ypes - Things to Remember\ntype inlining , Item 13: Know the Dif ferences Between type and interface\ntype-level programming , Generics and T ype-Level Programming\ntype narrowing , strictNullChecks , Item 22: Understand T ype Narrowing -\nThings to Remember , Item 47: Prefer T ype-Safe Approaches to Monkey\nPatching\ntype operations\navoiding repetition with , Item 15: Use T ype Operations and Generic\nT ypes to A void Repeating Y ourself - Things to Remember\nruntime values and , T ype Operations Cannot Af fect Runtime V alues -\nT ype Operations Cannot Af fect Runtime V alues\ntype parameters , Item 46: Use unknown Instead of any for V alues with an\nUnknown T ype , Item 50: Think of Generics as Functions Between T ypes\navoiding unnecessary , Item 51: A void Unnecessary T ype Parameters -\nThings to Remember\nin classes , Item 50: Think of Generics as Functions Between T ypes\ntype predicates , Item 22: Understand T ype Narrowing\ntype signatures , Item 12: Apply T ypes to Entire Function Expressions When\nPossible - Things to Remember\ntype space versus value space , Y ou Cannot Check T ypeScript T ypes at\nRuntime , Item 8: Know How to T ell Whether a Symbol Is in the T ype\nSpace or V alue Space - Things to Remember\ntype system\nconfidence in , any Undermines Confidence in the T ype System\nexcess property checking , Item 1 1: Distinguish Excess Property\nChecking from T ype Checking - Things to Remember\nexploring with editor , Item 6: Use Y our Editor to Interrogate and\nExplore the T ype System - Things to Remember\nmodeling runtime behavior , Item 1: Understand the Relationship\nBetween T ypeScript and JavaScript\nas optional and gradual , Item 5: Limit Use of the any T ype ,\nUnsoundness and the any T ype\nsoundness , Item 1: Understand the Relationship Between T ypeScript\nand JavaScript\nas static , Item 1: Understand the Relationship Between T ypeScript and\nJavaScript\ntesting types , Item 55: W rite T ests for Y our T ypes - Item 55: W rite T ests\nfor Y our T ypes\ntype widening , Item 20: Understand How a V ariable Gets Its T ype - Things\nto Remember\ntype-level programming\navoiding unnecessary type parameters , Item 51: A void Unnecessary\nT ype Parameters - Things to Remember\ncodegen (code generation) , Item 58: Consider Codegen as an\nAlternative to Complex T ypes - Things to Remember\nconditional types versus overload signatures , Item 52: Prefer\nConditional T ypes to Overload Signatures - Things to Remember\ndisplaying types , Item 56: Pay Attention to How T ypes Display - Things\nto Remember\ndistribution of unions over conditional types , Item 53: Know How to\nControl the Distribution of Unions over Conditional T ypes - Things to\nRemember\nfunctions versus generic types , Item 50: Think of Generics as\nFunctions Between T ypes - Things to Remember\ntail-recursive generic types , Item 57: Prefer T ail-Recursive Generic\nT ypes - Things to Remember\ntemplate literal types , Item 54: Use T emplate Literal T ypes to Model\nDSLs and Relationships Between Strings - Things to Remember\ntesting types , Item 55: W rite T ests for Y our T ypes - Things to\nRemember\ntypeof operator , Item 8: Know How to T ell Whether a Symbol Is in the\nT ype Space or V alue Space , Item 15: Use T ype Operations and Generic\nT ypes to A void Repeating Y ourself - Item 15: Use T ype Operations and\nGeneric T ypes to A void Repeating Y ourself , Define T ypes with a Runtime\nLibrary\ntypes\ndisplaying , Item 56: Pay Attention to How T ypes Display - Things to\nRemember\nexporting public API types , Item 67: Export All T ypes That Appear in\nPublic APIs - Things to Remember\ninability to check at runtime , Y ou Cannot Check T ypeScript T ypes at\nRuntime - Y ou Cannot Check T ypeScript T ypes at Runtime\ninterfaces versus , Item 13: Know the Dif ferences Between type and\ninterface - Things to Remember , Simplify Y our T ypes\nmirroring , Item 70: Mirror T ypes to Sever Dependencies - Things to\nRemember\nnaming , Item 41: Name T ypes Using the Language of Y our Problem\nDomain - Things to Remember\nreconstructing at runtime , Item 74: Know How to Reconstruct T ypes at\nRuntime - Things to Remember\nrelationships between , Item 54: Use T emplate Literal T ypes to Model\nDSLs and Relationships Between Strings - Item 54: Use T emplate\nLiteral T ypes to Model DSLs and Relationships Between Strings\nas sets of values , Item 7: Think of T ypes as Sets of V alues - Things to\nRemember , Item 35: Prefer More Precise Alternatives to String T ypes ,\nItem 50: Think of Generics as Functions Between T ypes\nsimplifying , Simplify Y our T ypes\ntesting , Item 4: Get Comfortable with Structural T yping - Item 4: Get\nComfortable with Structural T yping , Item 50: Think of Generics as\nFunctions Between T ypes , Item 55: W rite T ests for Y our T ypes - Things\nto Remember\nvalues with changing types , V alues with Changing T ypes - V alues with\nChanging T ypes\ntypes.d.ts file , Undeclared Globals\nT ypeScript\ndebugging with source maps , Item 73: Use Source Maps to Debug\nT ypeScript - Things to Remember\nin devDependencies , Item 65: Put T ypeScript and @types in\ndevDependencies - Things to Remember\nexperimenting with , Item 80: Use @ts-check and JSDoc to Experiment\nwith T ypeScript - Things to Remember\ninability to check at runtime , Y ou Cannot Check T ypeScript T ypes at\nRuntime - Y ou Cannot Check T ypeScript T ypes at Runtime\nmigrating to  ( see  migration)\nmixing with JavaScript , Item 81: Use allowJs to Mix T ypeScript and\nJavaScript - Things to Remember\npreferring ECMAScript features , Item 72: Prefer ECMAScript\nFeatures to T ypeScript Features - Things to Remember\nrelationship with JavaScript , Item 1: Understand the Relationship\nBetween T ypeScript and JavaScript - Things to Remember , Item 72:\nPrefer ECMAScript Features to T ypeScript Features , Item 74: Know\nHow to Reconstruct T ypes at Runtime\nT ypeScript compiler (tsc) , Item 6: Use Y our Editor to Interrogate and\nExplore the T ype System\ncode generation versus type checking , Item 3: Understand That Code\nGeneration Is Independent of T ypes - Things to Remember\nperformance , Item 78: Pay Attention to Compiler Performance - Things\nto Remember\nT ypeScript playground , Y ou Cannot Check T ypeScript T ypes at Runtime ,\nItem 8: Know How to T ell Whether a Symbol Is in the T ype Space or V alue\nSpace\nT ypeScript server (tsserver) , Item 6: Use Y our Editor to Interrogate and\nExplore the T ype System , Item 78: Pay Attention to Compiler Performance -\nThings to Remember\ntypescript-eslint , Item 10: A void Object W rapper T ypes (String, Number ,\nBoolean, Symbol, BigInt)\ntypescript-json-schema , Generate Runtime V alues from Y our T ypes , Things\nto Remember\nU\nunchecked array accesses , Item 48: A void Soundness T raps\nundeclared class members , Undeclared Class Members - Undeclared Class\nMembers\nundeclared globals , Undeclared Globals\nundefined values , Object and Array Lookups\navoiding in aliases , Item 32: A void Including null or undefined in T ype\nAliases - Things to Remember\nstrictNullChecks , strictNullChecks - strictNullChecks\nunifying types versus modeling dif ferences , Item 39: Prefer Unifying T ypes\nto Modeling Dif ferences - Things to Remember\nunion types , Item 19: Use Dif ferent V ariables for Dif ferent T ypes\nconditional types and , Item 52: Prefer Conditional T ypes to Overload\nSignatures\ndisplaying , Item 56: Pay Attention to How T ypes Display\ndistribution over conditional types , Item 53: Know How to Control the\nDistribution of Unions over Conditional T ypes - Things to Remember\nexcluding null , Item 22: Understand T ype Narrowing\nforming , Item 7: Think of T ypes as Sets of V alues\nkeyof , Item 7: Think of T ypes as Sets of V alues\nas sets of values , Item 7: Think of T ypes as Sets of V alues\nsimplifying , Simplify Y our T ypes\ntagged unions  ( see  tagged unions)\nunion interfaces, lack of , Item 13: Know the Dif ferences Between type\nand interface\nunions of interfaces versus interfaces of unions , Item 34: Prefer Unions\nof Interfaces to Interfaces with Unions - Things to Remember\nunions of string literal types , Enums\nunique symbol type , Item 64: Consider Brands for Nominal T yping\nunit testing, relationship with type checking , Item 77: Understand the\nRelationship Between T ype Checking and Unit T esting - Things to\nRemember\nunit types , Item 7: Think of T ypes as Sets of V alues\nuniversal set , Item 7: Think of T ypes as Sets of V alues\nunknown type\nany type versus , Item 46: Use unknown Instead of any for V alues with\nan Unknown T ype - Things to Remember\nwith arrays , Item 44: Prefer More Precise V ariants of any to Plain any\nassignability , Item 46: Use unknown Instead of any for V alues with an\nUnknown T ype\ndomain of , Item 7: Think of T ypes as Sets of V alues\nas function return , Item 51: A void Unnecessary T ype Parameters\ntype assertions and , Item 9: Prefer T ype Annotations to T ype\nAssertions\nunsafe type assertions, hiding , Item 45: Hide Unsafe T ype Assertions in\nW ell-T yped Functions - Things to Remember\nunsoundness , Runtime T ypes May Not Be the Same as Declared T ypes ,\nUnsoundness and the any T ype\n( see also  soundness of type system)\n""use strict"" , Other Features\nuser -defined type guards , Item 9: Prefer T ype Annotations to T ype\nAssertions , Item 22: Understand T ype Narrowing , Item 46: Use unknown\nInstead of any for V alues with an Unknown T ype\nV\nvalid states, representing in type design , Item 29: Prefer T ypes That Always\nRepresent V alid States - Things to Remember\nvalue space versus type space , Y ou Cannot Check T ypeScript T ypes at\nRuntime , Item 8: Know How to T ell Whether a Symbol Is in the T ype\nSpace or V alue Space - Things to Remember\nvalues\navoiding mixing null/non-null , Item 33: Push Null V alues to the\nPerimeter of Y our T ypes - Things to Remember\nchanging types , V alues with Changing T ypes - V alues with Changing\nT ypes\ndefault , Item 37: Limit the Use of Optional Properties , Other Features\nas immutable , Item 7: Think of T ypes as Sets of V alues\nnullable , Other Features\nspecial, types for , Item 36: Use a Distinct T ype for Special V alues -\nThings to Remember\nsynchronizing , Item 61: Use Record T ypes to Keep V alues in Sync -\nThings to Remember\ntype operations and runtime values , T ype Operations Cannot Af fect\nRuntime V alues - T ype Operations Cannot Af fect Runtime V alues\ntypes as sets of , Item 7: Think of T ypes as Sets of V alues - Things to\nRemember , Item 35: Prefer More Precise Alternatives to String T ypes ,\nItem 50: Think of Generics as Functions Between T ypes\nvariables\navoiding reusing , Item 19: Use Dif ferent V ariables for Dif ferent T ypes -\nThings to Remember\ndeclaring , Other Features\nshadowed , Item 19: Use Dif ferent V ariables for Dif ferent T ypes\ntype information in names , Item 31: Don’ t Repeat T ype Information in\nDocumentation\ntype narrowing , Item 22: Understand T ype Narrowing - Things to\nRemember\ntype widening , Item 20: Understand How a V ariable Gets Its T ype -\nThings to Remember\nvariadic functions , Item 62: Use Rest Parameters and T uple T ypes to Model\nV ariadic Functions - Things to Remember\nvariance in objects and arrays , T ypeScript’ s Inaccurate Model of V ariance\nfor Objects and Arrays - T ypeScript’ s Inaccurate Model of V ariance for\nObjects and Arrays\nversion matching in dependency management , Item 66: Understand the\nThree V ersions Involved in T ype Declarations - Things to Remember\nviewing\ntype declarations , Item 6: Use Y our Editor to Interrogate and Explore\nthe T ype System - Item 6: Use Y our Editor to Interrogate and Explore\nthe T ype System\ntype errors , Item 6: Use Y our Editor to Interrogate and Explore the\nT ype System - Item 6: Use Y our Editor to Interrogate and Explore the\nT ype System\nvisibility modifiers , Member V isibility Modifiers (Private, Protected, and\nPublic)\nvocabularies (from problem domain) , Item 41: Name T ypes Using the\nLanguage of Y our Problem Domain - Things to Remember\nW\nweak types , Item 1 1: Distinguish Excess Property Checking from T ype\nChecking\nwidening , Item 20: Understand How a V ariable Gets Its T ype - Things to\nRemember\nZ\nZod , Define T ypes with a Runtime Library - Define T ypes with a Runtime\nLibrary",70316
98-About the Author.pdf,98-About the Author,"About the Author\nDan V anderkam  is an independent software developer based in upstate\nNew Y ork. He was previously a principal software engineer at Sidewalk\nLabs and a senior staf f software engineer at Google. He also worked on\nopen source genome visualizations at Mount Sinai’ s Icahn School of\nMedicine, as well as on Google search features used by billions of people\n(search for “sunset nyc” or “population of france”). He has a long history of\nbuilding open source projects.\nWhen he’ s not programming, Dan enjoys rock climbing at the nearby\nShawangunk Ridge, hiking in the Catskills, and birdwatching all around the\nworld. He writes at effectivetypescript.com  and at danvk.or g . He earned his\nbachelor ’ s in Computer Science from Rice University in Houston, T exas,\nand lives in W allkill, New Y ork.\nColophon\nThe animal on the cover of Effective T ypeScript  is a red-billed oxpecker\n( Buphagus erythr or hynchus ). These birds inhabit a fragmented range across\neastern Africa, from Ethiopia and Somalia in the northeast to a few pockets\nin South Africa; however , these birds can be said to inhabit the range of the\ngrazing animals on which they spend almost all their lives.\nRed-billed oxpeckers are related to starlings and mynahs, although they are\nof a distinct and separate family . About eight inches long and weighing\nabout two ounces, these birds have a bark-brown head, back, and tail, with\npaler coloring below . Their most striking physical features are their red\nbeaks and red eyes set of f by bright yellow eyerings.\nDominating the life of this bird is where and how it finds its food: red-billed\noxpeckers feed on ticks and other animal parasites, and they perch on\nanimals as they forage. Their host animals are most often antelope (such as\nkudu and impala) as well as lar ge animals such as zebra, giraf fe, buf falo,\nand rhinoceros (elephants do not tolerate them). Red-billed oxpeckers have\nevolved adaptations to assist them in their search for food, such as a flat\nbeak to pierce thick animal hair , as well as sharp claws and a stif f tail to\nhang on to their host animals. These birds even conduct courtship while\nperched on a host animal, leaving only during nesting season. Parent birds\nraise three chicks in a nest hole (lined with hair pulled from their host) close\nto the animal herds so that they can feed themselves and their young.\nThe birds’ relationship with their animal hosts was once seen as a clear -cut\nand classic example of mutualism (a mutually beneficial interaction\nbetween species). However , recent studies have shown that oxpeckers’\nfeeding habits don’ t significantly af fect hosts’ parasite loads; additionally ,\noxpeckers actually work to keep animals’ wounds open, so that they can\nfeed on their blood.\nRed-billed oxpeckers remain common across their range; although pesticide\nuse is a threat, their adoption of domestic cattle herds as a food source helps\ntheir population remain stable. Many of the animals on O’Reilly covers are\nendangered; all of them are important to the world.\nThe cover illustration is by Jose Marzan, based on a black-and-white\nengraving from Elements of Ornithology . The series design is by Edie\nFreedman, Ellie V olckhausen, and Karen Montgomery . The cover fonts are\nGilroy and Guardian Sans. The text font is Adobe Minion Pro; the heading\nfont is Adobe Myriad Condensed; and the code font is Dalton Maag’ s\nUbuntu Mono.",3460
