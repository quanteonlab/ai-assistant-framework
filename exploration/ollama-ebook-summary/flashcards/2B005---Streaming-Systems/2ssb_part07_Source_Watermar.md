# Flashcards: 2B005---Streaming-Systems_processed (Part 7)

**Starting Chapter:** Source Watermark Creation

---

#### Watermark Concept
Watermarks are a critical mechanism used in stream processing to determine when to close windows and ensure correctness. The watermark is a monotonically increasing timestamp of the oldest work not yet completed.
:p What is a watermark in the context of stream processing?
??x
A watermark is a monotonic timestamp that indicates the oldest unprocessed data within a windowed processing system. It helps in determining when to emit results and close windows, ensuring completeness and visibility.
x??

---
#### Completeness Property
The watermark allows you to correctly emit any aggregations at or before the current watermark timestamp $T$, as no more on-time events will occur past this timestamp due to its monotonic nature.
:p What does the completeness property of a watermark guarantee?
??x
The completeness property guarantees that once the watermark has advanced past some timestamp $T $, no more processing will occur for on-time (non-late) data at or before $ T$. This ensures that any aggregations emitted up to this point are complete and can be trusted.
x??

---
#### Visibility Property
A message stuck in the pipeline prevents the watermark from advancing, allowing you to identify the source of delays by examining the message blocking progress.
:p What does the visibility property allow us to do?
??x
The visibility property allows us to pinpoint where a delay or blockage is occurring within the pipeline. If messages are getting delayed, it helps in identifying and resolving issues by looking at the specific message that is preventing the watermark from advancing.
x??

---
#### Watermark Creation Source
Watermarks for data sources can be created either perfectly or heuristically. Perfect watermarks ensure accurate timestamps on every event, while heuristic methods approximate these values based on observed behavior.
:p Where do watermarks come from?
??x
Watermarks are generated by assigning logical event timestamps to messages as they enter the pipeline from their source. The method used can be either perfect, where exact timestamps are assigned, or heuristic, where approximations are made based on observed data patterns.
x??

---
#### Perfect Watermark Example
Perfect watermarks guarantee precise timestamps for every message, ensuring no late events slip through undetected. In a windowed summation example, each event gets its timestamp accurately placed.
:p What is the role of perfect watermarks in stream processing?
??x
Perfect watermarks ensure that every message has an accurate timestamp, allowing for precise handling of on-time and late data. This guarantees correctness but may be more resource-intensive compared to heuristic methods.
x??

---
#### Heuristic Watermark Example
Heuristic watermarks approximate timestamps based on observed patterns or heuristics within the stream. They are less precise than perfect watermarks but can still provide useful information for windowing and watermarking operations.
:p How do heuristic watermarks differ from perfect ones?
??x
Heuristic watermarks use approximations based on observed behavior in the data stream, making them less precise but more efficient than perfect watermarks. This approach balances accuracy with computational efficiency.
x??

---
#### Example Code: Watermark Creation
Here's a simplified example of how watermarks can be created using pseudocode:
```java
public class Event {
    private long timestamp;
    // other fields and methods
}

public class WatermarkCreator {
    private long latestWatermark;

    public void update(Event event) {
        if (event.timestamp > latestWatermark) {
            latestWatermark = event.timestamp; // Update watermark based on the new event's timestamp
        }
    }

    public long getLatestWatermark() {
        return latestWatermark;
    }
}
```
:p How would you implement a basic watermark creator in Java?
??x
You can implement a watermark creator by maintaining a variable to track the latest timestamp seen. Whenever an event is received, check its timestamp against this value and update if necessary:
```java
public class Event {
    private long timestamp;
    // other fields and methods
}

public class WatermarkCreator {
    private long latestWatermark;

    public void update(Event event) {
        if (event.timestamp > latestWatermark) {
            latestWatermark = event.timestamp; // Update watermark based on the new event's timestamp
        }
    }

    public long getLatestWatermark() {
        return latestWatermark;
    }
}
```
This ensures that the watermark always reflects the most recent processing point, helping to manage windows correctly.
x??

#### Perfect Watermark Creation
Background context: Perfect watermark creation ensures that no data with event times less than the watermark will ever be seen again from this source. This method provides a strict guarantee, making pipelines using perfect watermarks free from late data. However, it requires perfect knowledge of the input, which is impractical for many real-world distributed inputs.

:p What is perfect watermark creation in the context of stream processing?
??x
Perfect watermark creation assigns timestamps to incoming messages such that the resulting watermark guarantees no data with event times less than the watermark will be seen again from this source. It provides a strict guarantee and ensures pipelines do not have to deal with late data, as all future data will have event times greater than or equal to the watermark.

Example: Consider a system where ingress timestamps are used for assigning event times. The watermark then tracks the current processing time relative to the arrival of new messages in the pipeline.
??x
---

#### Heuristic Watermark Creation
Background context: Heuristic watermark creation offers an estimate that no data with event times less than the watermark will be seen again, but this estimation might include some late data. This method is more flexible and practical for many real-world distributed inputs where perfect knowledge of all input sources is not feasible.

:p What distinguishes heuristic watermark creation from perfect watermark creation?
??x
Heuristic watermark creation provides an estimate that no data with event times less than the watermark will be seen again, which might include some late data. Unlike perfect watermark creation, it does not provide a strict guarantee and may require pipelines to handle late data.

Example: In dynamic sets of time-ordered logs, tracking the minimum unprocessed event times across existing files can create an accurate heuristic watermark by leveraging available knowledge about the input.
??x
---

#### Use Cases for Perfect Watermark Creation
Background context: Perfect watermarks are ideal in scenarios where input timestamps can be assigned perfectly, such as ingress timestamping and static sets of time-ordered logs. These cases offer a strict guarantee that no late data will occur.

:p Which use case exemplifies perfect watermark creation with ingress timestamps?
??x
Ingress timestamping is an example of perfect watermark creation. It involves assigning event times based on the current processing time as messages enter the system, ensuring that the watermark tracks the progress of data relative to their arrival in the system without losing event times.

Example: 
```java
public class IngressTimestamping {
    private long currentTime;

    public void processMessage(Message message) {
        message.setEventTime(currentTime++);
        // Process the message
    }
}
```
??x
---

#### Use Cases for Heuristic Watermark Creation
Background context: Heuristic watermarks are more practical in scenarios where perfect knowledge of all input sources is not feasible, such as dynamic sets of time-ordered logs and Google Cloud Pub/Sub. These use cases require creating an accurate estimate to manage late data.

:p Which example illustrates the application of heuristic watermark creation with dynamic sets of time-ordered logs?
??x
Dynamic sets of time-ordered logs represent a scenario where heuristic watermark creation can be effectively used. By tracking the minimum unprocessed event times across existing files and monitoring growth rates, an accurate heuristic watermark can be established even without perfect knowledge of all inputs.

Example: 
```java
public class HeuristicWatermarkCreator {
    private Map<String, Long> minEventTimes = new HashMap<>();

    public void updateWatermark(String logFile, long minEventTime) {
        minEventTimes.put(logFile, Math.min(minEventTimes.getOrDefault(logFile, 0L), minEventTime));
    }

    public long getWatermark() {
        return Collections.min(minEventTimes.values());
    }
}
```
??x
---

---
#### Input Watermark
Background context: In a multi-stage pipeline, an input watermark captures the progress of everything upstream of that stage. This helps understand how complete the input data is for the current stage.

:p Define and explain the concept of input watermark in a multi-stage pipeline.
??x
The input watermark at a specific stage represents the latest event time seen by all its upstream sources and stages combined. It essentially tracks when new data has arrived and processed up to that point.

For example, consider a two-stage pipeline where Stage 1 processes user-level aggregates from raw data and Stage 2 computes team-level aggregates based on these per-user results. The input watermark for Stage 2 would be the latest event time seen by all sources feeding into Stage 1.
```java
// Pseudocode to calculate input watermark at a stage
public long getInputWatermark() {
    List<Long> upstreamWatermarks = getUpstreamSources().stream()
        .map(Source::getCurrentWatermark)
        .collect(Collectors.toList());
    return Collections.min(upstreamWatermarks);
}
```
x??

---
#### Output Watermark
Background context: An output watermark captures the progress of a stage itself, defined as the minimum of the stageâ€™s input watermark and the event times of all non-late data active messages within the stage.

:p Explain the concept of an output watermark in a multi-stage pipeline.
??x
The output watermark for a stage indicates when the stage has processed data up to a certain point. It is determined by taking the minimum of two values: 
1. The input watermark, which tells us how far we are from the latest event time seen upstream.
2. The event times of all non-late active messages within the current stage.

This helps in understanding when the stage can produce output data that is not late and meets the required processing level.

For instance, consider a windowed aggregation over 10 seconds:
```java
// Pseudocode to calculate output watermark at a stage
public long getOutputWatermark() {
    long inputWatermark = getInputWatermark();
    List<Long> activeMessages = getStageData().stream()
        .filter(message -> !isMessageLate(message))
        .map(Message::getEventTime)
        .collect(Collectors.toList());
    return Math.min(inputWatermark, Collections.min(activeMessages));
}
```
x??

---
#### Event-Time Latency and Lag
Background context: The difference between the input watermark and output watermark of a stage gives the amount of event-time latency or lag introduced by that stage. This indicates how delayed behind real time the output will be.

:p Define and explain event-time latency and lag in a multi-stage pipeline.
??x
Event-time latency, or simply "lag," is the difference between the input watermark (the latest event time seen upstream) and the output watermark (when the current stage has processed data up to that point). This value indicates how much delayed the output of each stage is behind both real-time and the latest input.

For a 10-second windowed aggregation, the lag would be at least 10 seconds because it takes at least 10 seconds from when the first event in the window arrives until all events have been aggregated.
```java
// Pseudocode to calculate stage latency
public long getLatency() {
    return getInputWatermark() - getOutputWatermark();
}
```
x??

---
#### Watermarks Across Multiple Buffers within a Stage
Background context: Within a single stage, processing is often segmented into multiple conceptual components (buffers) that contribute to the output watermark. Each buffer tracks its own watermark, and the overall output watermark of the stage is the minimum across all such buffers.

:p Explain how watermarks are tracked in different buffers within a single stage.
??x
Watermarks can be tracked individually for each buffer within a stage. Each buffer represents an active state where data resides before final processing or transmission to downstream stages. The overall output watermark for the stage is calculated as the minimum of the watermarks across all these buffers.

For example, in a streaming system with buffers:
```java
// Pseudocode to calculate output watermark from multiple buffers
public long getOutputWatermark() {
    List<Long> bufferWatermarks = new ArrayList<>();
    // Assuming we have three buffers (Buffer1, Buffer2, Buffer3)
    bufferWatermarks.add(Buffer1.getWatermark());
    bufferWatermarks.add(Buffer2.getWatermark());
    bufferWatermarks.add(Buffer3.getWatermark());
    return Collections.min(bufferWatermarks);
}
```
x??

---

