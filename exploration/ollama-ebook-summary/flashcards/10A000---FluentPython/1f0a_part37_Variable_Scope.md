# Flashcards: 10A000---FluentPython_processed (Part 37)

**Starting Chapter:** Variable Scope Rules

---

#### Function Decorators and Registration Decorators

Background context: In Python, decorators are a powerful feature that allows modifying or enhancing the behavior of functions. A decorator is essentially a function that takes another function as an argument and returns a new function with enhanced functionality.

:p What does Example 9-2 illustrate about how decorators work in Python?
??x
Example 9-2 illustrates that function decorators are executed as soon as the module containing them is imported, but the decorated functions only run when they are explicitly invoked. This highlights the difference between "import time" and runtime execution.

The example demonstrates a `register` decorator applied to two functions (`f1` and `f2`). The decorator adds the decorated function to a list called `.registry`, which happens at import time, whereas the actual functionality of these functions is only executed when they are called.
x??

---

#### Registration Decorators in Practice

Background context: In Python frameworks, registration decorators are often used to add functions to some central registry. These registries can map URLs to HTTP response generators or other types of mappings.

:p How do real-world decorators differ from the one described in Example 9-2?
??x
Real-world decorators typically define an inner function and return it, as opposed to returning the decorated function unchanged. The `register` decorator in Example 9-2 returns the same function passed as an argument without any modifications, which is unusual for real decorators.

However, this technique can be useful when adding functions to a registry that does not need to modify their behavior.
x??

---

#### Variable Scopes in Python

Background context: In Python, variable scopes determine where variables are accessible within code. Understanding these scopes is crucial for debugging and writing modular code.

:p What errors might you encounter due to incorrect understanding of variable scopes?
??x
You might encounter `NameError` when a global variable has not been defined or `UnboundLocalError` when a local variable is referenced before it is assigned in the function body. 

For example, if you have:
```python
def f1(a):
    print(a)
    print(b)

b = 6
f1(3) # This will raise NameError: global name 'b' is not defined

def f2(a):
    print(a)
    print(b)
    b = 9

f2(3) # This will raise UnboundLocalError: local variable 'b' referenced before assignment
```

In `f1`, the interpreter treats `b` as a global because it's not assigned within the function. In `f2`, the interpreter assumes that `b` is a local variable, leading to an error when trying to print it before it has been assigned.
x??

---

#### Closures in Python

Background context: Closures are functions that remember and have access to variables from their lexical scope even when they are executed outside that scope. Understanding closures helps in writing more flexible and reusable code.

:p What is a closure, and why do we need them?
??x
A closure is a function object that remembers values in enclosing scopes even if those values go out of scope. Closures are needed for creating functions that can maintain state or interact with variables outside their own local scope, providing functionality similar to private members of classes in other languages.

For example:
```python
def outer_function(x):
    def inner_function(y):
        return x + y
    return inner_function

closure_example = outer_function(10)
print(closure_example(5)) # Outputs 15
```

Here, `inner_function` is a closure because it retains the value of `x` from its parent function even after the parent function has finished execution.
x??

---

#### Bytecode Differences in Python

Background context: The dis module allows us to examine the bytecode generated by Python for functions. This can provide insights into how functions are executed and optimized.

:p What does Example 9-5 and Example 9-6 demonstrate about the `print` function calls?
??x
Example 9-5 demonstrates that in the `f1` function, both `a` and `b` are loaded from the global scope when they are referenced. On the other hand, Example 9-6 shows that in the `f2` function, only `a` is loaded from a local scope; the attempt to load `b` as a local fails because it hasn't been assigned yet.

Here's a detailed comparison:
Example 9-5 (bytecode for f1):
```python
def dis(f1):
    dis(f1)
```
Example 9-6 (bytecode for f2):
```python
def dis(f2):
    dis(f2)
```

The key difference is in the handling of `b`:
- In `f1`, it's a global variable.
- In `f2`, it's treated as a local before being assigned, leading to an error if referenced before assignment.

Understanding these differences helps in writing correct and efficient Python code.
x??

---

#### Bytecode and Local Variables
Background context explaining how Python's bytecode operates, specifically focusing on local variables. The example provided demonstrates that a variable's nature as local cannot change within the function body despite later assignments.

:p What does the given Python bytecode indicate about the nature of variables in functions?
??x
The given Python bytecode shows that the compiler considers `b` as a local variable even after it gets reassigned later. This is because the scope and type of a variable—whether it’s local or not—are determined at the time the function is compiled, not when executed.

```python
# Example code snippet to illustrate
def example_function():
    13 LOAD_FAST                 1 (b)
    16 CALL_FUNCTION             1 (1 positional , 0 keyword pair)
    19 POP_TOP
    20 LOAD_CONST                1 (9)
    23 STORE_FAST                1 (b)
```
x??

---

#### Closures in Python
Background context explaining the concept of closures and how they differ from anonymous functions. The text provides an example of a functional implementation using higher-order functions to create a running average calculator.

:p What is a closure in Python?
??x
A closure in Python is a function that has extended scope, meaning it can access variables that are not global or local to itself but come from the local scope of an outer function. This allows the inner function to maintain state across multiple calls, effectively remembering values from its parent's execution context.

```python
# Example code snippet for make_averager function
def make_averager():
    series = []  # Local variable in make_averager but free in averager
    def averager(new_value):
        series.append(new_value)
        total = sum(series)
        return total / len(series)
    return averager
```
x??

---

#### Class-Based Running Average Calculator
Background context explaining how a running average can be implemented using a class. This approach uses an instance method to store and update the history of values.

:p How is the `Averager` class used for calculating a running average?
??x
The `Averager` class creates instances that are callable, allowing you to keep track of a series of numbers and calculate their mean at any point. Each instance maintains its own list (`self.series`) which stores all values seen so far.

```python
class Averager:
    def __init__(self):
        self.series = []
    
    def __call__(self, new_value):
        self.series.append(new_value)
        total = sum(self.series)
        return total / len(self.series)

# Example usage
avg = Averager()
print(avg(10))  # Output: 10.0
print(avg(11))  # Output: 10.5
print(avg(12))  # Output: 11.0
```
x??

---

#### Functional Implementation of Running Average Calculator
Background context explaining how a running average can be implemented using a higher-order function. This approach uses an inner function to store and update the history of values.

:p How does the `make_averager` function create a running average calculator?
??x
The `make_averager` function is a higher-order function that returns another function (`averager`) with access to its own local variable `series`. This inner function can be called repeatedly, updating and using this shared state to compute new averages.

```python
def make_averager():
    series = []  # Local variable in make_averager but free in averager
    def averager(new_value):
        series.append(new_value)
        total = sum(series)
        return total / len(series)
    return averager

# Example usage
avg = make_averager()
print(avg(10))  # Output: 10.0
print(avg(11))  # Output: 10.5
print(avg(12))  # Output: 11.0
```
x??

---

#### Free Variables in Closures
Background context explaining the concept of free variables and how they are used in closures to maintain state across function calls.

:p What role do free variables play in closures?
??x
Free variables in a closure are variables that are referenced within an inner function but not defined in its own local scope. They come from the outer function's local scope, allowing the inner function to access and modify them even after the outer function has returned. This is crucial for maintaining state across multiple calls of the inner function.

```python
def make_averager():
    series = []  # Local variable in make_averager but free in averager
    def averager(new_value):
        series.append(new_value)
        total = sum(series)
        return total / len(series)
    return averager

# Example usage
avg = make_averager()
print(avg(10))  # Output: 10.0
print(avg(11))  # Output: 10.5
print(avg(12))  # Output: 11.0
```
x??

---

#### Closures and Free Variables
Background context: In Python, a closure is a function object that has access to variables from its lexical scope even when the function is executed outside that scope. This allows for the preservation of state across multiple calls. The `__code__.co_freevars` attribute contains names of free variables used in the function, and `__closure__` holds their values.
:p What are closures and how do they work in Python?
??x
Closures in Python allow a function to retain access to variables from its lexical scope even when that function is called outside that scope. When a nested function accesses a variable from an enclosing function, it forms a closure if the inner function retains references to these free variables.

Here's how it works with code:
```python
def outer_function(series):
    def avg(new_value):
        # series is a free variable here
        return new_value + series[0]  # This creates a closure
    return avg

avg = outer_function([1, 2, 3])
print(avg(4))  # Outputs: 5
```
x??

---
#### Nonlocal Keyword in Python
Background context: In Python, the `nonlocal` keyword is used to declare that a variable inside a nested function refers to a variable defined in the enclosing scope. This allows the inner function to modify variables from its outer function without creating a local copy.
:p What does the `nonlocal` keyword do in Python?
??x
The `nonlocal` keyword in Python allows you to modify variables in an outer (but non-global) scope, effectively making these variables free variables within the nested function. This is useful when you want to maintain state across multiple function calls without using global variables.
Example:
```python
def make_averager():
    count = 0
    total = 0

    def averager(new_value):
        nonlocal count, total
        count += 1
        total += new_value
        return total / count
    return averager

avg = make_averager()
print(avg(10))  # Outputs: 10.0
```
x??

---
#### Efficient Running Average Calculation
Background context: When implementing a running average function, it is inefficient to store all historical values. A more efficient approach is to maintain only the total and count of items seen so far.
:p Why is maintaining a list of all historical values inefficient for calculating a running average?
??x
Maintaining a list of all historical values in each call to calculate the running average is inefficient because it requires storing and updating a potentially large list. This increases memory usage and slows down the function as the number of calls grows.

By contrast, maintaining only the total sum and count of items allows for constant-time updates and calculations.
```python
def make_averager():
    count = 0
    total = 0

    def averager(new_value):
        nonlocal count, total
        count += 1
        total += new_value
        return total / count
    return averager

avg = make_averager()
print(avg(10))  # Outputs: 10.0
```
x??

---
#### UnboundLocalError in Nested Functions
Background context: In Python, if a variable is assigned within a nested function and not declared as `nonlocal`, it will be treated as a local variable, leading to an `UnboundLocalError` when referenced before assignment.
:p Why does the following code raise an `UnboundLocalError`?
??x
The following code raises an `UnboundLocalError` because the variables `count` and `total` are assigned within the nested function `averager`, making them local to that scope. This means they cannot be referenced before being assigned, leading to an error.

```python
def make_averager():
    count = 0
    total = 0

    def averager(new_value):
        count += 1
        total += new_value
        return total / count
    return averager

avg = make_averager()
print(avg(10))  # Raises UnboundLocalError: local variable 'count' referenced before assignment
```
x??

---
#### Correct Implementation with `nonlocal` Keyword
Background context: Using the `nonlocal` keyword, you can declare a variable as a free variable within a nested function even if it is assigned inside that function. This allows maintaining state across multiple function calls.
:p How does using `nonlocal` fix the issue in Example 9-12?
??x
Using the `nonlocal` keyword fixes the issue by declaring `count` and `total` as free variables within the nested `averager` function. This means they are still accessible from the outer scope, allowing them to be updated without being treated as local variables.

Here’s the corrected implementation:
```python
def make_averager():
    count = 0
    total = 0

    def averager(new_value):
        nonlocal count, total
        count += 1
        total += new_value
        return total / count
    return averager

avg = make_averager()
print(avg(10))  # Outputs: 10.0
```
x??

---

