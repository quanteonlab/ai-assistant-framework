# Flashcards: 10A008---Computational-Physics---Rubin-H_-Landau_processed (Part 8)

**Starting Chapter:** 4.3.4 Decay Implementation and Visualization

---

#### Limiting Behavior of Exponential Decay

In scenarios where a large number of particles \( N \to \infty \) and the observation time interval \( \Delta t \to 0 \), the difference equation (4.21) approximates to a differential equation, leading us to derive the well-known exponential decay law.

:p What is the differential equation that describes exponential decay in this context?
??x
The differential equation that describes exponential decay when \( N \to \infty \) and \( \Delta t \to 0 \) is:

\[
\frac{dN(t)}{dt} = -\lambda N(t)
\]

This can be integrated to give the time dependencies of the total number of particles and their activity:

\[
N(t) = N(0)e^{-\lambda t} = N(0)e^{-t/\tau}, \quad \text{and} \quad \frac{dN}{dt}(t) = -\lambda N(0)e^{-\lambda t}
\]

where \( \lambda \) is the decay rate and \( \tau = \frac{1}{\lambda} \) is the mean lifetime.
x??

---

#### Discrete Decay Simulation

Simulating radioactive decay with discrete steps involves incrementing time in intervals of \( \Delta t \). For each interval, we count how many nuclei have decayed. The simulation ends when there are no more nuclei left to decay.

:p What is the pseudocode for a simple radioactive decay simulator?
??x
The pseudocode for simulating radioactive decay with discrete steps is as follows:

```plaintext
input N, lambda
t = 0
while N > 0
    Delta = 0
    for i = 1 to N
        if (r_i < lambda)
            Delta += 1
    endfor
    t = t + 1
    N = N - Delta
endwhile
Output t, Delta, N
```

In this code:
- \( N \) is the initial number of particles.
- \( \lambda \) is the decay rate.
- `r_i` are random numbers between 0 and 1.
- The loop increments time by one step each iteration until no more nuclei are left to decay.
x??

---

#### Context of Exponential Decay Limitation

In natural conditions, where \( N(t) \) can be a small number, the process is statistical rather than continuous. Although the fundamental law of nature remains valid, exponential decay (4.24) becomes less accurate as \( N \) decreases.

:p Why does exponential decay become inaccurate for smaller numbers of particles?
??x
Exponential decay becomes inaccurate when the number of particles \( N(t) \) is small because it approximates a continuous process. In reality, with few particles, each event (decay) is stochastic and random. The discrete nature of particle interactions means that the exponential model's assumptions about a smooth transition are no longer valid.

For very low numbers of particles, fluctuations become significant, leading to statistical variations that deviate from the expected behavior described by the continuous exponential decay equation.
x??

---

#### Time Scale Setting in Simulations

When setting up simulations with specific decay rates \( \lambda = 1/\tau \), one must consider the time scale. For instance, if the actual decay rate is \( \lambda = 0.3 \times 10^6 \text{s}^{-1} \) and we choose to measure times in units of \( 10^{-6} \text{s} \), random numbers \( r_i \) between 0 and 1 will yield values around the middle of the range, effectively approximating \( \lambda \approx 0.3 \).

:p How do you set up the time scale for a simulation with a given decay rate?
??x
To set up the time scale for a simulation with a given decay rate \( \lambda = 1/\tau \), you need to:

1. Determine the actual decay rate in units relevant to your measurement.
2. Choose the time unit such that it aligns well with the desired decay rate.

For example, if the actual decay rate is \( \lambda = 0.3 \times 10^6 \text{s}^{-1} \) and you decide to measure times in units of \( 10^{-6} \text{s} \):

- The random numbers \( r_i \) will be between 0 and 1.
- This setup will yield effective values for \( \lambda \) that are around the middle of its range, effectively approximating \( \lambda \approx 0.3 \).

The choice of time unit ensures that the simulation aligns with real-world expectations by scaling the decay rate appropriately.
x??

---

#### Testing Random Number Generators: Visual Inspection

Background context explaining the concept. A quick visual test for randomness involves plotting a list of numbers generated by a random number generator with `r` as the ordinate and `i` as the abscissa. Observe how there appears to be a uniform distribution between 0 and 1, and no particular correlation between points.

If applicable, add code examples with explanations.
:p How do you perform a quick visual test for randomness?
??x
By plotting the generated numbers on a graph where `r` is the ordinate (y-axis) and `i` is the abscissa (x-axis), observe if the points appear uniformly distributed between 0 and 1, and show no particular correlation. The eye and brain may try to recognize patterns, but true randomness should not be easily discernible.
x??

---

#### Testing Random Number Generators: Scatter Plot

Background context explaining the concept. An effective test for randomness involves making a scatter plot of `(xi = r2i, yi = r2i+1)` for many values of `i`. If points show noticeable regularity, the sequence is not random. Random points should uniformly fill a square with no discernible pattern.

If applicable, add code examples with explanations.
:p How do you create an effective test for randomness using a scatter plot?
??x
Create a scatter plot where each point is `(xi = r2i, yi = r2i+1)` for many values of `i`. If the points are randomly distributed and form a uniform cloud without any discernible pattern, the sequence is considered random.
x??

---

#### Testing Random Number Generators: kth Moment

Background context explaining the concept. A simple test of uniformity involves evaluating the `k`-th moment of a distribution using the formula:

\[ \langle x^k \rangle = \frac{1}{N} \sum_{i=1}^{N} x_i^k \]

If the numbers are distributed uniformly, then the `k`-th moment is approximately given by:

\[ \langle x^k \rangle \approx \int_0^1 dx \, x^k P(x) \approx \frac{1}{k+1} + O\left(\frac{1}{\sqrt{N}}\right) \]

If the deviation from this formula varies as \( 1/\sqrt{N} \), then you know that the distribution is random because this result derives from assuming randomness.

:p How do you test uniformity using the k-th moment?
??x
Evaluate the `k`-th moment of a distribution with:

\[ \langle x^k \rangle = \frac{1}{N} \sum_{i=1}^{N} x_i^k \]

If the numbers are uniformly distributed, then:

\[ \langle x^k \rangle \approx \frac{1}{k+1} + O\left(\frac{1}{\sqrt{N}}\right) \]

If the deviation from this formula varies as \( 1/\sqrt{N} \), it indicates randomness in the distribution.
x??

---

#### Testing Random Number Generators: Near-Neighbor Correlation

Background context explaining the concept. Another simple test determines the near-neighbor correlation in your random sequence by taking sums of products for small `k`:

\[ C(k) = \frac{1}{N} \sum_{i=1}^{N} x_i x_{i+k}, \quad (k=1,2,\ldots) \]

If points are not correlated, the correlation function should be close to zero.

:p How do you determine near-neighbor correlations in a random sequence?
??x
Calculate the near-neighbor correlation by taking sums of products for small `k`:

\[ C(k) = \frac{1}{N} \sum_{i=1}^{N} x_i x_{i+k}, \quad (k=1,2,\ldots) \]

If points are not correlated, the correlation function should be close to zero. This test helps identify any regularity in the sequence.
x??

---

#### Radioactive Decay Simulation: Plotting N(t) and ΔN(t)/Δt

Background context explaining the concept. Write a program to simulate radioactive decay using the simple program as a guide. Plot `ln(N(t))` versus time and `ln(ΔN(t)/Δt)` versus time, where `N(t)` is the number of atoms left at time `t`, and `ΔN(t)/Δt` is the rate of decay.

:p How do you plot the logarithm of the number of atoms left (N(t)) and the decay rate ln(ΔN(t)/Δt) versus time?
??x
Plot `ln(N(t))` versus time to check for exponential behavior. Similarly, plot `ln(ΔN(t)/Δt)` versus time to observe how the decay rate changes over time.

Example code in Python:
```python
import matplotlib.pyplot as plt

# Example data: t = [0, 1, 2, ..., T]
# N_t = [N0 * exp(-lambda*t) for t in range(T+1)]
t = [i for i in range(10)]  # Time steps
N_t = [100 * (0.3 ** (i)) for i in range(10)]  # Example decay data

# Calculate dN/dt and ln(dN/dt)
dNdtdNdt = [(N_t[i+1] - N_t[i]) / dt for i in range(len(N_t)-1)]
ln_dNdt = [np.log(abs(x)) for x in dNdtdNdt]

plt.plot(t, np.log(N_t), label='ln N(t)')
plt.plot(t[:-1], ln_dNdt, label='ln(ΔN(t)/Δt)')
plt.xlabel('Time')
plt.ylabel('Logarithmic Values')
plt.legend()
plt.show()
```
x??

---

#### Radioactive Decay Simulation: Slopes and Proportional Relationships

Background context explaining the concept. Create plots to show that the slopes of `N(t)` versus time are independent of `N(0)`, and another showing that the slopes are proportional to the value for λ.

:p How do you create a plot showing the independence of slopes from N(0)?
??x
To show that the slopes of `N(t)` versus time are independent of `N(0)`, plot the logarithm of `N(t)` (i.e., `ln(N(t))`) against time. The slope should be constant, reflecting a linear relationship indicative of exponential decay.

Example code in Python:
```python
import numpy as np

# Example data: N_t = [N0 * exp(-lambda*t) for t in range(T+1)]
t = [i for i in range(10)]  # Time steps
N0, lambda_val = 100, 0.3  # Initial number and decay rate
N_t = [N0 * (np.exp(-lambda_val * i)) for i in t]

plt.plot(t, np.log(N_t), label='ln N(t)')
plt.xlabel('Time')
plt.ylabel('Logarithmic Values')
plt.legend()
plt.show()
```
x??

---

#### Radioactive Decay Simulation: Proportional Relationship

Background context explaining the concept. Create a plot showing that within expected statistical variations, `ln(N(t))` and `ln(ΔN(t)/Δt)` are proportional.

:p How do you create a plot showing the proportional relationship between ln(N(t)) and ln(ΔN(t)/Δt)?
??x
To show the proportional relationship between `ln(N(t))` and `ln(ΔN(t)/Δt)`, plot both quantities against each other. The slope should be constant, reflecting the proportionality.

Example code in Python:
```python
import numpy as np

# Example data: N_t = [N0 * exp(-lambda*t) for t in range(T+1)]
t = [i for i in range(10)]  # Time steps
N0, lambda_val = 100, 0.3  # Initial number and decay rate
N_t = [N0 * (np.exp(-lambda_val * i)) for i in t]

# Calculate dN/dt and ln(dN/dt)
dNdtdNdt = [(N_t[i+1] - N_t[i]) / dt for i in range(len(N_t)-1)]
ln_dNdt = [np.log(abs(x)) for x in dNdtdNdt]

plt.plot(np.log(N_t[:-1]), ln_dNdt, label='Proportional Relationship')
plt.xlabel('ln N(t)')
plt.ylabel('ln(ΔN(t)/Δt)')
plt.legend()
plt.show()
```
x??

---

#### Radioactive Decay Simulation: Explanation of Proportionality

Background context explaining the concept. The proportional relationship between `ln(N(t))` and `ln(ΔN(t)/Δt)` is a fundamental aspect of radioactive decay, reflecting the exponential nature of the process.

:p Explain the significance of the proportional relationship in radioactive decay.
??x
The proportional relationship between `ln(N(t))` and `ln(ΔN(t)/Δt)` indicates that the logarithm of the number of atoms left at time `t` (`ln(N(t))`) is directly proportional to the logarithm of the rate of change of this number (i.e., `ln(ΔN(t)/Δt)`). This relationship arises because radioactive decay follows an exponential law, where the rate of decay is proportional to the current number of atoms. Thus, a constant slope in such plots confirms the validity and consistency of the exponential decay model.
x??

--- 

These flashcards cover key concepts from the provided text, focusing on testing random number generators and simulating radioactive decay with relevant explanations and code examples where applicable.

#### Random Number Generator Testing

Background context: This section discusses a method to test whether random numbers generated by your generator are uniform and independent. The formula \( \sqrt{N} \left| \frac{1}{N}\sum_{i=1}^{N} x_i x_{i+k} - 1/4 \right| \) is used to approximate the integral, where \( k \) is a constant and \( N \) is the number of random numbers. This test helps determine if your generator produces uniformly distributed and independent random numbers.

:p What is the formula used to test whether generated random numbers are uniform and independent?
??x
The formula uses the sum of products of pairs of random numbers separated by a fixed distance \( k \):

\[ \sqrt{N} \left| \frac{1}{N}\sum_{i=1}^{N} x_i x_{i+k} - 1/4 \right| \]

This formula should be approximately equal to 1 if the random numbers are uniform and independent. The test is performed for different values of \( k \) and \( N \).
x??

---

#### Walk.py: Random Walk Simulation

Background context: This script simulates a simple random walk in two dimensions. Each step has an equal probability of moving left, right, up, or down from the current position. The `random.random()` function is used to generate random numbers within the range [0, 1). By subtracting 0.5 and multiplying by 2, the result is scaled to a symmetric interval around zero.

:p What does the `Walk.py` script simulate?
??x
The `Walk.py` script simulates a two-dimensional random walk where at each step, the walker moves either left, right, up, or down with equal probability. The position of the walker is updated based on random values generated by `random.random()`.

Code:
```python
from visual import *
from visual.graph import *

j = 0

while j < 1500: 
    rate(2)
    j += 1
    
    x = -4 + 8 * random.random()  
    y = -3 + 6 * random.random()
    
    sphere(pos=(x, y), radius=0.2, color=color.red)
```
This code snippet generates a series of points representing the walker's path on a grid.

x??

---

#### DecaySound.py: Simulating Spontaneous Decay

Background context: This script simulates spontaneous radioactive decay by generating random numbers to determine if a decay event occurs based on a given decay constant. The `winsound.Beep()` function is used to play a sound each time a decay event happens, mimicking the noise of a Geiger counter.

:p What does the `DecaySound.py` script simulate?
??x
The `DecaySound.py` script simulates spontaneous radioactive decay where decays occur with a probability determined by a random number and a predefined decay constant. Each decay is accompanied by a sound beep to mimic the noise of a Geiger counter.

Code:
```python
from visual import *
from visual.graph import *
import random, winsound

lambda1 = 0.005  # Decay constant
max = 80.
time_max = 500
seed = 68111
number = nloop = max

graph1 = gdisplay(title='Spontaneous Decay', xtitle='Time', ytitle='Number')
decayfunc = gcurve(color=color.green)

for time in range(0, time_max + 1):  # Time loop
    for atom in range(1, number + 1):  # Decay loop
        decay = random.random()
        if (decay < lambda1):
            nloop -= 1  # A decay
            winsound.Beep(600, 100)  # Sound beep

number = nloop
decayfunc.plot(pos=(time, number))
```
x??

---

#### Testing Random Number Generator with Walk.py and DecaySound.py

Background context: The provided scripts `Walk.py` and `DecaySound.py` are examples of how to test the quality of a random number generator. `Walk.py` uses the random walk algorithm to ensure that the generated numbers are uniformly distributed, while `DecaySound.py` simulates spontaneous decay events based on a given probability.

:p How does `Walk.py` help in testing the quality of a random number generator?
??x
`Walk.py` helps test the quality of a random number generator by simulating a two-dimensional random walk. The script uses uniformly distributed random numbers to move the walker either left, right, up, or down at each step. By analyzing the distribution and independence of these steps, we can infer whether the random number generator produces high-quality pseudo-random numbers.

The key test involves computing:
\[ \sqrt{N} \left| \frac{1}{N}\sum_{i=1}^{N} x_i x_{i+k} - 1/4 \right| \]

This formula should be approximately equal to 1 if the random numbers are uniform and independent. The test is performed for different values of \( k \) and \( N \).

x??

--- 

These flashcards cover key concepts from the provided text, explaining each in detail with relevant code snippets and explanations. Each card focuses on a single question or concept related to testing random number generators using specific scripts.

