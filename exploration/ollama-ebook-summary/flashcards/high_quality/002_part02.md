# High-Quality Flashcards: 002 (Part 2)

---

#### BDD as a Concept
BDD is not primarily about testing, but about sharing knowledge efficiently among all stakeholders. The main objective is to ensure that everyone—from developers and testers to business analysts—understands the requirements of the application.

:p What does BDD focus on according to the provided text?
??x
BDD focuses on sharing knowledge effectively between development and non-technical stakeholders like business analysts, ensuring a common understanding of the application's behavior.
x??

---

#### Conversations in BDD
In BDD, deep conversations are central. These conversations involve three or more stakeholders who are typically referred to as "the amigos." The goal is to ensure that everyone is aligned on the requirements and expectations for the software.

:p What does BDD promote according to the text?
??x
BDD promotes deep conversations among multiple stakeholders (referred to as "the amigos"), ensuring alignment on the application's requirements and behaviors.
x??

---

#### Living Documentation through Scenarios
A key benefit of BDD is the creation of living documentation. These scenarios are written in plain, business language and serve as a reference for understanding how the system should behave.

:p What does BDD offer that can be trusted?
??x
BDD offers "living documentation" that explains what the application is doing and can be trusted because it remains up-to-date with the current requirements.
x??

---

#### Use of Scenarios in BDD
Scenarios used in BDD must use the language of the business domain. This approach helps detect misunderstandings or ambiguities early, ensuring that everyone has a clear understanding of what the system should do.

:p What is essential about scenarios in BDD?
??x
Scenarios in BDD are written using the language of the business domain, helping to detect misunderstandings or ambiguities early and ensure clarity among all stakeholders.
x??

---

#### BDD vs. Testing
BDD is not just a testing framework; it’s about ensuring that everyone involved in a project has a shared understanding of what the application should do.

:p How does BDD differ from traditional testing approaches?
??x
BDD differs from traditional testing by focusing on knowledge sharing and alignment among all stakeholders, rather than being solely about writing tests.
x??

---

---

---
#### BDD and Living Documentation
Behavior-Driven Development (BDD) uses a domain-specific language to create living documentation. This involves stakeholders, particularly the three amigos: business owners, developers, and testers. The scenarios or examples created become tests within tools like Cucumber or SpecFlow.

BDD provides value through conversations but offers more benefits when paired with automation. Automated BDD ensures consistency between high-level descriptions (scenarios) and low-level implementation code.
:p What is the main advantage of using BDD over just having conversations?
??x
Automated BDD ensures that scenarios and source code are in sync, providing living documentation and reducing redundancy problems.
x??

---
#### Redundancy and Reconciliation
In BDD, both scenarios (describing behavior) and actual application code describe the same functionality. This dual description is redundant but beneficial as it makes the system understandable to non-technical stakeholders.

However, this redundancy can be a problem if the two descriptions evolve independently, leading to inconsistency issues.
:p Why is having both scenarios and source code describing the same behavior considered redundant?
??x
Having both scenarios and source code describing the same behavior ensures that the system's requirements are clear in multiple representations, which aids understanding. However, it also means that there can be inconsistencies if one changes without updating the other.
x??

---
#### Roberval Balance Mechanism
Cucumber or SpecFlow tools act as a balance (Roberval mechanism) to reconcile the redundant descriptions of behavior between scenarios and actual code.

These tools parse plain text scenarios and use glue code provided by developers to drive the application. They extract parameters from "Given" and "When" sections, pass them to the application, and check assertions in "Then" sections.
:p How do Cucumber or SpecFlow tools reconcile discrepancies between scenarios and source code?
??x
Cucumber or SpecFlow tools parse plain text scenarios and use glue code to drive the application. They extract parameters from "Given" and "When" sections for calling actual code, and check assertions based on results.
```java
public class ScenarioParser {
    public void executeScenario(String scenario) {
        // Parse and extract parameters
        String[] params = parseParameters(scenario);
        
        // Call the application code with parameters
        Object result = callApplicationCode(params[0], params[1]);
        
        // Check assertions based on expected results
        assertResult(result, params[2]);
    }
    
    private String[] parseParameters(String scenario) {
        // Logic to extract "Given" and "When" sections
        return new String[]{"param1", "param2"};
    }
    
    private Object callApplicationCode(String param1, String param2) {
        // Call actual application code with parameters
        return "result";
    }
    
    private void assertResult(Object result, String expectedResult) {
        // Check if the result matches the expected result
        System.out.println(result.equals(expectedResult));
    }
}
```
x??

---
#### Three Amigos
The three amigos refer to a set of stakeholders in BDD: business owners, developers, and testers. They collaborate closely during BDD practices.

This collaboration ensures that everyone is aligned on the requirements and expectations.
:p Who are the three amigos in BDD?
??x
The three amigos in BDD are business owners (stakeholders), developers, and testers. They work together to ensure clear communication and alignment on project requirements.
x??

---
#### Reconciliation Mechanism
A reconciliation mechanism is necessary when scenarios and code evolve independently. Tools like Cucumber or SpecFlow help by ensuring that the two descriptions of behavior remain consistent.

These tools act as a balance (Roberval mechanism) between the redundant pieces of knowledge, regularly checking if the scenarios and code are in sync.
:p What role do Cucumber or SpecFlow play in BDD?
??x
Cucumber or SpecFlow act as a reconciliation mechanism by parsing plain text scenarios, driving application code with glue code, extracting parameters from "Given" and "When" sections, and using assertions to check if the results match expectations. This ensures that the behavior described in scenarios aligns with the actual implementation.
x??

---

---

#### Behavior-Driven Development as an Example of Living Specifications

Behavior-Driven Development (BDD) is a method that focuses on developing software by clearly defining expected behaviors through collaborative effort between developers, testers, and business analysts. The documentation is structured into feature files that describe the behavior in plain text and are used to generate executable specifications.

:p What is BDD and how does it use feature files?
??x
BDD uses feature files as a way to collaboratively define the desired behaviors of software through plain text descriptions. These descriptions provide an opportunity for gathering documentation directly within source control, making it easier to maintain and update as the project evolves.

Example feature file content:
```plaintext
68 Chapter 2 Behavior-Driven Development as an Example of Living Specifications
26     PV?                          FV = $100
27     |               |              |
28     ---------------------------------------> t (years)
29     0               1              2
32 Scenario: Present Value of a single cash amount
34 Given a future cash amount of $100 in 2 years
35 And an interest rate of 8%
36 When we calculate its present value
37 Then its present value is $85.73
```
x??

---

#### Living Documentation Website

Living documentation websites are part of the BDD approach, where feature files and their corresponding test scenarios are rendered into a readable format, often HTML or PDF.

:p How does living documentation work in the context of BDD?
??x
Living documentation integrates feature files directly within the source control. These files not only contain executable tests but also descriptions, formulas, and ASCII diagrams that provide context and explanations for the business requirements. The integration allows developers to maintain a single source of truth for both the development process and documentation.

For example:
```plaintext
This documentation will be rendered in the living documentation website as a pretty document called “Feature: Investment Present Value.”
```
x??

---

#### Co-Location of Descriptions and Scenarios

In BDD, descriptions often use sample numbers that are not necessarily representative of real business processes. This separation helps maintain clarity and flexibility.

:p Why is it important to separate volatile parts from non-volatile parts in BDD?
??x
Separating the volatile parts (the specific scenarios) from the non-volatile parts (general descriptions) ensures that changes in requirements do not require updates to the entire document. Sample numbers used for calculations or examples can be changed without affecting the general principles described.

Example:
```plaintext
One way to do this is to clarify that the description uses sample numbers, not the numbers that are necessarily used for the configuration of the business process at any point in time.
```
x??

---

#### Tools for Generating Living Documentation

Tools like Pickle, Relish, and Tzatziki understand Markdown descriptions and can integrate them with feature files. These tools facilitate consistent domain documentation.

:p What are some tools that help generate living documentation?
??x
Pickle, Relish, and Tzatziki are tools designed to understand Markdown descriptions located next to feature files. They enable an integrated approach for documenting business requirements in a readable format. For instance, Tzatziki can export PDFs as required by financial regulators.

Example:
```plaintext
Tools like Pickle, http://www.picklesdoc.com and Relish, http://www.relishapp.com understand Markdown descriptions and even plain Markdown files located next to the feature files.
```
x??

---

#### Property-Based Testing

Property-based testing is a technique that exercises general properties against randomly generated samples. This approach complements BDD by making general properties executable.

:p What is property-based testing in the context of BDD?
??x
Property-based testing involves formulating general properties and validating them using random data generation. This method helps ensure that general rules hold true under a variety of conditions, providing a robust way to test software behavior.

Example:
```plaintext
Scenario: The sum of all cash amounts exchanged must be zero for derivatives

Given any derivative financial instrument
And a random date during its lifetime
When we generate the related cash flows on this date for the payer and the receiver
Then the sum of the cash flows of the payer and the receiver is exactly zero.
```
x??

---

#### Glossary Creation in BDD

A glossary in BDD can be created manually or extracted from code. It should contain definitions of terms used in feature files.

:p How does one create a glossary for BDD?
??x
Creating a glossary involves defining key terms and concepts used in feature files. This can be done manually as Markdown files co-located with other feature files, ensuring they are included in the living documentation website. A dummy empty feature file could also serve this purpose.

Example:
```plaintext
It’s possible to create a glossary manually as a Markdown file and to co-locate it with the other feature files.
```
x??

---

---

#### Identifying Authoritative Knowledge
Background context explaining the importance of identifying authoritative sources of knowledge. In a project, knowledge can be spread across various documents and people's minds. Traditional documentation may duplicate this knowledge, leading to inconsistencies over time as decisions change.

:p What is the importance of identifying authoritative sources of knowledge in a project?
??x
The importance lies in ensuring that when knowledge needs to be accessed or updated, you can reliably refer back to the most accurate source. This helps maintain consistency and accuracy across different parts of the system without relying on potentially outdated or incomplete documentation.

For example, if a decision is made regarding how data should be handled, identifying the authoritative source ensures that all relevant teams (e.g., developers, testers) are aware of this change in real-time. Without proper identification, it's easy to miss updates, leading to confusion and bugs.
x??

---

#### Extracting Knowledge Mechanisms
Background context explaining the need for lightweight mechanisms to extract knowledge from its location and bring it where needed. The mechanisms should be simple and reliable since time is limited.

:p What are some examples of mechanisms that can be used to extract knowledge from various sources?
??x
Examples include automated scripts that pull relevant information from source code, configuration files, test results, runtime logs, and other tools. These mechanisms ensure that the most up-to-date and accurate information is always available when needed.

For instance, a script could parse through the source code of a Java application to extract comments or specific annotations indicating best practices or warnings.
```java
public class Example {
    // @Deprecated: Use newFeature() instead.
    public void oldMethod() {
        System.out.println("This method is deprecated.");
    }
}
```
A more complex example might involve scraping runtime logs for specific error messages that indicate issues with the application's behavior.

:p How can automation be used to extract knowledge from source code in a Java project?
??x
Automation can be implemented using tools like Javadoc or regular expressions within scripts. For instance, you could write a script that searches through all .java files in your project directory for comments containing specific keywords (e.g., "TODO," "FIXME," "WARNING").

Here's a simple example of how to do this in Python:
```python
import os

def extract_comments(directory):
    with open('knowledge_base.txt', 'w') as file:
        for root, dirs, files in os.walk(directory):
            for file_name in files:
                if file_name.endswith('.java'):
                    with open(os.path.join(root, file_name)) as f:
                        lines = f.readlines()
                        for line in lines:
                            if "TODO" in line or "FIXME" in line or "WARNING" in line:
                                file.write(f"{line.strip()}\n")

extract_comments("/path/to/your/project")
```
This script walks through the project directory, reads each .java file, and writes any lines containing specific keywords to a text file.

x??

---

---

#### Publishing Immutable Documents

Background context: Ensuring that documents published from a single source of truth are strictly immutable is crucial to avoid editing risks. This approach helps maintain consistency and reliability, especially when dealing with sensitive or critical information.

If you produce many paper documents for printing, incorporating unique identifiers such as barcodes linking to the latest version can help direct readers to the correct information even after physical distribution.

:p What should be done to prevent someone from editing a published document?
??x
To prevent unauthorized edits, favor formats like PDF over editable formats such as Microsoft Office. Additionally, use locking flags where available to make it more difficult for edits to occur. The focus is not on making edits impossible but rather making them hard enough that they encourage updating the authoritative source and republishing.

```java
// Pseudocode for applying a lock flag in a document management system
public void applyLockFlag(String docId) {
    Document doc = getDocumentById(docId);
    if (doc.canEdit()) {
        doc.setLocked(true);
        saveDocument(doc);
    }
}
```
x??

---

#### Versioning Published Documents

Background context: Every published document must clearly identify its version and include a link to the latest version. This practice helps in managing versions effectively, ensuring that all stakeholders can access the most up-to-date information.

For paper documents intended for printing, embedding barcodes linking to online folders containing the latest version ensures that even printed copies direct readers to the updated content.

:p How should published documents be managed to ensure clarity on their versions and accessibility?
??x
Each document should include clear versioning information and a link to the location of the latest version. For example, a document might state "Version 1.2 - Last updated: March 10, 2023" and provide an online link for the latest version.

For paper documents, consider using barcodes that link directly to the folder housing the current version on a server or cloud storage solution.

```java
// Example of adding version information in a document management system
public class Document {
    private String version;
    private String lastUpdated;

    public void setVersion(String version) {
        this.version = version;
    }

    public void setLastUpdated(String date) {
        this.lastUpdated = date;
    }
}
```
x??

---

#### Reconciliation Mechanisms

Background context: When knowledge is replicated in multiple places, setting up reconciliation mechanisms ensures that all instances remain consistent. This prevents inconsistencies and the need for repetitive updates.

A common example of a reconciliation mechanism is checking a restaurant bill to ensure no discrepancies exist between what was ordered and charged.

:p Why should you set up a reconciliation mechanism when duplicating information?
??x
Setting up a reconciliation mechanism is essential because duplicated knowledge can lead to inconsistencies if not kept in sync. This becomes particularly problematic as the same information needs to be updated across multiple locations, increasing the risk of errors or outdated data. By using a reconciliation mechanism, you ensure that all instances of replicated knowledge are consistently maintained.

For instance, an automated test can check that two copies of the same scenario (like a restaurant bill) remain in sync, alerting you if any discrepancies arise.

```java
// Pseudocode for an automated test to reconcile information
public class ReconciliationTest {
    public void runReconciliation(String[] sources) {
        for (String source : sources) {
            parseAndCompare(source);
        }
    }

    private void parseAndCompare(String source) {
        // Parse the input and compare against a known good state or another instance
    }
}
```
x??

---

#### Consistency Tests with BDD

Background context: Behavior-Driven Development (BDD) provides a way to document behavior through scenarios. These scenarios can be automatically tested using tools that parse natural language descriptions into executable code, ensuring consistency across multiple representations of the same knowledge.

A Roberval balance is used as an analogy where a small change on one side immediately reveals itself when compared with another balanced system.

:p How does BDD help ensure consistency in replicated information?
??x
BDD helps ensure consistency by documenting behavior through scenarios that can be automatically tested. The process involves parsing natural language descriptions into executable code using step definitions. When a scenario and its corresponding implementation disagree, the test automation fails, signaling an inconsistency.

For example, testing a scenario like "Given party BARNABA is marked as bankrupt" and verifying that "an alert: Trade against the bankrupt party BARNABA is triggered" ensures that both the documentation and the system behavior align correctly.

```java
// Pseudocode for BDD step definitions
public class BddStepDefinitions {
    @Given("^party (.*) is marked as bankrupt$")
    public void partyMarkedAsBankrupt(String party) {
        bankruptParties.put(party);
    }

    @Then("^an alert: (.*$)")
    public void anAlertIsTriggered(String expectedMessage) {
        assertEquals(expectedMessage, actualMessage);
    }
}
```
x??

---

---

#### Concept of Code Insufficiency
Background context: Ralph Johnson's quote emphasizes that while source code is crucial, it often fails to convey all necessary information about a program's design and rationale. Programming languages are limited in expressing detailed design decisions and their reasoning.

:p What does Ralph Johnson imply about the role of source code in understanding a program?
??x
Ralph Johnson implies that source code alone might not fully capture the programmer’s intentions, key decisions, and rationale behind those decisions. The quote suggests that while the source code is essential for building software, it often lacks the detailed explanations needed to understand the design process.
x??

---

#### Design Decisions and Rationale
Background context: Code does not always communicate the full story about why certain design choices were made. This can lead to misunderstandings among developers who work on a project after its initial development.

:p Why is code sometimes insufficient in explaining design decisions?
??x
Code may be insufficient because it focuses primarily on implementation details rather than the rationale and reasoning behind those implementations. Key decisions such as architectural choices, performance trade-offs, or specific feature implementations might not be documented adequately within the source code.
x??

---

#### Bridge Metaphor for Design Documentation
Background context: Using the bridge construction metaphor, Johnson illustrates that while technical drawings (akin to source code) provide essential information about design and implementation, they often lack critical details like rationale and historical context.

:p How does the bridge metaphor illustrate the limitations of code in documenting decisions?
??x
The bridge metaphor shows that technical drawings (like source code) describe the physical structure but fail to capture the reasoning behind certain choices. For example, dimensions, material selections, and calculations related to durability and safety are documented but not explained fully.
x??

---

#### Augmenting Programming Languages for Better Documentation
Background context: To address the limitations of traditional programming languages in documenting design decisions and rationales, one must extend the language capabilities through naming conventions, annotations, or even domain-specific languages.

:p What is suggested to augment programming languages for better documentation?
??x
It is suggested to define custom ways to declare intentions and reasons behind key decisions. This can be achieved using strong naming conventions, annotations, attributes, or creating a domain-specific language (DSL). These methods should provide more structured and detailed information about design decisions than simple comments.
x??

---

#### Workarounds for Limited Language Support
Background context: In some cases, languages do not support certain design practices. However, workarounds like naming conventions can help. For example, prefixing private methods with an underscore or using `this` as a parameter name.

:p How might you use naming conventions to overcome limitations in programming languages?
??x
You can use naming conventions to clarify the purpose and significance of variables and procedures. For instance, prefixing private methods with an underscore (`_`) can indicate they are not part of the public API. Similarly, using `this` as a first parameter name can signal that the function operates on the current object.
x??

---

#### Using Code Comments for Documentation
Background context: While comments can provide additional information, they often lack structure and are prone to becoming outdated or irrelevant during refactoring.

:p What are the limitations of using plain comments for documentation?
??x
Plain comments can become unstructured and disorganized, making them difficult to maintain. They may also be ignored by developers over time, especially if their relevance changes with new code updates or refactorings.
x??

---

#### Creating a Domain-Specific Language (DSL)
Background context: To fully capture the intentions and rationales behind design decisions, creating or reusing a DSL can offer more structured and expressive ways to document these decisions.

:p How does creating a domain-specific language help in documenting design decisions?
??x
Creating a domain-specific language allows you to define syntax and semantics tailored to your specific application domain. This makes it easier to express complex ideas and intentions in a concise and clear manner, reducing the likelihood of misunderstandings among developers.
x??

---

#### Summary: Augmenting Code for Clarity
Background context: The overall advice is to enhance code through structured documentation methods beyond simple comments to ensure clarity and maintainability.

:p What overarching approach does the text recommend for improving code clarity?
??x
The text recommends enhancing code through structured documentation techniques such as strong naming conventions, annotations, attributes, or creating a DSL. This approach helps convey key decisions and their rationales more effectively than plain comments.
x??

---

---

#### Keeping Documentation Close to Code
Annotations should be placed as close as possible to the related code. This ensures that any refactorings do not break the annotations and maintain their accuracy.

:p How can you ensure that documentation remains accurate when refactoring code?
??x
By placing annotations near the relevant code, they are less likely to be accidentally altered during refactoring. For instance:
```java
// Original code
@Deprecated("Use methodB instead")
public void methodA() {
    // implementation
}

// Refactored code after renaming class
@Deprecated("Use methodB instead")  // Annotation remains in the correct place
class OldClass {
    @Deprecated("Use methodB instead")
    public void methodA() {  // Method signature has been renamed and annotated accordingly
        // implementation
    }
}
```
x??

---

#### Compiler Error Checking for Annotations
Using annotations with structured code enables compiler error checking, ensuring that the additional information provided by the annotations is valid.

:p How does compiler error checking help in managing annotations?
??x
Compiler error checking helps maintain the integrity of the annotations. For example:
```java
// Correct usage
@Deprecated("Use methodB instead")
public void methodA() {
    // implementation
}

// Incorrect usage - would cause a compilation error if not caught by IDE or compiler
@Deprecated("Use methodB instead")
void methodA() {  // Missing return type, which might be caught during compilation
}
```
x??

---

#### Autocompletion and Searchability in IDEs
IDEs provide autocompletion for annotations, making it easier to use them. They also make the augmented code easily searchable.

:p How does autocompletion benefit developers when using annotations?
??x
Autocompletion saves time by suggesting valid annotations as you type. For instance:
```java
@Deprecated("Use methodB instead")
public void methodA() {
    // implementation
}
```
When typing `@`, the IDE suggests available annotations like `@Deprecated`. This speeds up development and reduces errors.

x??

---

#### Refactoring Proof Annotations
Annotations must be designed to remain accurate or change in tandem with the code, ensuring they do not require manual maintenance during refactorings.

:p What does "refactoring proof" mean for annotations?
??x
"Refactoring proof" means that when a class or method is renamed or deleted, the annotations attached to them are updated automatically. For example:
```java
// Before refactoring
@Deprecated("Use methodB instead")
public void oldMethod() {
    // implementation
}

// After renaming 'oldMethod' to 'newMethod'
@Deprecated("Use methodB instead")  // Annotation updates with new method name
public void newMethod() {  // Renamed and annotated correctly
    // implementation
}
```
x??

---

#### Using Annotations for Documentation
Annotations are a powerful tool for documenting code by making decisions explicit and adding rationales behind them.

:p How can annotations be used to document design decisions?
??x
Annotations can capture the rationale and context of design decisions, such as:
```java
// Example annotation usage
@DomainService("User management service")
public class UserService {
    // implementation
}
```
This approach makes it easier for future maintainers to understand why certain choices were made.

x??

---

#### Searching and Navigating Annotations
Annotations can be searched within the IDE, making it easy to find related code from a given annotation.

:p How does searching by annotations benefit developers?
??x
Searching by annotations helps traceability and impact analysis. For example:
```java
@Deprecated("Use methodB instead")
public void oldMethod() {
    // implementation
}
```
If you search for `@Deprecated`, the IDE will show all methods annotated with `@Deprecated`.

x??

---

#### Custom Annotations
Custom annotations should be documented well, using standard names and practices to encourage deliberate practice.

:p How should custom annotations be handled?
??x
Custom annotations should have clear documentation and follow industry standards. For example:
```java
// Custom annotation definition
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface DomainService {
    String value();
}
```
Documentation for this custom annotation would explain its purpose, usage, and any relevant context.

x??

---

---

#### Annotations and Their Flexibility

Annotations are more than just tags; they are first-class citizens in programming languages like Java (.Net). They have a name, belong to a module (package or namespace), can hold parameters, and can be annotated by other annotations. Because they are classes, they also support structured comments syntax used by documentation generators.

:p What is the significance of annotations in programming?
??x
Annotations significantly enhance the capabilities of code by allowing for rich metadata beyond simple tags. They enable more precise semantics, making it easier for tools to understand and process the code at a higher level of abstraction. This allows for better tool integration and automation.
??x

---

#### Using Annotations with Parameters

Annotations can have parameters, which provide additional information about the annotated elements. For example, an annotation used on a builder pattern can specify the types that the builder produces.

:p How can annotations be used to describe the products of a builder?
??x
You can define an annotation with parameters that describe the product type(s) produced by a builder. Here's an example:

```java
public @interface Builder {
    Class[] products() default {};
}

@Builder(products = {Supa.class, Dupa.class})
public class SupaDupaBuilder {
    //...
}
```

In this code:
- The `@Builder` annotation has a parameter named `products`.
- It is applied to the `SupaDupaBuilder` class.
- The `products` parameter specifies that instances of `Supa` and `Dupa` are produced by this builder.

This allows tools to understand which classes can be built using this builder, enhancing automation and tool integration.
??x

---

#### Applying Annotations with Meta-Annotations

Annotations use meta-annotations to specify where they can be applied. For example, an `@Adapter` annotation can be used on types or packages:

```java
@Target({ ElementType.TYPE, ElementType.PACKAGE })
public @interface Adapter {
}
```

:p What is the purpose of meta-annotations?
??x
Meta-annotations define rules and targets for where other annotations can be applied. They provide a way to specify the valid context in which an annotation can appear. For example, `@Target` specifies whether an annotation can be applied to classes, methods, fields, etc.

In this code:
```java
@Target({ ElementType.TYPE, ElementType.PACKAGE })
public @interface Adapter {
}
```
- The `@Target` meta-annotation is used within the `Adapter` annotation.
- It specifies that `Adapter` can be applied to both types and packages.
??x

---

#### Benefits of Machine Readable Annotations

The knowledge declared using annotations is machine-readable, meaning tools can exploit this knowledge. Living diagrams and glossaries rely on such possibilities.

:p How do machine-readable annotations benefit the development process?
??x
Machine-readable annotations allow tools to understand and interpret the design intents and semantics expressed in the code. This enables automation of various tasks such as documentation generation, static analysis, and more sophisticated refactoring capabilities.

For example:
- Documentation generators can use these annotations to automatically generate comprehensive and accurate documentation.
- Static analyzers can use them to detect potential issues based on predefined rules.
- IDEs can provide better insights and auto-completion features based on the annotated information.

In summary, machine-readable annotations enhance tool integration, making development processes more efficient and less error-prone.
??x

---

#### Structured Comments in Annotations

Annotations benefit from structured comments syntax used by documentation generators. This allows for conveying a lot of knowledge through simple annotations.

:p How do structured comments within annotations help?
??x
Structured comments within annotations allow for detailed descriptions, parameters, and other metadata that can be extracted and used by documentation tools. They enable precise semantics and rich metadata that is not available from return types or implemented interfaces alone.

For example:
```java
public @interface Adapter {
    // Structured comment here
}
```

The structured comments provide a clear description of what the annotation does, making it easier for tools to understand and utilize.
??x

---

---

#### NotNull Property
Background context explaining the `NotNull` property. This is a desirable property where parameters cannot be null, making it easier to reason about code behavior.

:p What does the `NotNull` property ensure in parameter design?
??x
The `NotNull` property ensures that parameters passed to functions or methods are never null. This helps avoid null pointer exceptions and makes the code more robust and predictable.
```java
public void processTransaction(@NotNull Transaction transaction) {
    // Code here, assuming 'transaction' is not null
}
```
x??

---

#### Positive Property
Background context explaining the `Positive` property. A parameter must be a positive value to ensure that only valid or meaningful values are passed.

:p What does the `Positive` property guarantee for parameters?
??x
The `Positive` property guarantees that all parameters adhering to this constraint will always hold a positive value, ensuring that they represent valid data.
```java
public void deposit(@Positive int amount) {
    // Code here, assuming 'amount' is greater than 0
}
```
x??

---

#### Immutable Property
Background context explaining the `Immutable` property. An immutable class cannot be modified after it is created, which ensures that its state remains constant.

:p What does the `Immutable` property imply for a class?
??x
The `Immutable` property implies that once an instance of a class is created, its state cannot change. Any method in the class should only return new instances rather than modifying the existing one.
```java
public final class Money {
    private final int amount;
    private final String currency;

    public Money(int amount, String currency) {
        this.amount = amount;
        this.currency = currency;
    }

    // Getters but no setters
}
```
x??

---

#### Identity by Value Property
Background context explaining the `Identity by value` property. Equality is defined based on the data values rather than object references.

:p How does the `Identity by value` property define equality?
??x
The `Identity by value` property defines equality based on the actual content or data of the objects, not their memory addresses. This means two instances can be considered equal if they have the same internal state.
```java
public class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Point point = (Point) obj;
        return x == point.x && y == point.y;
    }
}
```
x??

---

#### Pure Function Property
Background context explaining the `Pure` property. A function or method is pure when it does not have side effects and always returns the same result given the same input.

:p What makes a function `pure`?
??x
A function is considered `pure` if it does not alter any external state, does not depend on any external state, and always returns the same output for the same inputs. It has no side effects.
```java
public int add(int a, int b) {
    return a + b;
}
```
x??

---

#### Idempotent Property
Background context explaining the `Idempotent` property. A function produces the same effect regardless of how many times it is called with the same arguments.

:p What does the `Idempotent` property ensure for a function?
??x
The `Idempotent` property ensures that calling a function multiple times with the same arguments will have the same effect as calling it once. This can be particularly useful in distributed systems where functions might get called multiple times.
```java
public void sendEmail(String recipient, String message) {
    // Code to ensure email is sent only once even if called multiple times
}
```
x??

---

#### Associative Property
Background context explaining the `Associative` property. For a function like `(a + b) + c = a + (b + c)` where the grouping of arguments does not affect the result.

:p What does the `Associative` property imply for a function?
??x
The `Associative` property implies that how arguments are grouped in a function call does not change the final result. This is useful for operations like addition or multiplication.
```java
public int sum(int a, int b, int c) {
    return (a + b) + c; // Should be equal to a + (b + c)
}
```
x??

---

#### Custom Annotations for Design Patterns
Background context explaining the use of custom annotations in Java. These annotations can help document and enforce design patterns by grouping related properties.

:p How can custom annotations like `@ValueObject`, `@Entity`, etc., be used?
??x
Custom annotations such as `@ValueObject`, `@Entity`, and others can be used to group related properties, documenting and enforcing design patterns. These annotations help in clearly defining the purpose and behavior of classes within a domain.
```java
public @interface ValueObject {
    // Meta-annotations for other properties like @Immutable, @SideEffectFree, etc.
}

@ValueObject
public class FueldCardTransaction {
    private int amount;
    private String cardNumber;

    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        FueldCardTransaction that = (FueldCardTransaction) obj;
        return amount == that.amount && cardNumber.equals(that.cardNumber);
    }
}
```
x??

---

#### Domain Patterns and Stereotypes
Background context explaining how domain-driven design categorizes classes into fundamental patterns like value objects, entities, services, etc. These categories help in expressing a lot of information succinctly.

:p How do stereotypes and tactical patterns assist in designing classes?
??x
Stereotypes and tactical patterns assist in designing classes by categorizing them based on their purpose within the domain model. This helps in expressing complex behaviors and relationships more clearly. For example, marking a class as `@ValueObject` indicates that it is immutable, value-based, side effect-free, and can be transferred.
```java
public @interface Entity {
    // Meta-annotations for entity-specific restrictions
}

@Entity
public class Customer {
    private String id;
    private String name;

    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Customer customer = (Customer) obj;
        return id.equals(customer.id);
    }
}
```
x??

---

---

#### Module-Wide Knowledge Augmentation
This concept deals with defining properties or design decisions that apply to a set of artifacts within a module. This can include attributes like immutability, nullability, side effects, and more. Such knowledge augmentation helps tools understand the context better, making development more efficient.

:p How do you define properties at the module level?
??x
Defining properties at the module level involves specifying common characteristics that apply to all elements within a module. For example, if a module is marked as immutable by default, then any mutable class in this module would need an explicit annotation to indicate it deviates from the norm.

```java
@NonNull @Module(singleton = true)
public class ExampleService {
    public String provideData() {
        return "Data";
    }
}
```
x??

---

#### Custom Annotations for Properties
Custom annotations can be created to express specific properties such as immutability or nullability. There are two common approaches: one that denotes when a property is met and another when it’s not.

:p What are the two types of custom annotations mentioned in the context?
??x
The two types of custom annotations for expressing properties are:
- One for cases where the property is met (e.g., @Immutable)
- Another for cases where the property is not met (e.g., @Mutable)

These can be used to indicate whether a class is immutable or mutable, non-null or nullable respectively. By default, you might choose one type of annotation over the other as a standard across your project.

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Immutable {
    // Annotation logic here
}
```
x??

---

#### Handling Many Kinds of Modules
In software projects, modules can be defined in various ways. Commonly used units include packages, classes, nested modules, working sets, filesets, source folders, Maven modules, and inheritance relationships.

:p What are the different types of modules mentioned?
??x
The text mentions several types of modules:
- Packages (e.g., x.y.z)
- Classes (including member fields, methods, and nested classes)
- Working Sets in an IDE like Eclipse
- Filesets defined by tools like Ant
- Source folders in projects (src/main/java or src/test/java)
- Maven modules at the scale of subprojects
- Pointcuts in aspect-oriented programming

Each type defines a logical grouping with its own characteristics.

```java
// Example of defining a package-level module constraint
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.PACKAGE)
public @interface Module {
    String[] value(); // Define constraints for the module
}
```
x??

---

#### Stereotypes and Logical Grouping
Stereotypes are annotations that implicitly define sets of occurrences. For example, the Value Object pattern can be used to mark classes that should behave as immutable entities.

:p How do stereotypes contribute to defining logical groupings?
??x
Stereotypes help in defining logical groupings by marking classes or modules with specific roles or behaviors. This makes it easier for tools and developers to understand the intended usage of these components. For instance, using a stereotype like @ValueObject can indicate that the class should be treated as immutable.

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface ValueObject {
    // Stereotype logic here
}
```
x??

---

#### Primary Programming Paradigm at Module Level
The primary programming paradigm for a module can also be defined, which could include object-oriented, functional, or procedural styles. This helps in maintaining consistency and clarity within the codebase.

:p How does defining the primary programming paradigm help?
??x
Defining the primary programming paradigm ensures that developers adhere to consistent coding practices throughout the module. For example, marking a module as "functional" might encourage the use of immutable data structures and higher-order functions.

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.MODULE)
public @interface PrimaryProgrammingParadigm {
    String value(); // Define the primary paradigm
}
```
x??

---

#### Architecture Constraints in Modules
Modules can also define architectural constraints, such as different areas for high-quality standards and legacy code. These constraints might include style preferences like Checkstyle configurations or unit test coverage.

:p What are some common architecture constraints that can be defined at the module level?
??x
Common architecture constraints that can be defined at the module level include:
- Style preferences (e.g., Checkstyle configuration)
- Metrics thresholds
- Unit test coverage
- Allowed or forbidden imports

These help in maintaining a consistent and maintainable codebase.

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.MODULE)
public @interface ArchitectureConstraints {
    String stylePreferences(); // Define style preferences
    int metricsThreshold(); // Define metric thresholds
}
```
x??

---

---

#### Intrinsic vs. Extrinsic Knowledge in Design Patterns

Background context: Understanding the difference between intrinsic and extrinsic knowledge is crucial for effective design, especially when using design patterns and documenting elements within a system.

Explanation: Intrinsic properties are inherent to an element itself—what it really is—and do not change based on external factors or contexts. Extrinsic properties, in contrast, are related to the relationships or roles of the element in other parts of the system or over time.

:p What is intrinsic knowledge?
??x
Intrinsic knowledge refers to properties and attributes that are inherent to an element itself, such as its core functionality or design decisions, which do not change based on external factors. For example, a `Car` being red or having a hybrid engine.
x??

---
#### Intrinsic Knowledge in Documentation

Background context: When documenting elements within a system, attaching only intrinsic knowledge ensures that the documentation remains relevant and unchanged when unrelated changes occur.

Explanation: By focusing on intrinsic knowledge, you ensure that any change not directly related to an element does not modify its documentation. For instance, selling a car should not affect its user manual or design decisions.

:p What is the benefit of attaching only intrinsic knowledge to elements?
??x
Attaching only intrinsic knowledge reduces maintenance efforts over time because changes unrelated to the core functionality do not require updates in the documentation. This makes the system more robust and easier to maintain.
x??

---
#### Module-Wide Knowledge Augmentation

Background context: Modules can be augmented with additional knowledge through various techniques such as annotations, naming conventions, sidecar files, metadata databases, and domain-specific languages (DSL).

Explanation: Using these techniques helps in maintaining consistency and clarity within the codebase. For example, Java uses `package-info.java` for Javadoc and annotations.

:p How does a package-info.java file contribute to module-wide knowledge?
??x
A package-info.java file acts as a location for adding Javadoc comments and annotations about the package. It is essentially a sidecar file that enhances documentation without altering the core functionality.
```java
// Example of package-info.java
/**
 * Package: com.example.myapp.models
 */
```
x??

---
#### Design Patterns and Logical Groupings

Background context: Design patterns often define logical groupings based on roles within the pattern, such as abstract factories or builders.

Explanation: These groupings help in organizing code and making it more understandable by identifying key roles that each component plays.

:p What does an "Abstract Factory" pattern's role typically look like?
??x
In an Abstract Factory pattern, the core role is defined through the `@AbstractFactory.Abstract.*` annotations. This grouping helps in defining abstract factories and their concrete implementations.
```java
// Example of Abstract Factory
public interface AbstractFactory {
    ProductA createProductA();
    ProductB createProductB();
}
```
x??

---
#### Aggregates, Bounded Contexts, and Layers

Background context: Concepts like layers, domains, bounded contexts, and aggregate roots define logical groupings that are crucial for organizing large systems.

Explanation: These concepts help in breaking down a system into manageable parts, ensuring clarity and maintainability. For instance, an aggregate root is the entity that owns all other entities within its domain.

:p How does a bounded context differ from a domain?
??x
A bounded context defines the rules and responsibilities of a specific part of the system relative to its environment. A domain, on the other hand, refers to the core business logic or problem space being addressed by the system.
```java
// Example of Bounded Context
public class CustomerContext {
    private final CustomerRepository customerRepo;

    public CustomerContext(CustomerRepository customerRepo) {
        this.customerRepo = customerRepo;
    }
}
```
x??

---
#### Large Modules and Aggressive Filtering

Background context: Large modules often contain many items, necessitating aggressive filtering to manage complexity.

Explanation: Aggressive filtering involves prioritizing the most important elements while discarding or hiding others. This helps in focusing on what is truly relevant for a specific purpose.

:p Why do large modules require aggressive filtering?
??x
Large modules require aggressive filtering because they often contain too many items, making it difficult to manage and understand. By ranking and considering only the N most important elements, you can focus on what is crucial for a specific task or context.
```java
// Example of filtering in Java
List<String> filteredItems = items.stream()
                                  .filter(item -> item.startsWith("important"))
                                  .collect(Collectors.toList());
```
x??

---

---

#### Knowledge Augmentation and Design Rationale

Background context: The provided text discusses the importance of documenting design rationale to understand why certain decisions were made, especially when faced with alternative choices. This is crucial for maintaining transparency and enabling future developers or stakeholders to comprehend the reasoning behind complex architectural and design decisions.

:p What are some examples of situations where recording the rationale might be particularly important?
??x
Recording the rationale can be essential in scenarios such as:
- When a stakeholder insists on a specific approach ("stakeholder prefers it that way").
- When integrating legacy systems with modern interfaces ("This facade exposes the legacy system through a pretty API because there is no good reason to rewrite the legacy but we still want to consume it with the same convenience as if it were brand new").

In these cases, documenting why a particular design or implementation was chosen helps future developers understand and maintain the system effectively.
x??

---
#### Ad Hoc Document for Rationale

Background context: The text suggests using an ad hoc document to record the rationale behind important decisions. This is particularly useful for large, complex systems where multiple quality attributes need to be considered.

:p How can you create an ad hoc document for recording design rationale?
??x
To create an ad hoc document for recording design rationale:
1. Include all requirements and relevant quality attributes.
2. Ensure the document evolves slowly but at least once a year.
3. Focus only on main attributes that span large areas of the system, not local decisions.

Example structure might include sections like:
- Requirements
- Quality Attributes (e.g., performance, security, scalability)
- Decisions and Rationale

```markdown
# System Design Documentation

## Requirements
- User Interface
- Data Persistence

## Quality Attributes
- Performance: [Rationale]
- Security: [Rationale]

## Decisions and Rationale
- Why we chose a specific database over others: [Rationale]
```
x??

---
#### Annotations for Rationale

Background context: The text mentions using annotations to document decisions, which can include fields such as `rationale` to explain the reasoning behind certain choices.

:p How might you use annotations in your codebase to capture rationale?
??x
You can use annotations with fields like `rationale` to document decisions directly within the source code. For example:

```java
public class MyClass {
    @MyAnnotation(rationale = "We only know how to do that way")
    public void myMethod() {
        // Method implementation
    }
}
```

This approach allows quick access to rationale for each decision, making it easier to understand the design choices without needing additional documentation.

```java
@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.METHOD)
@interface MyAnnotation {
    String rationale();
}
```
x??

---
#### Blog Post as Rationale

Background context: The text suggests that a blog post can serve as an effective way to document rationale, especially because it provides human context and reasoning.

:p Why might you choose to write a blog post for recording rationale?
??x
A blog post is beneficial for documenting rationale when:
1. You want to provide detailed explanations of the decision-making process.
2. You need to capture the political and personal aspects that influenced decisions.
3. Future references are needed, as questions about past decisions may arise.

Blog posts can be valuable because they offer a narrative approach to documentation, which is easier for humans to understand than technical documents or code comments alone.

Example blog post structure:

```markdown
# Rationale Behind Design Decision: [Title]

## Background
- Problem Context
- Stakeholder Requirements

## The Decisions
1. Why we chose X over Y
2. Trade-offs and implications

## Conclusion
- Summary of rationale
```
x??

---

---

#### Importance of Explicit Rationale

Background context: The importance of making decisions explicit by documenting the rationale behind them helps improve the quality of software development. This practice ensures that decisions are well-thought-out and not based on assumptions or incomplete information.

:p Why is it important to document the rationale behind a decision in software development?
??x
Documenting the rationale provides clarity, ensuring that decisions are deliberate and understandable by all stakeholders involved. It helps in identifying potential improvements and avoiding suboptimal solutions that might be implemented hastily.
x??

---

#### Deliberate Design Decisions

Background context: Without deliberate design decisions, software structures can become random and difficult to manage. This lack of structure often results from a failure to explore multiple alternatives or consider the long-term consequences of quick fixes.

:p What is the consequence of a lack of deliberate design in software development?
??x
A lack of deliberate design leads to a disorganized and hard-to-maintain codebase, where decisions are made without proper thought. This can result in missed opportunities and suboptimal solutions that are difficult to scale or modify in the future.
x??

---

#### Avoiding Speculation

Background context: Documenting solutions for speculative needs is advised against because traditional architecture documentation often overestimates the future conditions without accounting for potential impediments.

:p What advice does Sam Newman give regarding documenting speculative needs?
??x
Sam Newman advises against documenting solutions to speculative needs, as it can lead to overly optimistic and unrealistic plans. Instead, focus on documented decisions based on proven actual needs.
x??

---

#### Incremental Approaches

Background context: In incremental approaches like emerging design, the solution is built in small slices driven by the most critical need at each stage.

:p What approach does the author recommend for building solutions?
??x
The author recommends an incremental approach where solutions are developed slice by slice, focusing on addressing the most important needs at each instant. This method avoids speculation and ensures that development is responsive to current requirements.
x??

---

#### Skills as Pre-Documented Rationales

Background context: Common decisions in software design can be documented once per principle applied consistently throughout the project. For example, documenting adherence to principles like the Single Responsibility Principle.

:p How can skills be used as pre-documented rationales?
??x
Skills and consistently followed principles (like the Single Responsibility Principle) can serve as documented rationales. Documenting these principles in a single place acknowledges their influence on decision-making processes.
x??

---

---

#### Highlighting the Core Domain Elements
Background context: In large domain models, it can be challenging to understand which elements are more critical. Eric Evans suggests highlighting these core elements within the repository itself using annotations or specific flags.

:p What is the highlighted core and how does it help developers?
??x
The highlighted core refers to a subset of important elements in a domain model that need special attention. By flagging these elements, developers can focus on understanding and maintaining only what is truly critical, making the overall domain easier to comprehend.
??x

---

#### Using Annotations for Core Concepts
Background context: Annotations are used to mark important concepts within code repositories, guiding developers to identify and prioritize core domain elements.

:p How do annotations help in identifying core concepts?
??x
Annotations like `@CoreConcept` help by marking specific classes or methods as part of the highlighted core. This makes it easy for developers to know which parts of the code are critical without needing additional documentation.
??x

---

#### Curation Through Annotations
Background context: Tools can leverage annotations to curate and display information based on the importance of elements within a project.

:p How do tools use annotations for curation?
??x
Tools scan source code for annotations such as `@CoreConcept` to generate relevant diagrams, documentation, or other outputs. This ensures that only important elements are highlighted in different contexts.
??x

---

#### Highlighting Exemplars in Code
Background context: Identifying and highlighting exemplary code can serve as a model for best practices within the team.

:p What is an exemplar in this context?
??x
An exemplar is a piece of code that serves as a desirable model to imitate. It should be high-quality, practical, and used in production to ensure principles make sense.
??x

---

#### Custom Annotations for Exemplars
Background context: Creating custom annotations helps in marking specific classes or methods as exemplary.

:p How do custom annotations help in identifying exemplars?
??x
Custom annotations like `@Exemplar` can be created to flag classes or methods that are particularly good examples of a style or best practice. This helps developers identify and learn from the best practices implemented by others.
??x

---

#### Ensuring Exemplars Are Realistic
Background context: Exemplars should represent real-world scenarios to ensure principles make sense in practical applications.

:p Why should exemplars be actual code used in production?
??x
Exemplars should be real-world services that get things right, ensuring that the principles they represent are applicable and useful. This approach prevents the use of isolated examples that might not reflect actual usage.
??x

---

#### Describing Exemplars with Annotations
Background context: Providing detailed descriptions for annotations helps clarify which aspects of the code are exemplary.

:p How can you describe an exemplar using annotations?
??x
You can add a description to an annotation like `@Exemplar` that explains why the piece of code is considered exemplary. For example:
```java
@Exemplar("A very good example of a REST resource with content negotiation and the use of URI-templates")
```
This helps clarify which aspects are worth emulating.
??x

---

---

---

#### Living Curation: Identifying Authoritative Knowledge

Living curation involves maintaining and updating a guide or tour of a codebase that reflects its current state. This can be achieved through metadata augmentation, which adds tags to code elements to describe their significance.

:p What is living curation in the context of codebases?
??x
Living curation refers to the practice of dynamically updating guides or tours for a codebase as it evolves. By augmenting the code with metadata (tags), you can create an updated guide automatically, reflecting changes and additions made over time.
x??

---

#### Augmented Code Approach

Augmenting code means adding extra metadata about elements in the code that can later be used to generate curated guides or tours. This approach helps in creating detailed documentation without cluttering the actual codebase.

:p How does the augmented code approach enhance code documentation?
??x
The augmented code approach enhances documentation by allowing you to add metadata (like tags) to specific parts of the code, which can then be used to automatically generate comprehensive guides or tours. This method keeps the actual code clean and readable while providing rich contextual information.
x??

---

#### Bookmark Method for Code Documentation

For relatively stable codebases, a simple bookmark with descriptions and links can serve as an effective guide. On platforms like GitHub, linking directly to specific lines of code is straightforward.

:p How does the bookmark method work for documenting code?
??x
The bookmark method involves creating a lightweight document (like HTML or Markdown) that lists key parts of interest in the codebase, each with a brief description and a direct link to their location. This approach is useful when the codebase changes infrequently.
Example:
```html
<!DOCTYPE html>
<html>
<body>
  <h1>Guide to Key Features</h1>
  <ul>
    <li><a href="https://github.com/example/repo/blob/main/src/Foo.cs#L20">Enrich Method - Customer Purchase Enrichment</a></li>
  </ul>
</body>
</html>
```
x??

---

#### Dynamic Curation for Frequently Changing Codebases

Dynamic curation relies on tags and search features of an IDE to create guides automatically. This approach is more efficient when the codebase changes frequently.

:p What is dynamic curation in coding?
??x
Dynamic curation involves tagging significant parts of a codebase with metadata that can be used by an IDE's search feature to generate up-to-date guides or tours. It’s particularly useful for large, frequently changing projects.
Example:
```csharp
[KeyLandmark("The main steps of enriching the Customer Purchase from the initial order to a ready-to-confirm purchase")]
public void Enrich(CustomerPurchase cp)
{
    //...
}
```
x??

---

#### Tagging and Naming Strategies

Choosing appropriate tags for significant elements in code can help create meaningful guides. Key terms like `KeyLandmark`, `MustSee`, or `TopAttraction` are commonly used.

:p What are some naming suggestions for significant code annotations?
??x
Some naming suggestions for significant code annotations include:
- **KeyLandmark**: For important features or key processes.
- **MustSee**: For critical sections that users should definitely see.
- **SightSeeingSite**, **CoreConcept**, or **CoreProcess**: For core ideas or steps.
- **PlaceOfInterest** (POI), **PointOfInterest** (POI): For interesting code segments.
- **TopAttraction**: For the most important parts of the codebase.
- **VIPCode**: For very important and frequently referenced code.

These names help categorize and prioritize different aspects of the code for easy navigation and understanding.
x??

---

#### Implementing Custom Annotations

Creating custom annotations in C# or Java involves defining an attribute class that can be attached to methods, classes, or other elements. This helps in marking significant parts of the codebase for later reference.

:p How do you implement a custom annotation (attribute) in C#?
??x
To implement a custom annotation in C#, you define a class that inherits from `Attribute`. Here’s an example:
```csharp
public class KeyLandmarkAttribute : Attribute
{
    public string Description { get; }

    public KeyLandmarkAttribute(string description)
    {
        Description = description;
    }
}
```
This attribute can then be applied to methods or classes, providing a brief description. For instance:
```csharp
[KeyLandmark("The main steps of enriching the Customer Purchase from the initial order to a ready-to-confirm purchase")]
public void Enrich(CustomerPurchase cp)
{
    //...
}
```
x??

---

#### Example in Java

Java supports annotations similarly to C#. The same approach can be applied by defining an annotation and using it on code elements.

:p How do you implement a custom annotation in Java?
??x
In Java, you define an annotation by annotating the `@interface` keyword with `@Retention`. Here’s how to create a similar `KeyLandmarkAttribute`:
```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface KeyLandmark {
    String value();
}
```
This annotation can then be used to tag methods, providing a description. Example:
```java
package acme.documentation.annotations;

@KeyLandmark("The main steps of enriching the Customer Purchase from the initial order to a ready-to-confirm purchase")
public class Foo {
    public void enrich(CustomerPurchase cp) {
        //...
    }
}
```
x??

---

---

#### Living Glossary Concept
A living glossary is a form of documentation that can be automatically generated from the source code. It enhances traditional comments and documentation by using annotations to categorize and prioritize relevant information, making it easier to maintain as the codebase evolves.

Background context: In many languages like Java or C#, developers embed structured comments in their code, which can then be extracted by tools such as Javadoc to create a comprehensive report on the project. By extending this with custom annotations, you can further refine and automate the documentation process.
:p What is a living glossary?
??x
A living glossary refers to a dynamic form of documentation generated from source code using structured comments and annotations. It allows developers to describe classes, interfaces, or methods in detail, which are then extracted by tools like Javadoc into a cohesive document that can be easily maintained as the project evolves.
x??

---

#### Custom Doclet Concept
A custom doclet is an extension of documentation generation capabilities where you can tailor how and what kind of documentation is generated. Tools such as Javadoc allow developers to create their own doclets, enabling them to export documentation in various formats.

Background context: Javadoc provides a framework for generating JavaDoc from code comments. By creating a custom Doclet, developers can extend the functionality beyond the default output, allowing more sophisticated and tailored documentation processes.
:p How does a custom doclet enhance the documentation process?
??x
A custom doclet enhances the documentation process by providing greater flexibility in how and what kind of information is extracted from code comments. For example, a custom Doclet can filter out irrelevant classes, generate documentation in different formats (e.g., Excel), or apply specific business logic to structure the output.
x??

---

#### Annotations Concept
Annotations are used as metadata for classes, methods, or other elements in your code. They provide a way to add domain-specific information without altering the actual functionality of the code.

Background context: In languages like Java and C#, annotations can be used to add semantic meaning to parts of the codebase. These annotations can be later parsed by tools such as Javadoc to generate relevant documentation.
:p What are annotations, and how do they benefit documentation?
??x
Annotations are metadata tags added to classes, methods, or other elements in your code that provide additional information without changing their behavior. They benefit documentation because these metadata can be extracted by tools like Javadoc, allowing for more accurate and context-aware descriptions of the code.
x??

---

#### CoreConcept Annotation Concept
The `@CoreConcept` annotation is used to mark important parts of the codebase that are central to understanding the domain or business logic.

Background context: By annotating classes, interfaces, or methods with `@CoreConcept`, developers can highlight key elements in their documentation. This helps maintainers and other stakeholders quickly understand what’s crucial for the project.
:p What is the purpose of the `@CoreConcept` annotation?
??x
The purpose of the `@CoreConcept` annotation is to mark classes, interfaces, or methods that are fundamental to understanding the domain or business logic. By using this annotation, developers can ensure these key components are emphasized in the generated documentation.
x??

---

#### CoreBehavior Annotation Concept
The `@CoreBehavior` annotation is used to indicate behavior or actions within a system.

Background context: The `@CoreBehavior` annotation helps identify and document critical behaviors that define how parts of the code interact. This can be particularly useful when generating state machines, event handlers, or other dynamic behaviors.
:p What does the `@CoreBehavior` annotation signify?
??x
The `@CoreBehavior` annotation signifies important behavior or actions within a system. It is used to document and emphasize critical interactions or processes that define how parts of the code interact with each other.
x??

---

#### StateMachine Annotation Concept
The `@StateMachine` annotation indicates that a method or class implements state machine logic.

Background context: A state machine is a behavioral model where an object's behavior depends on its current state. The `@StateMachine` annotation helps in documenting these states and transitions, making it easier to understand the dynamic nature of certain parts of the code.
:p What does the `@StateMachine` annotation represent?
??x
The `@StateMachine` annotation represents that a method or class implements state machine logic. It documents how an object's behavior changes based on its current state, facilitating better understanding and maintenance of such complex systems.
x??

---

#### Event Class Concept
The `Event` class is used to define events that can trigger state transitions in the system.

Background context: In a state machine, events are signals or actions that cause state transitions. The `Event` class provides a way to represent these events in code and document them for clarity.
:p What role does the `Event` class play?
??x
The `Event` class plays a crucial role by defining events that can trigger state transitions in the system. It helps in documenting what actions or occurrences are significant enough to change the state of an object, making it easier to maintain and understand the logic behind these transitions.
x??

---

---

#### Living Diagrams Overview
Background context explaining the concept. In software development, diagrams are often used to convey design and system architecture information. However, these diagrams can become outdated quickly as code changes without updates, making them unreliable over time.
:p What is a living diagram?
??x
A living diagram is a diagram that automatically generates itself from the source code every time there is a change, ensuring it always reflects the current state of the software.
x??

---
#### Purpose of Living Diagrams
Explain why setting up mechanisms for automatic generation of diagrams can be beneficial in long-term projects. The goal is to maintain accuracy and relevance of design representations without manual intervention.
:p What are the benefits of using living diagrams?
??x
Using living diagrams ensures that design documents stay current with the actual code, reducing the risk of outdated or incorrect information. This helps in keeping important knowledge about system designs readily accessible for future reference and discussions.
x??

---
#### Diagram Real Estate
Discuss the importance of focusing a diagram on one message to make it more effective. Explain why complex diagrams are less useful than simple ones that convey their purpose clearly.
:p Why is it important to have "one diagram, one story"?
??x
Having "one diagram, one story" ensures that each diagram serves its intended purpose effectively by focusing solely on the relevant information. This makes the diagram more understandable and less overwhelming for its audience, leading to better communication and comprehension during discussions.
x??

---
#### Filtering Information in Diagrams
Describe the process of filtering unnecessary information from a diagram to make it useful. Emphasize the importance of clarity and relevance in diagrams.
:p How should you approach the creation of a living diagram?
??x
When creating a living diagram, start by identifying its purpose clearly. Then, filter out any non-essential elements that do not contribute to this specific focus. This ensures the diagram remains simple and easy to understand while providing valuable insights.
x??

---
#### Example of Diagram Focus
Provide an example of how filtering can be applied in practice when generating a diagram for different audiences or purposes. Illustrate with a code snippet or a simplified scenario.
:p How would you create a living diagram for explaining external actors in a system?
??x
To create a living diagram that explains the external actors in a system for non-technical stakeholders, use only high-level information such as black boxes and names of actors without technical details like JBoss, HTTP, or JSON. For example:

```java
public class SystemOverview {
    public void displayActors() {
        System.out.println("System A - User Interface");
        System.out.println("System B - Database");
    }
}
```

This focuses on the relevant actors and their relationships with the system.
x??

---
#### Importance of Continuous Integration
Explain how continuous integration can be used to automate the generation of diagrams. Discuss the benefits of integrating diagram creation into the build process.
:p How can continuous integration (CI) support living diagrams?
??x
Continuous integration (CI) can trigger the automatic generation of diagrams during each build or a special on-demand build, ensuring that diagrams are always up-to-date with the codebase. This helps maintain accuracy and relevance without manual effort.

For example:
```java
public class CIJob {
    public void runBuild() {
        // Code to generate diagram using source code
        System.out.println("Generating updated system diagram...");
    }
}
```

This ensures that diagrams are generated automatically, reducing the risk of them becoming outdated.
x??

---

---

#### Living Diagrams and Hexagonal Architecture

Background context: This concept discusses how to generate automatically updated diagrams that represent the software architecture, which helps in understanding dependencies and design intent. The hexagonal architecture enforces a clear separation of concerns by allowing dependencies only from the outside to the inside.

:p What is the main advantage of using living diagrams over static diagrams?
??x
The main advantage of using living diagrams is that they automatically update whenever the system changes, ensuring that the documentation remains relevant and accurate without manual intervention. This helps in making design violations more visible and ensures transparency in the architecture.
x??

---

#### Hexagonal Architecture Constraints

Background context: The hexagonal architecture enforces a specific direction for dependencies to ensure clear separation of concerns. It only allows dependencies from the outside towards the inside, not vice versa.

:p How does the hexagonal architecture constrain dependencies?
??x
The hexagonal architecture constrains dependencies such that they can only go from the outside to the inside and never in the opposite direction. This ensures a clear separation between the core application logic (inside) and external interfaces like databases or user interfaces (outside).
x??

---

#### Highlighting Violations

Background context: To improve visibility of design violations, it is possible to highlight them with different colors or symbols. This can help teams quickly identify areas that need attention.

:p How can design violations be highlighted in a living diagram?
??x
Design violations can be highlighted by using different colors or symbols such as big red arrows indicating dependencies going the wrong direction. This makes violations more visible, allowing team members to address them promptly.
x??

---

#### Purpose of Diagrams and Design

Background context: The success of diagrams depends on their relevance, which in turn is tied to a deep understanding of design intent. Good documentation practices are closely linked to good design practices.

:p Why must useful diagrams be relevant?
??x
Useful diagrams must be relevant because they need to accurately represent the intended design. A diagram that fails to capture the design intent effectively becomes less useful, making it necessary for designers to have a deep understanding of their designs.
x??

---

#### Business Overview as a Living Diagram

Background context: This case study illustrates how a living diagram can serve as an overview of business areas supported by a software system. It highlights the benefits of automatically generating diagrams from source code.

:p What is the main benefit of using a living diagram for documenting the business overview?
??x
The main benefit of using a living diagram for documenting the business overview is that it remains up-to-date without manual intervention, ensuring accuracy and relevance as the system evolves.
x??

---

#### Existing Source Code with Naming Issues

Background context: The existing codebase has naming inconsistencies, which can make it difficult to understand relationships between components. Annotations are introduced to address these issues.

:p What problem does introducing annotations solve in this context?
??x
Introducing annotations solves the problem of understanding the relationships between components by adding explicit metadata that describes their business domains and interactions.
x??

---

#### Custom Annotation Implementation

Background context: A custom annotation is created to declare business domains and express relationships between them. This helps in generating a living diagram automatically.

:p How does the `@BusinessDomain` annotation help in creating a living diagram?
??x
The `@BusinessDomain` annotation helps by adding explicit metadata about the business domain of each package and its related domains, facilitating the generation of a living diagram that accurately represents these relationships.
x??

---

#### Generating Living Diagrams with Graphviz

Background context: The process involves using tools like Graphviz to generate diagrams automatically from source code. This requires scanning the code, creating DOT files, and rendering them into images.

:p What are the main steps in generating a living diagram using Graphviz?
??x
The main steps in generating a living diagram using Graphviz include:
1. Scanning the source code or class files to collect annotated packages.
2. Adding entries to the DOT file for each package with its annotations.
3. Saving the DOT file.
4. Running Graphviz dot at the command line with options to generate an image file.
x??

---

#### Accommodating Changes in Living Diagrams

Background context: As the system evolves, new components appear and existing ones change. The living diagram automatically adapts to reflect these changes.

:p How does a living diagram adapt when new business domains are added?
??x
A living diagram adapts by automatically updating whenever new components with their annotations are introduced or existing components are modified. This ensures that the diagram reflects the current state of the system.
x??

---

#### Adding Quality Attributes

Background context: To enrich the diagrams, quality attributes like performance or security can be included using additional annotations.

:p How can quality attributes be added to a living diagram?
??x
Quality attributes can be added by augmenting the code with package annotations that specify these attributes. The living diagram processor can then extract this information and include it in the final diagram.
x??

---

#### Enforcing Guidelines with Living Diagrams

Background context: By using living diagrams, you can enforce guidelines about architecture through verifiers that check for unexpected dependencies.

:p How does a verifier differ from a living diagram generator?
??x
A verifier differs from a living diagram generator in its purpose. While the latter generates visual representations of the system's structure and relationships, a verifier checks for expected patterns or violations based on dependency rules.
x??

---

---

#### Context Diagrams in Software Development

Background context: In software development, understanding and documenting how a system integrates with its environment is crucial. A context diagram helps visualize these integrations by identifying external actors and their relationships to the system. This diagram supports reasoning about potential impacts of changes.

:p What is a context diagram used for?
??x
A context diagram is used to document the integration points between a system and other systems or entities (actors) in its environment. It provides a high-level view that aids in understanding how changes in one part of the system might affect others, as well as helps new team members get up to speed on the system’s external dependencies.

---

#### Living Diagrams

Background context: A living diagram is an automated representation of a system's context that updates dynamically with any changes made to the codebase. This approach ensures that the documentation remains relevant and reduces manual effort in maintaining it.

:p How does a living diagram differ from a static one?
??x
A living diagram differs from a static one because it automatically refreshes itself whenever there are modifications in the system, such as adding or renaming modules. It uses augmented code (e.g., annotations) to capture information about external actors and their relationships with the system. This ensures that the documentation stays up-to-date without requiring frequent manual updates.

---

#### Augmented Code for Context Diagrams

Background context: To generate a dynamic context diagram, the codebase needs to be annotated or supplemented with metadata that describes its interactions with other systems or entities (actors).

:p How can external actors and their relationships be automatically identified in a system?
??x
External actors and their relationships are automatically identified by augmenting the code with annotations. These annotations provide information such as the name, type (system, API), and direction of interaction (using or being used) for each actor. For example:

```java
/**
 * Vehicle Management is a legacy system which manages which
 * drivers is associated to a vehicle for a period of time.
 */
@ExternalActor(
    name = "Legacy Vehicle Assignment System",
    type = SYSTEM,
    direction = ExternalActor.Direction.SPI)
package flottio.fuelcardmonitoring.legacy;
```
This annotation declares the `Legacy Vehicle Assignment System` as an external actor that provides services (SPI) to the system.

---

#### Hyperlinks in Context Diagrams

Background context: Adding hyperlinks to a context diagram enables users to quickly navigate to relevant code locations when they need more details about an actor. This enhances usability and efficiency of the documentation.

:p How can hyperlinks be added to a context diagram?
??x
Hyperlinks can be added by embedding URLs that point directly to specific locations in the source code repository. When a user clicks on an external actor in the diagram, it opens the corresponding URL in the repository, allowing them to view the actual implementation or related code.

For example:
```java
@ExternalActor(
    name = "Fuelo Fuel Card Provider",
    type = SYSTEM,
    direction = Direction.API)
public class FuelCardTxListener {
}
```
The annotation includes a detailed description that can be used as part of the hyperlink text. Additionally, stable link patterns from Chapter 8 could be employed to ensure these links remain valid over time.

---

#### Benefits and Limitations

Background context: While living diagrams offer significant benefits in terms of keeping documentation up-to-date and reducing maintenance effort, there are also limitations that need to be managed.

:p What are the main advantages and disadvantages of using a living diagram for documenting external actors?
??x
Advantages:
- Automatically updates with code changes.
- Reduces the manual effort required to maintain documentation.
- Ensures that all integration points remain documented.

Disadvantages:
- Requires initial setup and annotation of the codebase.
- There is a risk that some external actors might be overlooked if not properly annotated.
- The diagram may become complex, making it harder to read for users unfamiliar with the system.

---

#### Example of Context Diagram

Background context: A generated context diagram can visually represent the relationships between a system and its external actors in a clear and concise manner. This example illustrates such a diagram.

:p What does a typical context diagram look like?
??x
A typical context diagram might have two sections, one for actors using the system (API side) and another for actors used by the system (service providers side). For instance:

```
 API (actors using the system)
 • Fuelo Card API
 • Fleet Management Teams
 • Support & Monitoring

 SPI (actors providing services to the system)
 • Google Geocoding
 • GPS Tracking from Garmin
 • Legacy Vehicle Assignment System
```

This diagram provides a clear overview of who interacts with or is interacted by the system, making it easier for developers and stakeholders to understand its external dependencies.

---

---

