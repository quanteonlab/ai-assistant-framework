# High-Quality Flashcards: 002 (Part 4)

---

#### Deliberate Design and TDD
Background context: Deliberate design is crucial when implementing Test-Driven Development (TDD). TDD involves writing tests before the actual code, ensuring that each part of the system works as intended. The process requires careful consideration at every step to avoid unnecessary complexity.
:p What is TDD, and how does it support deliberate design?
??x
TDD stands for Test-Driven Development, a practice where developers write tests before writing the corresponding production code. By following this approach, developers ensure that their designs emerge naturally from the tests they create, leading to cleaner and more maintainable code.
In TDD, each test drives the development of new functionality, and when a test fails, it prompts the developer to implement just enough code to pass the test. This iterative process encourages clear thinking about design decisions at every step, promoting deliberate rather than impulsive coding practices.

For example:
```java
public class Calculator {
    public int add(int a, int b) {
        // Implementation goes here
    }
}

// Test before implementation
@Test
void shouldAddTwoNumbers() {
    Calculator calc = new Calculator();
    assertEquals(3, calc.add(1, 2));
}
```
x??

---

#### Living Documentation and Its Benefits
Background context: Living documentation refers to the use of code comments, diagrams, and other forms of inline documentation that reflect the current state of the system. This approach ensures that the documentation stays up-to-date with the codebase.
:p What is living documentation, and why is it beneficial?
??x
Living documentation involves generating documentation directly from the source code. It includes auto-generated diagrams, comments, and other structured information that accurately reflects the actual implementation. The benefits of this practice include:

1. **Visibility**: Issues in design become apparent through visual means like diagrams.
2. **Transparency**: The development process becomes more transparent to stakeholders.
3. **Feedback Tool**: Living documentation can serve as a feedback mechanism, helping developers adjust and correct their code over time.

For example:
```java
/**
 * This method calculates the factorial of a given number.
 * @param n the number whose factorial is to be calculated.
 * @return the factorial of n.
 */
public int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
```
x??

---

#### Deliberate vs. Upfront Decision-Making
Background context: Decisions in software development can be either deliberate or upfront. Deliberate decision-making involves making conscious choices after understanding the potential trade-offs, while upfront decisions are made without thorough consideration.
:p What is the difference between a deliberate and an upfront decision?
??x
A **deliberate** decision is one that is made carefully by considering all options and their implications. Developers think through the consequences of each choice before implementing it.

For example:
```java
// Deliberate decision to use a factory pattern for object creation
public class CarFactory {
    public static Car createCar(String type) {
        if ("sedan".equals(type)) {
            return new Sedan();
        }
        // More types can be added here
        throw new IllegalArgumentException("Invalid car type");
    }
}

// Upfront decision to hard-code the logic, which may become complex later
public class CarFactory {
    public static Car createCar(String type) {
        if (type == "sedan") return new Sedan();
        // More conditions can clutter this method over time
        return null;
    }
}
```
x??

---

#### Documentation as a Form of Code Review
Background context: Documentation serves not only to explain the code but also acts as a form of code review. It helps ensure that changes are made in line with agreed-upon standards and makes it easier for others to understand the system.
:p How does documentation function as a code review?
??x
Documentation can be seen as an implicit form of peer review because it forces developers to think through their decisions and document them clearly. By writing down the rationale behind design choices, developers ensure that future changes are made with consideration of these reasons.

For example:
```java
/**
 * This method updates the user's profile information.
 * @param userId the ID of the user whose profile is being updated.
 * @param info a map containing new values for different fields.
 */
public void updateProfile(String userId, Map<String, String> info) {
    User existingUser = userRepository.findById(userId);
    if (existingUser != null) {
        // Update each field based on the provided map
        existingUser.setField1(info.get("field1"));
        existingUser.setField2(info.get("field2"));
        userRepository.save(existingUser);
    }
}
```
x??

---

#### Shameful Documentation and Its Pitfalls
Background context: Shameful documentation is created to document known issues or problems without actually fixing them. This type of documentation indicates that the underlying issues are severe enough to warrant explicit mention but have not been addressed.
:p What characterizes shameful documentation, and why should it be avoided?
??x
Shameful documentation refers to situations where existing documentation highlights problems in the codebase rather than providing a solution. Examples include troubleshooting guides that document known bugs or traps without fixing them.

For example:
```java
/**
 * This method handles user authentication.
 * @param username the username for login.
 * @param password the password for login.
 * @return true if the credentials are correct, false otherwise.
 */
public boolean authenticateUser(String username, String password) {
    try {
        // Code that may fail due to known issues
    } catch (IOException e) {
        System.err.println("Authentication failed: " + e.getMessage());
        return false;
    }
}
```
x??

---

---

#### Hygienic Transparency
Background context: The idea is to make the internal quality of software visible to both developers and non-developers, which creates pressure for improvement. This can be achieved through various means like living documents, living diagrams, code metrics, word clouds, etc.

:p How does making internal quality visible improve it?
??x
Making internal quality visible increases awareness among all stakeholders about the issues in the codebase, thereby creating a pressure to address these problems and improve overall quality. This visibility can be achieved through various tools like living documents, diagrams, and metrics.
x??

---

#### The Law of Ripolin
Background context: Le Corbusier's book "The Decorative Art of Today" introduces the idea that if everything in a home were painted white (similar to using Ripolin paint), dirt would be immediately visible. This concept is applied to software documentation where clean, clear code reveals its issues more easily.

:p How does good documentation relate to Le Corbusier's Law?
??x
Good documentation should reveal the true nature of the code and its design flaws just as a white-painted home would show dirt. By making the code and its structure visible through thorough and effective documentation, developers can identify areas for improvement more easily.
x??

---

#### Word Clouds of the Language in the Code
Background context: A word cloud is a simple diagram that highlights frequently used words versus less frequent ones. In software development, it can help determine if the codebase aligns well with its business domain.

:p What does a word cloud reveal about a codebase?
??x
A word cloud reveals whether technical terms or business-related language dominate in the code. If technical terms dominate, it suggests that the code may not closely reflect the business domain. Conversely, if domain-specific language is dominant, it indicates better alignment with the business context.
x??

---

#### Diagnostics and Metrics for Code Quality
Background context: Diagnostic tools like word clouds can help identify issues in the code by making its internal structure visible. Metrics and other diagnostic tools are crucial in identifying areas needing improvement.

:p What is a simple method to generate a word cloud from source code?
??x
To generate a word cloud from source code, you can follow these steps:
1. Parse the source code files.
2. Ignore programming language keywords and punctuation.
3. Count the frequency of remaining words.
4. Use an online tool or library like d3.layout.cloud.js to render the word cloud.

Example pseudocode for filtering tokens:

```java
SEPARATORS = ";:.,?!<><=+-^&|*/\" \r\n {}[]()"
KEYWORDS = { "abstract", "continue", "for", "new", "switch", "assert", "default", "if", "package", ... }
STOPWORDS = { "the", "it","is", "to", "with", "what's", "by", "or", "and", "both", "be", "of", "in", "obj", ... }

for each file in source code:
    text = read file as string
    tokens = split(text, SEPARATORS)
    filtered_tokens = filter out KEYWORDS and STOPWORDS from tokens
    print(filtered_tokens)

// You can also use a library like Guava to count occurrences:
bag.add(token);
```

x??

---

#### Le Corbusier's White Paint Analogy
Background context: The analogy uses the idea of painting everything white (Ripolin) in a house, making dirt visible. This concept is applied to software documentation where clean code highlights issues and flaws.

:p How does applying this analogy help in improving code quality?
??x
Applying the Ripolin analogy helps by making the internal structure and any dirty or hidden aspects of the code more visible. This increased visibility creates a sense of ownership and responsibility, encouraging developers to improve the overall quality and maintainability of the codebase.
x??

---

#### Signature Survey for Code Design
Background context: Ward Cunningham's signature survey filters out all non-language punctuation from source files to visualize the shape and design of the code.

:p What is the purpose of a signature survey in code design?
??x
The purpose of a signature survey is to focus on the structure and composition of functions, methods, and classes by filtering out language-specific punctuation. This allows developers to see how these elements are organized without being distracted by syntax or variable names, helping to identify design patterns and potential improvements.
x??

---

---

#### Importance of Evolving Architecture Documentation

Background context: The best architecture is an evolving creature, since it is hard to get it right on the first try and then has to adapt to changing contexts. Good documentation should be easy to explain succinctly and minimize hard-to-change decisions.

:p Why is continuous evolution crucial for architecture?

??x
Continuous evolution is crucial because architectures are complex systems that need to adapt over time in response to changes in requirements, technology, or business needs. Documentation must support this flexibility by being easy to understand and update without causing significant disruption.
x??

---

#### Decision Logs (ADR) Concept

Background context: ADRs help document important architectural decisions with their rationales, alternatives, and consequences. This practice improves traceability and maintainability of the architecture.

:p What is an Architectural Decision Record (ADR)?

??x
An Architectural Decision Record (ADR) is a structured format used to document significant architectural decisions along with their rationales, alternatives considered, and potential consequences.
x??

---

#### Example ADR for New Claim Management

Background context: ADRs maintain the rationale behind key architecture decisions. This example covers decisions related to user experience, legacy software revamp, and business process modeling.

:p What are the main decisions documented in the ADR for the new Claim Management system?

??x
The main decisions documented include:
- UX approach with a focus on user-friendly screens.
- Revamping existing legacy software through a progressive approach.
- Using Domain-Driven Design (DDD) to partition the legacy system.
- Formalizing business rules through process modeling.

These decisions aim to improve user experience and manage risks associated with revamping legacy systems.
x??

---

#### CQRS and Event Sourcing Decision

Background context: The decision log includes specific technical choices like using CQRS and event sourcing. These patterns help manage write and read operations efficiently while maintaining auditability.

:p What is the rationale behind choosing CQRS combined with Event Sourcing for the Claim Management system?

??x
The rationale behind choosing CQRS combined with Event Sourcing is to exploit the asymmetry between write and read actions, speed up read accesses, and maintain an accurate record of user intents. This approach ensures that audit trails are easily traceable while improving performance.

Example Code:
```java
public class CommandHandler {
    public void handleCreateClaimCommand(claimCommand) {
        // Handle command logic here.
        eventPublisher.publish(new ClaimCreatedEvent(claimCommand));
    }
}

public class EventSourcingRepository {
    public void applyEvents(List<Event> events) {
        for (Event event : events) {
            switch (event.getType()) {
                case CLAIM_CREATED:
                    handleClaimCreated(event.getPayload());
                    break;
                // More cases as needed.
            }
        }
    }

    private void handleClaimCreated(Map<String, Object> payload) {
        Claim claim = new Claim(payload);
        save(claim);
    }
}
```
x??

---

#### Value-First Approach

Background context: The value-first approach emphasizes immutability and reduces boilerplate code in Java by favoring value objects over mutable classes.

:p Why is the value-first approach important for avoiding bugs?

??x
The value-first approach is important because it avoids bugs that arise from mutability. By using immutable value objects, developers reduce the risk of unintended side effects and ensure more predictable behavior. This approach also simplifies code maintenance by minimizing boilerplate code.

Example Code:
```java
@Value
public class Claim {
    private final String id;
    private final Date dateOfIncident;

    public Claim(String id, Date dateOfIncident) {
        this.id = id;
        this.dateOfIncident = dateOfIncident;
    }
}

@Getter @Builder
@NoArgsConstructor
@AllArgsConstructor
public class ClaimBuilder {
    private String id;
    private Date dateOfIncident;
}
```
x??

---

#### Summary of Key Concepts

--- 
This concludes the flashcards based on the provided text. Each card covers a different aspect of evolving architecture documentation and decision-making processes, ensuring you have a comprehensive understanding of these topics.
---

---

#### Transparent Architecture
Transparent architecture involves embedding architecture documentation within software artifacts, such as source code repositories. This ensures that every individual has access to all architectural knowledge, enabling decentralized decision-making based on this information.

Background context: The goal is to make architecture documentation easily accessible and up-to-date for everyone involved in the project, reducing dependencies on a few architects and promoting better collaboration across teams.
:p What is transparent architecture?
??x
Transparent architecture refers to embedding detailed architectural information within software artifacts like source code repositories. This makes the architecture knowledge available to every team member, enabling them to make informed decisions without needing explicit guidance from architects.
x??

---

#### Living Architecture Documentation
Living architecture documentation involves using automated tools to generate up-to-date diagrams and documents directly from the source code or system runtime data. These living artifacts are continuously updated as the software evolves.

Background context: The key is maintaining a dynamic, real-time view of the architecture that reflects the current state of the system rather than relying on outdated static documents.
:p What is living architecture documentation?
??x
Living architecture documentation involves generating and updating architectural diagrams and documents automatically based on the current state of the codebase or runtime data. This ensures that everyone has access to the most recent information about the system's architecture.
```java
// Example of a simple method in a class that generates a diagram
public class DiagramGenerator {
    public void generateDiagram() {
        // Code to read from the source code and produce a visual representation
        System.out.println("Generating diagram...");
    }
}
```
x??

---

#### Strategic Goals, Architectural Principles, Design and Delivery Practices
These are three key components that Sam Newman suggests organizing in architecture documentation. They help define the system's vision, principles, and practices.

Background context: This approach ensures that everyone understands the high-level goals of the project and the underlying architectural decisions.
:p What are the three main components of architecture documentation according to Sam Newman?
??x
The three main components of architecture documentation according to Sam Newman are:
- Strategic Goals (e.g., enable scalable business, support entry into new markets)
- Architectural Principles (e.g., consistent interfaces and data flow, no silver bullet)
- Design and Delivery Practices (e.g., standard REST/HTTP, encapsulate legacy, minimal customization of COTS/SaaS)

These components help define the system's vision and principles.
x??

---

#### Living System Diagrams in Microservices
In a microservices architecture, living system diagrams can be generated from runtime data to provide real-time visibility into service interactions.

Background context: This approach helps teams understand how services interact with each other without relying on static documentation or manual diagrams.
:p How are living system diagrams useful in a microservices architecture?
??x
Living system diagrams in a microservices architecture are useful because they provide real-time, dynamic views of service interactions. They can be generated from runtime data, such as distributed tracing, and help teams understand the current state of the system's architecture without relying on static documentation.
```java
// Example method to generate a living diagram from tracing data
public class ServiceDiagramGenerator {
    public void generateServiceDiagram() {
        // Code to read distributed tracing data and produce a visual representation
        System.out.println("Generating service diagram...");
    }
}
```
x??

---

#### Architectural Annotations
Architectural annotations are metadata added to code or documentation that provide design information, making the architecture more explicit.

Background context: By adding these annotations, developers can document various aspects of their design decisions directly in the codebase.
:p What is an architectural annotation?
??x
An architectural annotation is a piece of metadata added to the code or documentation that provides detailed design information. It makes the architecture more explicit by documenting key elements such as layers, idempotency, side effects, and sensitive data.

Example:
```java
@Layer(LayerType.INFRASTRUCTURE)
package com.example.infrastructure;

@Idempotent
void store(Customer customer);

@SideEffect(SideEffect.WRITE, "Database")
void save(Event e);

@Sensitive("Risk of Fraud")
public final class CreditCard {
    ...
}
```
x??

---

#### Living Diagrams and Documents
Living diagrams and documents are automatically generated from the source code or runtime data. They provide up-to-date views of the architecture that can be accessed by everyone.

Background context: These living artifacts ensure that the architectural knowledge is continuously updated and easily accessible, promoting better collaboration and informed decision-making.
:p What are living diagrams and documents?
??x
Living diagrams and documents are automatically generated from the source code or runtime data. They provide up-to-date views of the architecture that can be accessed by everyone, ensuring that the architectural knowledge is always current.

Example:
```java
// Example method to generate a diagram using a custom annotation
public class CustomDiagramGenerator {
    public void generateCustomDiagram() {
        // Code to read from annotations and produce a visual representation
        System.out.println("Generating custom diagram...");
    }
}
```
x??

---

#### Distributed Tracing for Living Diagrams
Distributed tracing infrastructure can be used to generate living diagrams, providing visibility into service interactions.

Background context: Tools like Zipkin can capture trace data across services, which can then be visualized in real-time.
:p How can distributed tracing tools be used for generating living diagrams?
??x
Distributed tracing tools like Zipkin can be used to generate living diagrams by capturing trace data across services and visualizing it in real-time. This provides a dynamic view of service interactions.

Example:
```java
// Example method to use Zipkin for tracing and diagram generation
public class TracingDiagramGenerator {
    public void generateTracingDiagram() {
        // Code to read from the distributed tracing infrastructure (e.g., Zipkin) and produce a visual representation
        System.out.println("Generating tracing diagram...");
    }
}
```
x??

---

---

#### Transparent Architecture 365
Background context: This section discusses the use of annotations and design knowledge augmentation to enforce design decisions in software development. It emphasizes using tools like static analysis, architectural constraint templates, and custom rules to ensure that code adheres to intended architecture.

:p What is transparent architecture?
??x
Transparent architecture refers to the practice of enhancing source code with metadata such as annotations or tags, which helps tools check for compliance with design principles and architectural constraints. This allows developers to focus on implementing functionality while ensuring that the implementation aligns with higher-level design goals.
x??

---
#### Enforced Design Decisions Using Annotations
Background context: The text explains how annotations can be used to enforce specific design decisions by checking dependencies according to declared patterns and stereotypes.

:p How do you check for violations of design principles using annotations?
??x
You use tools like static analysis or architectural constraint templates to check if the code adheres to specified design rules. For example, if a class annotated as a value object should not have field-level dependencies on entity or service classes.
```java
if (type.isInvolvedIn(VALUE_OBJECT)) {
    if (dependency.isInvolvedIn(ENTITY) || 
        dependency.isInvolvedIn(SERVICE)) {
        // Raise an anomaly
    }
}
```
x??

---
#### Custom Rules in Static Analysis Tools
Background context: The text provides examples of custom rules that can be implemented using tools like SonarQube or ArchUnit to enforce specific architectural constraints.

:p What is an example of a custom rule for enforcing the separation between layers?
??x
A rule could enforce that "the persistence layer cannot depend on web code" by forbidding access from `.dao` classes to any `.web` classes.
```java
noClasses().that().resideInAPackage("..dao..")
    .should().accessClassesThat()
    .resideOutsideOfPackage("..web..")
    .check(importedClasses);
```
x??

---
#### Living Architecture Documentation
Background context: The text highlights the importance of documenting and protecting design decisions as part of living documentation that evolves with the code.

:p How does regular visualization help in maintaining architecture integrity?
??x
Regularly visualizing the architecture during development helps compare the actual implementation with the intended design, allowing for adjustments if necessary. This can be done using automated tools to generate diagrams or other documents.
```java
noClasses().that().resideInAPackage("..domain..")
    .should().accessClassesThat()
    .resideOutsideOfPackage("..domain..")
    .check(importedClasses);
```
x??

---
#### Test-Driven Architecture
Background context: The text emphasizes using quality attributes as tests to ensure that the system meets critical non-functional requirements.

:p How can you define a performance test for a specific scenario?
??x
You can define a performance test by first describing it in a test script, then implementing it as a realistic test. For example:
```java
@QualityAttribute @SlowTest @ProductionLikeEnv @Pending
Scenario: Number of requests at peak time
Given the system is deployed on a production-like environment
When it receives a load of 10k requests over 5mn,
the error rate is less than 0.1%, and 
the response time is below 100ms at 99.5 percentile.
```
x??

---
#### Quality Attributes as Scenarios
Background context: The text discusses using scenarios to document quality attributes in a declarative manner, making them serve both as documentation and test cases.

:p How can you document a security requirement as a scenario?
??x
A security requirement like "when we run standard penetration testing suites, zero flaw is detected" can be documented with custom tags such as `@QualityAttribute`, `@SlowTest`, and `@ProductionLikeEnv`. The external link to the full description of the test suite is part of your documentation.
```java
@QualityAttribute @SlowTest @ProductionLikeEnv @Pending
Scenario: Penetration testing scenario
Given we run a standard penetration testing suite,
When it detects zero flaws,
Then the system meets our security requirements.
```
x??

---
#### Monitoring and Fault Tolerance
Background context: The text introduces tools like Netflix's Chaos Monkey to simulate outages and verify fault tolerance at different levels.

:p How does Chaos Gorilla help in verifying fault tolerance?
??x
Chaos Gorilla simulates an outage of an entire Amazon availability zone to ensure that services automatically re-balance without user-visible impact or manual intervention. The mere description of the tool, along with its configuration parameters, documents the fault-tolerance requirements.
```java
// Example configuration for Chaos Gorilla
{
    "outageFrequency": "1 week"
}
```
x??

---

#### Small-Scale Simulation Characteristics

Background context: A small-scale simulation is a simplified model of a system that serves as a communication tool and documentation. It must be small enough to fit in a normal personâ€™s brain, easy to tinker with, executable, and able to exhibit dynamic behavior.

:p What are the key characteristics of a small-scale simulation?
??x
A small-scale simulation should:
- Be small enough to fit in the brain of a normal person or developer.
- Be easy to tinker with and invite interactive exploration.
- Be executable and show dynamic behavior at runtime.
- Predict results through execution, observable even during computation.

For example, consider a small-scale simulation for a financial system that focuses on transaction processing:
```java
public class TransactionSimulator {
    private List<Transaction> transactions;

    public void addTransaction(Transaction transaction) {
        // Simple logic to add a transaction without complex validations
        transactions.add(transaction);
    }

    public double getBalance() {
        return transactions.stream()
                           .mapToDouble(Transaction::getValue)
                           .sum();
    }
}
```
x??

---

#### Simplifying a System for Small-Scale Simulation

Background context: To create a small-scale simulation, one must simplify the full system aggressively, focusing on critical aspects rather than all features. Techniques include curation, mocks and stubs, approximation, more convenient units, brute-force calculation, and batch versus event-driven approaches.

:p What techniques can be used to simplify a complex system for creating a small-scale simulation?
??x
Techniques to simplify a complex system for a small-scale simulation include:
- Curation: Ignore non-central member data.
- Mocks, stubs, and spies: Use test companions to replace non-centrally relevant subparts.
- Approximation: Accept realistic accuracy over strict precision.
- More convenient units: Simplify data input/output.
- Brute-force calculation: Opt for the simplest algorithm with explanatory power.
- Batch versus event-driven: Convert or simplify based on coding and understanding simplicity.

For example, using mocks to simulate external dependencies:
```java
public class ExternalServiceMock {
    private final Map<String, String> responses = new HashMap<>();

    public void setResponse(String key, String value) {
        responses.put(key, value);
    }

    public String getResponse(String key) {
        return responses.get(key);
    }
}
```
x??

---

#### Small-Scale Simulation as Living Architecture Documentation

Background context: A small-scale simulation acts as a living documentation of a system, helping in reasoning on the structure and behavior. It is valuable for explaining systems by focusing on one or two critical aspects.

:p How does a small-scale simulation serve as living architecture documentation?
??x
A small-scale simulation serves as living architecture documentation because:
- It is executable and shows dynamic behavior.
- It allows reasoning on static structure through code observation.
- It can be tinkered with, creating test cases or interacting via REPL.
- It simplifies complex systems to focus on critical aspects.

For example, a simplified version of a user registration system might show only the validation logic:
```java
public class UserValidator {
    public boolean isValidUser(String username) {
        // Simple validation logic for demonstration purposes
        return !username.isEmpty() && username.length() < 20;
    }
}
```
x??

---

#### Proofs of Concept as Communication Tools

Background context: In large companies, a small-scale model under the name "proof of concept" can serve as an alternative to lengthy studies and presentations. It helps converge on tough questions by focusing on working code.

:p What is a proof of concept (POC) in the context of software development?
??x
A proof of concept (POC) in software development is:
- A small-scale model that serves as a communication tool.
- Used to quickly explore and map domains, discover issues, grow vocabulary, and agree on shared vision.
- Helps ground discussions with concrete reference code.
- Useful for practical scenarios where full-scale implementation would be impractical.

For example, a POC for integrating payment gateways might focus on basic transaction processing:
```java
public class PaymentGatewaySimulator {
    public boolean processTransaction(Transaction transaction) {
        // Simple logic to simulate transaction processing
        return true;
    }
}
```
x??

---

#### Small-Scale Simulation vs. Legacy or External Systems

Background context: A small-scale simulation can act as an inexpensive proxy for impractical legacy or external systems, allowing easier understanding of their effects without running complex and state-dependent batches.

:p How does a small-scale simulation help with legacy or external system integrations?
??x
A small-scale simulation helps with legacy or external system integrations by:
- Providing a simplified model to understand the effects.
- Avoiding complex batch processes that depend on database states.
- Making it easier to grasp interactions in context.

For example, simulating an external weather API for a weather reporting application:
```java
public class WeatherApiSimulator {
    private final Map<String, String> weatherData = new HashMap<>();

    public void setWeather(String city, String temperature) {
        weatherData.put(city, temperature);
    }

    public String getWeather(String city) {
        return weatherData.getOrDefault(city, "Unknown");
    }
}
```
x??

---

---

#### Small-Scale Simulation and Walking Skeleton
Background context: The chapter discusses the benefits of creating a small-scale simulation or "walking skeleton" to clarify thoughts, improve design, and test competing approaches. This is particularly useful during the early stages of project development.

:p What are the benefits of building a small-scale simulation?
??x
The benefits include clarifying thoughts, improving design by simplifying concepts, and allowing for quicker testing of different approaches based on actual facts rather than opinions. This method helps in understanding the core functionality without the distractions of complex details.
x??

---
#### Single Responsibility Principle (SRP)
Background context: The chapter mentions that a small-scale simulation can help identify whether a system follows the single responsibility principle, which states that every class should have only one reason to change.

:p How does a small-scale simulation indicate adherence to the single responsibility principle?
??x
If a small-scale simulation can be created by reusing the same code from the original system just by assembling a naive subset of its elements, it suggests that the original design adheres to the single responsibility principle. Each part of the system is responsible for one aspect only, making the system easier to maintain and extend.
x??

---
#### Alistair Cockburn's Walking Skeleton
Background context: The idea of creating a small-scale simulation or "walking skeleton" is attributed to Alistair Cockburn in his book "Crystal Clear: A Human-Powered Methodology for Small Teams."

:p What does the term "walking skeleton" refer to?
??x
The term "walking skeleton" refers to a minimal, runnable version of an application that has enough structure and core functionality to demonstrate its viability. It is used as a starting point in software development projects to ensure that basic functionalities are working.
x??

---
#### Applicability of Small-Scale Simulations
Background context: The chapter suggests that small-scale simulations can be used not only for design but also for training purposes, where new joiners can build their own mental models about the system by experimenting with it.

:p How can small-scale simulations aid in the onboarding process?
??x
Small-scale simulations allow new team members to experiment with the system and form their own understanding of its core functionalities without risk. This hands-on approach helps them grasp complex systems more easily, similar to how children learn physics through play.
x??

---
#### System Metaphor for Training
Background context: The chapter mentions that explaining something to a group requires determining what they already know to build on existing knowledge.

:p What is the importance of understanding the prior knowledge of an audience in training?
??x
Understanding the prior knowledge of an audience is crucial because it allows trainers to build upon the existing knowledge, making the learning process more effective. This approach ensures that the information is presented in a way that aligns with the audience's current level of understanding.
x??

---

---

#### System Metaphor Explanation
Background context: A system metaphor is a powerful tool for explaining complex systems by comparing them to something more familiar. This helps leverage prior knowledge and makes new information easier to understand and remember.

:p What is a system metaphor?
??x
A system metaphor is a way of explaining a new or unfamiliar system by relating it to something that people are already familiar with, such as stacking glasses or an assembly line.
x??

---
#### Monoids and Stackable Objects
Background context: Monoids are mathematical structures that allow for the composition of elements. A common way to explain this concept is through tangible, stackable objects like beer glasses or chairs.

:p How can monoids be explained using stackable objects?
??x
Monoids can be explained by imagining a set of stackable objects such as beer glasses or chairs. Just as you can stack one glass on top of another to form a tower, or stack multiple chairs together to create a bench, the elements in a monoid can be combined according to specific rules (like addition or multiplication) to produce a new element that is part of the same set.
x??

---
#### Assembly Line Metaphor
Background context: The assembly line metaphor describes a linear process where parts move from one machine to another. This helps explain concepts like dependencies and quality control.

:p How does an assembly line metaphor help in understanding system architecture?
??x
An assembly line metaphor is useful because it illustrates the idea of a linear, step-by-step process where each stage depends on the previous ones. Just as defects in earlier stages can propagate to later stages, issues in one part of the system can affect others downstream.
x??

---
#### Modular Synthesizer Metaphor
Background context: The modular synthesizer metaphor was used by a team building a cash flow calculation engine. It helps explain complex systems through the concept of interconnected modules.

:p How does the modular synthesizer metaphor apply to creating a cash flow calculation engine?
??x
The modular synthesizer metaphor applies by envisioning the engine as a set of electronic modules, each with buttons and knobs that can be wired together in various ways via patch cords. Similarly, the financial instrument can be broken down into smaller, interconnected components (modules) that process data and produce outputs, much like how different parts of a modular synthesizer create complex sounds.
x??

---
#### Redundancy Mechanism
Background context: Metaphors not only explain but also serve as redundancy mechanisms by providing multiple perspectives on the same concept. This ensures better understanding even when individuals don't have prior knowledge.

:p Why are metaphors useful for teams with varying levels of familiarity?
??x
Metaphors are useful because they can bridge knowledge gaps by leveraging familiar concepts to explain new ones. Even if some team members do not know a specific metaphor, the overall concept remains understandable through its comparison to something more known.
x??

---

---

#### Embedding Data as Dictionaries
Background context: In a batch system, instead of using spreadsheets to store data, the team can embed this data directly into their code as dictionaries or maps. This approach allows for easier versioning and modification compared to manually managing spreadsheet files.

:p How can the team embed data from a former spreadsheet file in their code?
??x
The team can embed the equivalent of the former spreadsheet file by hardcoding it as a dictionary (or map) within their source code. For example, in Java:

```java
Map<String, Object> data = new HashMap<>();
data.put("key1", "value1");
data.put("key2", 42);
```

This approach allows for better integration with the development environment and easier management of data.
x??

---

#### Exporting Data as Files
Background context: The embedded dictionary can be exported to various file formats such as `.xls`, `.csv`, or `.json` for non-developer audiences. This ensures that stakeholders outside the development team can access this information without needing to browse through code.

:p How can the embedded data be exported in different file formats?
??x
The embedded data (dictionary) can be serialized into various file formats such as `.xls`, `.csv`, or `.json`. For example, using Java, one might use libraries like Apache POI for `.xls` files and Jackson for JSON:

```java
// Serializing to CSV
CSVWriter writer = new CSVWriter(new FileWriter("data.csv"));
List<String[]> csvData = new ArrayList<>();
for (Map.Entry<String, Object> entry : data.entrySet()) {
    csvData.add(new String[]{entry.getKey(), entry.getValue().toString()});
}
writer.writeAll(csvData);
writer.close();

// Serializing to JSON
ObjectMapper mapper = new ObjectMapper();
String json = mapper.writeValueAsString(data);
```

These examples show how the same dictionary can be converted into different file formats.
x??

---

#### Integrated Documentation for Developers
Background context: IDEs provide built-in documentation features like Javadoc and UML class diagrams that are readily available to developers. However, these might not suffice for non-developer stakeholders.

:p Why might integrated documentation (Javadoc, UML) in the IDE be insufficient for non-developers?
??x
Integrated documentation such as Javadoc reports and UML class diagrams may not provide enough context or depth for non-developer stakeholders. These tools are primarily designed for developers to understand code structures and interfaces but lack comprehensive explanations of business concepts.

For instance, while a method comment like `/** @param param1 Description */` provides developer-friendly documentation, it does not explain the meaning behind the parameter in business terms.
x??

---

#### Introducing a Living Glossary
Background context: To address the need for non-developer stakeholders to understand the business concepts embedded within code, the team can create a living glossary. This glossary would be generated from the code itself and maintained as part of the documentation.

:p What is a living glossary in this context?
??x
A living glossary is a dynamic document that extracts and explains key terms used in the business domain from the source code, particularly within specific packages like `/domain`. These terms are extracted from classes, interfaces, enums, and method names, along with relevant Javadoc comments.

For example:

```java
public interface PaymentService {
    /**
     * Transfers funds between two accounts.
     * @param sourceAccount The account to deduct funds from.
     * @param destinationAccount The account to credit funds to.
     */
    void transferFunds(Account sourceAccount, Account destinationAccount);
}

// Glossary entry:
"Payment Service": A service interface that defines methods for transferring funds between accounts. 
- `transferFunds`: Method to move money from one account to another.
```

The glossary is "living" because it updates automatically as the codebase evolves, ensuring that all terms are up-to-date and accurately reflected in documentation.
x??

---

#### Showing Design Intent with Naming Conventions
Background context: If the internal design follows a known pattern like Hexagonal Architecture, naming conventions can make this structure visible within the code. This makes the architecture more understandable to developers and stakeholders.

:p How can the team document the use of Hexagonal Architecture in their project?
??x
To document the use of Hexagonal Architecture, the team should include clear naming conventions for different parts of the system in the README file:

1. Document the overall structure:
```
1. The design of this module follows the Hexagonal Architecture pattern (link to a reference on the web).
2. By convention, domain model code is placed in `src/*/domain/*` packages.
3. All infrastructure-related code resides elsewhere.
```

This documentation helps both developers and stakeholders understand how the architecture is implemented and maintained.

For example:

```java
// src/main/java/com/example/domain/Account.java
package com.example.domain;

public class Account {
    // Domain logic here
}
```

```java
// src/main/java/com/example/infrastructure/PaymentGateway.java
package com.example.infrastructure;

public class PaymentGateway {
    // Infrastructure code here
}
```

The README file serves as a centralized reference to these conventions, ensuring that the design intent is clear and consistent.
x??

---

#### Living Documentation Approach
Background context explaining the living documentation approach. Agile practices and compliance goals often overlap, focusing on risk mitigation, traceability, quality control, and continuous improvement. The approach suggests using lightweight declarations and automation to satisfy compliance requirements without the need for formal, tedious documents.

:p How can agile practices meet or exceed high-level compliance objectives?
??x
Agile practices can meet or exceed compliance objectives by focusing on risk mitigation, traceability, quality under control, and continuous improvement. By leveraging lightweight declarations, knowledge augmentation, and automation, teams can efficiently satisfy most of the high-level compliance requirements without the burden of excessive paperwork.

For instance, using a source control system to generate documentation from code and tests automates much of the compliance process.
??x
The answer with detailed explanations.
Automation through tools like version control systems can significantly reduce manual compliance tasks. For example:
```java
public class DocumentationGenerator {
    public static void main(String[] args) {
        // Retrieve information from source control system
        String code = retrieveCodeFromSourceControl();
        List<TestCase> tests = retrieveTestResultsFromSystem();

        // Generate documentation based on the retrieved data
        generateDocumentation(code, tests);
    }

    private static String retrieveCodeFromSourceControl() {
        // Code to fetch code from version control
        return "Sample code";
    }

    private static List<TestCase> retrieveTestResultsFromSystem() {
        // Code to fetch test results
        return new ArrayList<>();
    }

    private static void generateDocumentation(String code, List<TestCase> tests) {
        // Generate documentation using the retrieved data
        System.out.println("Generated Documentation: " + code + "\n" + tests);
    }
}
```
x??

---

#### Compliance Documentation Requirements
Background context explaining how to review compliance documentation requirements and map them to agile practices. This involves identifying how each compliance item can be satisfied with living documentation approaches, such as using lightweight declarations and automation.

:p How can you identify if a compliance requirement is met by your agile process?
??x
Identify if a compliance requirement is met by your agile process by reviewing the high-level goals of risk mitigation, traceability, quality control, and continuous improvement. Map each compliance item to see how it could be satisfied with lightweight declarations, knowledge augmentation, or automation.

For example, for documentation on change requests:
- User stories or bugs in Agile can replace traditional request logs.
- Automated tests and living documentation artifacts from BDD (Behavior Driven Development) and TDD (Test Driven Development) can cover study and impacts.
??x
The answer with detailed explanations.
By mapping compliance items to agile practices, you ensure that your process meets high-level goals while reducing paperwork. For instance:
```java
public class ChangeRequestManager {
    public void manageChangeRequests(List<ChangeRequest> requests) {
        // Process each request using agile methods
        for (ChangeRequest request : requests) {
            handleUserStory(request);
            automateTestsForImpactAnalysis(request);
            generateCABReport(request);
        }
    }

    private void handleUserStory(ChangeRequest request) {
        System.out.println("Handling user story: " + request.getDescription());
    }

    private void automateTestsForImpactAnalysis(ChangeRequest request) {
        // Automate tests to assess impacts
        System.out.println("Automated test results for impact analysis.");
    }

    private void generateCABReport(ChangeRequest request) {
        // Generate CAB report based on automated test results and user story details
        System.out.println("Generated CAB report: " + request.getExpectedBenefits());
    }
}
```
x??

---

#### Continuous Delivery and ITIL
Background context explaining how continuous delivery can coexist with process-oriented environments like those following ITIL. Agile practices, when properly implemented, can meet or even exceed the requirements of traditional processes.

:p How can you map agile practices to a more traditional compliance framework?
??x
Map agile practices to a more traditional compliance framework by focusing on lightweight declarations and automation. For example:
- In ITIL's request for change management, user stories or bugs in Agile can replace traditional log entries.
- Automated tests from BDD/TDD create living documentation artifacts that cover study and impacts.

For instance:
```java
public class ChangeRequestHandler {
    public void handleChangeRequests(List<ChangeRequest> requests) {
        // Use agile practices to map to ITIL processes
        for (ChangeRequest request : requests) {
            manageUserStories(request);
            automateTestsForImpacts(request);
            generateCABReport(request);
        }
    }

    private void manageUserStories(ChangeRequest request) {
        System.out.println("Managing user stories: " + request.getDescription());
    }

    private void automateTestsForImpacts(ChangeRequest request) {
        // Automate tests to assess impacts
        System.out.println("Automated test results for impact analysis.");
    }

    private void generateCABReport(ChangeRequest request) {
        // Generate CAB report based on automated test results and user story details
        System.out.println("Generated CAB report: " + request.getExpectedBenefits());
    }
}
```
x??

---

#### Managing Requests for Change
Background context explaining the management of requests for change under ITIL, compared to agile practices. Agile promotes slicing work into small chunks but may not track every detail in a tracking tool.

:p How can you manage requests for change using agile methods?
??x
Manage requests for change using agile methods by leveraging lightweight declarations and automation. User stories or bugs in Agile replace traditional log entries, while automated tests from BDD/TDD generate living documentation artifacts that cover study and impacts.

For example:
```java
public class ChangeRequestManager {
    public void manageChangeRequests(List<ChangeRequest> requests) {
        // Use agile methods to track change requests
        for (ChangeRequest request : requests) {
            handleUserStory(request);
            automateTestsForImpacts(request);
            generateCABReport(request);
        }
    }

    private void handleUserStory(ChangeRequest request) {
        System.out.println("Handling user story: " + request.getDescription());
    }

    private void automateTestsForImpacts(ChangeRequest request) {
        // Automate tests to assess impacts
        System.out.println("Automated test results for impact analysis.");
    }

    private void generateCABReport(ChangeRequest request) {
        // Generate CAB report based on automated test results and user story details
        System.out.println("Generated CAB report: " + request.getExpectedBenefits());
    }
}
```
x??

---

#### Release Management
Background context explaining release management under ITIL, compared to agile practices. Agile focuses on rapid deployment and continuous delivery.

:p How can you manage releases using agile methods?
??x
Manage releases using agile methods by leveraging automated tools for content, impacts, and approval processes. For example:
- Use ticketing systems with prewritten documents and generated release notes.
- Generate living documentation from change studies and iteration demos.
- Automate tests to check SLA, deployments, and smoke tests.

For instance:
```java
public class ReleaseManager {
    public void manageReleases(List<Release> releases) {
        // Use agile methods for managing releases
        for (Release release : releases) {
            prepareReleaseNotes(release);
            generateLivingDocumentation(release);
            performDeploymentTests(release);
            getApproval(release);
        }
    }

    private void prepareReleaseNotes(Release release) {
        System.out.println("Prepared release notes: " + release.getDates());
    }

    private void generateLivingDocumentation(Release release) {
        // Generate living documentation from change studies and iteration demos
        System.out.println("Generated living documentation for impacts.");
    }

    private void performDeploymentTests(Release release) {
        // Perform automated tests to check SLA, deployments, and smoke tests
        System.out.println("Performed deployment tests: " + release.getTestStrategy());
    }

    private void getApproval(Release release) {
        // Get approval based on generated documentation
        System.out.println("Approval status: " + release.getDecisionDate());
    }
}
```
x??

---

---

#### Superimposed Structure
Background context explaining the concept. When working within a legacy system, especially when integrating a bubble context into a larger application, defining clear boundaries between old and new systems can be challenging. Legacy systems often lack a clear structure or exhibit an unstructured mess.

Especially with large legacy applications, it is hard to delineate between what is part of the existing system versus what you are trying to add or modify.
:p What does superimposed structure refer to in the context of working on legacy systems?
??x
Superimposed structure refers to the process of adding a new feature or making changes within an unstructured legacy application. You create a mental model that maps your desired architecture and functionality onto the existing, often disorganized codebase.

To illustrate this concept using pseudocode for a simple example, let's consider integrating a new payment pipeline stage into an existing e-commerce system.
```pseudocode
function processPayment(userSession) {
    // Existing logic to handle user session
    
    // New superimposed structure: Payment Stage
    if (userSession.paymentStage != "payment") {
        // Logic for handling the order preparation and checkout stages
        ...
        
        // Transitioning to payment stage
        userSession.paymentStage = "payment";
        
        // Payment processing logic
        processPaymentDetails(userSession);
    }
    
    // Continue with existing flow if not in payment stage
    ...
}
```
x??

---
#### Mental Model for Legacy Systems
Background context explaining the concept. When dealing with legacy systems, it is crucial to create a mental model of how you want the system to function, as opposed to how it currently functions. This model can be a description of the system as it should have been built in hindsight.

Creating this mental model helps guide changes and improvements while making sense of the current state.
:p How does one create a mental model for working with legacy systems?
??x
One creates a mental model by reading code, interviewing older developers, and fixing bugs to better understand the behavior of the legacy application. This process involves creating a clear structure in your head that you project over the existing application.

For example, if you are integrating a new feature, you might start with a high-level flowchart or diagram representing how you want the system to work.
```pseudocode
// Example mental model for integrating a new payment stage
function integratePaymentStage(userSession) {
    // Define stages of user journey
    const stages = ["catalog", "shoppingCart", "orderPreparation", "payment"];
    
    // Determine current stage based on userSession data
    const currentStage = getCurrentStage(userSession);
    
    if (currentStage === "payment") {
        processPayment(userSession);
    } else {
        navigateUserThroughStages(userSession, stages.slice(stages.indexOf(currentStage) + 1));
    }
}
```
x??

---
#### Business Pipeline Model
Background context explaining the concept. The business pipeline model views a system as a series of stages in the order they occur during typical user interaction, similar to a sales funnel. This model helps understand how users navigate through different parts of the application.

The key insight is that volume decreases significantly at each stage, providing a useful perspective for technical and operational design.
:p What is the business pipeline model and why is it important?
??x
The business pipeline model is an approach that views the system as a series of stages corresponding to user interaction. It helps in designing each part of the process from both a technical standpoint and operationally.

For instance, consider the following pseudocode:
```pseudocode
function handleUserJourney(userSession) {
    const stages = ["catalog", "shoppingCart", "orderPreparation", "payment"];
    
    for (const stage of stages) {
        switch (stage) {
            case "catalog":
                showCatalog(userSession);
                break;
            case "shoppingCart":
                addItemsToCart(userSession);
                break;
            case "orderPreparation":
                prepareOrder(userSession);
                break;
            case "payment":
                processPayment(userSession);
                break;
        }
    }
}
```
x??

---

---

---
#### External Annotations
Background context: In situations where touching a fragile system to add documentation is risky or not allowed, external annotations can be used. These are stored outside the source code and can still provide valuable information.

:p How do external annotations help when modifying large codebases?
??x
External annotations help by allowing you to document changes without directly altering the codebase, thereby reducing the risk of introducing regressions or breaking existing functionality. This approach is useful when your team is not allowed to change production code just for documentation purposes.
??

---
#### Biodegradable Transformation Documentation
Background context: When dealing with legacy systems that require transformation from one state to another over a long period, it's essential to document these changes effectively. The transformation may never reach its intended end state but still needs to be communicated and understood by various teams.

:p What is the purpose of biodegradable transformation documentation?
??x
The purpose of biodegradable transformation documentation is to capture and communicate the temporary processes involved in transforming a legacy system over time, ensuring that all relevant teams are informed about ongoing changes. This type of documentation should eventually become obsolete as the transformation process completes.
??

---
#### Handling Package Renames with External Annotations
Background context: If you need to maintain external annotations for package names or other internal elements in your codebase, renaming a package can lead to inconsistencies between the code and the external documentation.

:p What issue arises when renaming packages in a legacy system while using external annotations?
??x
When renaming packages in a legacy system with external annotations, the associated external documentation must also be updated to reflect these changes. Failing to do so will result in discrepancies between the annotated package names and their actual names in the codebase, potentially leading to errors or misunderstandings.
??

---
#### Using Annotations for Legacy Documentation
Background context: In cases where touching the source code is not an option, annotations can still be used as a means of external documentation. Tools can parse these annotations and utilize them similarly to internal ones.

:p How can you use annotations in external documents to achieve similar functionality as internal annotations?
??x
You can create external documents that map package names or other elements to specific tags, which tools can then parse. This way, the system can use this external documentation as if it were embedded within the code itself. For example:

```text
1  acme.phenix.core = DomainModel FleetManagement
2  acme.phenix.allocation = DomainModel Dispatching
3  acme.phenix.spring = Infrastructure Dispatching
```

Tools can then read this file and apply the same logic used for internal annotations.
??

---

---

#### Strangler Application Strategy
Background context: The strangler application strategy is used when building a new application to replace an older one over time. It involves creating a bubble context that exists temporarily and replaces parts of the old system gradually. This approach allows for incremental changes, reducing risk.

:p What is the purpose of the strangler application strategy?
??x
The primary purpose of the strangler application strategy is to incrementally replace an older application with a new one by using a temporary bubble context that integrates with the existing system. This helps manage complexity and reduce risks associated with large-scale replacements.
x??

---

#### Strangled By Annotation
Background context: When implementing a strangler application, it's important to annotate both the new and old applications appropriately. The `@StrangledBy` annotation is used on the older application to indicate that it will be replaced by a new one.

:p How do you mark an application as being strangled by another?
??x
You use the `@StrangledBy("new bubble context application")` annotation on the old application to indicate that it will eventually be replaced by the new strangler application. This helps developers understand which parts of the system are in transition.
x??

---

#### Bankruptcy Annotation
Background context: For applications that are too fragile for changes, they can be marked as "bankrupt" to prevent further modifications. This is especially useful when integrating a new application with an old one.

:p How do you mark an application as bankrupt?
??x
You can mark an application as bankrupt using various methods such as:
- Adding annotations on the package or in the `AssemblyConfig` file.
- Creating a `BANKRUPTCY.txt` file to explain what needs to be done and avoided.
- Removing commit privileges from developers.
- Monitoring commits and raising alerts for changes in a bankrupt application.

For example, you might use an annotation like:
```java
@Deprecated("Strangled by Butterfly")
```
x??

---

#### Maxims for Legacy Systems
Background context: In large legacy system transformations, it's crucial to share key decisions and visions with the team. Maxims are used to communicate these critical pieces of information effectively.

:p What is a maxim in the context of legacy systems?
??x
A maxim in the context of legacy systems is a concise statement that captures a fundamental principle or decision relevant to the project. It helps ensure everyone shares the same vision and objectives throughout the transformation process.
x??

---

#### Enforced Legacy Rules
Background context: To maintain consistency and enforce design decisions, you can create enforced legacy rules. These are custom design rules that are automatically checked at runtime.

:p How do you enforce a design decision in a legacy system?
??x
You enforce a design decision by:
1. Capturing the stack trace to identify who is calling a deprecated method.
2. Checking if any caller in the stack trace belongs to an allowed list of methods.
3. Logging failures for specific follow-up actions.

For example, you might use Java's `assert` statement or other runtime checks:
```java
public class Enforcer {
    public void enforceRule() {
        try {
            // Code that could be called by deprecated methods
        } catch (Exception e) {
            String stackTrace = Arrays.toString(e.getStackTrace());
            if (!isAllowedCaller(stackTrace)) {
                throw new RuntimeException("Not allowed to call this method.");
            }
        }
    }

    private boolean isAllowedCaller(String stackTrace) {
        // Logic to check if the caller is in the allowed list
        return false;
    }
}
```
x??

---

---

#### Focusing on Differences
Background context explaining the concept. When describing a specific thing, such as a dog, we focus on its differences from a generic category, like a mammal. If the generic category is well-known or well-described before introducing the specific item, it's more efficient to describe only the significant differences.

The important concept here is **salience**, defined as "a striking point or feature." Our objective is to highlight and convey these salient points efficiently without overwhelming the reader with unnecessary details.
:p How does focusing on differences help in documentation?
??x
Focusing on differences helps by reducing the amount of information needed to describe a specific item. By highlighting only what makes it unique, we can make the document more concise and easier to understand. This approach is particularly useful when dealing with complex systems or technologies where the generic aspects are already well-known.

For example, if documenting a dog breed, you would focus on traits that distinguish it from other breeds rather than listing all mammal characteristics.
x??

---
#### Salience in Documentation
The concept of **salience** refers to striking points or features that make information more noticeable and memorable. In the context of documentation, salience helps by focusing on what is most important or unique about a subject.

The objective is to identify and emphasize these key aspects rather than overwhelming the reader with all available information.
:p What does the term "salience" mean in the context of documentation?
??x
In the context of documentation, **salience** means highlighting striking points or features that make certain pieces of information more noticeable and memorable. By focusing on salient points, we ensure that critical information stands out and is easily recalled by readers.

For instance, when documenting a software feature, you would focus on the unique functionalities that set it apart from other similar features.
x??

---
#### Documentation Efficiency Techniques
This section discusses techniques to make documentation more effective by reducing redundancy and making key information more noticeable. By focusing on differences and emphasizing salient points, we can reduce the cognitive load on readers and ensure they grasp the essential details quickly.

Techniques include:
- Focusing on what is different or unique (differences from a generic category).
- Highlighting striking points or features.
:p How do techniques like focusing on differences improve documentation?
??x
Techniques like focusing on differences improve documentation by making it more efficient and easier to understand. By concentrating on what is unique or distinctive, we reduce the amount of redundant information, which helps readers process and retain key details more effectively.

For example, in a software manual, you might focus on how a particular feature works differently from similar features rather than detailing all common functionalities.
x??

---

---

#### Continuous Delivery
Background context explaining continuous delivery and its importance in software development. Continuous delivery is a method of software development where changes are made small, frequent, and incremental to ensure that new features can be integrated into the codebase without disrupting existing functionality.

:p What is continuous delivery?
??x
Continuous delivery involves making small, frequent, and incremental changes to the codebase, ensuring that every change can be easily deployed. This process helps in maintaining stability and reducing the risk of deployment failures.
x??

---

#### Continuous Documentation
Background context on how continuous documentation is integral to keeping documentation up-to-date with minimal effort.

:p What is continuous documentation?
??x
Continuous documentation involves updating documentation as changes are made to the codebase, ensuring that the documentation remains relevant and useful without requiring extensive manual updates. This can be achieved through automated tools or by embedding documentation directly into the source code.
x??

---

#### Continuous Training
Background context on the importance of ongoing learning in a development environment.

:p What is continuous training?
??x
Continuous training refers to the process of continuously improving knowledge and skills within an organization, ensuring that team members are up-to-date with new technologies and methodologies. This can involve workshops, seminars, or self-paced learning resources.
x??

---

#### Contracts
Background context on published contracts and their role in defining expectations.

:p What are published contracts?
??x
Published contracts define the expected behavior of code or systems, providing clear documentation that stakeholders can refer to. These contracts help ensure consistency and adherence to agreed-upon specifications across different teams or projects.
x??

---

#### Conventions
Background context on adhering to conventions in software development.

:p What are conventions in coding?
??x
Conventions in coding refer to established practices or guidelines that are followed consistently throughout a codebase. These conventions help maintain readability, consistency, and ease of maintenance by defining how certain elements should be implemented.
x??

---

#### Conversations
Background context on the role of conversations in knowledge sharing and documentation.

:p What is the importance of conversations?
??x
Conversations play a crucial role in knowledge sharing and documentation by facilitating discussions among team members. They help ensure that everyone has a common understanding, provide opportunities for knowledge consolidation, and can lead to the creation of living documentation.
x??

---

#### Custom Annotations
Background context on custom annotations and their uses.

:p What are custom annotations?
??x
Custom annotations are user-defined tags or metadata added to code elements to provide additional information. These annotations can be used to extend standard functionality, apply specific rules, or generate documentation automatically.
x??

---

#### CVS (Concurrent Versions System)
Background context on the purpose and usage of CVS.

:p What is CVS?
??x
CVS (Concurrent Versions System) is a version control system that allows multiple developers to work on the same codebase simultaneously. It helps manage changes, track history, and resolve conflicts.
x??

---

#### D3.js
Background context on D3.js and its use in visualizing data.

:p What is D3.js?
??x
D3.js (Data-Driven Documents) is a JavaScript library for producing dynamic, interactive data visualizations in web browsers. It allows developers to bind arbitrary data to a Document Object Model (DOM), and then apply data-driven transformations to the document.
x??

---

#### Dependency Injection Containers
Background context on dependency injection containers.

:p What are DI containers?
??x
Dependency Injection (DI) containers manage the creation, configuration, and lifecycle of objects in an application. They help separate concerns by decoupling components from their dependencies, making the code more modular and testable.
x??

---

#### DDD (Domain-Driven Design)
Background context on DDD and its relevance to software development.

:p What is Domain-Driven Design?
??x
Domain-Driven Design (DDD) is a software development approach that emphasizes collaboration between business experts and developers. It focuses on understanding the domain model, building rich domain objects, and ensuring that the system accurately represents the real-world domain.
x??

---

#### Decisions Logs
Background context on decision logs and their use in documenting design decisions.

:p What are decision logs?
??x
Decision logs document significant design decisions throughout a project's lifecycle. They help capture the rationale behind certain choices, provide visibility into the development process, and aid in knowledge transfer among team members.
x??

---

#### Declarative Automation
Background context on declarative automation and its benefits.

:p What is declarative automation?
??x
Declarative automation involves specifying what outcomes should be achieved rather than how to achieve them. This approach allows for more flexible and reusable automation scripts that are easier to maintain and update.
x??

---

#### Dependency Management
Background context on managing dependencies in a project.

:p What is dependency management?
??x
Dependency management involves tracking, resolving, and updating external libraries or modules used by a project. It ensures that the correct versions of these dependencies are available at build time and runtime.
x??

---

#### Diagrams
Background context on diagrams and their uses in documentation.

:p What role do diagrams play in documentation?
??x
Diagrams serve as visual representations of complex information, making it easier to understand relationships between different elements. They can be used for architectural overviews, process flows, or any other aspect that benefits from a visual representation.
x??

---

#### Domain-Driven Design (DDD)
Background context on DDD and its relevance in software development.

:p What is Domain-Driven Design?
??x
Domain-Driven Design (DDD) is an approach to software design that focuses on aligning the technical solution with the business domain. It involves deep understanding of the problem space, modeling core domain concepts, and ensuring that these models are reflected in the code.
x??

---

#### Dependency Injection Containers
Background context on DI containers.

:p What are DI containers?
??x
DI containers manage dependencies for objects within an application. They help separate concerns by making objects more modular and testable, as they can be easily configured and replaced without changing the object itself.
x??

---

#### Design Documentation
Background context on design documentation and its differences from conventional design.

:p What is design documentation?
??x
Design documentation provides a detailed description of how an application or system should work. It differs from coding patterns by focusing on architectural decisions, flow diagrams, and high-level designs rather than the implementation details.
x??

---

#### Domain-Driven Design (DDD)
Background context on DDD.

:p What is Domain-Driven Design?
??x
Domain-Driven Design (DDD) is a software development approach that emphasizes close collaboration between domain experts and developers to create software models that accurately reflect the business domain. It focuses on rich domain models, ubiquitous language, and context mapping.
x??

---

#### Dependency Injection Containers
Background context on DI containers.

:p What are DI containers?
??x
DI containers help manage dependencies in applications by providing a central repository for object creation and configuration. They reduce coupling between components and make the code more testable and maintainable.
x??

---

#### Dependency Management
Background context on dependency management.

:p What is dependency management?
??x
Dependency management involves managing external libraries or modules used by a project, including versioning, conflict resolution, and ensuring that the correct dependencies are available at build time and runtime.
x??

---

---

