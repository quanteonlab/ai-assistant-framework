# Flashcards: Pro-ASPNET-Core-7_processed (Part 105)

**Starting Chapter:** 19.2 Understanding RESTful web services

---

#### Resetting the Database
Background context: The chapter discusses how to reset a database in an ASP.NET Core project using Entity Framework (EF) tools. This is essential for starting with a clean slate or when changes are made to the schema that require data to be reseeded.

:p How do you reset the database in an ASP.NET Core project using EF?
??x
To reset the database, you first need to drop it and then recreate it. The commands provided use `dotnet ef` for this purpose. Here's how:

```sh
# Drop the database
dotnet ef database drop --force

# Recreate the database with initial data (from listing 18.13)
```

The `-force` flag is used to bypass any potential errors and ensure that the database is dropped completely.

x??

---

#### Adding the CSS Framework
Background context: The chapter explains how to add a CSS framework, specifically Bootstrap, which will be used for styling the HTML responses generated by the application. This involves using the LibMan package manager to install Bootstrap.

:p How do you add and manage CSS frameworks in an ASP.NET Core project?
??x
To add and manage CSS frameworks like Bootstrap, you use the LibMan tool, which is a package manager that can be installed globally via `dotnet tool`.

1. First, uninstall any existing version of the LibMan tool:
   ```sh
   dotnet tool uninstall --global Microsoft.Web.LibraryManager.Cli
   ```

2. Then install the specific version used in this book (version 2.1.175):
   ```sh
   dotnet tool install --global Microsoft.Web.LibraryManager.Cli --version 2.1.175
   ```

3. Initialize LibMan in your project and then add Bootstrap:
   ```sh
   libman init -p cdnjs
   libman install bootstrap@5.2.3 -d wwwroot/lib/bootstrap
   ```

These commands set up LibMan, initialize it for the project using CDNs (Content Delivery Networks), and install Bootstrap 5.2.3 in the `wwwroot/lib` directory.

x??

---

#### Configuring the Request Pipeline
Background context: The chapter introduces creating a middleware component to ensure that the application has been properly configured. Middleware components are used to intercept requests before they reach the controller, allowing for custom processing or checks.

:p How do you add and configure middleware in an ASP.NET Core project?
??x
To add and configure middleware in your ASP.NET Core project:

1. Create a class file `TestMiddleware.cs` under the `WebApp` folder.
2. Define the middleware logic:
   ```csharp
   using WebApp.Models;
   namespace WebApp {
       public class TestMiddleware {
           private RequestDelegate nextDelegate;

           public TestMiddleware(RequestDelegate next) {
               nextDelegate = next;
           }

           public async Task Invoke(HttpContext context, DataContext dataContext) {
               if (context.Request.Path == "/test") {
                   await context.Response.WriteAsync($"There are " +$"{dataContext.Products.Count()} products" +$"There are " +$"{dataContext.Categories.Count()} categories" +$"There are " +$"{dataContext.Suppliers.Count()} suppliers");
               } else {
                   await nextDelegate(context);
               }
           }
       }
   }
   ```

3. Add the middleware to the request pipeline in `Program.cs`:
   ```csharp
   using Microsoft.EntityFrameworkCore;
   using WebApp.Models;

   var builder = WebApplication.CreateBuilder(args);

   // Configuration and services setup

   var app = builder.Build();

   app.UseMiddleware<TestMiddleware>();

   // Other configurations like routing, database context creation, etc.

   app.Run();
   ```

This middleware checks if the request path is `/test` and writes some information about the data context to the response. Otherwise, it passes the request to the next delegate in the pipeline.

x??

---

---
#### Dropping the Database
Background context: The example project for this chapter and others can be downloaded from a GitHub repository. This is important for developers to follow along with examples provided.

:p How do you drop the database using Entity Framework Core?
??x
You use the `dotnet ef database drop --force` command within the project folder to drop the database.
```bash
dotnet ef database drop --force
```
x?

---

---
#### Starting the Example Application
Background context: The application is started by running the `dotnet run` command in the project directory. This step initializes the application and allows you to test it locally.

:p How do you start the example application?
??x
You start the example application using the following command:
```bash
dotnet run
```
x?

---

---
#### Requesting a URL to See Application Response
Background context: Once the application is running, you can request a specific URL (e.g., `http://localhost:5000/test`) to see the response. This step helps verify that the application is functioning as expected.

:p How do you test the example application by requesting a URL?
??x
You can test the example application by navigating to the URL in your browser or using a tool like curl:
```bash
http://localhost:5000/test
```
x?

---

---
#### Understanding RESTful Web Services
Background context: REST (Representational State Transfer) is a common approach for creating web services. It uses URLs and HTTP methods to define the API. There are no strict rules, but some conventions exist.

:p What is REST in terms of web services?
??x
REST is an architectural style for designing networked applications that use a simple stateless, client–server, cacheable communications protocol (typically HTTP). It defines APIs through URLs and HTTP methods like GET, POST, PUT, PATCH, DELETE.
x?

---

---
#### Understanding Request URLs and Methods
Background context: RESTful services typically use URLs to identify resources and HTTP methods to specify actions. Here are common HTTP methods with their typical operations.

:p What do the HTTP methods represent in a RESTful web service?
??x
HTTP methods like GET, POST, PUT, PATCH, DELETE represent different actions that can be performed on the identified resource through the URL.
- **GET**: Retrieve one or more data objects.
- **POST**: Create a new object.
- **PUT**: Update an existing object.
- **PATCH**: Update part of an existing object.
- **DELETE**: Delete an object.

For example, `/api/products/1` might identify a specific product with the ID `1`, and the method would specify what to do with that resource.
x?

---

---
#### Understanding JSON
Background context: Most RESTful web services use JSON (JavaScript Object Notation) for data formatting. It's simple and easily consumed by JavaScript clients.

:p What is JSON used for in RESTful web services?
??x
JSON is used in RESTful web services to format the response data, making it easy to consume by JavaScript clients.
```json
{
  "name": "Product",
  "price": 19.99,
  "category": "Electronics"
}
```
x?

---

---
#### Creating a Web Service Using Minimal API
Background context: The minimal API approach in ASP.NET Core can be used to create simple web services by defining routes and handling HTTP methods.

:p How do you create a basic RESTful web service using the minimal API?
??x
You define endpoints using `app.MapGet` and `app.MapPost` to handle GET and POST requests. Here's an example:
```csharp
app.MapGet("/api/products/{id}", async (HttpContext context, DataContext data) => {
    // Get product by ID
});
app.MapGet("/api/products", async (HttpContext context, DataContext data) => {
    // Get all products
});
app.MapPost("/api/products", async (HttpContext context, DataContext data) => {
    // Add a new product
});
```
x?

---

---
#### Testing the Web Service
Background context: After creating the web service, you can test it by making HTTP requests to specific URLs. The provided code handles GET and POST requests for products.

:p How do you test the web service with specific HTTP methods?
??x
You can use different tools or browser extensions to send HTTP requests:
- For `GET /api/products/1`: Use a tool like curl.
- For `POST /api/products`: You might need to use Postman or another API client.

Example using curl:
```bash
curl -X GET "http://localhost:5000/api/products/1"
```
x?

---

---
#### Alternative Web Service Design Patterns (GraphQL, gRPC)
Background context: While REST is a common pattern, other alternatives like GraphQL and gRPC exist. These provide different ways to query data.

:p What are some alternative web service design patterns mentioned in the text?
??x
The text mentions:
- **GraphQL**: Provides access to all application data and lets clients query for specific data.
- **gRPC**: A remote procedure call framework focused on speed and efficiency, not supported directly by ASP.NET Core but has .NET implementations available.

These provide more flexibility compared to REST in certain scenarios.
x?

---

#### Sending a POST Request Using `Invoke-RestMethod`
Background context: In this section, you learn how to send a JSON-formatted HTTP POST request using PowerShell's `Invoke-RestMethod` command. The example demonstrates creating and storing new data through a web service endpoint that processes the request.

:p What is the purpose of sending an HTTP POST request in this context?
??x
The purpose of sending an HTTP POST request is to create a new product entry in the database by sending a JSON object with relevant properties (Name, Price, CategoryId, SupplierId) through the web service endpoint.
```powershell
Invoke-RestMethod http://localhost:5000/api/products -Method POST -Body @{
    Name = "Swimming Goggles";
    Price = 12.75;
    CategoryId = 1;
    SupplierId = 1
} | ConvertTo-Json -ContentType "application/json"
```
x??

---

#### Using a Controller for Web Services
Background context: The section discusses the drawbacks of using individual endpoints to create web services, such as repeated code and maintenance issues. Controllers are introduced as a more elegant solution that allows defining a web service in a single class.

:p What is the primary benefit of using controllers over individual endpoints when creating web services?
??x
The primary benefit of using controllers is that they reduce redundancy by handling common tasks like data serialization, content type management, and database access within a centralized class. This makes the code more maintainable and easier to understand.
x??

---

#### Enabling the MVC Framework for Web Services
Background context: The text explains how to configure the ASP.NET Core MVC framework in order to create web services using controllers instead of individual endpoints.

:p What are the two main components needed to enable the MVC framework when creating a web service?
??x
The two main components needed to enable the MVC framework are a service and an endpoint. These components work together to handle HTTP requests, manage data models, and generate responses.
x??

---

#### The Rise and Fall of the MVC Pattern in ASP.NET Core
Background context: This section delves into the history and evolution of the Model-View-Controller (MVC) pattern within ASP.NET Core, explaining its importance but also noting that other patterns are now commonly used.

:p What were some key reasons for the decline of the exclusive use of MVC in ASP.NET Core development?
??x
Key reasons for the decline of the exclusive use of MVC in ASP.NET Core development include the rise of alternative web application styles like Razor Pages and Blazor, which provide more flexibility and different approaches to building web applications. Additionally, while MVC is still valuable, understanding it is no longer a strict prerequisite for effective ASP.NET Core development.
x??

---

#### Creating a Web Service Using a Controller
Background context: The text provides an example of how to create a web service using a controller in a single class, replacing the need for multiple individual endpoints.

:p How does using controllers help simplify and improve web services created with ASP.NET Core?
??x
Using controllers simplifies and improves web services by centralizing common tasks such as database interactions, response content management, and data serialization. This reduces redundancy and makes the codebase more maintainable and easier to understand.
x??

---

#### The Role of MVC in Modern ASP.NET Core Development
Background context: The text discusses how the importance of MVC has evolved in modern development practices within ASP.NET Core, highlighting its current status as one among several viable approaches.

:p How does understanding the MVC pattern remain relevant today in an ASP.NET Core context?
??x
Understanding the MVC pattern remains relevant because it provides a structured approach to web application development that is still widely used and understood. It helps developers grasp key concepts of model management, request handling, and response generation, which are crucial for building scalable applications.
x??

---

#### Enabling the MVC Framework in Program.cs
Background context: The provided code snippet is from a `Program.cs` file in an ASP.NET Core application, setting up and enabling the Model-View-Controller (MVC) framework. It configures services like database contexts and controllers for handling HTTP requests.

:p How does the `AddControllers` method enable MVC functionality?
??x
The `AddControllers` method registers the MVC services required to process incoming HTTP requests and return responses, effectively enabling the use of controllers in your application.
```csharp
builder.Services.AddControllers();
```
x??

---

#### Configuring DbContext for Data Access
Background context: The code snippet configures a database context using Entity Framework Core. It sets up the connection string and enables logging sensitive data.

:p How is the `AddDbContext` method used to configure the database context?
??x
The `AddDbContext` method is used to add a service that represents the database context, configuring it with a specific SQL Server connection string.
```csharp
builder.Services.AddDbContext<DataContext>(opts => {
    opts.UseSqlServer(builder.Configuration["ConnectionStrings:ProductConnection"]);
    opts.EnableSensitiveDataLogging(true);
});
```
x??

---

#### Mapping Controllers and Defining Routes
Background context: The `MapControllers` method is used to define the routes that will allow controllers to handle incoming HTTP requests. Additionally, a simple route for the root URL is defined.

:p How does the `MapControllers` method function in an ASP.NET Core application?
??x
The `MapControllers` method sets up routes that map to controller actions based on their names and conventions.
```csharp
app.MapControllers();
```
x??

---

#### Creating a ProductsController Class
Background context: The provided code snippet demonstrates the creation of a simple `ProductsController` class, which processes HTTP GET requests.

:p What is the purpose of creating a `ProductsController` class in an ASP.NET Core application?
??x
The purpose of creating a `ProductsController` class is to define actions that can handle HTTP requests and return responses. In this case, it provides methods to get product data.
```csharp
using Microsoft.AspNetCore.Mvc;
using WebApp.Models;

namespace WebApp.Controllers {
    [Route("api/[controller]")]
    public class ProductsController : ControllerBase {
        [HttpGet]
        public IEnumerable<Product> GetProducts() { 
            return new Product[] { 
                new Product() { Name = "Product #1" }, 
                new Product() { Name = "Product #2" } 
            }; 
        }

        [HttpGet("{id}")]
        public Product GetProduct() {
            return new Product() {
                ProductId = 1, 
                Name = "Test Product"
            };
        }
    }
}
```
x??

---

#### Understanding the ControllerBase Class
Background context: The `ControllerBase` class is a base class for controllers in ASP.NET Core, providing access to features of the MVC framework and underlying platform.

:p What does the `ControllerBase` class provide?
??x
The `ControllerBase` class provides a base implementation for controllers in ASP.NET Core, offering methods and properties that enable interaction with the MVC framework and ASP.NET Core services.
```csharp
public class ProductsController : ControllerBase {
    // controller actions here
}
```
x??

---

---

#### NonController Attribute Usage

Background context: The `NonController` attribute is used to apply to classes that should not receive HTTP requests, ensuring they do not inadvertently handle web requests. This is useful for utility classes or services.

:p What does the `NonController` attribute do?
??x
The `NonController` attribute prevents a class from being considered a controller and thus unable to process HTTP requests. Classes with this attribute can still be used for business logic, services, or other non-web-related purposes.
x??

---

#### Useful ControllerBase Properties

Background context: The `BaseController` class in ASP.NET Core provides several useful properties that describe the current request and its context.

:p What are some of the key properties provided by the `BaseController` class?
??x
The `BaseController` class offers these key properties:
- `HttpContext`: Returns the HttpContext object for the current request.
- `ModelState`: Provides details about data validation, useful in data processing scenarios.
- `Request`: Returns the HttpRequest object for the current request.
- `Response`: Returns the HttpResponse object for the current response.
- `RouteData`: Contains data extracted from the request URL by the routing middleware.
- `User`: Describes the user associated with the current request.

For example:
```csharp
public class ProductsController : ControllerBase
{
    public IActionResult GetProducts()
    {
        var context = HttpContext; // Access HttpContext
        var request = Request; // Access HttpRequest
        var response = Response; // Access HttpResponse
        return Ok(); // Return a successful response
    }
}
```
x??

---

#### Route Attribute in Controllers

Background context: The `Route` attribute is used to define the URL pattern for a controller. It is applied at the class level.

:p How does the `Route` attribute work with controllers?
??x
The `Route` attribute defines the URL path for a controller based on its name. The `[controller]` part of the attribute value is replaced by the actual name of the controller class. For example:
```csharp
[Route("api/[controller]")]
public class ProductsController : ControllerBase { ... }
```
This sets the URL to `/api/products`. The `Route` attribute is crucial for mapping actions within the controller.

For more detail, consider this example:
```csharp
[Route("api/[controller]")]
public class OrdersController : ControllerBase { ... }
```
Here, the URL would be mapped as `/api/orders`.

x??

---

#### HTTP Method Attributes

Background context: The `HttpGet`, `HttpPost`, `HttpDelete`, `HttpPut`, and other attributes are used to specify which HTTP methods a controller action supports.

:p What do the HTTP method attributes do in ASP.NET Core controllers?
??x
The HTTP method attributes determine which types of HTTP requests can be handled by actions within a controller. For example:
- `[HttpGet]` specifies that an action should only handle GET requests.
- `[HttpPost]` specifies that an action should only handle POST requests.

These attributes are crucial for defining the behavior and endpoint mapping in web services.

For instance, to define a method that handles GET requests:
```csharp
[HttpGet]
public Product[] GetProducts()
{
    // Action logic here
}
```
x??

---

---
#### HTTP Method and URL Patterns in MVC
Background context explaining how HTTP methods and URL patterns are mapped to action methods in ASP.NET Core MVC. The attributes on controller actions determine which URLs the server responds to.

:p What is an example of an attribute used to handle GET requests for a specific URL pattern?
??x
The `HttpGet` attribute applied to the `GetProduct` action method:
```csharp
[HttpGet("{id}")]
public Product GetProduct()
{
    // Implementation here
}
```
This attribute tells MVC that this action handles GET requests for URLs in the form of `api/products/{id}`. The `{id}` part is a placeholder that can be filled with specific values during runtime.
x??
---

---
#### Importance of Mapping Each HTTP Method and URL Pattern to One Action Method
Background context explaining the importance of ensuring each combination of HTTP method and URL pattern maps to only one action method in a controller.

:p Why should each combination of HTTP method and URL pattern map to only one action method in a controller?
??x
To ensure that the MVC framework can determine which action method to invoke when a request is received. Mapping multiple actions to the same method could lead to ambiguity, as the framework would not know which method to use.
x??
---

---
#### GET vs POST Requests
Background context explaining the differences between GET and POST requests in terms of safety, side effects, and state changes.

:p What are the rules for using GET and POST requests according to standards conventions?
??x
GET requests should be used for all read-only information retrieval. POST requests should be used for any operation that changes the application state. GET requests are considered safe (no side effects besides information retrieval), while POST requests are considered unsafe (making a decision or changing something).
x??
---

---
#### Action Method Results and MVC Framework
Background context explaining how the MVC framework handles action method results, taking care of setting response headers and serializing data objects.

:p How does the MVC framework handle the serialization of objects from action methods?
??x
The MVC framework automatically processes the object returned by the action method, setting appropriate response headers and handling JSON serialization. For example:
```csharp
[HttpGet("{id}")]
public Product GetProduct()
{
    // Implementation here
}
```
When this `GetProduct` method is called, the MVC framework will serialize the `Product` object into a JSON format and set the appropriate content-type header.
x??
---

---
#### Dependency Injection in Controllers
Dependency injection is a design pattern where objects depend on, or "inject," other objects to use instead of creating and managing these dependencies themselves. This makes the code more modular and testable.

In this context, the controller receives its dependencies through its constructor, which allows for better separation of concerns and easier testing by mocking dependencies.
:p How are dependencies managed in controllers using dependency injection?
??x
Dependencies are injected into the controller via the constructor. The framework automatically resolves these dependencies at runtime based on the application's service registration.

For example:
```csharp
public class ProductsController : ControllerBase {
    private DataContext context;
    
    public ProductsController(DataContext ctx) {
        context = ctx;
    }
}
```
In this case, `DataContext` is injected into the controller to provide access to the application’s data. The constructor ensures that a new instance of `DataContext` is created for each controller.
x??
---
#### Service Resolution in Controller Actions
Controller actions can also declare dependencies through their parameters. These dependencies must be decorated with the `[FromServices]` attribute to explicitly indicate that they should be resolved by the dependency injection framework.

This approach allows for flexibility, as some action methods might have different dependencies than others.
:p How do you declare and resolve dependencies in controller actions?
??x
Dependencies in controller actions are declared through their parameters. To ensure these dependencies are resolved via dependency injection, the `[FromServices]` attribute is used. For example:

```csharp
[HttpGet("{id}")]
public Product? GetProduct([FromServices] ILogger<ProductsController> logger) {
    logger.LogInformation("GetProduct Action Invoked");
    return context.Products.OrderBy(p => p.ProductId).FirstOrDefault();
}
```
Here, the `ILogger<ProductsController>` dependency is declared in the action method. The `[FromServices]` attribute tells ASP.NET Core to resolve this dependency using its service provider.

This approach allows individual actions to declare their own dependencies without affecting others.
x??
---
#### Entity Framework Core Context Lifecycle
Entity Framework Core (EF Core) manages the lifecycle of `DbContext` instances for you, creating a new context each time a controller is instantiated. Relying on this managed behavior ensures that queries are isolated and do not affect one another.

Reusing context objects across different requests can lead to unexpected side effects because EF Core tracks changes made within the same context instance.
:p What is the recommended lifecycle of `DbContext` instances in ASP.NET Core?
??x
EF Core manages the lifecycle of `DbContext` instances by creating a new context each time a controller handles a request. This approach ensures that each context operates independently, avoiding potential issues like tracking changes across unrelated queries.

For example:
```csharp
public class ProductsController : ControllerBase {
    private DataContext context;
    
    public ProductsController(DataContext ctx) {
        context = ctx;
    }
    
    [HttpGet]
    public IEnumerable<Product> GetProducts() {
        return context.Products;
    }
}
```
Here, a new `DataContext` instance is created each time the controller handles a request.

Avoid attempts to reuse context objects between requests or across different controllers. Instead, allow EF Core to manage the context lifecycle for you.
x??
---
#### Logging in Controllers
Logging can be enabled in controllers by injecting an `ILogger<T>` service into their constructor. The `[FromServices]` attribute is used to explicitly indicate that this dependency should be resolved through dependency injection.

This approach ensures that logging functionality is consistently available throughout the application.
:p How do you integrate logging into controller actions using dependency injection?
??x
To integrate logging into controller actions, you can inject an `ILogger<T>` service via the action method's parameters. The `[FromServices]` attribute must be used to indicate that this dependency should be resolved through the service provider.

For example:
```csharp
[HttpGet("{id}")]
public Product? GetProduct([FromServices] ILogger<ProductsController> logger) {
    logger.LogInformation("GetProduct Action Invoked");
    return context.Products.OrderBy(p => p.ProductId).FirstOrDefault();
}
```
In this case, `ILogger<ProductsController>` is injected into the action method to log information. The `[FromServices]` attribute tells ASP.NET Core to resolve this dependency using its service provider.

This ensures that logging messages are properly formatted and logged, making it easier to track actions performed by users or administrators.
x??
---

---
#### Controller Lifecycle and Action Methods
Controllers in ASP.NET Core follow a lifecycle where each controller object handles one request, and only one action method is invoked by the MVC Framework for each object. This means that actions cannot rely on side effects from methods called in a specific sequence as they are not guaranteed to be executed.
:p What does the controller lifecycle imply about invoking action methods?
??x
The controller lifecycle implies that every time an HTTP request arrives, a new instance of the controller is created and only one action method within that controller is invoked by the MVC Framework. This ensures that each controller handles one request at a time, preventing side effects from other actions.
```csharp
[HttpGet]
public Product? GetProduct(long id,
    [FromServices] ILogger<ProductsController> logger)
{
    logger.LogDebug("GetProduct Action Invoked");
    return context.Products.Find(id);
}
```
x?
---

---
#### Model Binding Overview
Model binding is a feature in the ASP.NET Core MVC Framework that automatically binds route data to action method parameters based on the request URL. This simplifies accessing and using data from the client's request without manual parsing.
:p How does model binding work with route data?
??x
Model binding works by mapping values from the request URL (route data) directly into the corresponding action method parameters. For example, in the `GetProduct` method, a `long id` parameter is automatically populated with the ID value from the URL path segment.
```csharp
[HttpGet("{id}")]
public Product? GetProduct(long id,
    [FromServices] ILogger<ProductsController> logger)
{
    logger.LogDebug("GetProduct Action Invoked");
    return context.Products.Find(id);
}
```
x?
---

---
#### Model Binding from Request Body
Model binding can also process data sent in the request body, typically used for receiving JSON payloads. This allows clients to send structured data that is easily mapped to action method parameters.
:p How does model binding handle data in the request body?
??x
Model binding handles data in the request body by parsing the content and mapping it to the appropriate action method parameter marked with the `[FromBody]` attribute. In the `SaveProduct` example, a `Product` object is received from the JSON payload sent in the POST request.
```csharp
[HttpPost]
public void SaveProduct([FromBody] Product product)
{
    context.Products.Add(product);
    context.SaveChanges();
}
```
x?
---

---
#### Logging in Controllers
Using logging services like `ILogger<T>` allows for detailed tracking and debugging of actions within controllers. The example shows how to log the invocation of an action method using this service.
:p How can you use logging services in controller actions?
??x
You can use logging services, such as `ILogger<ProductsController>`, to log messages related to your controller actions. In the `GetProduct` action, a debug message is logged when the action is invoked to track its execution.
```csharp
[HttpGet("{id}")]
public Product? GetProduct(long id,
    [FromServices] ILogger<ProductsController> logger)
{
    logger.LogDebug("GetProduct Action Invoked");
    return context.Products.Find(id);
}
```
x?
---

---
#### Using Services in Controllers
Services can be injected into controller actions via the constructor, providing access to functionality that is shared across multiple actions. This promotes code reusability and separation of concerns.
:p How are services used within controller actions?
??x
Services are typically injected through the constructor of a controller class using dependency injection. In the `ProductsController`, the `DataContext` service is passed via the constructor, allowing the controller to interact with the database.
```csharp
public class ProductsController : ControllerBase {
    private DataContext context;
    public ProductsController(DataContext ctx) {
        context = ctx;
    }
}
```
x?
---

---
#### Populating Product Object via MVC Framework
Background context explaining the process of model binding and how it works with POST requests. The example demonstrates creating a `Product` object from request body values and storing it in the database.

:p How does the MVC framework populate a `Product` object when handling a POST request?
??x
The MVC framework uses model binding to parse incoming HTTP request data into an instance of the `Product` class. This involves populating properties like `Name`, `Price`, `CategoryId`, and `SupplierId` with values from the request body. The process can also include data validation, as described in chapter 29.

```csharp
[HttpPost]
public void SaveProduct([FromBody] Product product) {
    context.Products.Add(product);
    context.SaveChanges();
}
```
x??

---
#### Sending POST Request to Create a New Product
Background on using `Invoke-RestMethod` to send an HTTP POST request with JSON content. The example uses PowerShell to create and store a new `Product`.

:p How do you use the `Invoke-RestMethod` command in PowerShell to create a new product?
??x
You can use the `Invoke-RestMethod` command to send a POST request to your API endpoint, passing a JSON object containing the product details. The `-Body`, `-Method`, and `-ContentType` parameters are crucial for this operation.

```powershell
Invoke-RestMethod http://localhost:5000/api/products -Method POST -Body (@{ Name="Soccer Boots"; Price=89.99; CategoryId=2; SupplierId=2} | ConvertTo-Json) -ContentType "application/json"
```
x??

---
#### Storing New Data via Controller Actions
Explanation of adding controller actions to save, update, and delete `Product` objects. The example includes actions for creating new products and updating existing ones.

:p How do you add an action in the `ProductsController` to save a new product?
??x
You can add a `[HttpPost]` action method to the `ProductsController`. This method uses model binding to receive a `Product` object from the request body, adds it to the database context, and saves changes.

```csharp
[HttpPost]
public void SaveProduct([FromBody] Product product) {
    context.Products.Add(product);
    context.SaveChanges();
}
```
x??

---
#### HTTP PUT Method for Updating Products
Explanation of using the `HTTP PUT` method to update a specific product in the database. The example demonstrates sending an updated object via a PUT request.

:p How do you use the `Invoke-RestMethod` command to update a product?
??x
To update a product, you send an HTTP PUT request with a JSON body containing the updated values of the product. This method uses model binding to receive the updated `Product` object and then updates it in the database.

```powershell
Invoke-RestMethod http://localhost:5000/api/products -Method PUT -Body (@{ ProductId=1; Name="Green Kayak"; Price=275; CategoryId=1; SupplierId=1} | ConvertTo-Json) -ContentType "application/json"
```
x??

---
#### HTTP DELETE Method for Deleting Products
Explanation of using the `HTTP DELETE` method to delete a product by its ID. The example shows creating and removing a `Product` object in the controller.

:p How do you add an action in the `ProductsController` to delete a product?
??x
To implement deletion, you can use the `[HttpDelete("{id}")]` attribute with an action method that receives the primary key of the product. You then create and remove a `Product` object using this ID.

```csharp
[HttpDelete("{id}")]
public void DeleteProduct(long id) {
    context.Products.Remove(new Product() { 
        ProductId = id, 
        Name = string.Empty 
    });
    context.SaveChanges();
}
```
x??

---

