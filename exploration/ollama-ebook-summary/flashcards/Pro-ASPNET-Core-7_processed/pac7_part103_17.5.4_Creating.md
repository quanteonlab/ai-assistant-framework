# Flashcards: Pro-ASPNET-Core-7_processed (Part 103)

**Starting Chapter:** 17.5.4 Creating and applying the database migration. 17.5.5 Seeding the database

---

#### Creating Initial Migration
Background context explaining how Entity Framework Core manages database relationships using migrations. Migrations are used to create and update databases based on model changes.

:p How do you create an initial migration that sets up a new database for storing `Calculation` objects?
??x
To create the initial migration, use the following command in a PowerShell window:
```powershell
dotnet ef migrations add Initial
```
This command generates a migration file named `Initial`, which contains code to set up the database schema. The generated files are placed in the `Migrations` folder within your project.

??x
The answer explains the use of the `dotnet ef` command and its purpose.
```powershell
public class InitialMigration : Migration {
    protected override void Up(MigrationBuilder migrationBuilder) {
        // Code to create tables and columns for Calculation objects
    }

    protected override void Down(MigrationBuilder migrationBuilder) {
        // Code to drop tables and columns if needed
    }
}
```
The `Up` method contains the logic to apply changes, while `Down` is used to revert them.

x??

---

#### Applying a Migration
Background context explaining how migrations are applied to update the database schema. The `dotnet ef database update` command executes these migrations.

:p How do you apply a migration to prepare the database for storing `Calculation` objects?
??x
To apply a migration, use the following command in the project folder:
```powershell
dotnet ef database update
```
This command reads the latest migration and applies it to the database. The SQL statements used during this process are displayed in the PowerShell window.

??x
The answer explains the purpose of the `database update` command.
```sql
-- Example of an SQL statement that might be executed
CREATE TABLE Calculations (
    Count INT PRIMARY KEY,
    Result BIGINT NOT NULL
);
```
This example shows a typical SQL statement generated by Entity Framework Core to create a table for storing `Calculation` objects.

x??

---

#### Seeding the Database with SeedData.cs
Background context explaining why seed data is important and how it's typically handled in EF Core. The code example uses a custom class to add initial data to the database, ensuring unique keys are managed by the database.

:p How do you seed the `Calculation` table with predefined data using Entity Framework Core?
??x
You can seed the `Calculation` table using the `SeedData` class defined in `SeedData.cs`. Hereâ€™s how:

1. Define a `SeedData` class that depends on `CalculationContext` and `ILogger<SeedData>`.
2. Implement the `SeedDatabase` method to add initial data.

```csharp
public class SeedData {
    private CalculationContext context;
    private ILogger<SeedData> logger;

    public SeedData(CalculationContext dataContext, ILogger<SeedData> log) {
        context = dataContext;
        logger = log;
    }

    public void SeedDatabase() {
        context.Database.Migrate();
        if (context.Calculations?.Count() == 0) {
            logger.LogInformation("Preparing to seed database");
            var initialData = new Dictionary<int, long>() { 
                {1, 1}, {2, 3}, {3, 6}, {4, 10}, {5, 15},
                {6, 21}, {7, 28}, {8, 36}, {9, 45}, {10, 55}
            };
            context.Calculations.AddRange(
                initialData.Select(kvp => new Calculation() {
                    Count = kvp.Key,
                    Result = kvp.Value
                })
            );
            context.SaveChanges();
            logger.LogInformation("Database seeded");
        } else {
            logger.LogInformation("Database not seeded");
        }
    }
}
```

??x
The `SeedData` class contains a method `SeedDatabase` that seeds the database with predefined data. It uses the `CalculationContext` to interact with the database, ensuring unique keys are handled by SQL.

```csharp
// Example of how to register services and call SeedDatabase
builder.Services.AddDbContext<CalculationContext>(opts => {
    opts.UseSqlServer(builder.Configuration["ConnectionStrings:CalcConnection"]);
});
builder.Services.AddTransient<SeedData>();

var app = builder.Build();
bool cmdLineInit = (app.Configuration["INITDB"] ?? "false") == "true";
if (app.Environment.IsDevelopment() || cmdLineInit) {
    var seedData = app.Services.GetRequiredService<SeedData>();
    seedData.SeedDatabase();
}
```

x??

---

#### Enabling Database Seeding in Program.cs
Background context explaining how to enable database seeding during development and explicitly at runtime.

:p How do you ensure the `Calculation` table is seeded with initial data when running the application?
??x
To ensure the `Calculation` table is seeded, modify the `Program.cs` file as follows:

1. Register the `SeedData` service.
2. Check for a configuration setting to seed the database if in development mode or via command line.

```csharp
var builder = WebApplication.CreateBuilder(args);

// Other configurations...

builder.Services.AddTransient<SeedData>();

var app = builder.Build();
bool cmdLineInit = (app.Configuration["INITDB"] ?? "false") == "true";
if (app.Environment.IsDevelopment() || cmdLineInit) {
    var seedData = app.Services.GetRequiredService<SeedData>();
    seedData.SeedDatabase();
}

// Other configurations...
```

??x
The `Program.cs` file is modified to include the `SeedData` service and check for a configuration setting (`INITDB`) to automatically seed the database during development or when specified via command line.

```csharp
public class Program {
    public static void Main(string[] args) {
        var builder = WebApplication.CreateBuilder(args);

        // Other configurations...

        builder.Services.AddTransient<SeedData>();

        var app = builder.Build();
        bool cmdLineInit = (app.Configuration["INITDB"] ?? "false") == "true";
        if (app.Environment.IsDevelopment() || cmdLineInit) {
            var seedData = app.Services.GetRequiredService<SeedData>();
            seedData.SeedDatabase();
        }

        // Other configurations...
    }
}
```

x??

---

---
#### Seeding a Database
Background context explaining how to seed a database using Entity Framework Core. The application starts, and it seeds with predefined calculations if the `INITDB=true` argument is provided. This process includes checking for pending migrations, counting existing rows, and adding new data if necessary.
:p How do you start the application and seed the database?
??x
You start the application by running `dotnet run INITDB=true`, which will initiate seeding of the database with predefined calculations defined in the `SeedData` class. The process checks for pending migrations, counts existing rows in the `Calculations` table, and adds new data if the table is empty.
x??

---
#### Using Entity Framework Core in Endpoints
Background context explaining how to use Entity Framework Core within endpoints to access database data using LINQ queries. The endpoint retrieves or updates calculations based on user input.
:p How does an endpoint like `SumEndpoint` interact with the database?
??x
The `SumEndpoint` interacts with the database by declaring a dependency on the `CalculationContext` and using its `DbSet<T>` properties to perform LINQ queries. For example, it searches for existing calculations or adds new ones if needed.
```csharp
public class SumEndpoint {
    public async Task Endpoint(HttpContext context, CalculationContext dataContext) {
        int count;
        int.TryParse((string?)context.Request.RouteValues["count"], out count);
        long total = dataContext.Calculations?
            .FirstOrDefault(c => c.Count == count)?.Result ?? 0;
        if (total == 0) {
            for (int i = 1; i <= count; i++) {
                total += i;
            }
            dataContext.Calculations?.Add(new() { Count = count, Result = total });
            await dataContext.SaveChangesAsync();
        }

        string totalString = $"({DateTime.Now.ToLongTimeString()}) " + total;
        await context.Response.WriteAsync($"({DateTime.Now.ToLongTimeString()}) Total for {count} values: {totalString}");
    }
}
```
x??

---
#### Querying the Database
Background context explaining how Entity Framework Core translates LINQ queries into SQL and executes them against the database. The example shows a query to find existing calculations or add new ones.
:p How does an endpoint retrieve data from the database?
??x
An endpoint retrieves data by using LINQ queries to search for existing records in the `Calculations` table. For instance, it uses `FirstOrDefault` to check if there's an existing calculation with the given count:
```csharp
long total = dataContext.Calculations?
    .FirstOrDefault(c => c.Count == count)?.Result ?? 0;
```
If no record is found, a new calculation object is added and saved.
x??

---
#### Storing Data in the Database
Background context explaining how to store new calculations in the database if they don't already exist. The example demonstrates adding a new `Calculation` object and saving changes asynchronously.
:p How does an endpoint store new data in the database?
??x
The endpoint stores new data by adding a new `Calculation` object to the `Calculations` DbSet and then calling `SaveChangesAsync()`:
```csharp
dataContext.Calculations?.Add(new() { Count = count, Result = total });
await dataContext.SaveChangesAsync();
```
This ensures that the changes are committed to the database.
x??

---
#### Logging Sensitive Data
Background context explaining how Entity Framework Core logs SQL queries but omits sensitive data by default. The example shows enabling logging of sensitive data for debugging purposes.
:p How can you enable detailed logging in Entity Framework Core?
??x
To enable logging that includes sensitive data, use the `EnableSensitiveDataLogging` method when configuring the database context:
```csharp
builder.Services.AddDbContext<CalculationContext>(opts => {
    opts.UseSqlServer(builder.Configuration["ConnectionStrings:CalcConnection"]);
    opts.EnableSensitiveDataLogging(true);
});
```
This allows you to see parameter values in logging messages, which can be useful for debugging.
x??

---

#### Caching Mechanisms in ASP.NET Core
Background context: Caching is a technique used to improve application performance by storing results of expensive operations so they can be reused. In the context of web applications, caching can significantly reduce database load and response time. ASP.NET Core provides two main mechanisms for caching responses: Response Cache and Output Cache.

:p What are the two caching mechanisms provided by ASP.NET Core?
??x
Response Cache and Output Cache are the two mechanisms provided by ASP.NET Core.
The Response Cache mechanism requires a specific header to be set, allowing it to use cached responses selectively. On the other hand, Output Cache is more complex but comprehensive, using cached responses for a wider range of requests.

Code example:
```csharp
app.UseResponseCache();
app.UseOutputCache();
```
x??

---

#### Entity Framework Core Overview
Background context: Entity Framework Core (EF Core) is an open-source object-relational mapper (ORM) developed by Microsoft. It provides a way to work with data in relational databases using C# classes. EF Core simplifies database operations and enables developers to focus more on the business logic.

:p What does Entity Framework Core provide?
??x
Entity Framework Core provides access to relational data, allowing developers to create, read, update, and delete (CRUD) operations easily. It can be configured as a service and consumed via dependency injection in ASP.NET Core applications. EF Core supports LINQ queries for complex data manipulations.

Code example:
```csharp
public class BloggingContext : DbContext
{
    public DbSet<Blog> Blogs { get; set; }
    public DbSet<Post> Posts { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer("Server=(localdb)\\mssqllocaldb;Database=Blogging;Trusted_Connection=True;");
    }
}

public class Blog
{
    public int BlogId { get; set; }
    public string Name { get; set; }

    // Navigation property to link the blog with its posts.
    public virtual ICollection<Post> Posts { get; set; }
}
```
x??

---

