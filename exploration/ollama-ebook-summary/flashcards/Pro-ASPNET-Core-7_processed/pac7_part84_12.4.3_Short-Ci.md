# Flashcards: Pro-ASPNET-Core-7_processed (Part 84)

**Starting Chapter:** 12.4.3 Short-Circuiting the request pipeline

---

#### Creating Custom Middleware
Background context: In ASP.NET Core, middleware is a fundamental component that processes HTTP requests and responses. Middleware components are pipelines that run from top to bottom on both incoming requests and outgoing responses, allowing developers to add functionality or features without altering the core framework.

:p What is the purpose of custom middleware in ASP.NET Core?
??x
Custom middleware allows you to modify the request and response lifecycle by adding specific behaviors at various points. This can include logging, authentication checks, content transformation, or any other task that needs to be performed during the processing of an HTTP request.
```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.Use(async (context, next) => {
    await next();
    await context.Response.WriteAsync($" Status Code: { context.Response.StatusCode}");
});

// Example of a custom middleware function
app.MapGet("/", () => "Hello World.");
```
x??

---

#### Understanding the Return Pipeline Path
Background context: Middleware components can modify the `HttpResponse` object after the `next()` function has been called. This means that you can add content or headers to the response at various points in the pipeline, providing flexibility and control over how requests are handled.

:p How does custom middleware modify the HTTPResponse object?
??x
Custom middleware modifies the HTTPResponse object by writing additional content or changing its properties after the `next()` function is called. This allows for modifications to be made before and after the response is processed by other components in the pipeline.
```csharp
app.Use(async (context, next) => {
    await next();
    await context.Response.WriteAsync($" Status Code: { context.Response.StatusCode}");
});
```
x??

---

#### Short-Circuiting the Request Pipeline
Background context: Some middleware components can decide not to pass on requests further in the pipeline, effectively "short-circuiting" it. This is useful when a complete response can be generated by a single component, or when certain conditions should prevent the request from being processed further.

:p How does short-circuiting affect the request processing?
??x
Short-circuiting affects the request processing by stopping the execution of subsequent middleware components in the pipeline. If a middleware determines that it needs to generate a complete response, it can call `WriteAsync` directly and not invoke the `next()` function, thus bypassing other components.
```csharp
app.Use(async (context, next) => {
    if (context.Request.Path == "/short") {
        await context.Response.WriteAsync("Request Short Circuited");
    } else {
        await next();
    }
});
```
x??

---

#### Passing Requests and Responses Through the Pipeline
Background context: Middleware components can operate at various points in the pipeline, either before or after other middleware has processed the request. This allows for a flexible and modular approach to handling requests and responses.

:p Where can middleware components operate in relation to the request processing?
??x
Middleware components can operate both before and after the request is passed through other components in the pipeline. This means they can modify the request or response at different stages, providing flexibility in how requests are processed.
```csharp
app.Use(async (context, next) => {
    if (context.Request.Method == HttpMethods.Get && context.Request.Query["custom"] == "true") {
        context.Response.ContentType = "text/plain";
        await context.Response.WriteAsync("Custom Middleware ");
    }
    await next();
});
```
x??

---

#### Modifying a Response in the Return Path
Background context: After other middleware has processed the request, custom middleware can modify the response by writing to the `HttpResponse` object. This is typically done after calling `next()`, allowing for modifications that occur later in the pipeline.

:p What happens when custom middleware modifies the response after the next function?
??x
When custom middleware modifies the response after the `next()` function, it writes additional content or headers to the response. The response is modified before it reaches other components further down the pipeline.
```csharp
app.Use(async (context, next) => {
    await next();
    await context.Response.WriteAsync($" Status Code: { context.Response.StatusCode}");
});
```
x??

---

#### Checking HasStarted Property for Response Modifications
Background context: Middleware should avoid modifying the response status code or headers once ASP.NET Core has started to send the response to the client. The `HasStarted` property can be used to check if this condition is met, preventing exceptions.

:p Why should middleware not change the response status code or headers after HasStarted?
??x
Middleware should not change the response status code or headers after `HasStarted` because ASP.NET Core has already begun sending the response to the client. Modifying these properties at this stage can cause exceptions and unpredictable behavior.
```csharp
// Example of checking HasStarted
if (!context.Response.HasStarted) {
    // Modify response here
}
```
x??

---

#### Understanding Short-Circuiting in Middleware
Background context: Short-circuiting allows middleware to generate a complete response without passing the request further down the pipeline. This is useful for optimization and ensuring that requests are processed efficiently.

:p What does short-circuiting allow developers to do?
??x
Short-circuiting allows developers to prevent the request from being passed further in the pipeline by generating a complete response within a middleware component. This can be used for optimization, where a single component can handle the entire request.
```csharp
app.Use(async (context, next) => {
    if (context.Request.Path == "/short") {
        await context.Response.WriteAsync("Request Short Circuited");
    } else {
        await next();
    }
});
```
x??

---
#### Map Method for Creating Pipeline Branches
Background context explaining how the `Map` method is used to create sections of middleware pipelines that process specific URLs. The `UseMiddleware` and `Use` methods are essential for defining these branches.

:p How does the `Map` method in ASP.NET Core help in creating pipeline branches?
??x
The `Map` method allows developers to define a section of the request pipeline that processes requests based on specified URL patterns. It essentially creates a new sequence of middleware components that will be used for specific URLs, allowing for more granular control over how different parts of the application handle incoming requests.

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.Map("/branch", branch => {
    // Add middleware to this branch
});
```
x??

---
#### Using MapWhen Method for Predicate-Based Branching
Background context explaining that ASP.NET Core supports `MapWhen`, which allows requests to be directed to specific pipeline branches based on a predicate, not just URL patterns. This method provides more flexibility in defining how different types of requests are handled.

:p How does the `MapWhen` method differ from the `Map` method in ASP.NET Core?
??x
The `MapWhen` method is used for creating branches in the request pipeline based on predicates rather than just URLs. It allows you to define a function that receives an `HttpContext` and returns a boolean value indicating whether the branch should be followed. This provides more flexibility as requests can be selected for specific pipeline branches based on criteria beyond just URL patterns.

```csharp
app.MapWhen(context => context.Request.Query["custom"].Value == "true", branch => {
    // Add middleware to this branch
});
```
x??

---
#### Creating a Pipeline Branch with Map and Use Methods
Background context explaining the use of `Map` to create branches in the request pipeline, followed by using `UseMiddleware` or `Use` methods to add middleware components. The example demonstrates how to set up different sequences of middleware for specific URLs.

:p How does the code snippet set up a branch in the ASP.NET Core pipeline?
??x
The code sets up a branch in the request pipeline for requests that start with `/branch`. It adds middleware and custom logic to this branch, which processes these requests differently from the main path through the pipeline.

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.Map("/branch", branch => {
    // Add QueryStringMiddleware to this branch
    branch.UseMiddleware<Platform.QueryStringMiddleWare>();
    // Add custom middleware logic
    branch.Use(async (context, next) => {
        await context.Response.WriteAsync("Branch Middleware");
    });
});
// Additional setup for the main pipeline path
app.UseMiddleware<Platform.QueryStringMiddleWare>();
app.MapGet("/", () => "Hello World.");
app.Run();
```
x??

---
#### Understanding Short-circuiting in Request Pipelines
Background context explaining that short-circuiting can occur if a branch of middleware does not invoke `next()`, meaning requests do not pass through the main pipeline. This allows for efficient handling of specific types of requests without unnecessary processing.

:p How does short-circuiting work in ASP.NET Core request pipelines?
??x
Short-circuiting occurs when a section of the request pipeline (a branch) processes a request and does not invoke `next()`. This means that once this branch is executed, no further middleware components from the main pipeline will be invoked for that request. Short-circuiting can optimize performance by efficiently handling specific types of requests without unnecessary processing.

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.Map("/branch", branch => {
    // Add QueryStringMiddleware to this branch
    branch.UseMiddleware<Platform.QueryStringMiddleWare>();
    // This middleware does not invoke next()
    branch.Use(async (context, next) => {
        await context.Response.WriteAsync("Branch Middleware");
    });
});
// Additional setup for the main pipeline path
app.UseMiddleware<Platform.QueryStringMiddleWare>();
app.MapGet("/", () => "Hello World.");
app.Run();
```
x??

---

---
#### Using MapWhen to Branch Middleware Pipeline
Background context: The `MapWhen` method is used to conditionally branch the middleware pipeline based on a predicate function. This allows for dynamic routing of requests without requiring explicit redirection.

:p How does the `MapWhen` method work in ASP.NET Core?
??x
The `MapWhen` method evaluates a predicate function for each request and branches the pipeline if the predicate returns true. In the given example, the middleware is added to process requests where the query string contains the key "branch".

```csharp
app.MapWhen(context => context.Request.Query.Keys.Contains("branch"), 
    branch => {
        // Add middleware components here
});
```
x??

---
#### Creating Terminal Middleware
Background context: Terminal middleware is designed to handle requests that do not require further processing by other middleware components. It typically writes a response directly and does not call the `next` delegate.

:p What distinguishes terminal middleware from regular middleware in ASP.NET Core?
??x
Terminal middleware always terminates the request pipeline, meaning it does not forward the request to any subsequent middleware or handlers. This is often achieved using the `Run` method, which explicitly indicates that no further processing should occur for a given request.

```csharp
branch.Run(async (context) => {
    await context.Response.WriteAsync("Branch Middleware");
});
```
x??

---
#### Example of Using Run Method for Terminal Middleware
Background context: The `Run` method is a convenience feature in ASP.NET Core that allows developers to create terminal middleware components. It simplifies the process by directly writing a response without needing to call the `next` delegate.

:p How does using the `Run` method differ from the `Use` method when creating middleware?
??x
The `Run` method is used for terminal middleware, which means it writes a response and ends processing without forwarding the request to any other components. This differs from the `Use` method, which can be used for both regular and terminal middleware but requires handling the `next` delegate.

```csharp
((IApplicationBuilder)app).Map("/branch", branch => {
    branch.UseMiddleware<Platform.QueryStringMiddleWare>();
    branch.Run(async (context) => {
        await context.Response.WriteAsync("Branch Middleware");
    });
});
```
x??

---
#### Creating Custom Middleware
Background context: Custom middleware can be created as class-based components that can act either as regular or terminal middleware. This flexibility is achieved by defining a constructor with an optional `nextDelegate` parameter.

:p How does the `QueryStringMiddleWare` component handle different request methods and query parameters?
??x
The `QueryStringMiddleWare` component checks if the request method is GET and if the "custom" query string parameter is present. If both conditions are met, it writes a response without calling the next middleware (if provided).

```csharp
public async Task Invoke(HttpContext context) {
    if (context.Request.Method == HttpMethods.Get &&
        context.Request.Query["custom"] == "true") {
        if (context.Response.HasStarted) {
            context.Response.ContentType = "text/plain";
        }
        await context.Response.WriteAsync("Class Middleware");
    }
    if (next != null) {
        await next(context);
    }
}
```
x??

---
#### Applying Custom Middleware in Both Standard and Terminal Forms
Background context: The `QueryStringMiddleWare` component can be used both as regular middleware by passing a non-null `nextDelegate` to the constructor or as terminal middleware when no such delegate is provided.

:p How does the application of `QueryStringMiddleWare` differ between standard and terminal forms?
??x
In the standard form, the `QueryStringMiddleWare` uses the provided `nextDelegate` to forward requests if conditions are not met. In the terminal form, it writes a response directly without calling the next middleware.

```csharp
var app = builder.Build();
((IApplicationBuilder)app).Map("/branch", branch => {
    branch.Run(new Platform.QueryStringMiddleWare().Invoke);
});
```
x??

---

