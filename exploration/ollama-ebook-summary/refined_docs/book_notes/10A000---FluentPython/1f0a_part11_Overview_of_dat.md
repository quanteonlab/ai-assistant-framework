# High-Quality Flashcards: 10A000---FluentPython_processed (Part 11)

**Rating threshold:** >= 8/10

**Starting Chapter:** Overview of data class builders

---

**Rating: 8/10**

#### Classic Named Tuples
Background context: The classic `NamedTuple` is a factory function from the `collections` module that simplifies creating named tuples. It allows you to define classes with fields and automatically generates methods like `__init__`, `__repr__`, and `__eq__`.

:p What are the key differences between using `NamedTuple` in Python 3.6+ compared to its earlier versions?
??x
The key differences include enhanced readability, support for PEP 526 variable annotations, and the ability to override or add methods directly within a class statement.

Code example:
```python
from collections import namedtuple

Coordinate = namedtuple('Coordinate', 'lat lon')
```
In this example, `Coordinate` is created with fields `lat` and `lon`, and it automatically has useful methods like `__repr__` and `__eq__`.

x??

---

#### Typing.NamedTuple
Background context: `typing.NamedTuple` is a type annotation extension of the classic `NamedTuple`. It not only provides similar functionality but also adds type hints to each field, making your code more readable and maintainable.

:p How does `typing.NamedTuple` differ from the classic `NamedTuple` in terms of syntax?
??x
`typing.NamedTuple` allows you to specify types for fields using PEP 526 syntax or by passing a list of tuples where each tuple contains the field name and its type. Additionally, it can be used directly in class statements with type annotations.

Code example:
```python
import typing

Coordinate = typing.NamedTuple('Coordinate', [('lat', float), ('lon', float)])
```
This creates a `Coordinate` class with fields `lat` (of type `float`) and `lon` (also of type `float`).

x??

---

#### Data Class Introduction
Background context: Introduced in Python 3.7, data classes are a convenient way to create simple data containers with minimal boilerplate code. They automatically generate common methods like `__init__`, `__repr__`, `__eq__`, and more.

:p What is the main purpose of using data classes over traditional class definitions?
??x
The main purpose is to reduce redundancy in writing boilerplate code for initializing, representing, comparing, and hashing objects. Data classes handle these tasks automatically, making your code cleaner and more readable.

Example:
```python
from dataclasses import dataclass

@dataclass
class Coordinate:
    lat: float
    lon: float
```
This `Coordinate` class is created with automatic methods generated by the `dataclass` decorator, reducing the need to write these methods manually.

x??

---

#### TypedDict Introduction
Background context: While `typing.TypedDict` shares some syntax similarities with data classes and named tuples, it serves a different purpose. It's used for creating dictionaries where keys represent field names and values can be of any type.

:p How does `typing.TypedDict` differ from data classes?
??x
`typing.TypedDict` is not meant to create concrete classes that you can instantiate but rather to provide static typing hints for dictionaries or records. It focuses on ensuring type consistency in function parameters or variables, whereas data classes are designed to be instantiated objects with methods and attributes.

Example:
```python
from typing import TypedDict

class CoordinateDict(TypedDict):
    lat: float
    lon: float
```
This `CoordinateDict` class is a type hint for dictionaries that should contain keys 'lat' and 'lon', both of which are expected to be floats.

x??

---

#### Summary of Data Class Builders
Background context: The chapter covers various tools like classic `NamedTuple`, `typing.NamedTuple`, data classes, and `TypedDict`. Each tool has its strengths and is suitable for different scenarios based on the need for static typing, boilerplate reduction, or object instantiation.

:p What are some key differences between `collections.namedtuple` and `dataclasses.dataclass`?
??x
Key differences include:
- `NamedTuple` subclasses `tuple` and does not support instance modifications.
- `dataclass` can be instantiated and supports methods like `__init__`, `__repr__`, etc., making it more flexible for object-oriented design.

Example:
```python
from collections import namedtuple

Coordinate = namedtuple('Coordinate', 'lat lon')

# vs.

from dataclasses import dataclass

@dataclass
class Coordinate:
    lat: float
    lon: float
```
The `NamedTuple` version is immutable, while the `dataclass` version can be modified and supports additional methods.

x??

---

**Rating: 8/10**

#### Variable Annotations and `typing.Optional`

Variable annotations can be used to declare the expected type of a variable. This is particularly useful with `Optional` from the `typing` module, which allows you to specify that a field can either hold a certain type or `None`. When defining such fields in a class or a dataclass, Python stores these annotations but does not enforce them at runtime.

:p What are variable annotations and how do they work with `Optional[str]`?
??x
Variable annotations allow you to declare the expected types of variables. With `Optional[str]`, it signifies that a field can either be a string (`str`) or `None`. When defined in a class, Python stores these as part of the class's metadata but does not enforce type checking at runtime.

For example:
```python
from typing import Optional

class ExampleClass:
    name: Optional[str] = None
```
In this case, `name` can be either `str` or `None`, and is stored in the `__annotations__` dictionary of the class. However, attempting to assign a non-`str` value directly to `name` will not result in an error at runtime.

x??

---

#### The Role of `__annotations__`

The `__annotations__` special attribute holds type hints declared using variable annotations. This dictionary is used by tools like `typing.NamedTuple` and the `@dataclass` decorator to enhance class definitions, even if the class definition itself does not use these annotations directly.

:p What does the `__annotations__` attribute store in a class with type hints?
??x
The `__annotations__` attribute stores type hints declared using variable annotations. These hints are stored as key-value pairs where keys are variable names and values are their corresponding types. For example, if you have:
```python
class ExampleClass:
    name: str = 'John'
```
Then `ExampleClass.__annotations__` would be:
```python
{'name': <class 'str'>}
```

However, the type hints in `__annotations__` do not affect attribute creation. Only those that are bound to values become class attributes. For instance, if you have:
```python
class ExampleClass:
    name: str = 'John'
    age: int
```
Only `name` would be a class attribute with the value `'John'`, while `age` is just an annotation without any default value.

x??

---

#### Plain Class vs. NamedTuple

In Python, you can use variable annotations in plain classes to document types, but these type hints are not enforced at runtime and do not create attributes by themselves. On the other hand, when using `typing.NamedTuple`, these annotations become part of the class structure as both attributes and their corresponding default values.

:p What is the difference between a plain class with variable annotations and a NamedTuple in terms of attribute creation?
??x
In a plain class with variable annotations, type hints are stored in the `__annotations__` dictionary but do not create actual attributes unless they are bound to values. For example:
```python
class DemoPlainClass:
    name: str = 'John'
    age: int

print(DemoPlainClass.__annotations__)
# {'name': <class 'str'>, 'age': <class 'int'>}
```
Here, `name` is a class attribute with the value `'John'`, but `age` is just an annotation without any default value. Attempting to use `DemoPlainClass.age` would result in an `AttributeError`.

In contrast, when using `typing.NamedTuple`, these annotations are stored in the `__annotations__` dictionary and also become part of the class as attributes with their corresponding default values:
```python
from typing import NamedTuple

class DemoNTClass(NamedTuple):
    name: str = 'John'
    age: int

print(DemoNTClass.__annotations__)
# {'name': <class 'str'>, 'age': <class 'int'>}
```
Here, both `name` and `age` are class attributes with their respective default values.

x??

---

**Rating: 8/10**

#### Instance Attributes and Class Attributes Behavior
Background context: The provided text discusses how instance attributes and class attributes behave within a `DemoDataClass`. It highlights that while `a` and `b` are typical instance attributes, `c` is actually a class attribute accessed via an instance. This example illustrates the mutability of instances in Python.

:p How does accessing and modifying `c` demonstrate the behavior between instance and class attributes?
??x
Accessing `dc.c` returns the class attribute value, but assigning to `dc.c` changes only the instance's local copy of `c`, not the class-level one. This shows that instance attributes can shadow class attributes.
```python
>>> dc = DemoDataClass(9)
>>> dc.a  # Returns: 9
>>> dc.b  # Returns: 1.1
>>> dc.c  # Returns: 'spam'
>>> dc.c = 'new value'  # Only changes the instance's `c`, not the class attribute.
>>> dc.c  # Returns: 'new value'
>>> DemoDataClass.c  # Still returns: 'spam'
```
x??

---

#### Mutable Instances in Python
Background context: The text highlights that instances of a class are mutable by default, meaning their attributes can be changed. No type checking is done at runtime.

:p What happens when you assign new values to instance attributes?
??x
Assigning new values to instance attributes changes the specific instance's state without affecting other instances or the class itself.
```python
>>> dc.a = 10  # Changes only `dc`'s `a`, not other instances of DemoDataClass.
>>> dc.b = 'oops'  # Again, this is just for the instance `dc`.
```
x??

---

#### Dynamic Instance Attributes
Background context: The provided text shows how a new attribute can be dynamically added to an instance.

:p Can you explain how dynamic attributes work in Python instances?
??x
Dynamic attributes allow adding new attributes to an instance at runtime. These do not affect the class itself but are specific to that instance.
```python
>>> dc.z = 'secret stash'  # Added a new attribute `z` to `dc`.
```
x??

---

#### Data Class Decorator Overview
Background context: The text introduces the `@dataclass` decorator and its keyword arguments, explaining their functionality.

:p What does the `@dataclass` decorator do?
??x
The `@dataclass` decorator simplifies creating classes with common methods like `__init__`, `__repr__`, `__eq__`, etc. It can be customized using several keyword arguments.
```python
@dataclass
class MyDataClass:
    a: int
    b: float = 1.0
    c: str = 'default'
```
x??

---

#### Keyword Arguments of @dataclass Decorator
Background context: The text lists the keyword arguments that can be passed to `@dataclass`.

:p What are some common settings for the `@dataclass` decorator?
??x
Common settings include:
- `init=True`: Generates an `__init__` method.
- `repr=True`: Generates a `__repr__` method.
- `eq=True`: Generates `__eq__`.
- `order=False`: Prevents sorting based on comparison methods.
- `unsafe_hash=False`: Does not generate a `__hash__` method unless required.
- `frozen=False`: Allows modification of the instance.

```python
@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)
class MyClass:
    # class definition here
```
x??

---

#### Impact of `init`, `repr`, and `eq` Arguments
Background context: The text explains how these arguments affect the generated methods.

:p How do the `init`, `repr`, and `eq` arguments impact data classes?
??x
- `init=True`: Generates an `__init__` method with parameters based on class fields.
- `repr=True`: Generates a `__repr__` method for easy representation of instances.
- `eq=True`: Generates `__eq__` to compare instances for equality.

```python
@dataclass(init=True, repr=True, eq=True)
class MyClass:
    x: int
    y: float = 0.0

# This would generate methods like __init__, __repr__, and __eq__.
```
x??

---

#### `frozen` Argument in @dataclass Decorator
Background context: The text discusses the `frozen` argument, which makes instances immutable.

:p What does setting `frozen=True` do with an instance?
??x
Setting `frozen=True` makes the instance "immutable" by generating `__setattr__` and `__delattr__` methods that raise `FrozenInstanceError` if an attempt is made to modify attributes after initialization.
```python
@dataclass(frozen=True)
class MyClass:
    x: int

# This class cannot be modified once created.
```
x??

---

#### Hashability with @dataclass Decorator
Background context: The text explains how `@dataclass` handles hashability based on the `frozen` and `eq` arguments.

:p How does setting `frozen=True` affect hashability in data classes?
??x
Setting `frozen=True` along with `eq=True` generates a suitable `__hash__` method, making instances hashable. If `eq=False`, `__hash__` is set to `None`, indicating unhashable instances.
```python
@dataclass(frozen=True)
class MyClass:
    x: int

# Instances of this class are hashable and can be used in sets or dictionaries.
```
x??

