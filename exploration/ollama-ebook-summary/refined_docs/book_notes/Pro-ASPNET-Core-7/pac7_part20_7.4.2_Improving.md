# High-Quality Flashcards: Pro-ASPNET-Core-7_processed (Part 20)

**Rating threshold:** >= 8/10

**Starting Chapter:** 7.4.2 Improving the URLs

---

**Rating: 8/10**

#### Updating the Model View Type
The `@model` directive was changed from a simpler type to `ProductsListViewModel`, which contains information about the products and paging details. This change is necessary for handling paginated data properly.

:p Why did you change the model view type from a simpler type to `ProductsListViewModel`?
??x
By changing the model view type to `ProductsListViewModel`, we can include both product information and paging details in the model passed to the view. This allows us to handle pagination more effectively, as it provides all necessary data for generating page links.

```csharp
@model ProductsListViewModel
```

x??

---

**Rating: 8/10**

#### Generating User-Friendly URLs with ASP.NET Core Routing
By adding a new route in the `Program.cs` file, the application can generate more user-friendly URLs for navigating through paginated data. This improves the URL structure and enhances the user experience.

:p What is the benefit of using composable URL patterns like "http://localhost/Page2" instead of query string URLs?
??x
Using composable URL patterns such as "http://localhost/Page2" improves readability and makes URLs more memorable for users. It separates page navigation from other query parameters, making the URLs cleaner and easier to understand.

```csharp
app.MapControllerRoute("pagination",
                        "Products/Page{productPage}",
                        new { Controller = "Home", action = "Index" });
```

x??

---

**Rating: 8/10**

#### Ensuring URL Changes Reflect in the Application
After adding a new route for pagination, ASP.NET Core automatically updates the URLs used by the application. Tag helpers like `page-model` are aware of these changes and generate appropriate links.

:p How does ASP.NET Core routing ensure that the new URL scheme is applied throughout the application?
??x
ASP.NET Core routing integrates tightly with tag helpers such as `page-model`. When the route configuration is updated, any URLs generated by tag helpers will automatically reflect the new structure. This ensures consistent and user-friendly navigation across the application.

```csharp
app.MapControllerRoute("pagination",
                        "Products/Page{productPage}",
                        new { Controller = "Home", action = "Index" });
```

x??

---

---

**Rating: 8/10**

#### Styling Content with Bootstrap
Background context: The process of styling content using Bootstrap classes in Razor views, particularly focusing on product listings and pagination links.

:p How does one style products listed in a Razor view?

??x
Styling products involves using Bootstrap's card, badge, and other utility classes. Here’s an example from the `Index.cshtml` file:

```csharp
@model ProductsListViewModel

@foreach (var p in Model.Products ?? Enumerable.Empty<Product>()) {
    <div class="card card-outline-primary m-1 p-1">
        <div class="bg-faded p-1">
            <h4>
                @p.Name
                <span class="badge rounded-pill bg-primary text-white" style="float:right">
                    <small>@p.Price.ToString("c")</small>
                </span>
            </h4>
        </div>
        <div class="card-text p-1">@p.Description</div>
    </div>
}
<div page-model="@Model.PagingInfo" page-action="Index"
     page-classes-enabled="true" page-class="btn"
     page-class-normal="btn-outline-dark" 
     page-class-selected="btn-primary" class="btn-group pull-right m-1"></div>
```

In this example, the `.card`, `.card-text`, and `.badge` classes are used to style individual product items. The badge is styled with a right float.

x??

---

**Rating: 8/10**

#### Customizing Pagination Links
Background context: Implementing custom pagination link styles in Razor views using `PageLinkTagHelper`.

:p How does one customize the appearance of pagination links?

??x
To customize pagination links, define custom attributes on the div element that specify the Bootstrap classes. Here’s how to do it:

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Rendering;
using Microsoft.AspNetCore.Mvc.Routing;
using Microsoft.AspNetCore.Mvc.ViewFeatures;
using Microsoft.AspNetCore.Razor.TagHelpers;

namespace SportsStore.Infrastructure
{
    [HtmlTargetElement("div", Attributes = "page-model")]
    public class PageLinkTagHelper : TagHelper
    {
        private IUrlHelperFactory urlHelperFactory;

        public PageLinkTagHelper(IUrlHelperFactory helperFactory)
        {
            urlHelperFactory = helperFactory;
        }

        [ViewContext]
        [HtmlAttributeNotBound]
        public ViewContext? ViewContext { get; set; }

        public PagingInfo? PageModel { get; set; }
        public string? PageAction { get; set; }
        public bool PageClassesEnabled { get; set; } = false;
        public string PageClass { get; set; } = String.Empty;
        public string PageClassNormal { get; set; } = String.Empty;
        public string PageClassSelected { get; set; } = String.Empty;

        public override void Process(TagHelperContext context, TagHelperOutput output)
        {
            if (ViewContext == null || PageModel == null)
            {
                IUrlHelper urlHelper = urlHelperFactory.GetUrlHelper(ViewContext);
                TagBuilder result = new TagBuilder("div");
                for (int i = 1; i <= PageModel.TotalPages; i++)
                {
                    TagBuilder tag = new TagBuilder("a");
                    tag.Attributes["href"] = urlHelper.Action(PageAction, new { productPage = i });
                    if (PageClassesEnabled)
                    {
                        // Add necessary Bootstrap classes here
                    }
                    result.InnerHtml.Append(tag);
                }
                output.Content.SetElementContent(result);
            }
        }
    }
}
```

This example shows how to use custom attributes and tag helper logic to generate styled pagination links. The `PageClass`, `PageClassNormal`, and `PageClassSelected` properties allow you to specify the Bootstrap classes.

x??

---

---

**Rating: 8/10**

#### Partial View in ASP.NET Core
A partial view is a reusable piece of markup that can be embedded into another Razor view. This allows for reducing code duplication and maintaining consistency across multiple views.

:p What is the purpose of creating a partial view in an ASP.NET Core application?
??x
The purpose of creating a partial view is to encapsulate common or frequently used pieces of content, such as product summaries in this case, which can be reused throughout different parts of your application. This reduces code duplication and promotes cleaner, more maintainable code.

Example:
```csharp
@model ProductsListViewModel
@foreach (var p in Model.Products ?? Enumerable.Empty<Product>()) {
    <partial name="ProductSummary" model="p" />
}
```
x??

---

**Rating: 8/10**

#### Updating Index.cshtml with Partial View
By refactoring `Index.cshtml` to use a partial view, you can maintain cleaner code and reuse the same markup across different views.

:p Why was the existing Razor markup moved to a separate partial view?
??x
The existing Razor markup was moved to a separate partial view named "ProductSummary" to reduce redundancy. This approach allows for maintaining a single source of truth for product summaries, making it easier to update and reuse this content throughout your application without duplicating code.

Example:
```csharp
@model ProductsListViewModel
@foreach (var p in Model.Products ?? Enumerable.Empty<Product>()) {
    <partial name="ProductSummary" model="p" />
}
```
x??

---

